<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>JavaScript | LiSir</title><meta name="keywords" content="JS"><meta name="author" content="LiSir,zewei4703@gmail.com"><meta name="copyright" content="LiSir"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="JavaScript"><meta name="application-name" content="JavaScript"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="JavaScript"><meta property="og:url" content="http://example.com/2024/07/30/JavaScript/index.html"><meta property="og:site_name" content="LiSir"><meta property="og:description" content="JS引入方式 内部脚本：将JS代码定义在HTML页面中  JavaScript代码必须位于script标签内 在HTML文档中，可以再任意地方 ，放置任意数量的script 一般会把脚本置于body元素的底部，可以改善显示速度   外部脚本：将JS代码定义在外部JS文件中，然后引入到HTML页面中"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://example.com/img/default_cover.jpg"><meta property="article:author" content="LiSir"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/img/default_cover.jpg"><meta name="description" content="JS引入方式 内部脚本：将JS代码定义在HTML页面中  JavaScript代码必须位于script标签内 在HTML文档中，可以再任意地方 ，放置任意数量的script 一般会把脚本置于body元素的底部，可以改善显示速度   外部脚本：将JS代码定义在外部JS文件中，然后引入到HTML页面中"><link rel="shortcut icon" href="/img/touxiang.jpg"><link rel="canonical" href="http://example.com/2024/07/30/JavaScript/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: LiSir","link":"链接: ","source":"来源: LiSir","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'LiSir',
  title: 'JavaScript',
  postAI: '',
  pageFillDescription: 'JS引入方式, JS基础语法, 书写语法, 变量, 数据类型, 原始类型, 运算符, 逻辑与(ampamp)与逻辑或(||), 逻辑与 (ampamp), 逻辑或 (||), 短路求值(重要), 非运算符(!), 流程控制, JS函数, 函数的定义, 匿名函数, 回调函数, 回调函数的基本概念, 注意事项, 递归函数, 生成一个范围随机数, JS对象, Array(数组对象), JavaScript 数组方法, String对象, JavaScript 字符串方法, 查找字符串中的字符串, 把字符串转换为数组, String.includes(), String.startsWith(), String.endsWith(), 为了很好记忆做出的总结, json对象, BOM对象, Window对象, Location对象, navigator对象, history对象, DOM对象, 什么是DOM, DOM节点, 文档节点（Document Node）, 元素节点（Element Node）, 属性节点（Attribute Node）, 文本节点（Text Node）, 注释节点（Comment Node）, 查找节点, 父节点查找(只能找到最近一级), 子节点查找, 兄弟节点查找, 新增节点, 创建节点, 设置属性和内容, 添加节点到DOM中, 克隆节点, 删除节点, 日期对象, 创建 Date 对象, 日期对象的常用方法, 获取日期和时间的部分, 设置日期和时间的部分, 格式化日期, 其他方法, 1. toLocaleString(), 2. toLocaleDateString(), 3. toLocaleTimeString(), 参数选项, 更多方法, 时间戳, 获取时间戳, 时间戳转换为日期, 使用时间戳, 实际应用, JS事件监听, 事件绑定, 常见事件, 鼠标事件, 键盘事件, 文档和窗口(window)事件, 表单事件, 其他事件, 事件对象, 环境对象, 事件流, 事件捕获 (Event Capturing), 目标阶段 (Target Phase), 事件冒泡 (Event Bubbling), 事件流的传播方向, 使用事件处理程序, 阻止冒泡, 事件解绑, 事件委托, 如何实现事件委托, 实现步骤, 示例代码, 阻止事件的默认行为, 元素在页面中的位置, 页面滚动, cliet家族, offset家族, 获取元素大小位置的另外方法, 总结, 变量, 1.变量的赋值, 2.var、const、let的区别, 为什么不用var 声明, 推荐使用 let 的情况：, 推荐使用 const 的情况：, 总结, webAPI基本认识, 获取DOM元素, 根据CSS选择器来获取DOM元素, 其他获取DOM元素的方法, 操作元素内容, 对象.innerHtml属性, 对象.innerText属性, 案例, 操作元素的属性, 操作元素常用属性, 举例, 操作元素样式属性, 通过style属性来操作CSS, 通过类名(className)来操作CSS, 通过classList操作类控制CSS, 操作表单元素属性, 获取和设置表单元素的值, 检查复选框的状态, 设置复选框的状态, 操作选择框（下拉列表）, 添加和删除表单元素, 设置和获取表单元素的CSS样式, 监听表单事件, 本地存储, localStorage 对象, setItem(keyvalue), getItem(key), removeItem(key), sessionStorage 对象, setItem(keyvalue), getItem(key), removeItem(key), 存储复杂类型的数据, Storage 对象属性和方法, 正则表达式, 创建正则表达式, 常用的正则表达式模式, 使用正则表达式的常见方法, 元字符, 常见元字符, 边界符, 量词, 字符类, 修饰符, 示例, 匹配任何数字, 匹配以数字开头的字符串, 匹配以数字结尾的字符串, 匹配连续三个或更多的字符, 匹配连续一个到三次的字符, 匹配任何数字或字母, 匹配任何非数字, JavaScript异步, JS中的Promise(更详细请移步笔记Vue前置知识.md), 基本语法, promise的三种状态, promise对象的使用, 回调地狱, promise链式调用, JavaScript Async(异步), Async 语法, Await 语法, 基础语法, async和await捕获错误, Ajax, Axios, 基础语法, 请求配置, 常用配置项, 错误处理, 请求方法, HTTP响应状态码, 成功状态码, 重定向状态码, 客户端错误状态码, 服务器错误状态码, 什么是 Ajax, Ajax如何工作, Ajax基础语法, Ajax传递参数, 携带查询参数, 携带要提交的数据, xhr对象, 获得xhr对象, xhr对象方法, xhr对象属性, 同步请求x2F异步请求, 服务器响应请求, 服务器响应属性, responseText 属性, responseXML 属性, 服务器响应方法, getAllResponseHeaders() 方法, 实例, getResponseHeader() 方法, 实例, JavaScript进阶, JS中的堆和栈, 栈（Stack）, 堆（Heap）, 关键区别, 作用域, 局部作用域, 函数作用域, 块作用域, 例子, 全局作用域, 作用域链, JS垃圾回收机制, 标记与清除（Mark and Sweep）, 引用计数（Reference Counting）, 分代收集（Generational Collection）, 增量收集（Incremental Collection）, 压缩（Compaction）, 如何避免内存泄漏, 闭包, 闭包的形成, 闭包的作用, 变量提升, 函数进阶, 函数提升, 函数参数, 默认参数, 动态参数, 箭头函数, 箭头函数的参数, 箭头函数中的this, 解构赋值, 数组结构, 忽略某些值, 使用默认值, 解构嵌套数组, 对象结构, 解构基本对象, 忽略某些属性, 使用默认值, 解构嵌套对象, 解构并重命名属性, 深入对象, 创建对象, 构造函数, 实例成员amp静态成员, 存在的问题, 内置构造函数, Object—对象, Array—数组, Number—数值, 两种编程思想, 1. 面向过程编程（Procedural Programming）, 2. 面向对象编程（Object-Oriented Programming OOP）, 原型(重要), 原型对象, constructor属性, 对象原型, 原型继承, 出现的问题, 原型链, 深浅拷贝, 浅拷贝 (Shallow Copy), 深拷贝 (Deep Copy), 异常处理, 异常处理语法, 深度学习this, this指向, 针对普通函数, 针对箭头函数, 改变this指向, 使用 .call(), 使用 .apply(), 使用 .bind(), 理解图, 防抖和节流, 防抖, 节流, 防抖和节流的总结, JS插件, 制作轮播图, 快速收集表单内容引入方式内部脚本将代码定义在页面中代码必须位于标签内在文档中可以再任意地方放置任意数量的一般会把脚本置于元素的底部可以改善显示速度外部脚本将代码定义在外部文件中然后引入到页面中外部文件中只包含代码不包含标签标签不能够自闭合也就是不可以写成基础语法书写语法区分大小写与一样变量名函数名以及其他一切东西都是区分大小写的每行结尾的分号可有可无注释单行注释注释内容多行注释注释内容大括号代表代码块判断输出语句写入警告框写入输出在浏览器控制台输出内容在浏览器控制台输出对象变量中用关键字的缩写来声明变量的特点作用域比较大全局变量可以重复定义同一个变量相当于一个覆盖是一门弱类型语言变量可以存放不同类型的值张三定义的值是字符串张三把值赋值给输出变量名需要遵循如下规则组成字符可以是任何字母数字下划线或美元符号数字不能开头建议使用驼峰命名如关键字来定义变量它的用法类似于但是所声明的变量只在关键字所在的代码块内有效且不允许重复声明关键字用来声明一个只读的常量一旦声明常量的值就不能改变数据类型中分为原始类型和引用类型原始类型运算符算术运算符赋值运算符比较运算符与会进行类型转换不会进行类型转换逻辑与与逻辑或在编程中和是逻辑运算符它们用于组合布尔表达式这些运算符在大多数支持语言风格语法的编程语言中都是可用的比如等逻辑与逻辑与运算符返回当且仅当其两边的操作数都为否则返回示例使用结果为因为是逻辑或逻辑或运算符返回如果其任一操作数为只有当两边的操作数都为时才返回示例使用结果为因为是短路求值重要需要注意的是这两个运算符具有短路求值的行为对于如果左边的操作数为则右边的操作数不会被计算因为无论右边是什么结果都不会改变最终结果对于如果左边的操作数为则右边的操作数不会被计算同上非运算符非运算符接受一个操作数并返回一个布尔值如果操作数是假值则返回如果操作数是真的则返回在中以下值被认为是假值空字符串除了上述假值之外的所有值都被认为是真值例如非零数值如非空字符串如数组如对象如三元运算符条件表达式类型转换字符串类型转为数字方法这个方法能够将字符串转为数字原理是从字符串左边开始读取读取到不是数字的地方如他会读取到这个为止而停下来停下来取该位置前面的输出转为转为转为可以使用一元加号前缀来把字符串转为数字型其他类型转为类型和转为其他均转为类型空字符串转为其他均转为类型和类型均转为隐式转换检测数据类型检测的名字流程控制值得注意的是在中这些流程控制语句和我们的是完全一致的和函数函数的定义参数参数要执行的代码另一种方式调用参数参数要执行的代码注意形式参数不需要类型因为是弱类型语言返回值类型也不需要定义可以再函数内部直接使用返回即可调用函数名称实际参数列表匿名函数函数分为函数表达式函数表达式函数表达式和具名函数有名函数有什么不同呢具名函数的调用可以写到任何位置匿名函数的函数表达式形式写法必须先声明在使用否则会报错未声明立即执行函数立即执行函数第二种写法上面结构中第二个小括号是实参中的小括号传递的是形参中写入要执行的逻辑注意多个立即执行函数要在函数末尾用分号隔开回调函数回调函数是编程中一个非常重要的概念尤其在异步编程模型中极为常见在中回调函数的应用尤为广泛因为是单线程的但可以通过异步操作实现并发效果回调函数的基本概念回调函数就是一个作为参数传递给另一个函数的函数当外部函数完成某些操作后会回调这个函数作为处理结果的一种方式这使得程序可以在等待某个耗时操作如网络请求文件读写等的同时继续执行其他代码而不会阻塞执行流程示例假设你有一个函数它需要一段时间才能完成操作为了不让主线程等待你可以传入一个回调函数当完成时调用这个回调函数模拟异步操作假设这个操作需要秒使用回调函数在这个例子中函数接受一个回调函数作为参数当异步操作完成时它调用回调函数并传递结果这样即使需要较长时间来完成主线程也不会被阻塞可以立即执行后续代码注意事项回调函数可以导致所谓的回调地狱特别是当多个异步操作嵌套在一起时这种情况下代码结构可能会变得难以阅读和维护因为每个操作的回调都嵌套在前一个操作的回调内为了解决这个问题现代倾向于使用链和语法来使异步代码看起来更像同步代码递归函数什么叫递归函数呢如果一个函数在内部可以调用其本身那么这个函数就是递归函数简单理解函数内部自己调用自己这就是递归函数递归函数的作用和循环效果类似由于递归很容易发生栈溢出错误所以必须要有退出条件生成一个范围随机数是随机数函数返回一个之间的浮点数并且不包括包括向下取整比如就取就取如生成的随机数生成之间的随机数对象数组对象定义变量名元素列表或者变量名元素列表定义数组或者数组方法把数组转换为数组值逗号分隔的字符串将所有数组元素结合为一个字符串可以指定分隔符结果是从数组中删除最后一个元素并返回被删除的值在数组结尾处向数组添加一个新的元素并返回新数组的长度向数组追加新元素的简易方法向追加删除首个数组元素并把所有其他元素位移到更低的索引返回被删除的值从删除第一个元素使用也可以删除数组元素但是会导致留空洞空洞会变为推荐使用或方法删除元素在开头向数组添加新元素并把旧元素向后移动并返回新数组的长度用于向数组添加新项该函数接收两个参数第一个参数定义在某个索引位置之前添加新元素拼接第二个参数定义删除多少元素剩下参数定义要添加的新元素该函数返回值是被删除元素组成的数组也可以使用该函数进行删除元素第一个参数是要删除元素的索引第二个参数是删除元素的个数比如比如通过合并连接现有数组来创建一个新数组方法可以使用任意数量的数组参数方法不会更改现有数组它总是返回一个新数组参数可以是具体的值也可以是数组用数组的某个片段切出新数组方法创建新数组它不会从源数组中删除任何元素可接受两个参数索引比如切的区间是前闭后开的也就是包括不包括如果结束参数没写那么会从索引位置向后切出剩余部分包括索引位置处的元素数组排序以字母顺序对数组进行排序只对字母生效数字无效如果想用该函数比较数字则应该通过比值函数来修正比值函数升序降序反转数组中的元素查找数组中的最高值举例子在本例中我们使用来正确地将数组的所有元素作为单独的参数传递给由于不依赖于的值所以通常这里会传入或者找数组中的最低值比较字符串数组迭代为每个数组元素调用一次函数回调函数该函数接收三个参数该函数只对数组进行遍历不返回新数组方法方法通过对每个数组元素执行函数来创建新数组方法不会对没有值的数组元素执行函数方法不会更改原始数组该方法返回一个新数组同样它也有个参数项目值项目索引数组本身创建一个包含满足某些条件的数组元素的新数组它有个参数项目值项目索引数组本身可以用来对数组中的所有元素进行聚合计算比如求和计算乘积查找最大值最小值函数的执行顺序是从左到右函数是从右到左语法完全一致该函数接受一个回调函数它会被执行数组中的每一个元素除了第一个除非提供了初始值该参数是该回调函数的返回值同时它也是下次调用时的第一个参数当前元素的值可选的当前元素的索引可选的被遍历的数组本身初始值可选对于该方法做出如下特别解释可接受初始值如果给出初始值那么给出的值会被赋值给调用回调函数的同时传入了初始值检查所有数组值是否满足某个条件接受个参数项目值项目索引数组本身如果所有值满足该条件返回如果所有值当中有一个不满足则返回检查某些数组值是否满足某个条件接受个参数项目值项目索引数组本身如果数组当中的某些值满足条件则返回否则返回在数组中搜索元素值并返回其位置语法是查找的项目用来定义开始起点值小于时将从结尾开始的给定位置开始并查到到结尾如果未找到则返回如果某项目多次出现则返回第一次出现的位置索引特别注意一定要注意该函数执行的方向开始位置可能会变但执行顺序是不会变的从数组结尾处开始查找语法必需要检索的项目可选从哪里开始搜索负值将从结尾开始的给定位置开始并搜索到开头特别注意一定要注意该函数执行的方向开始位置可能会变但执行顺序是不会变的返回数组中满足某个条件的第一个元素的值接受个参数项目值项目索引数组本身返回数组中满足某个条件的第一个元素的索引值接受个参数项目值项目索引数组本身对象对象方式一方式二字符串方法查找字符串中的字符串属性返回字符串的长度方法返回字符串中指定文本首次出现的索引位置从计算未找到返回可传递起始位置参数方法返回指定文本在字符串中最后一次出现的索引未找到返回可传递起始位置参数检索方向从结尾向开始方向检索检索字符串中的字符串方法搜索特定值的字符串并返回匹配的位置返回首次出现的位置可以使用正则表达式进行匹配提取部分字符串值得注意的是下面这三种切字符串的方法索引值是负值的时候只是指定了重字符串末尾开始而没有改变切割方向切割方向还是从左到右的提取字符串的某个部分并在新字符串中返回被提取的部分有切割切片的意思两个参数开始索引和结束索引切出来的片段不包括结束索引参数值可以是负数如果出现负数则意味着从字符串结尾开始计数如果只有一个参数那么就是从该位置向后切类似于但不接受负值索引两个参数开始索引和结束索引切出来的片段不包括结束索引如果只有一个参数那么就是从该位置向后切参数不能为负值替换字符串内容方法用另一个值替换在字符串中指定的值返回值是一个新的字符串对原字符串无影响默认只替换首个匹配该函数对大小写敏感注意字母的大小写参数要替换谁参数替换为谁转换为大写和小写通过把字符串转换为大写通过把字符串转换为小写方法连接两个或多个字符串可替换我们知道有可以用来拼接字符串不改变原来字符串返回一个新的字符串方法方法删除字符串两端的空白符提取字符串字符方法返回字符串中指定下标位置的字符串返回指定索引位置的字符方法返回字符串中指定索引的字符编码返回指定索引位置字符的编码属性访问返回但不推荐这样使用把字符串转换为数组将字符串转换为数组可指定分隔符如果指定了分隔符那么它会把字符串中的每个字符按照给定的分隔符分割成一个单个的字符串并返回一个数组返回指定了分隔符但分隔符是空字符串那么被返回的数组将是间隔单个字符的数组返回如果未指定分隔符则返回一个由该字符串本身组成的数组该字符串就是数组的第一个元素返回字符串搜索本小节着重介绍后两个方法前两个方法在上一小节已经介绍过了方法根据正则表达式在字符串中搜索匹配项并将匹配项作为对象返回参数是一个正则表达式如果正则表达式没有加修饰符则匹配第一个符合表达式的字符串若没有符合条件的字符串则返回返回数组如果字符串包含指定值方法返回两个参数第一个为要检索的值第二个参数为开始索引该方法是新引入的开始索引如果是负值改变了索引方向也改变了检索方向对大小写敏感如果字符串以指定值开头则方法返回否则返回两个参数第一个是要检索的值必选第二个开始位置可选对大小写敏感区分大小写如果字符串以指定值结尾则方法返回否则返回两个参数第一个是要检索的值必选第二个开始位置可选区分大小写为了很好记忆做出的总结数组添加元素的方法在末尾添加在头部添加能够更精确添加元素删除元素的方法在末尾删除在头部删除也能够进行元素删除对数组进行切片方法把数组转换为字符串方法字符串字符串长度属性把字符串转换为数组可以指定分隔符对字符串进行切割方法对象概念对象标记法是通过对象标记法书写的文本由于其语法简单层次结构鲜明现多用于作为数据载体在网络中进行数据传输数据格式男性定义案例定义小李北京字符串转为对象方法对象转为字符串方法对象概念浏览器对象模型允许与浏览器对话将浏览器的各个组成部分封装为对象对象介绍浏览器窗口对象获取直接使用其中可以省略和效果一样属性对对象的只读引用请参阅对象用于窗口或框架的对象请参阅对象对对象的只读引用请参阅对象介绍是一个全局对象所有通过定义在全局作用域中的变量函数都会变成对象的属性和方法对象下的属性和方法调用的时候可以省略方法显示带有一段消息和一个确认按钮的警告框显示带有一段消息以及确认按钮和取消按钮的对话按照指定的周期以毫秒计来调用函数或计算表达式在指定的毫秒数后调用函数或计算表达式和都可以进行清除操作延时函数参数有两个一个是回调函数一个是延时的秒数秒后打印清除延时函数周期执行函数参数有两个一个是回调函数一个是周期执行的秒数清除周期执行函数示例代码获取方法对话框确认取消您确认删除该记录吗定时器周期性的执行某一个函数定时器执行了次定时器延迟指定时间执行一次对象介绍地址栏对象获取使用获取其中可以省略不写属性设置或返回完整的如果设置那么他会自动跳转所设置的返回地址中参数部分用于获取或设置中的锚点后面的部分这个属性返回一个字符串该字符串以开头用于重新加载当前文档传入参数表示强制刷新类似与代码示例获取当前完整的设置自动跳转对象的数据类型是对象该对象记录了浏览器自身的相关信息常用属性和方法检测浏览器的版本以及平台对象的数据类型是对象它管理历史记录该对象与浏览器地址栏的操作相应如前进后退历史记录等等常用属性和方法对象方法可以后退前进参数前进后退功能参数是前进一个页面如果是则后退一个页面对象什么是概念文档对象模型将标记语言的各个组成部分封装为对应的对象整个文档对象元素对象属性对象文本对象注释对象通过就能够对进行如下操作改变元素的内容改变元素的样式对事件作出反应添加和删除元素节点让我们通过一些简单的例子来理解节点文档节点文档节点代表整个或文档它是所有其他节点的父节点是文档节点元素节点元素节点是标签如等和是元素节点属性节点属性节点是元素上的属性例如等和是属性节点文本节点文本节点是元素内的纯文本不包含任何标签是文本节点注释节点注释节点是文档中的注释这个是注释节点查找节点在该小节我们主要利用关系来查找父节点查找只能找到最近一级父节点查找用途获取当前元素的父节点语法子节点查找子节点查找用途获取当前元素的所有子节点包括文本节点和元素节点语法用途获取当前元素的第一个或最后一个子节点语法或用途获取所有的元素节点语法该方法返回一个伪数组索引访问可以使用索引来访问元素类似于数组的方式长度属性通常有一个属性表示对象中的元素数量非数组不是真正的类型对象因此不支持数组的一些方法如等兄弟节点查找下一个兄弟节点用途获取当前元素的下一个同级元素节点语法上一个兄弟节点用途获取当前元素的上一个同级元素节点语法新增节点创建节点使用标签名方法来创建一个新的元素设置属性和内容你可以设置新元素的属性和内容这是一个新的元素添加节点到中将新元素添加到文档树中的某个位置常见的方法有将新元素作为最后一个子节点添加到指定的父节点中插入到父元素中某个子元素的前面参数有两个第一个是要插入的新元素第二个参数是参考的元素替换父元素中某个子元素移除指定的子节点举个例子示例添加到文档末尾在某个元素前插入替换某一个元素克隆节点使用背景复制一个原有节点把复制的节点放入到指定的元素内部克隆节点用途复制出一个一模一样的节点语法参数若为则克隆时会包含后代节点以及内容一起克隆若为则不包含后代节点默认是删除节点在中如要删除某个节点必须通过其父元素进行删除语法要删除的元素若不存在父子关系则无法删除如果该节点被删除那么就会从中移除该节点日期对象在中对象用于处理日期和时间这个内置对象可以用来获取设置以及操作日期和时间数据下面是一些关于对象的基本使用方法创建对象无参数创建一个表示当前日期和时间的对象带参数创建一个指定日期和时间的对象注意月份是从开始的所以月是毫秒数创建一个从年月日午夜开始经过的毫秒数所表示的日期这里的参数是从开始时间结束时间所经过的毫秒数日期对象的常用方法获取日期和时间的部分你可以使用对象的方法来获取日期和时间的不同部分例如返回从年月日午夜开始经过的毫秒数返回星期示例输出当前年份输出当前月份输出当前日期设置日期和时间的部分同样也可以设置日期和时间的不同部分例如设置从年月日午夜开始经过的毫秒数示例设置为一月格式化日期中没有内置的日期格式化函数但你可以使用第三方库如或者使用模板字符串和计算来实现简单的格式化例如输出在格式化日期中遇到时分秒补时可以使用三元运算符其他方法在中对象提供了多个方法来格式化日期和时间其中是一个非常有用的内置方法它返回一个表示日期时间的本地格式化的字符串此外还有其他一些相关的方法可以帮助你以不同的方式格式化日期方法返回一个本地化格式的日期时间字符串默认情况下它会使用浏览器的语言环境设置来决定日期的格式输出本地格式的日期和时间方法仅返回日期部分的本地化格式字符串输出本地格式的日期方法仅返回时间部分的本地化格式字符串输出本地格式的时间参数选项这些方法都支持选项对象作为参数允许你进一步定制输出格式例如你可以指定使用小时制还是小时制是否显示秒等自定义格式更多方法除了上面提到的方法外对象还提供了其他一些有用的方法返回日期时间的标准格式字符串返回一个符合标准的日期时间字符串与类似用于序列化返回日期时间的字符串格式和的更多选项可以指定时区时间格式等时间戳使用场景制作倒计时效果什么是时间戳指从年月日时分秒起至现在的毫秒数获取时间戳要获取当前时间的时间戳可以使用方法获取当前时间的时间戳如果你已经有了一个对象可以通过调用方法来获取该日期对应的时间戳获取对象对应的时间戳同样如果有了对象可以通过在前面加一个转换获得通过隐式转换把字符型转换为数字型来获取第中方法可以获取指定时间的时间戳时间戳转换为日期如果你有一个时间戳并想将其转换为对象可以使用构造函数给定的时间戳将时间戳转换为对象使用时间戳时间戳在中非常有用尤其是在需要比较不同时间点或者执行定时任务时例如你可以使用时间戳来计算两个时间点之间的时间差执行某些操作操作耗时毫秒实际应用这里是一个示例展示如何使用时间戳来计算从年月日到年月日这段时间的时间戳计算年月日的时间戳注意月份是从开始的输出时间戳事件监听事件事件是发生在元素上的事情比如按钮被点击鼠标移动到元素上按下键盘按键事件监听可以在事件被侦测到时执行代码事件绑定方式一通过标签中的时间属性进行绑定按钮我被点击了方式二通过元素属性绑定按钮我被点击了常见事件在中事件是用户或浏览器的动作它们可以触发预定义的函数或代码块事件驱动的编程是现代开发的核心部分允许网站对用户的交互作出反应以下是在中常见的几种事件类型鼠标事件当用户点击鼠标左键时触发当用户双击鼠标左键时触发当鼠标按钮被按下时触发当鼠标按钮被释放时触发当鼠标在页面上移动时持续触发和当鼠标进入或离开一个元素时触发这两个事件不会存在冒泡和捕获和类似于和会存在捕获和冒泡阶段当用户右击鼠标时触发键盘事件当键盘上的一个键被按下时触发当按下有字符输出的键时触发当键盘上的一个键被释放时触发文档和窗口事件当页面或资源加载完成时触发当页面正在卸载时触发页面即将卸载之前触发当窗口大小改变时触发当页面滚动时触发表单事件当表单元素如输入框下拉列表的内容被改变时触发和当元素获得或失去焦点时触发当表单被提交时触发其他事件当错误发生时触发如图像加载失败和分别在窗口尺寸变化或滚动时触发触摸设备上的事件事件处理可以通过直接在标签中设置事件属性如或者通过的来监听事件事件对象事件处理器通常会接收到一个事件对象这个对象包含了关于事件的所有信息如事件类型触发事件的元素鼠标的位置键盘按键等事件对象通常作为函数的第一个参数传递例如输出这里的指的是事件对象事件对象在中提供了一系列的属性用于描述触发事件的详细信息下面列出了事件对象中一些常用的属性描述事件的类型如等指向事件最初触发的元素即使事件被冒泡到其他元素始终指向最初触发事件的元素指向当前正在处理事件的元素如果事件被冒泡或捕获将根据事件流而变化描述事件当前处于哪个阶段或事件发生的精确时间戳单位通常是毫秒方法阻止事件的默认行为例如在链接上阻止页面跳转方法阻止事件冒泡到父级元素类似于但是它还会阻止事件处理函数队列中的后续函数执行和对于鼠标事件表示鼠标指针相对于视口的位置不包括滚动条偏移和对于鼠标事件表示鼠标指针相对于整个文档的位置包括滚动条偏移和对于鼠标事件表示鼠标指针相对于屏幕的位置对于鼠标事件表示哪个鼠标按钮被按下主按钮通常是左键中间按钮次按钮通常是右键或对于键盘事件是一个数字表示按下的键在现代浏览器中更推荐使用属性它是一个字符串提供了更清晰的键标识类似于但跨浏览器兼容性更好布尔值表示是否同时按下了或键环境对象环境对象指的是函数内部特殊的变量它代表着当函数运行时所处的环境作用弄清楚的指向指代的对象也不同函数调用方式不同指代的对象也不同谁调用该函数就指向谁这是判断指向的粗略规则事件流定义事件流指定是一个事件完整执行过程中的流动路径在中事件流描述了事件是如何在文档对象模型中传播的事件流主要分为两个阶段事件捕获和事件冒泡还存在一个中间阶段即目标阶段在这个阶段事件直接作用于目标元素事件捕获这是事件流第一阶段从父到子事件捕获是从树的根节点通常是或开始事件沿着元素层级向下传播直到达到目标元素在这一阶段事件处理程序有机会在事件到达目标元素之前进行拦截和响应给函数写入第三个参数意味着开启了捕获机制事件要同名目标阶段一旦事件到达目标元素目标元素上的事件处理程序被调用这是事件直接作用于触发事件的元素的阶段事件冒泡这是事件流第二阶段从子到父在事件冒泡阶段事件从目标元素开始沿树向上逐级传播直到达到树的根节点在这个过程中事件处理程序可以被沿途的任何父元素捕获给函数写入第三个参数这也是默认值所以一般不写意味着开启了冒泡机制当触发冒泡机制时一个元素触发事件后会一次从触发事件的子元素向上调用所有父级元素的同名事件事件冒泡默认存在事件流的传播方向事件捕获从外部到内部从根节点到目标节点事件冒泡从内部到外部从目标节点到根节点使用事件处理程序你可以使用方法来附加事件处理程序并通过传递第三个布尔参数来选择事件流的哪个阶段来触发该处理程序如果第三个参数为则事件处理程序会在事件捕获阶段被调用如果第三个参数为或省略则事件处理程序会在事件冒泡阶段被调用阻止冒泡目标能够写出阻止冒泡的代码问题因为默认就有冒泡模式的存在所以容易导致事件影响到父级元素需求若想把事件就限制在当前元素内就需要阻止事件冒泡前提阻止事件冒泡需要拿到事件对象语法事件对象有动植物等的繁殖增殖观点理论等的传播运动光线声音等的传送的意思注意此方法可以阻断事件流动传播不光在冒泡阶段有效捕获阶段也有效事件解绑解绑事件利用定义的事件存在冒泡不存在捕获我被点击了通过赋值空对象来解绑解绑通过添加的事件我是通过添加的事件点击之后我就被解绑了由于第二个参数需要传入函数的名字所以匿名函数无法移除注意匿名函数无法解绑事件委托事件委托是一种在父元素上处理子元素事件的技术它的核心思想是而不是在每个子元素上单独添加事件监听器你可以在一个共同的祖先元素上添加一个监听器然后根据事件的目标来确定哪个子元素触发了事件这种方法可以显著减少事件监听器的数量从而提升性能特别是在处理大量动态生成的元素时如何实现事件委托事件委托利用了事件冒泡的特性即事件从最深层的触发元素开始向上冒泡到树的更高层当事件冒泡至监听器所在的元素时你可以检查事件的目标是否符合你的需求实现步骤选择一个合适的祖先元素选择一个包含所有相关子元素的共同祖先作为事件监听器的挂载点添加事件监听器在选定的祖先元素上添加事件监听器通常是在等常见事件类型上检查事件目标在事件处理函数中使用来确定触发事件的实际元素并根据需要做出响应如果需要更确切的确定元素可以通过元素的来进一步判断示例代码假设你有一个列表其中包含许多链接你想要在这些链接被点击时执行某个操作但是你不想为每个链接单独添加事件监听器检查目标是否是我们感兴趣的元素阻止默认行为例如链接跳转在这个例子中我们没有在每个标签上添加事件监听器而是将监听器添加到了元素上当用户点击任何一个链接时事件会冒泡到元素然后我们检查以确定哪个链接被点击阻止事件的默认行为在中阻止元素的默认行为通常是在事件处理函数中完成的这样可以防止与该事件相关的默认动作被执行例如阻止链接的导航表单的提交或阻止某些键盘快捷键的默认行为要阻止元素的默认行为可以使用方法这个方法是事件对象的一个属性当在事件处理函数中被调用时会取消事件的默认行为以下是一个阻止链接点击时默认跳转行为的例子在这个例子中当链接被点击时原本的跳转行为会被取消而控制台将输出一条信息同样地如果你想要阻止表单提交的默认行为可以这样做在这里执行自定义的提交逻辑在这个表单提交的例子中阻止了表单的默认提交动作使页面不会重新加载或导航到表单的需要注意的是并不影响事件的冒泡或捕获过程如果你想阻止事件的进一步传播可以使用但通常用于取消事件的默认行为而用于阻止事件向父元素的传播在某些情况下如阻止拖放行为或阻止某些键盘快捷键的默认行为也是必需的例如阻止用户使用复制文本元素在页面中的位置页面滚动在中通常指的是与滚动条和滚动位置相关的操作浏览器窗口或元素的滚动可以通过以下几种方式来访问或修改或这些方法用于将浏览器窗口滚动到特定的位置它们接受两个参数第一个是水平位置坐标第二个是垂直位置坐标滚动到页面顶部以下像素的位置或者使用方法平滑滚动到指定位置此方法相对于当前位置移动窗口同样接受两个参数分别表示水平和垂直方向上的偏移量向下滚动像素和这两个属性返回窗口当前的滚动位置是水平滚动距离是垂直滚动距离输出垂直滚动的距离和这些属性用于获取或设置特定元素的滚动位置表示垂直滚动距离表示水平滚动距离获取元素的垂直滚动距离将元素的垂直滚动位置设置为像素和这些属性返回元素的内容高度和宽度包括溢出的部分获取元素内容的高度包括不可见部分这个方法会将元素滚动到视图内可选择性地使元素对齐到视口的顶部中心或底部平滑滚动并使元素居中显示家族家族的一系列属性提供了关于浏览器窗口可视区域的信息而不包括工具栏滚动条菜单栏等非内容区域返回元素的宽度包括内边距但不包括边框和滚动条如果应用于对象它返回浏览器窗口的可视宽度不包括滚动条类似于但返回高度这包括元素的内边距但不包括边框和滚动条在对象上它返回浏览器窗口的可视高度返回元素左侧边框的宽度如果元素没有边框此值为返回元素顶部边框的宽度如果元素没有边框此值为这个属性通常与鼠标事件一起使用表示相对于视口的鼠标水平位置例如在等事件中提供了鼠标的水平坐标与类似但表示垂直坐标家族在开发中家族的属性提供了一组与元素的位置和尺寸有关的信息这些属性主要用于获取元素相对于其偏移父元素的位置和尺寸而通常是元素最近的具有定位的祖先元素或者是元素本身如果没有任何定位的祖先家族主要包括以下几个属性返回元素的宽度包括元素的内容内边距边框但不包括外边距单位是像素返回元素的高度包括元素的内容内边距边框但不包括外边距单位是像素返回元素左边缘相对于其的左边缘的偏移量单位是像素只读属性返回元素顶边缘相对于其的顶边缘的偏移量单位是像素只读属性返回元素的这个元素是最近的具有定位属性的祖先元素或者是元素如果没有定位的祖先这些属性非常实用尤其是在动态调整布局响应式设计元素对齐或动画效果中由于它们返回的是实际的像素值因此可以用于计算和调整元素的位置和大小值得注意的是家族的属性返回的值总是数值而不是带有单位的字符串这意味着如果需要进行样式设置你可能需要将这些数值转换为带有单位的字符串图解获取元素大小位置的另外方法方法该方法返回元素的位置大小是相对于视口的位置来看的总结属性作用说明和被卷去的头部和左侧配合页面滚动事件来使用可读写和获得元素的宽度和高度不包含元素的滚动条等用于利用读取元素大小只读属性和获取元素的宽度和高度包含元素的滚动条等只读属性和获取元素距离自己已经拥有定位属性的父级元素的左上方向的距离获取元素位置的时候可以使用只读属性变量语法变量名变量的赋值语法变量要赋的值或者弹出输入框请输入姓名请输入姓名的区别在较旧的使用关键字来声明变量而不是现在开发中一般不再使用它只是我们可能再老版程序中看到它为了解决的一些问题为什么不用声明可以先使用在声明不合理声明过的变量可以重复声明不合理比如变量提升全局变量没有块级作用域等等推荐使用的情况当你需要声明一个变量且这个变量的值可能会发生变化时使用允许你在块级作用域内声明变量这有助于避免变量之间的冲突和意外覆盖推荐使用的情况当你声明一个变量并且知道它的值不会改变时应该使用使用可以明确表示该变量是不可变的这有助于提高代码的可读性和可维护性即使是对象或数组虽然你可以改变它们的内容但仍然有助于确保不会重新分配一个新的引用总结默认使用尽可能地使用来声明变量这样可以确保在变量值不需要改变的情况下它们不会被意外修改只有当需要改变时使用当你确定某个变量的值会在后续的代码中发生改变时才使用来声明基本认识获取元素根据选择器来获取元素选择匹配的第一个元素语法选择器获取匹配的第一个元素通过标签元素和类名来进行选择参数包含一个或多个有效的选择器字符串返回值选择器匹配的第一个元素一个对象选择多个元素语法返回值返回一个数组得到的是一个伪数组有长度有索引号的数组但是没有等数组方法想要得到里面的每一个对象则需要遍历的方式获得其他获取元素的方法操作元素内容对象属性将文本内容添加更新到任意标签位置能够解析标签通常配合模板字符使用对象属性将文本内容添加更新到任意标签位置显示纯文本不能够解析标签案例修改元素内容这是修改前的内容点我修改内容这是修改前的内容点我修改内容这是修改后的内容我是我只能修改文本并不能识别标签操作元素的属性操作元素常用属性通过设置修改标签的元素属性比如通过更换图片最常见的属性比如等语法对象属性修改的值举例修改元素内容这是修改前的内容点我修改内容这是修改前的内容点我修改内容这是修改后的内容我是我只能修改文本并不能识别标签操作元素样式属性通过属性来操作通过类名来操作通过操作类控制通过属性来操作语法对象属性值多单词采取小驼峰命名注意单位对象属性值通过类名来操作语法对象类名修改较多样式推荐使用该方法因为是关键字所以这里要使用来代替通过这种方式是新值替换旧值会顶替掉之前的类名如果使用这种方法要记得保留原来类名通过类名来操作通过操作类控制追加一个类对象类名删除一个类对象类名切换一个类对象类名如果原来有切换的类那么这个类通过切换就会被移除如果没有那么就会添加这个类通过操作类控制添加这行代码会让第三个盒子背景变为红色操作表单元素属性操作表单及其元素的属性可以通过来实现以下是一些常见的操作比如获取或设置表单元素的属性值样式等获取和设置表单元素的值获取文本框的值设置文本框的值检查复选框的状态检查复选框是否被选中设置复选框的状态设置复选框为选中状态操作选择框下拉列表获取选择框的选中项的值设置选择框的选中项添加和删除表单元素创建一个新的输入元素设置新输入元素的类型和将新输入元素添加到表单中从表单中移除一个元素设置和获取表单元素的样式设置元素的背景颜色获取元素的背景颜色注意这将返回计算后的样式可能与设置的不同监听表单事件当提交按钮被点击时执行某些操作表单已提交本地存储对象对象提供对特定网站的本地存储的访问它允许您存储读取添加修改和删除该域的数据项存储的数据没有到期日期并且在浏览器关闭时不会被删除这些数据将在几天几周和几年内均可用本地存储只能存为字符串温馨提示本地存储在进行增删改等业务推荐使用同一个键值推荐用数组存储多个方便处理用途用于将数据项存储在中参数它接受一个名称和一个值作为参数实例利用存储数据以形式存储小李用途用于从中读取相应键对应的值参数接收一个键值字符串形式实例小李用途删除对应键的值参数接收一个值实例从中删除数据对象对象与对象相同不同之处在于对象存储会话的数据当浏览器关闭时数据会被删除用途方法将数据项存储在存储中参数它接受一个名称和一个值作为参数实例用途方法从存储中检索数据项参数它接受一个名称作为参数实例用途删除对应键的值参数接收一个值存储复杂类型的数据这里以对象类型举例如果要存储一个对象类型的数据步骤如下把对象类型转换成字符串类型语法对象使用本地存储的存储方法存储数据如果要取出一个字符串类型的对象数据步骤如下通过方法取出字符串类型的对象数据把取出来的字符串类型数据转换成对象类型语法对象属性和方法属性方法描述返回存储中第个键的名称返回存储在对象中的数据项数返回指定的键名的值将键添加到存储中或者如果键已经存在则更新该键的值从存储中删除该键清空所有键正则表达式在中正则表达式是一种用于匹配字符串中字符组合的强大工具它们可以用来执行复杂的文本处理任务如搜索替换和提取文本使用场景来进行表单验证过滤敏感词等等创建正则表达式字面量表示法是修饰符详见修饰符小结构造函数方式常用的正则表达式模式匹配特定字符匹配任何单个字符除了换行符匹配数字匹配字母或数字匹配空白字符重复匹配前面的子表达式零次或多次匹配前面的子表达式一次或多次匹配前面的子表达式零次或一次匹配前面的子表达式恰好次匹配前面的子表达式至少次匹配前面的子表达式至少次但不超过次选择或运算符用于匹配多个表达式中的任意一个边界表示行的开始表示行的结束表示单词边界使用正则表达式的常见方法方法输出方法输出输出元字符在的正则表达式中元字符是一些具有特殊含义的字符它们被用来定义复杂的搜索模式下面列出了一些常用的元字符及其功能常见元字符边界符在方括号内表示取反即匹配不在方括号内的字符不在方括号内时如果位于正则表达式的开头则表示匹配字符串的开始美元符号如果位于正则表达式的末尾则表示匹配字符串的结尾量词星号表示匹配前面的字符零次或多次加号表示匹配前面的字符一次或多次问号表示匹配前面的字符零次或一次花括号表示重复前面的字符次花括号表示重复前面的字符至少次花括号表示重复前面的字符至少次但不超过次字符类方括号定义字符集匹配方括号中的任何一个字符点表示匹配任何单个字符除了换行符取反方括号定义非字符集匹配不属于方括号中的任何字符圆括号定义捕获组用于对匹配进行分组并捕获匹配的部分管道符号表示逻辑或匹配两个或多个选项中的任意一个单词边界匹配单词边界即单词字符和非单词字符之间的边界非单词边界匹配非单词边界即两个单词字符或两个非单词字符之间的地方数字匹配任何十进制数字等同于非数字匹配任何非数字字符等同于单词字符匹配任何单词字符等同于非单词字符匹配任何非单词字符等同于空白字符匹配任何空白字符等同于非空白字符匹配任何非空白字符等同于字符串开始表示匹配字符串的开始字符串结束表示匹配字符串的结束字符串结束同样表示匹配字符串的结束上次匹配结束处表示从上次匹配的结束位置开始匹配转义字符分别代表新行回车制表符换页符和垂直制表符修饰符语法正则表达式修饰符也就是在正则表达式后面的就是修饰符全局匹配这个标志告诉正则表达式引擎在整个字符串中查找所有匹配项而不仅仅是找到第一个匹配后就停止如果没有使用这个标志正则表达式默认是从左向右只匹配第一个符合条件的结果忽略大小写当使用此标志时正则表达式在进行匹配时不区分大小写例如将会匹配等多行模式此标志使和能够分别匹配每行的开始和结束而不仅仅是整个字符串的开始和结束例如在多行文本中将匹配每一行的开头为的部分单行模式也被称为模式此标志使得可以匹配任何字符包括换行符没有此标志时不匹配换行符模式此标志使得正则表达式支持完整的字符范围当使用等预定义类时将考虑所有字符而不仅仅是字符粘贴模式该标志使得正则表达式只能从上次匹配的位置开始匹配这通常与全局标志一起使用以便在连续的调用中保持匹配的位置示例让我们通过一些例子来看看这些元字符是如何使用的匹配任何数字匹配以数字开头的字符串匹配以数字结尾的字符串匹配连续三个或更多的字符匹配连续一个到三次的字符匹配任何数字或字母匹配任何非数字异步中的更详细请移步笔记前置知识概念是一种处理异步操作的更优雅的方法对象代表了一个最终会在未来完成或失败的值的初次计算结果基本语法的基本语法这里是用来执行异步任务的代码块异步任务执行成功调用此时可以通过方法访问结果异步任务执行失败调用此时可以通过方法处理错误接收结果成功后获得数据处理失败的三种状态有三种状态初始状态既未成功也未失败对应成功完成此时可以通过方法访问结果调用了函数操作失败此时可以通过方法处理错误调用了函数对象的使用执行某些异步任务成功时出错时下面就是对对象的使用成功时的代码出错时的代码回调地狱多个回调函数形成嵌套形成回调地狱缺点可读性差异常捕获困难耦合性差链式调用原理对象方法利用方法返回新的对象和上一个对象不相同概念依靠方法返回一个新的对象特性继续串联下一环任务直到结束简单示例北京市获取查看返回对象函数返回了一个新的对象方法返回一个新的对象北京市北京市北京市结合来使用链式调用重点由于每发起一次请求就会有一个新的对象所以可以下向下面这样写在函数中继续向外层一个新的对象的位置要写在函数外因为利用的是该函数的返回值北京的位置要写在函数外因为利用的是该函数的返回值返回北京市下的城市名称异步使函数返回使函数等待语法函数前的关键字使函数返回实例等同于以下是使用的方法成功时的代码出错时的代码实例使函数返回在这里调用返回时的动作成功的回调失败的回调语法函数前的关键字使函数获得对象成功状态的结果值只能获取请求成功时得到的结果只能使用在被修饰的函数内部关键字只能在函数中使用基础语法实例只能获取请求成功时得到的结果只能使用在被修饰的函数内部等待请求成功时将数据赋值给变量和捕获错误使用来捕获错误包裹可能出现错误的代码块如果在某一环节捕获到了错误那么剩余的代码不会执行来处理错误捕获错误利用包裹可能出现错误的代码等待请求成功时将数据赋值给变量利用来接收错误信息如果在某一环节捕获到了错误那么剩余的代码不会执行概念异步的和作用是开发者的梦想因为您能够不刷新页面更新网页在页面加载后从服务器请求数据在页面加载后从服务器接收数据在后台向服务器发送数据数据交换通过可以给服务器发送请求并获取服务器响应的数据异步交互可以在不重新加载整个页面的情况下与服务器交换数据并更新部分网页的技术如搜索联想用户名是否可用的校验等等是一个基于的库可以用于浏览器和中它被广泛用于与进行交互特别是在前端开发中用来发送请求基础语法请求方式请求地址请求参数向服务器发送数据用选项一般是请求携带查询参数用参数名参数值回调函数请求配置常用配置项必需发送请求的地址必需请求方法如可选发送到服务器的数据对于等方法来说这个数据会被序列化并发送到服务器可选发送到服务器的查询字符串参数可选自定义请求头可选请求超时时间单位为毫秒如果请求超过了指定的时间将抛出一个错误可选是否携带这对于跨域请求非常重要默认为可选指定响应的数据类型如可选验证服务器响应的状态码是否成功默认情况下只有状态码在范围内的才会被认为是成功的可选最大重定向次数默认为可选取消请求的用于取消正在进行的请求可选包含用户名和密码的对象用于基本身份验证错误处理错误处理的基本方式使用处理错误当请求失败时函数会捕获错误并允许你执行相应的错误处理逻辑请求方法下面是一些基本请求方法用于获取资源用于创建资源用于更新资源用于删除资源用于局部更新资源用于获取资源的元信息用于获取服务器支持的通信选项响应状态码下面是一些常用的状态码成功状态码请求已成功这是最常见的成功状态码请求被成功创建通常用于请求服务器成功处理了请求但不需要返回任何内容重定向状态码请求的资源已被永久移动到新位置临时重定向请求的资源现在临时位于不同的请求的资源未被修改因此返回并不包含资源的实体部分客户端错误状态码服务器无法理解请求的格式请求需要用户身份验证服务器理解请求客户端的请求但是拒绝执行此请求请求的资源不存在请求的方法不允许对请求的资源使用服务器错误状态码服务器遇到一个未曾预料的状况导致它无法完成对请求的处理作为网关或代理工作的服务器收到了来自上游服务器的有效响应但是无效的最终响应服务器目前无法使用可能是由于服务器过载或维护什么是并非编程语言仅仅组合了浏览器内建的对象从服务器请求数据和显示或使用数据是一个令人误导的名称应用程序可能使用来传输数据但将数据作为纯文本或文本传输也同样常见允许通过与场景后面的服务器交换数据来异步更新网页这意味着可以更新网页的部分而不需要重新加载整个页面如何工作网页中发生一个事件页面加载按钮点击由创建对象对象向服务器发送请求服务器处理该请求服务器将响应发送回网页由读取响应由执行正确的动作比如更新页面基础语法创建对象用于在后台与服务器交换数据定义回调函数当从服务器请求数据返回后执行的函数发送请求到服务器通常使用或方法处理服务器响应在回调函数中处理数据创建对象设置请求完成后的回调函数写法请求完成并且成功输出服务器响应的数据当然了上面的回调函数也可以写成下面这样写法对响应回来的结果进行处理初始化请求发送请求传递参数携带查询参数查询参数直接拼接在后面利用来把查询参数以的形式写在后面参数直接拼接在后面利用来把查询参数以的形式写在后面辽宁省携带要提交的数据设置请求头为设置请求头为准备数据并转为格式发送数据发送请求并把要发送的数据携带上完整逻辑如下设置请求头为把准备的数据转为字符串设置回调函数回调后执行的逻辑发送请求并把要发送的数据携带上对象获得对象对象通过构造函数创建对象方法方法描述创建新的对象取消当前请求返回头部信息返回特定的头部信息规定请求请求类型或文件位置异步或同步可选的用户名可选的密码向服务器发送请求用于请求向服务器发送请求用于请求将标签值对添加到要发送的标头对象属性属性描述定义接收到加载请求时要调用的函数定义当属性发生变化时调用的函数保存的状态请求未初始化服务器连接已建立请求已收到正在处理请求请求已完成且响应已就绪以字符串形式返回响应数据以数据返回响应数据返回请求的状态号如需完整列表请访问消息参考手册返回状态文本比如或同步请求异步请求同步代码逐行执行需原地等待结果才继续向下执行异步代码调用会耗用事件不阻塞代码继续执行完成后会执行一个回调函数耗时任务如需执行同步的请求请把方法中的第三个参数设置为默认执行异步请求也就是有时用于快速测试你也会在更老的代码中看到同步请求由于代码将等待服务器完成所以不需要函数实例我们不推荐同步的因为将停止执行直到服务器响应就绪如果服务器繁忙或缓慢应用程序将挂起或停止同步正在从标准中移除但是这个过程可能需要很多年现代开发工具被鼓励对使用同步请求做出警告并且当这种情况发生时可能会抛出异常同步和异步服务器响应请求服务器响应属性属性描述获取字符串形式的响应数据获取数据形式的响应数据属性属性以字符串的形式返回服务器响应因此您可以这样使用它实例属性对象有一个內建的解析器属性以对象返回服务器响应服务器响应方法方法描述从服务器返回特定的头部信息从服务器返回所有头部信息方法方法返回所有来自服务器响应的头部信息实例方法方法返回来自服务器响应的特定头部信息实例进阶中的堆和栈栈栈是一种先进后出的数据结构在中栈主要用来存储基本类型的值也称为原始类型如数字字符串布尔值和对象的引用特点栈中的数据存取非常快因为它是按照原则操作的栈空间的大小通常是固定的超出范围会导致栈溢出错误栈中的数据一旦不再需要就会被自动释放堆堆是一种无序的动态的数据结构在中用于存储对象和数组的实际内容特点堆中的数据可以动态分配和释放这意味着可以在运行时增加或减少内存堆中的数据访问速度比栈慢因为它涉及到指针查找和间接访问堆中的数据不会自动释放而是通过垃圾回收机制来清理不再使用的数据关键区别存储位置栈存储基本类型的值和对象的引用堆存储对象本身及其属性内存管理栈中的数据通常在创建时就已经确定了大小并且当作用域结束时自动释放堆中的数据会在运行时动态分配并由垃圾回收器管理当对象不再被引用时会被回收作用域规定了变量能够被访问的范围离开这个范围变量无法被访问作用域分为局部作用域和全局作用域局部作用域在中局部作用域指的是变量在一个特定的代码块如函数内部内可见和可访问的范围当变量在一个函数内部被声明时它只能在该函数内部被访问这就是局部作用域的概念函数作用域使用关键字声明的变量在整个函数体内都是可见的这种作用域适用于整个函数而不是某个具体的代码块块作用域块被包裹的就是块使用和关键字声明的变量只在声明它们的代码块内可见这种作用域适用于像循环或条件语句这样的代码块例子函数作用域块作用域块作用域输出输出输出输出全局作用域标签和文件是全局作用域全局作用域内声明的变量可以被局部作用域访问作用域链作用域链本质上是底层的变量查找机制在函数执行时会优先查找当前函数作用域中查找变量如果当前作用域查找不到则会一次逐级查找父级作用域直到全局作用域垃圾回收机制的垃圾回收机制是一种自动管理内存的过程它负责释放不再使用的内存空间这使得开发者无需手动管理内存分配和释放从而降低了内存泄漏的风险以下是垃圾回收机制的一些关键方面标记与清除这是最基本的垃圾收集算法之一它分为两个阶段标记垃圾收集器标记所有从根节点开始能够寻找到的对象清除清理未被标记的对象这些对象被认为是垃圾可以被释放引用计数早期的引擎还使用了引用计数的方法来跟踪对象的引用数量当一个对象的引用计数变为时该对象就可以被回收这种方法简单快速但是容易导致循环引用的问题即两个或多个对象相互引用而无法被垃圾收集器识别为垃圾分代收集现代引擎使用了一种称为分代收集的技术这种技术基于观察到的事实新创建的对象往往很快就会被丢弃而存活时间较长的对象则很可能继续存活下去因此对象被划分为几代不同代的对象使用不同的策略进行垃圾回收年轻代新创建的对象通常放在这一代中年轻代的垃圾回收频率较高但每次回收的时间较短老年代经过多次年轻代垃圾回收后仍然存活的对象会被移动到老年代老年代的垃圾回收频率较低但每次回收可能需要更长的时间增量收集增量收集将垃圾回收过程分成多个小步骤这样可以在应用程序执行之间进行从而减少长时间的暂停压缩随着垃圾回收的进行内存中的空闲空间可能会变得碎片化压缩是一种技术它将存活的对象移动到连续的内存区域从而消除内存碎片如何避免内存泄漏尽管自动管理内存但在某些情况下仍可能出现内存泄漏以下是一些避免内存泄漏的方法解除事件监听器确保在不再需要时移除事件监听器断开引用如果一个元素被移除确保断开与它的所有引用使用弱引用在某些现代引擎中支持弱引用可以用来避免循环引用导致的内存泄漏清理定时器和回调确保在不再需要时清除定时器和回调函数避免闭包中的大对象闭包可以维持对大对象的引用确保它们在不再需要时被正确释放闭包闭包是中一个非常重要的概念简单来说闭包就是函数和它所能访问的外部作用域变量的组合也就是闭包内层函数外层函数的变量也就是内层函数要用到外层函数的变量闭包的形成闭包的形成通常涉及到以下三个要素函数必须有一个函数外部作用域函数必须访问其外部作用域中的变量返回值通常返回一个函数或者使外部作用域能够通过某种方式访问外部作用域变量访问外部作用域变量返回内部函数创建闭包输出闭包的作用保持数据私有闭包可以用来隐藏变量不让外部代码直接访问持久存储闭包可以让变量在函数执行完毕后依然存在模拟私有成员在面向对象编程中闭包可以用来实现类的私有方法和属性闭包可能会造成内存泄漏这和它的持久存储有关系变量提升了解仅针对于来声明的变量机制把所有声明的变量提升到当前作用域的最前面只提升不进行赋值输出在这个例子中虽然在使用之前被声明了但由于变量提升的作用这一行被移到了作用域的顶部而赋值操作则保持原位因此在输出的时候它还没有被赋值所以输出的是函数进阶函数提升机制会把所有函数声明提升到当前作用域的最前面只提升函数声明不提升调用函数提升例子输出在这个例子中尽管函数是在它被调用之后才被定义的但是因为函数声明被提升到了作用域的顶部所以可以正确地调用并返回结果警惕定义的变量后给改该变量赋值在这个例子中尽管看起来像是一个函数但实际上它是一个赋值给变量的函数表达式因此只有变量名被提升到了作用域的顶部而函数体没有被提升试图在定义之前调用会导致一个类型错误函数参数默认参数还支持默认参数允许你在函数定义时为参数指定默认值当调用函数时如果没有提供某些参数那么这些参数就会使用默认值输出输出动态参数使用对象场景参数个数不确定该对象返回了一个伪数组该数据并没有真正数组的方法输出使用剩余参数剩余参数必须位于参数列表的最后从开始引入了一种新的语法剩余参数语法它可以用于收集传递给函数的多余参数并将它们作为一个数组来处理注意点该语法获取的是剩余的参数比如传递三个参数在上面这个函数中是是那么通过剩余参数获得参数将会被放在一个数组中也就是会出现在数组中注意要与展开运算符做一个区分展开运算符可以用来展开数组输出应用场景求数组最大值合并数组等箭头函数箭头函数有着更简洁的函数写法并且不绑定箭头函数语法要比函数表达式简洁基本语法我是箭头函数箭头函数可以传递参数我是箭头函数这是传递的参数只有一个形参时可以省略参数的括号我是箭头函数这是传递的参数函数体只有一行可以省略大括号我是箭头函数这是传递的参数函数体只有一行代码可以省略箭头函数可以直接返回一个对象刘德华上面这种写法相当于下面这样写刘德华箭头函数的参数普通形参和剩余参数注意箭头函数里面没有使用箭头函数求和这里用剩余参数去写箭头函数中的箭头函数不绑定自己的它使作用域中的值这意味着箭头函数内部的值是根据它被定义的位置来决定的而不是根据它被调用的位置解构赋值数组结构作用快速批量赋值变量基本语法变量名使用数组解构会把数组中的值按照声明变量的顺序依次赋值相当于忽略某些值有时你可能只想解构数组中的部分值你可以通过在解构模式中留空来忽略某些值输出输出使用默认值输出输出输出解构嵌套数组输出输出输出输出对象结构在中对象解构是一种从对象中提取值并将其分配给变量的简洁方式这种方法可以让你以更直观的方式处理对象中的属性特别是当你需要从对象中提取特定的属性时非常有用对象解构的基本语法如下这里是用于接收对象中属性值的变量列表而是要解构的对象解构基本对象输出输出输出在这个例子中我们创建了一个包含姓名和年龄的对象然后通过解构将对象中的属性分别赋值给了三个变量忽略某些属性有时你可能只想解构对象中的部分属性你可以通过在解构模式中留空来忽略某些属性输出输出这里属性被忽略了因为它对应的解构位置为空使用默认值如果你希望在解构时为未提供的属性设置默认值可以这样做输出输出输出在这个例子中属性没有在原始对象中提供所以我们为它指定了一个默认值解构嵌套对象你还可以解构嵌套的对象注意要在前面写上要结构对象的名字输出输出输出在这个例子中我们有两个嵌套的对象我们通过解构来分别获取每个对象中的属性解构并重命名属性如果你想在解构的同时给变量重新命名可以这样做输出输出输出深入对象创建对象通过字面量方式创建直接使用大括号来定义一个对象输出使用创建对象佩奇佩奇使用构造函数来创建通过定义一个构造函数来创建对象这种方式可以用来创建多个具有相同属性和方法的对象输出构造函数这是一种特殊的函数主要用来初始化对象通过构造函数可以快速创建多个类似的对象一般构造函数有两个约定命名以大写字母开头他们只能由操作符来执行创建构造函数使用构造函数佩奇实例成员静态成员这里要注意与进行区别实例成员实例对象上的属性和方法就是实例属性和实例方法被称为实例成员静态成员构造函数上的属性和方法就是静态属性和静态方法称为静态成员存在的问题存在浪费内存的问题内置构造函数对象学习三个常用的静态方法静态方法就是只有构造函数可以调用静态方法获取对象中所有的属性语法佩奇获取对象的所有属性名并且返回是一个数组注意返回的是一个数组静态方法获取对象中所有的属性值语法佩奇获取对象的所有属性名并且返回是一个数组佩奇注意返回的是一个数组静态方法常用于对象拷贝语法佩奇获取对象的所有属性名并且返回是一个数组把对象的属性和属性值拷贝给对象注意返回的是一个数组使用场景一般用来给某个对象追加新属性特别适用数组详细用法请见对象数组对象小结基本语法这是通过构造函数创建的字符串下面是一些字符串的基本方法数值作用用于创建数组是一个内置构造函数一些常用方法设置保留小数位的长度保留两位小数四舍五入两种编程思想面向过程编程和面向对象编程面向过程编程面向过程编程是一种以过程为中心的编程范式它将程序视为一系列的过程或函数调用每个过程或函数完成特定的任务这种编程方式强调的是如何一步步地解决问题特点包括代码组织通过函数或子程序来组织代码使得代码更易于理解和复用数据处理数据通常作为参数传递给函数并且结果也通过函数返回控制流使用流程控制结构如循环和条件语句来控制程序执行的顺序面向对象编程面向对象编程是一种以对象为中心的编程范式它将程序视为对象的集合这些对象可以包含数据属性和行为方法强调的是对象之间的交互特点包括三大特性封装将数据和操作数据的方法绑定在一起隐藏内部细节只对外提供接口继承允许创建现有类的新版本新版本可以继承原始类的特性并添加新的功能多态允许一个接口代表多种类型也就是说同一个接口可以有多种不同的实现方式原型重要原型对象构造函数通过原型分配的函数是所有对象所共享的规定每一个构造函数都有一个属性指向另一个对象所以我们也成为原型对象该对象可以挂载函数对象实例化不会多次创建原型上函数节约内存我们可以吧那些不变的方法直接定义在对象上这样索引对象的实例就可以共享该方法构造函数和原型对象中的指向实例化对象示例自己定义数组拓展方法求和和最大值定义的方法任何数组都可以使用所以定义在数组的原型对象上求最大值在这里指向实例对象也就是求和在这里指向实例对象也就是调用属性每个原型对象中都有属性该属性也被成为构造函数作用该属性指向该原型对象的构造函数一图理解对象原型每个实例化的对象都会有一个属性指向构造函数的的原型对象之所以我们的实例化对象可以使用构造函数原型对象的方法和属性就是因为有对象原型的存在一图理解注意是非标准属性是只读属性和意义相同用来表示当前实例对象指向那个原型对象最后一点对象原型里面也有一个属性该属性指向创建该实例对象的构造函数三者最终关系如下原型继承假设我们有两个构造函数和我们想要让继承的属性和方法这可以通过将的属性设置为的实例来实现设置的为的实例这句代码是核心继承就是通过这样实现但是切记要写成下面这种格式修正指向输出出现的问题当你直接将设置为时所有实例共享原型上的属性这意味着如果你在一个实例中修改了原型上的属性那么这个变化会影响到其他所有实例要注意修正指向不能丢失了属性原型链的查找规则当我们在中访问一个对象的属性时如果该对象本身没有这个属性引擎会沿着该对象的原型链继续查找更具体的查找规则如下当访问一个对象属性方法时第一步查找该对象本身有没有该属性方法如果没有那么就查找它的原型也就是指向的原型对象如果还没有那就查找原型对象的原型也就的原型对象依次类推一直找到为止因为在往上找就是了对象原型存在的意义就在于为对象成员查找机制提供一个方向或者说一条路线可以使用运算符用于检测构造函数中的属性是否出现在某个实例对象的原型链上原型链是由一系列原型对象组成的链式结构最终会指向因为没有原型原型链的工作原理对象创建原型对象的概念当使用关键字创建一个对象时该对象会自动获得一个原型对象通常是构造函数的属性所指向的对象属性查找当访问一个对象的属性或方法时引擎首先会在该对象自身查找该属性如果没有找到它会沿着原型链向上查找直到找到该属性或到达原型链的末端原型链的末端原型链的末端是一个没有任何属性的空对象即原型链的构造内置原型每个内置的构造函数都有一个属性如等自定义构造函数自定义的构造函数同样拥有属性用于继承的目的原型链的构建当创建一个新对象时该对象的属性被设置为构造函数的属性所指向的对象一图理解上述红线的方向就是原型链的查找方向也是原型链的方向深浅拷贝在中对象的复制通常分为两种类型浅拷贝和深拷贝这两种拷贝方式的主要区别在于它们处理对象内部可变数据结构的方式不同浅拷贝浅拷贝会创建一个新的对象并尽可能地把原对象中的所有可枚举属性值复制到新对象中如果原对象中有引用类型的属性如数组对象等那么浅拷贝只会复制这些引用类型的地址而不是其内容这意味着对于引用类型的属性浅拷贝后的对象和原对象指向的是同一个内存地址因此改变其中一个对象会影响到另一个实现方法使用可以用来创建一个新对象并将一个或多个现有对象的可枚举属性拷贝到新对象中使用扩展运算符也可以用来实现对象的浅拷贝示例输出输出深拷贝深拷贝会创建一个新的对象并递归地复制原对象的所有属性包括引用类型的数据也会被完全复制从而保证了新对象与原对象不共享任何数据这使得修改新对象不会影响到原对象实现方法使用和这种方法可以简单地实现深拷贝但不适用于循环引用的对象函数等使用第三方库如的方法手动实现递归深拷贝示例输出需要注意的是使用和方法有一些限制比如不能处理函数日期正则表达式等特殊类型的对象如果你需要处理更复杂的数据结构或者有特殊需求可以考虑使用一些成熟的库例如的方法手写深拷贝深拷贝利用递归实现手写一个拷贝递归函数判断是否存在数组对象给新对象创建一个新数组接收方是新对象当中的新建的空数组送的一方就是旧数组处理对象类型的引用数据创建一个新对象接收方是新建的空对象送的一方就是旧对象是类型的这种写法不可取会被认为是像对象中追加一个属性名为的属性要采取下面这种写法异常处理在中异常处理是一种控制流结构用于捕获和处理程序执行过程中发生的错误或异常情况异常处理主要包括以下几个关键部分和块异常处理语法块块包含了可能会抛出异常的代码如果块中的代码执行正常则块将被跳过块块用于处理块中抛出的异常块接收一个参数通常命名为或这个参数包含了异常信息块块是可选的它包含了无论是否发生异常都需要执行的代码块在和块之后执行使用处理异常下面是一个简单的示例演示如何使用结构来处理可能的异常尝试执行可能会抛出异常的代码这里会抛出异常处理异常捕获到了异常不管是否有异常都会执行这里的代码执行块使用抛出异常你还可以使用语句手动抛出异常没有参数传递进来自定义异常在中你还可以创建自定义异常类来处理特定类型的错误例如无效的电子邮件地址电子邮件验证成功验证错误未知错误验证完成深度学习指向的指向在中非常重要下面就更加深层的理解指向针对普通函数总结一句话普通函数的调用方式决定了的指向即谁调用函数就指向谁普通函数没有明确调用者时指向严格模式下没有调用者指向针对箭头函数事实上箭头函数并不存在箭头函数会默认帮我们绑定外层的值所以在箭头函数中的值和外层的是一样的箭头函数中后的引用的就是最近作用域中的向外层作用域中一层一层查找直到找到需求看需要不需要使用不需要使用箭头函数更简洁方便改变指向当然可以下面是中用于改变指向的一些常用方法及其语法格式下面的参数中就是规定指向谁如果不需要指向则可以写使用该方法会调用函数方法调用一个函数并传入指定的值和参数列表语法示例输出使用该方法会调用函数方法与类似但是它接受一个参数数组语法示例输出使用注意方法不会调用函数方法创建一个新的函数这个新的函数的被绑定到提供的值上该方法的返回值是一个新函数语法示例输出理解图防抖和节流防抖单位时间内频繁触发事件但只执行最后一次触发简单理解王者荣耀的回城使用场景输入框的搜索建议窗口尺寸变化时重新布局鼠标移动时获取位置实现方式使用提供的防抖来处理手写防抖函数手写防抖函数防抖的概念单位时间内频繁触发事件但只执行最后一次触发手写防抖函数底层是使用定时器实现的定义一个定时器变量每次触发判断有没有定时器如果有清除没有就开启定时器存入到定时器变量在定时器里面调用函数节流节流的目的则是确保一个函数在指定的时间间隔内最多只被调用一次即使该函数被频繁触发它也只会在上一次调用之后等待指定的时间间隔再次执行单位时间内频繁触发事件只执行一次类似王者荣耀的技能是存在的时间内只执行一次使用场景鼠标滚轮滚动滚动事件定时任务手写节流函数防抖的概念单位时间内频繁触发事件只执行一次手写节流函数底层是使用定时器实现的定义一个定时器变量每次触发判断有没有定时器如果有定时不做任何操作没有就开启定时器存入到定时器变量在定时器里面调用函数清空定时器需要注意的是在定时器内部清除定时器不能使用而是要重新给定时器赋值为空才行防抖和节流的总结插件制作轮播图建议使用插件官网英文中文网快速收集表单内容建议使用插件该插件传递两个参数要收集那个表单的数据表单中的属性会被作为属性名来展示在收集的数据中建议的值最好和接口文档一致配置对象设置获取数据的结构对象推荐使用一般请求体里提交给服务器获取的是查询字符串设置是否获取表单中的空值获取表单中的空值不获取表单中的空值',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-15 11:56:12',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/img/touxiang.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://newerproduct.github.io/" title="我的博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/touxiang.jpg" alt="我的博客"/><span class="back-menu-item-text">我的博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="鱼图床"/><span class="back-menu-item-text">鱼图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">LiSir</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/HTML-CSS/" style="font-size: 1.05rem;">HTML,CSS<sup>1</sup></a><a href="/tags/JS/" style="font-size: 1.05rem;">JS<sup>1</sup></a><a href="/tags/JavaWeb/" style="font-size: 1.05rem;">JavaWeb<sup>1</sup></a><a href="/tags/Java%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">Java学习<sup>1</sup></a><a href="/tags/TypeScript/" style="font-size: 1.05rem;">TypeScript<sup>1</sup></a><a href="/tags/git%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">git学习<sup>1</sup></a><a href="/tags/jQuery/" style="font-size: 1.05rem;">jQuery<sup>1</sup></a><a href="/tags/java%E5%92%8Cvue%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E6%94%B9%E6%AD%A3%E5%92%8C%E5%AF%B9%E4%BB%96%E4%BB%AC%E7%9A%84%E7%90%86%E8%A7%A3%E6%95%B4%E7%90%86-%E5%8F%82%E5%8A%A0%E7%9A%84%E9%A1%B9%E7%9B%AE/" style="font-size: 1.05rem;">java和vue开发中遇到的错误以及如何改正和对他们的理解整理(参加的项目)<sup>1</sup></a><a href="/tags/js-node-js/" style="font-size: 1.05rem;">js-node.js<sup>1</sup></a><a href="/tags/jwt-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81-cookie/" style="font-size: 1.05rem;">jwt,身份认证,cookie<sup>1</sup></a><a href="/tags/nginx%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">nginx学习<sup>1</sup></a><a href="/tags/uni-app%E6%A1%86%E6%9E%B6/" style="font-size: 1.05rem;">uni-app框架<sup>1</sup></a><a href="/tags/vue-js/" style="font-size: 1.05rem;">vue.js<sup>1</sup></a><a href="/tags/vue-js%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/" style="font-size: 1.05rem;">vue.js前置知识<sup>1</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF-web-%E6%A1%86%E6%9E%B6/" style="font-size: 1.05rem;">前端,web,框架<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/" style="font-size: 1.05rem;">开发总结<sup>1</sup></a><a href="/tags/%E6%89%8B%E6%9C%BA%EF%BC%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%8Cless/" style="font-size: 1.05rem;">手机，移动端，less<sup>1</sup></a><a href="/tags/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%EF%BC%8C%E6%A8%A1%E5%9D%97/" style="font-size: 1.05rem;">打包工具，模块<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">数据结构<sup>1</sup></a><a href="/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-vue2-js/" style="font-size: 1.05rem;">状态管理工具(vue2.js)<sup>1</sup></a><a href="/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-vue3-js/" style="font-size: 1.05rem;">状态管理工具(vue3.js)<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">八月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">13</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url">前端开发</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/JS/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>JS</span></a></span></div></div><h1 class="post-title" itemprop="name headline">JavaScript</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-07-30T09:46:48.000Z" title="发表于 2024-07-30 17:46:48">2024-07-30</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-09-15T03:56:12.855Z" title="更新于 2024-09-15 11:56:12">2024-09-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为张家口"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>张家口</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/img/default_cover.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2024/07/30/JavaScript/"><header><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url">前端开发</a><a href="/tags/JS/" tabindex="-1" itemprop="url">JS</a><h1 id="CrawlerTitle" itemprop="name headline">JavaScript</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">LiSir</span><time itemprop="dateCreated datePublished" datetime="2024-07-30T09:46:48.000Z" title="发表于 2024-07-30 17:46:48">2024-07-30</time><time itemprop="dateCreated datePublished" datetime="2024-09-15T03:56:12.855Z" title="更新于 2024-09-15 11:56:12">2024-09-15</time></header><h1 id="JS引入方式"><a href="#JS引入方式" class="headerlink" title="JS引入方式"></a>JS引入方式</h1><ul>
<li><p>内部脚本：将JS代码定义在HTML页面中</p>
<ul>
<li>JavaScript代码必须位于script标签内</li>
<li>在HTML文档中，可以再任意地方 ，放置任意数量的script</li>
<li>一般会把脚本置于body元素的底部，可以改善显示速度</li>
</ul>
</li>
<li><p>外部脚本：将JS代码定义在外部JS文件中，然后引入到HTML页面中</p>
<ul>
<li><p>外部JS文件中，只包含JS代码，不包含script标签</p>
</li>
<li><p>script标签不能够自闭合，也就是不可以写成</p>
</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240503145115827.png" alt="image-20240503145115827"></p>
<h1 id="JS基础语法"><a href="#JS基础语法" class="headerlink" title="JS基础语法"></a>JS基础语法</h1><h2 id="书写语法"><a href="#书写语法" class="headerlink" title="书写语法"></a>书写语法</h2><ul>
<li><p>区分大小写：与java一样，变量名、函数名以及其他一切东西都是区分大小写的</p>
</li>
<li><p>每行结尾的分号可有可无</p>
</li>
<li><p>注释：</p>
<ul>
<li>单行注释：&#x2F;&#x2F;注释内容</li>
<li>多行注释：&#x2F;<em>注释内容</em> *&#x2F;</li>
</ul>
</li>
<li><p>大括号代表代码块：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断</span></span><br><span class="line"><span class="keyword">if</span>(count == <span class="number">3</span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>输出语句</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">alert</span>() <span class="comment">//写入警告框</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>()<span class="comment">//写入HTML输出</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>()<span class="comment">//在浏览器控制台输出内容</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>()<span class="comment">//在浏览器控制台输出对象</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240503151224544.png" alt="image-20240503151224544"></p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li><p><strong>JavaScript</strong> 中用 <strong>var</strong>关键字(<strong>variable</strong> 的缩写)来声明变量。</p>
<p><strong>var</strong>的特点：</p>
<ul>
<li>作用域比较大，全局变量。</li>
<li>可以重复定义同一个变量。相当于一个覆盖</li>
</ul>
</li>
<li><p><strong>JavaScript</strong> 是一门弱类型语言，变量<strong>可以存放不同类型的值</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;张三&quot;</span>;<span class="comment">//定义a的值是字符串张三</span></span><br><span class="line">a = <span class="number">20</span><span class="comment">//把值20赋值给a</span></span><br><span class="line"><span class="title function_">alert</span>(a)<span class="comment">//输出20</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>变量名需要遵循如下规则:</p>
<ul>
<li>组成字符可以是任何字母、数字、下划线(_)或美元符号($)</li>
<li>数字不能开头</li>
<li>建议使用驼峰命名(如<strong>userName</strong>)</li>
</ul>
</li>
<li><p><strong>let</strong> 关键字来定义变量。它的用法类似于 var，但是所声明的变量，只在let 关键字所在的代码块内有效，且不允许重复声明。</p>
</li>
<li><p><strong>const</strong> 关键字，用来声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>JS中分为：<strong>原始类型</strong>和<strong>引用类型</strong>。</li>
</ul>
<h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240503153618200.png" alt="image-20240503153618200"></p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li><p>算术运算符:+，-，*，&#x2F;，%，++，–</p>
</li>
<li><p>赋值运算符:&#x3D;，+&#x3D;，-&#x3D;，，&#x2F;&#x3D;,%&#x3D;</p>
</li>
<li><p>比较运算符:&gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;，!&#x3D;，&#x3D;&#x3D;，**&#x3D;&#x3D;&#x3D;**</p>
<p>&#x3D;&#x3D;与&#x3D;&#x3D;&#x3D;</p>
<ul>
<li>&#x3D;&#x3D;会进行类型转换，&#x3D;&#x3D;&#x3D;不会进行类型转换。</li>
</ul>
</li>
</ul>
<h4 id="逻辑与-与逻辑或"><a href="#逻辑与-与逻辑或" class="headerlink" title="逻辑与(&amp;&amp;)与逻辑或(||)"></a>逻辑与(&amp;&amp;)与逻辑或(||)</h4><p>在编程中，<code>&amp;&amp;</code> 和 <code>||</code> 是逻辑运算符，它们用于组合布尔表达式。这些运算符在大多数支持C语言风格语法的编程语言中都是可用的，比如 C、C++、Java、JavaScript 等。</p>
<h5 id="逻辑与"><a href="#逻辑与" class="headerlink" title="逻辑与 (&amp;&amp;)"></a>逻辑与 (&amp;&amp;)</h5><p>逻辑与运算符 <code>&amp;&amp;</code> 返回 <code>true</code> 当且仅当其两边的操作数都为 <code>true</code>。否则返回 <code>false</code>。</p>
<p><strong>示例:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean a = <span class="literal">true</span>;</span><br><span class="line">boolean b = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 &amp;&amp;</span></span><br><span class="line">boolean result = a &amp;&amp; b; <span class="comment">// 结果为 false, 因为 b 是 false</span></span><br></pre></td></tr></table></figure>

<h5 id="逻辑或"><a href="#逻辑或" class="headerlink" title="逻辑或 (||)"></a>逻辑或 (||)</h5><p>逻辑或运算符 <code>||</code> 返回 <code>true</code> 如果其任一操作数为 <code>true</code>。只有当两边的操作数都为 <code>false</code> 时才返回 <code>false</code>。</p>
<p><strong>示例:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean x = <span class="literal">true</span>;</span><br><span class="line">boolean y = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 ||</span></span><br><span class="line">boolean result = x || y; <span class="comment">// 结果为 true, 因为 x 是 true</span></span><br></pre></td></tr></table></figure>

<h5 id="短路求值-重要"><a href="#短路求值-重要" class="headerlink" title="短路求值(重要)"></a>短路求值(重要)</h5><p>需要注意的是，这两个运算符具有短路求值的行为：</p>
<ul>
<li>对于 <code>&amp;&amp;</code>，如果左边的操作数为 <code>false</code>，则右边的操作数不会被计算（因为无论右边是什么结果都不会改变最终结果）。</li>
<li>对于 <code>||</code>，如果左边的操作数为 <code>true</code>，则右边的操作数不会被计算（同上）。</li>
</ul>
<h4 id="非运算符"><a href="#非运算符" class="headerlink" title="非运算符(!)"></a>非运算符(!)</h4><p>非运算符 <code>!</code> 接受一个操作数，并返回一个布尔值：</p>
<ul>
<li>如果操作数是假值（falsy），则返回 <code>true</code>。</li>
<li>如果操作数是真的（truthy），则返回 <code>false</code>。</li>
</ul>
<p>在 JavaScript 中，以下值被认为是假值：</p>
<ul>
<li><code>false</code></li>
<li><code>0</code></li>
<li><code>&quot;&quot;</code> (空字符串)</li>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li><code>NaN</code></li>
</ul>
<p>除了上述假值之外的所有值都被认为是真值。例如：</p>
<ul>
<li>非零数值（如 <code>1</code>、<code>-3</code>）</li>
<li>非空字符串（如 <code>&quot;hello&quot;</code>）</li>
<li>数组（如 <code>[]</code>、<code>[1, 2, 3]</code>）</li>
<li>对象（如 <code>&#123;&#125;</code>、<code>new Date()</code>）</li>
</ul>
<ul>
<li>三元运算符:条件表达式?true_value:false value</li>
</ul>
<p>类型转换：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240622132055925.png" alt="image-20240622132055925"></p>
<ul>
<li><p>字符串类型转为数字：</p>
<ul>
<li><p>paseInt方法：<strong>这个方法能够将字符串转为数字，原理是从字符串左边开始读取，读取到不是数字的地方(如12A45他会读取到A这个为止而停下来)停下来，取该位置前面的输出。</strong></p>
<pre><code>alert(parseInt(&quot;12&quot;));//转为12
alert(parseInt(&quot;12A45&quot;));//转为12
alert(parseInt(&quot;A45&quot;));//转为NaN(not a number)
</code></pre>
</li>
</ul>
<ul>
<li>可以使用一元加号 (<code>+</code>) 前缀，来把字符串转为数字型。</li>
</ul>
</li>
<li><p>其他类型转为boolean：</p>
<ul>
<li>Number类型：0和NaN转为false，其他均转为true。</li>
<li>String类型：空字符串转为false，其他 均转为true。</li>
<li>Null类型和undefined类型：均转为false。</li>
</ul>
</li>
<li><p>隐式转换</p>
<ul>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240622131333679.png" alt="image-20240622131333679"></li>
</ul>
</li>
<li><p>检测数据类型</p>
<ul>
<li>typeof + 检测的名字</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240622130940174.png" alt="image-20240622130940174"></li>
</ul>
</li>
</ul>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><ul>
<li><p>if…else if ….else….</p>
</li>
<li><p>switch</p>
</li>
<li><p>for</p>
</li>
<li><p>while</p>
</li>
<li><p>do…while</p>
<p>值得注意的是，<strong>在JS中这些流程控制语句和我们的java是完全一致的。</strong></p>
</li>
<li><p>break和continue</p>
<ul>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240622145759783.png" alt="image-20240622145759783"></li>
</ul>
</li>
</ul>
<h1 id="JS函数"><a href="#JS函数" class="headerlink" title="JS函数"></a>JS函数</h1><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">functionName</span>(<span class="params">参数<span class="number">1</span>，参数<span class="number">2.</span>..</span>)&#123;</span><br><span class="line"><span class="comment">//要执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种方式调用</span></span><br><span class="line"><span class="keyword">let</span> functionName = <span class="keyword">function</span>(<span class="params">参数<span class="number">1</span>，参数<span class="number">2.</span>..</span>)&#123;</span><br><span class="line">    <span class="comment">//要执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意<ul>
<li>形式参数不需要类型。因为JS是弱类型语言。</li>
<li>返回值类型也不需要定义，可以再函数内部直接使用return返回即可。</li>
</ul>
</li>
<li>调用：函数名称(实际参数列表)</li>
</ul>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><ul>
<li><p>函数分为</p>
<ul>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240622154237927.png" alt="image-20240622154237927"></li>
</ul>
</li>
<li><p>函数表达式</p>
<ul>
<li><pre><code class="HTML">&lt;script&gt;
    // 1.函数表达式
let fn = function (x,y)&#123;
    console.log( x + y );
&#125;
fn(1,2);

// 函数表达式 和具名函数(有名函数) 有什么不同呢？

// 1.具名函数的调用可以写到任何位置
// 2.匿名函数的函数表达式形式写法必须先声明在使用，否则会报错未声明
&lt;/script&gt;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 立即执行函数</span><br><span class="line"></span><br><span class="line">  * ```js</span><br><span class="line">    // 1、立即执行函数</span><br><span class="line">    </span><br><span class="line">    (function(x,y)&#123;</span><br><span class="line">    </span><br><span class="line">      console.log(x+y);</span><br><span class="line">    </span><br><span class="line">    &#125;)(1,2);</span><br><span class="line">    </span><br><span class="line">    // 2、第二种 写法</span><br><span class="line">    </span><br><span class="line">    (function(x,y)&#123;</span><br><span class="line">    </span><br><span class="line">      console.log(x+y);</span><br><span class="line">    </span><br><span class="line">    &#125;(1,3));</span><br><span class="line">    </span><br><span class="line">    // 上面结构中，第二个小括号是实参，function()中的小括号传递的是形参&#123;&#125;中写入要执行的逻辑</span><br></pre></td></tr></table></figure>

* 注意：多个立即执行函数要在函数末尾用分号隔开。
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>回调函数是编程中一个非常重要的概念，尤其在异步编程模型中极为常见。在JavaScript中，回调函数的应用尤为广泛，因为JavaScript是单线程的，但可以通过异步操作实现并发效果。</p>
<h3 id="回调函数的基本概念"><a href="#回调函数的基本概念" class="headerlink" title="回调函数的基本概念"></a>回调函数的基本概念</h3><p>回调函数就是一个作为参数传递给另一个函数的函数。当外部函数完成某些操作后，会“回调”这个函数作为处理结果的一种方式。这使得程序可以在等待某个耗时操作（如网络请求、文件读写等）的同时继续执行其他代码，而不会阻塞执行流程。</p>
<p><strong>示例</strong></p>
<p>假设你有一个函数<code>doSomethingAsync</code>，它需要一段时间才能完成操作。为了不让主线程等待，你可以传入一个回调函数，当<code>doSomethingAsync</code>完成时调用这个回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomethingAsync</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 模拟异步操作</span></span><br><span class="line">        <span class="keyword">let</span> result = <span class="string">&#x27;Data from async operation&#x27;</span>;</span><br><span class="line">        <span class="title function_">callback</span>(result);</span><br><span class="line">    &#125;, <span class="number">2000</span>); <span class="comment">// 假设这个操作需要2秒</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用回调函数</span></span><br><span class="line"><span class="title function_">doSomethingAsync</span>(<span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received data:&#x27;</span>, data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>doSomethingAsync</code>函数接受一个回调函数作为参数。当异步操作完成时，它调用回调函数并传递结果。这样，即使<code>doSomethingAsync</code>需要较长时间来完成，主线程也不会被阻塞，可以立即执行后续代码。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>回调函数可以导致所谓的“回调地狱”（Callback Hell），特别是当多个异步操作嵌套在一起时。这种情况下，代码结构可能会变得难以阅读和维护，因为每个操作的回调都嵌套在前一个操作的回调内。为了解决这个问题，现代JavaScript倾向于使用Promise链和async&#x2F;await语法来使异步代码看起来更像同步代码。</p>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>什么叫递归函数呢？</p>
<p>如果一个函数在内部可以调用其本身，那么这个函数就是递归函数</p>
<ul>
<li>简单理解：函数内部自己调用自己，这就是递归函数。</li>
<li>递归函数的作用和循环效果类似。</li>
<li>由于递归很容易发生”栈溢出”错误，所以<strong>必须要有退出条件 return</strong></li>
</ul>
<h1 id="生成一个范围随机数"><a href="#生成一个范围随机数" class="headerlink" title="生成一个范围随机数"></a>生成一个范围随机数</h1><ul>
<li><p><code>Math.random()</code>是随机数函数，返回一个0~1之间的浮点数，并且不包括1，包括0</p>
</li>
<li><p><code>Math.floor()</code>向下取整，比如8.9就取8；10.4就取10</p>
</li>
</ul>
<p>如生成0-10的随机数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">11</span>)</span><br></pre></td></tr></table></figure>

<p>生成X~N之间的随机数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (X + N))</span><br></pre></td></tr></table></figure>

<h1 id="JS对象"><a href="#JS对象" class="headerlink" title="JS对象"></a>JS对象</h1><h2 id="Array-数组对象"><a href="#Array-数组对象" class="headerlink" title="Array(数组对象)"></a>Array(数组对象)</h2><ul>
<li><p>定义：let 变量名 &#x3D; new Array(元素列表)；或者let 变量名&#x3D; [元素列表];</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//定义数组</span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">let</span> arr1 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//或者let arr1 = [1,2,3,4,5]</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="JavaScript-数组方法"><a href="#JavaScript-数组方法" class="headerlink" title="JavaScript 数组方法"></a>JavaScript 数组方法</h3><ul>
<li><p>把数组转换为数组值（逗号分隔）的字符串。：<code>toString()</code></p>
</li>
<li><p>将所有数组元素结合为<strong>一个字符串</strong>，可以指定分隔符：<code>join()</code></p>
<ul>
<li><pre><code class="html">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;,&quot;Apple&quot;, &quot;Mango&quot;];
document.getElementById(&quot;demo&quot;).innerHTML = fruits.join(&quot; * &quot;); 
&lt;!--结果是：Banana * Orange * Apple * Mango	--&gt;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 从数组中删除最后一个元素，并返回被删除的值：`pop()`</span><br><span class="line"></span><br><span class="line">- （在数组结尾处）向数组添加一个新的元素，并返回新数组的长度：`push()`</span><br><span class="line"></span><br><span class="line">- 向数组追加新元素的简易方法：`length`</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];</span><br><span class="line">    fruits[fruits.length] = &quot;Kiwi&quot;;          // 向 fruits 追加 &quot;Kiwi&quot;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>删除<strong>首个</strong>数组元素，并把所有其他元素“位移”到更低的索引，返回被删除的值：<code>shift()</code></p>
<ul>
<li><pre><code class="js">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];
fruits.shift();            // 从 fruits 删除第一个元素 &quot;Banana&quot;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用delete也可以删除数组元素，但是会导致留空洞，空洞会变为`undefine`推荐使用`pop或shift方法删除元素`。</span><br><span class="line"></span><br><span class="line">- （在开头）向数组添加新元素，并把旧元素向后移动，并返回新数组的长度：`unshift()`</span><br><span class="line"></span><br><span class="line">- 用于向数组添加新项，该函数接收两个参数：`splice()`</span><br><span class="line">  - 第一个参数定义在某个索引位置之前添加新元素(拼接)</span><br><span class="line">  - 第二个参数定义删除多少元素</span><br><span class="line">  - 剩下参数定义要添加的新元素</span><br><span class="line">  - 该函数返回值是被删除元素组成的数组</span><br><span class="line">  - 也可以使用该函数进行删除元素（第一个参数是要删除元素的索引，第二个参数是删除元素的个数，比如`fruits.splice(0, 1); `）</span><br><span class="line">  - 比如：`fruits.splice(2, 0, &quot;Lemon&quot;, &quot;Kiwi&quot;);`</span><br><span class="line">  </span><br><span class="line">- 通过合并（连接）现有数组来创建一个新数组：`concat()`</span><br><span class="line">  - `concat()` 方法可以使用任意数量的数组参数</span><br><span class="line">  - `concat()` 方法不会更改现有数组。它总是返回一个新数组。</span><br><span class="line">  - 参数可以是具体的值，也可以是数组</span><br><span class="line">  </span><br><span class="line">- 用数组的某个片段切出新数组：`slice()`</span><br><span class="line">  - `slice()` 方法创建新数组。它不会从源数组中删除任何元素。</span><br><span class="line">  - `slice()` 可接受两个参数(索引)，比如 (1, 3)。</span><br><span class="line">  - 切的区间是前闭后开的，也就是包括1，不包括3</span><br><span class="line">  - 如果结束参数没写，那么会从索引位置向后切出剩余部分，包括索引位置处的元素</span><br><span class="line"></span><br><span class="line">### JavaScript 数组排序</span><br><span class="line"></span><br><span class="line">- 以字母顺序对数组进行排序：`sort()`！！！只对字母生效，数字无效</span><br><span class="line"></span><br><span class="line">  - 如果想用该函数比较数字，**则应该通过比值函数**来修正</span><br><span class="line">  - 比值函数：`(a,b)=&gt; return a-b;`升序   **/** `(a,b)=&gt; return b-a;`降序</span><br><span class="line"></span><br><span class="line">- 反转数组中的元素：`reverse()`</span><br><span class="line"></span><br><span class="line">- 查找数组中的最高值：`Math.max.apply`，举例子：</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    //在本例中，我们使用 apply() 来正确地将数组 arr 的所有元素作为单独的参数传递给 Math.max()。</span><br><span class="line">    //由于 Math.max() 不依赖于 this 的值，所以通常这里会传入 null 或者 undefined。</span><br><span class="line">    function myArrayMax(arr) &#123;</span><br><span class="line">        return Math.max.apply(null, arr);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>找数组中的最低值：<code>Math.min.apply</code></p>
</li>
<li><p>比较字符串：</p>
<ul>
<li><pre><code class="js">cars.sort(function(a, b)&#123;
      var x = a.type.toLowerCase();
      var y = b.type.toLowerCase();
      if (x &lt; y) &#123;return -1;&#125;
      if (x &gt; y) &#123;return 1;&#125;
      return 0;
&#125;);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### JavaScript 数组迭代</span><br><span class="line"></span><br><span class="line">- 为每个数组元素调用一次函数（回调函数）：`forEach(function(value,index,array)&#123;&#125;)`</span><br><span class="line"></span><br><span class="line">  - 该函数接收三个参数：value,index,array</span><br><span class="line"></span><br><span class="line">  - 该函数只对数组进行遍历，不返回新数组。</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    var txt = &quot;&quot;;</span><br><span class="line">    var numbers = [45, 4, 9, 16, 25];</span><br><span class="line">    numbers.forEach(myFunction);</span><br><span class="line">    </span><br><span class="line">    function myFunction(value, index, array) &#123;</span><br><span class="line">      txt = txt + value + &quot;&lt;br&gt;&quot;; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p><code>map(function(value,index,array)&#123;&#125;)</code>方法</p>
<ul>
<li><code>map()</code> 方法通过对每个数组元素执行函数来创建新数组。</li>
<li><code>map()</code> 方法不会对没有值的数组元素执行函数。</li>
<li><code>map()</code> 方法不会更改原始数组。</li>
<li>该方法返回一个新数组。</li>
<li>同样，它也有3个参数：项目值，项目索引，数组本身</li>
</ul>
</li>
<li><p>创建一个包含满足某些条件的数组元素的新数组：<code>filter(function(value,index,array)&#123;&#125;)</code></p>
<ul>
<li><p>它有3个参数：项目值，项目索引，数组本身</p>
</li>
<li><pre><code class="js">var numbers = [45, 4, 9, 16, 25];
var over18 = numbers.filter(myFunction);

function myFunction(value, index, array) &#123;
  return value &gt; 18;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 可以用来对数组中的所有元素进行聚合计算，比如求和、计算乘积、查找最大值/最小值：`reduce()`</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    array.reduce(callback(returnData, currentValue[, currentIndex[, array]])[, initialValue])</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>reduce函数的执行顺序是从左到右，函数<code>reduceRight()</code>是从右到左，语法完全一致。</p>
</li>
<li><p>该函数接受一个回调函数（<code>callback()</code>），它会被执行数组中的每一个元素（除了第一个，除非提供了初始值）。</p>
<ul>
<li><p><strong>returnData</strong>：该参数是该回调函数的返回值，同时它也是下次调用时的第一个参数。</p>
</li>
<li><p><strong>currentValue</strong>：当前元素的值。</p>
</li>
<li><p><strong>currentIndex</strong>：可选的，当前元素的索引。</p>
</li>
<li><p><strong>array</strong>：可选的，被遍历的数组本身。</p>
</li>
<li><p><strong>initialValue</strong>：初始值，可选。</p>
</li>
<li><p>对于该方法做出如下特别解释：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240824172102164.png" alt="image-20240824172102164"></p>
</li>
<li><p>可接受初始值，如果给出初始值那么给出的值会被赋值给returnData</p>
</li>
<li><pre><code class="js">    let arr = [1, 2, 3, 4, 5, 7];
    let sum = arr.reduce((callback,value)=&gt;&#123;
        return callback + value
    &#125;)
    console.log(sum);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```js</span><br><span class="line">  var numbers1 = [45, 4, 9, 16, 25];</span><br><span class="line">  //调用回调函数的同时传入了初始值100</span><br><span class="line">  var sum = numbers1.reduce(myFunction, 100);</span><br><span class="line">  </span><br><span class="line">  function myFunction(total, value) &#123;</span><br><span class="line">    return total + value;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>检查所有数组值是否满足某个条件：</p>
<ul>
<li><code>every(function(value,index,array)&#123;&#125;)</code></li>
<li>接受3个参数：项目值(value)，项目索引(index)，数组本身(array)</li>
<li>如果所有值满足该条件，返回true，如果所有值当中有一个不满足，则返回false</li>
</ul>
</li>
<li><p>检查某些数组值是否满足某个条件：</p>
<ul>
<li><code>some(function(value,index,array)&#123;&#125;)</code></li>
<li>接受3个参数：项目值(value)，项目索引(index)，数组本身(array)</li>
<li>如果数组当中的某些值满足条件，则返回true，否则返回false</li>
</ul>
</li>
<li><p>在数组中搜索元素值并返回其位置：</p>
<ul>
<li><code>indexOf()</code></li>
<li>语法：array.indexOf(item, start)，item是查找的项目，start用来定义开始起点（start值小于0时，将从结尾开始的给定位置开始，并查到到结尾）。</li>
<li>如果未找到，则返回<code>-1</code></li>
<li>如果某项目多次出现，则返回第一次出现的位置(索引)</li>
<li>！！！特别注意：<strong>一定要注意该函数执行的方向，开始位置可能会变，但执行顺序是不会变的</strong></li>
</ul>
</li>
<li><p>从数组结尾处开始查找：</p>
<ul>
<li><p><code>lastindexOf()</code></p>
</li>
<li><p>语法：</p>
</li>
<li><table>
<thead>
<tr>
<th><em>item</em></th>
<th>必需。要检索的项目。</th>
</tr>
</thead>
<tbody><tr>
<td><em>start</em></td>
<td>可选。从哪里开始搜索。负值将从结尾开始的给定位置开始，并搜索到开头。</td>
</tr>
</tbody></table>
</li>
<li><p>！！！特别注意：<strong>一定要注意该函数执行的方向，开始位置可能会变，但执行顺序是不会变的</strong></p>
</li>
</ul>
</li>
<li><p>返回数组中满足某个条件的第一个元素的值：</p>
<ul>
<li><code>find(function(value,index,array)&#123;&#125;)</code></li>
<li>接受3个参数：项目值(value)，项目索引(index)，数组本身(array)</li>
</ul>
</li>
<li><p>返回数组中满足某个条件的第一个元素的索引值：</p>
<ul>
<li><code>findIndex(function(value,index,array)&#123;&#125;)</code></li>
<li>接受3个参数：项目值(value)，项目索引(index)，数组本身(array)</li>
</ul>
</li>
</ul>
<h2 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//String对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//方式一：</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> stringTest = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;zhangsan&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//方式二：</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> stringTest1 =<span class="string">&quot;lisi&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="JavaScript-字符串方法"><a href="#JavaScript-字符串方法" class="headerlink" title="JavaScript 字符串方法"></a>JavaScript 字符串方法</h3><h4 id="查找字符串中的字符串"><a href="#查找字符串中的字符串" class="headerlink" title="查找字符串中的字符串"></a>查找字符串中的字符串</h4><ul>
<li><p><code>length</code> 属性返回字符串的长度：</p>
<ul>
<li><pre><code class="js">var txt = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;
var sln = txt.length;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `indexOf()` 方法返回字符串中指定文本*首次*出现的索引（位置）：</span><br><span class="line">  - 从0计算</span><br><span class="line">  - 未找到返回-1</span><br><span class="line">  - 可传递起始位置参数</span><br><span class="line">- `lastIndexOf()` 方法返回指定文本在字符串中*最后*一次出现的索引：</span><br><span class="line">  - 未找到返回-1</span><br><span class="line">  - 可传递起始位置参数</span><br><span class="line">  - 检索方向：从结尾向开始方向检索</span><br><span class="line"></span><br><span class="line">#### 检索字符串中的字符串</span><br><span class="line"></span><br><span class="line">- `search()` 方法搜索特定值的字符串，并返回匹配的位置： </span><br><span class="line">  - 返回首次出现的位置。</span><br><span class="line">  - 可以使用正则表达式进行匹配</span><br><span class="line"></span><br><span class="line">#### 提取部分字符串</span><br><span class="line"></span><br><span class="line">**！！！！**值得注意的是，下面这三种切字符串的方法，索引值是负值的时候，只是指定了重字符串末尾开始，而没有改变切割方向，切割方向还是从左到右的</span><br><span class="line"></span><br><span class="line">- `slice()` 提取字符串的某个部分并在新字符串中返回被提取的部分。</span><br><span class="line">  - slice有切割，切片的意思</span><br><span class="line">  - 两个参数：开始索引和结束索引，切出来的片段不包括结束索引。</span><br><span class="line">  - 参数值可以是负数，如果出现负数则意味着从字符串结尾开始计数</span><br><span class="line">  - 如果只有一个参数，那么就是从该位置向后切</span><br><span class="line">- `substring()` 类似于 `slice()`，但不接受负值索引：</span><br><span class="line">  - 两个参数：开始索引和结束索引，切出来的片段不包括结束索引。</span><br><span class="line">  - 如果只有一个参数，那么就是从该位置向后切</span><br><span class="line">  - 参数不能为**负值**</span><br><span class="line"></span><br><span class="line">#### 替换字符串内容</span><br><span class="line"></span><br><span class="line">- `replace()` 方法用另一个值替换在字符串中指定的值：</span><br><span class="line">  - 返回值是一个新的字符串，对原字符串无影响。</span><br><span class="line">  - 默认只替换首个匹配</span><br><span class="line">  - 该函数对大小写敏感(注意字母的大小写)</span><br><span class="line">  - 参数1：要替换谁？参数2：替换为谁</span><br><span class="line"></span><br><span class="line">#### 转换为大写和小写</span><br><span class="line"></span><br><span class="line">- 通过 `toUpperCase()` 把字符串转换为大写</span><br><span class="line">- 通过 `toLowerCase()` 把字符串转换为小写</span><br><span class="line"></span><br><span class="line">#### concat()方法</span><br><span class="line"></span><br><span class="line">- `concat()` 连接两个或多个字符串：</span><br><span class="line">  - 可替换`+`，我们知道`+`有可以用来拼接字符串</span><br><span class="line">  - 不改变原来字符串，返回一个新的字符串</span><br><span class="line"></span><br><span class="line">#### trim()方法</span><br><span class="line"></span><br><span class="line">- `trim()`方法删除字符串两端的空白符</span><br><span class="line"></span><br><span class="line">#### 提取字符串字符</span><br><span class="line"></span><br><span class="line">- `charAt()` 方法返回字符串中指定下标（位置）的字符串：</span><br><span class="line">  - 返回指定索引位置的字符</span><br><span class="line">- `charCodeAt()` 方法返回字符串中指定索引的字符 unicode 编码：</span><br><span class="line">  - 返回指定索引位置字符的unicode编码</span><br><span class="line"></span><br><span class="line">#### 属性访问（Property Access）</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">var str = &quot;HELLO WORLD&quot;;</span><br><span class="line">str[0];                   // 返回 H</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>但不推荐这样使用。</p>
<h4 id="把字符串转换为数组"><a href="#把字符串转换为数组" class="headerlink" title="把字符串转换为数组"></a>把字符串转换为数组</h4><ul>
<li><p><code>split()</code> 将字符串转换为数组：</p>
<ul>
<li><p>可指定分隔符。如果指定了分隔符，那么它会把字符串中的每个字符按照给定的分隔符分割成一个单个的字符串并返回一个数组</p>
<ul>
<li><pre><code class="js">let str2 = &quot;LI,ZE,WEI&quot;
console.log(str2.split(&quot;,&quot;));//返回[&#39;LI&#39;, &#39;ZE&#39;, &#39;WEI&#39;]
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 指定了分隔符，但分隔符是空字符串(`&quot; &quot;`)，那么被返回的数组将是间隔单个字符的数组</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    let str2 = &quot;LI,ZE,WEI&quot;</span><br><span class="line">    console.log(str2.split(&quot;&quot;)); //返回[&#x27;L&#x27;, &#x27;I&#x27;, &#x27;,&#x27;, &#x27;Z&#x27;, &#x27;E&#x27;, &#x27;,&#x27;, &#x27;W&#x27;, &#x27;E&#x27;, &#x27;I&#x27;]</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>如果未指定分隔符，则返回一个由该字符串本身组成的数组，该字符串就是数组的第一个元素</p>
<ul>
<li><pre><code class="js">let str2 = &quot;LI,ZE,WEI&quot;
console.log(str2.split()); //返回[&#39;LI,ZE,WEI&#39;]
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### JavaScript 字符串搜索</span><br><span class="line"></span><br><span class="line">- String.indexOf()</span><br><span class="line">- String.lastIndexOf()</span><br><span class="line">- String.startsWith()</span><br><span class="line">- String.endsWith()</span><br><span class="line"></span><br><span class="line">本小节着重介绍后两个方法，前两个方法在上一小节已经介绍过了</span><br><span class="line"></span><br><span class="line">#### String.match()</span><br><span class="line"></span><br><span class="line">- match() 方法根据正则表达式在字符串中搜索匹配项，并将匹配项作为 **Array 对象**返回。</span><br><span class="line"></span><br><span class="line">  - 参数是一个正则表达式</span><br><span class="line"></span><br><span class="line">  - 如果正则表达式没有加`g`修饰符，则匹配第一个符合表达式的字符串</span><br><span class="line"></span><br><span class="line">  - 若没有符合条件的字符串，则返回null</span><br><span class="line"></span><br><span class="line">  - ```js</span><br><span class="line">    let text = &quot;The rain in SPAIN stays mainly in the plain&quot;;</span><br><span class="line">    text.match(/ain/g)    // 返回数组 [ain,ain,ain]</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="String-includes"><a href="#String-includes" class="headerlink" title="String.includes()"></a>String.includes()</h4><ul>
<li>如果字符串包含指定值，<code>includes()</code> 方法返回 true。<ul>
<li>两个参数：第一个为要检索的值，第二个参数为开始索引</li>
<li>该方法是ES6新引入的</li>
<li>开始索引如果是负值，改变了索引方向，也改变了检索方向</li>
<li>对大小写敏感</li>
</ul>
</li>
</ul>
<h4 id="String-startsWith"><a href="#String-startsWith" class="headerlink" title="String.startsWith()"></a>String.startsWith()</h4><ul>
<li>如果字符串以指定值开头，则 <code>startsWith()</code> 方法返回 <code>true</code>，否则返回 <code>false</code>：、<ul>
<li>两个参数：第一个是要检索的值，必选；第二个开始位置，可选</li>
<li>对大小写敏感，区分大小写</li>
</ul>
</li>
</ul>
<h4 id="String-endsWith"><a href="#String-endsWith" class="headerlink" title="String.endsWith()"></a>String.endsWith()</h4><ul>
<li>如果字符串以指定值结尾，则 <code>endsWith()</code> 方法返回 <code>true</code>，否则返回 <code>false</code>：<ul>
<li>两个参数：第一个是要检索的值，必选；第二个开始位置，可选</li>
<li>区分大小写</li>
</ul>
</li>
</ul>
<h2 id="为了很好记忆做出的总结"><a href="#为了很好记忆做出的总结" class="headerlink" title="为了很好记忆做出的总结"></a>为了很好记忆做出的总结</h2><ul>
<li><p>数组：</p>
<p>添加元素的方法：<code>push()</code>在末尾添加，<code>unshift()</code>在头部添加，<code>splice()</code>能够更精确添加元素</p>
<p>删除元素的方法：<code>pop()</code>在末尾删除，<code>shift()</code>在头部删除，<code>splice()</code>也能够进行元素删除</p>
<p>对数组进行切片：<code>slice()</code>方法</p>
<p>把数组转换为字符串：<code>join()</code>方法</p>
</li>
<li><p>字符串：</p>
<p>字符串长度：length属性</p>
<p>把字符串转换为数组：<code>split()</code>，可以指定分隔符</p>
<p>对字符串进行切割：<code>slice()</code>方法</p>
</li>
</ul>
<h2 id="json对象"><a href="#json对象" class="headerlink" title="json对象"></a>json对象</h2><ul>
<li><p>概念: <strong>JavaScript Object Notation，JavaScript</strong>，对象标记法</p>
</li>
<li><p>JSON 是通过JavaScript 对象标记法书写的文本。</p>
</li>
<li><p>由于其语法简单，层次结构鲜明，现多用于作为<strong>数据载体</strong>，在网络中进行数据传输。</p>
</li>
</ul>
<p>数据格式：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;xiaoli&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">25</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span><span class="string">&quot;男性&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;key1&quot;</span><span class="punctuation">:</span><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240503172509557.png" alt="image-20240503172509557"></p>
<p>定义json案例</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="comment">//定义json</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> jsonStr = <span class="string">&#x27;&#123;&quot;name&quot; = &quot;小李&quot;,&quot;age&quot; = 25, &quot;address&quot; = &quot;北京&quot; &#125;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//JSON字符串转为JS对象——JSON.parse()方法</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> jsonStrObject = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr);</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(jsonStrObject);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//JS对象转为JS字符串——JSON.stringify()方法</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span>  jsObject = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(jsonStrObject);</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(jsObject);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="BOM对象"><a href="#BOM对象" class="headerlink" title="BOM对象"></a>BOM对象</h2><ul>
<li>概念:<strong>Browser Object Model</strong> 浏览器对象模型，允许lavaScript与浏览器对话，lavaScript 将浏览器的各个组成部分封装为<strong>对象</strong>。</li>
</ul>
<h4 id="Window对象"><a href="#Window对象" class="headerlink" title="Window对象"></a>Window对象</h4><ul>
<li><p>介绍:浏览器窗口对象。</p>
</li>
<li><p>获取:直接使用window，其中 window.可以省略<strong>window.alert()和alert()效果一样</strong></p>
</li>
<li><p>属性</p>
<ul>
<li>history:对 History 对象的只读引用。请参阅 History 对象</li>
<li>location:用于窗口或框架的 Location 对象。请参阅Location 对象。</li>
<li>navigator:对 Navigator 对象的只读引用。请参阅Navigator 对象</li>
</ul>
</li>
<li><p>介绍</p>
<ul>
<li>windows是一个全局对象</li>
<li>所有通过var定义在全局作用域中的变量、函数都会变成window对象的属性和方法</li>
<li>window对象下的属性和方法调用的时候可以省略window</li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li><strong>alert()</strong>:显示带有一段消息和一个确认按钮的警告框。</li>
<li><strong>confirm()</strong>:显示带有一段消息以及确认按钮和取消按钮的对话。</li>
<li>**setlnterval():**按照指定的周期(以毫秒计)来调用函数或计算表达式。</li>
<li><strong>setTimeout()</strong>:在指定的毫秒数后调用函数或计算表达式。</li>
</ul>
</li>
</ul>
<p>**setlnterval()<strong>和</strong>setTimeout()**都可以进行清除操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//延时函数参数有两个，一个是回调函数，一个是延时的秒数</span></span><br><span class="line"><span class="keyword">let</span> timer1 = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2秒后打印&quot;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="comment">//清除延时函数</span></span><br><span class="line"><span class="built_in">clearTimeout</span>(timer1)</span><br><span class="line"><span class="comment">//周期执行函数参数有两个，一个是回调函数，一个是周期执行的秒数</span></span><br><span class="line"><span class="keyword">let</span> timer2 = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1111&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">//清除周期执行函数</span></span><br><span class="line"><span class="built_in">clearInterval</span>(timer2)</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//获取</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="string">&quot;Hello BOM&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&quot;Hello BoM window&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 方法</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// confirm-对话框--确认:true ，取消:false</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> flag = <span class="title function_">confirm</span>(<span class="string">&quot;您确认删除该记录吗?&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(flag);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 定时器-setInterval -- 周期性的执行某一个函数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> i=<span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        i++;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;定时器执行了&quot;</span>+i+<span class="string">&quot;次&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;,<span class="number">2000</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//定时器延迟指定时间执行一次:-setTimeout </span></span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&quot;Js&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;,<span class="number">3000</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Location对象"><a href="#Location对象" class="headerlink" title="Location对象"></a>Location对象</h4><ul>
<li><p>介绍：地址栏对象。</p>
</li>
<li><p>获取：使用window.location获取，其中window.可以省略不写</p>
</li>
<li><p>属性：</p>
<ul>
<li><p><strong>href</strong>：设置或返回完整的URL，如果设置URL那么他会自动跳转所设置的URL。</p>
</li>
<li><p><strong>search</strong>：返回地址中参数部分。</p>
</li>
<li><p><strong>hash</strong>：用于获取或设置URL中的 “#（锚点）” 后面的部分。这个属性返回一个字符串，该字符串以 “#” 开头。</p>
</li>
<li><p>**reload()**：用于重新加载当前文档。传入参数true表示强制刷新，类似与ctrl+F5</p>
<p>代码示例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//获取当前完整的URL</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">href</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//设置URL自动跳转</span></span></span><br><span class="line"><span class="language-javascript">    location.<span class="property">href</span>=<span class="string">&quot;http://www.itcast.cn&quot;</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h4><ul>
<li>navigator的数据类型是对象，该对象记录了浏览器自身的相关信息</li>
<li>常用属性和方法<ul>
<li>userAgent：检测浏览器的版本以及平台</li>
</ul>
</li>
</ul>
<h4 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h4><ul>
<li><p>history的数据类型是对象，它管理历史记录，该对象与浏览器地址栏的操作相应，如前进、后退、历史记录等等</p>
</li>
<li><p>常用属性和方法</p>
<table>
<thead>
<tr>
<th>history对象方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>back()</td>
<td>可以后退</td>
</tr>
<tr>
<td>forword()</td>
<td>前进</td>
</tr>
<tr>
<td>go(参数)</td>
<td>前进后退功能，参数是1前进一个页面，如果是-1则后退一个页面</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="DOM对象"><a href="#DOM对象" class="headerlink" title="DOM对象"></a>DOM对象</h2><h3 id="什么是DOM"><a href="#什么是DOM" class="headerlink" title="什么是DOM"></a>什么是DOM</h3><ul>
<li><p>概念:<strong>Document Object Model</strong>，文档对象模型。</p>
</li>
<li><p>将标记语言的各个组成部分封装为对应的对象：</p>
<ul>
<li>Document：整个文档对象</li>
<li>Element：元素对象</li>
<li>Attribute：属性对象</li>
<li>Text：文本对象</li>
<li>Comment：注释对象</li>
</ul>
</li>
<li><p>JavaScript 通过DOM，就能够对HTML进行如下操作：</p>
<ul>
<li>改变 HTML元素的内容</li>
<li>改变 HTML元素的样式(CSS)</li>
<li>对 HTML DOM 事件作出反应</li>
<li>添加和删除 HTML元素</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240503180943024.png" alt="image-20240503180943024"></p>
<h3 id="DOM节点"><a href="#DOM节点" class="headerlink" title="DOM节点"></a>DOM节点</h3><p>让我们通过一些简单的例子来理解 DOM 节点：</p>
<h4 id="文档节点（Document-Node）"><a href="#文档节点（Document-Node）" class="headerlink" title="文档节点（Document Node）"></a>文档节点（Document Node）</h4><p>文档节点代表整个 HTML 或 XML 文档。它是所有其他节点的父节点。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &quot;document&quot; 是文档节点 --&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="元素节点（Element-Node）"><a href="#元素节点（Element-Node）" class="headerlink" title="元素节点（Element Node）"></a>元素节点（Element Node）</h4><p>元素节点是 HTML 标签，如 <code>&lt;div&gt;</code>、<code>&lt;p&gt;</code> 等。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &quot;&lt;div&gt;&quot; 和 &quot;&lt;/div&gt;&quot; 是元素节点 --&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="属性节点（Attribute-Node）"><a href="#属性节点（Attribute-Node）" class="headerlink" title="属性节点（Attribute Node）"></a>属性节点（Attribute Node）</h4><p>属性节点是 HTML 元素上的属性，例如 <code>id</code>、<code>class</code> 等。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &quot;id&quot; 和 &quot;class&quot; 是属性节点 --&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="文本节点（Text-Node）"><a href="#文本节点（Text-Node）" class="headerlink" title="文本节点（Text Node）"></a>文本节点（Text Node）</h4><p>文本节点是元素内的纯文本，不包含任何 HTML 标签。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &quot;Hello, world!&quot; 是文本节点 --&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="注释节点（Comment-Node）"><a href="#注释节点（Comment-Node）" class="headerlink" title="注释节点（Comment Node）"></a>注释节点（Comment Node）</h4><p>注释节点是 HTML 文档中的注释。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- This is a comment --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这个是注释节点 --&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h3><p><strong>在该小节，我们主要利用关系来查找</strong></p>
<h4 id="父节点查找-只能找到最近一级"><a href="#父节点查找-只能找到最近一级" class="headerlink" title="父节点查找(只能找到最近一级)"></a>父节点查找(只能找到最近一级)</h4><ul>
<li>父节点查找<ul>
<li><strong>用途</strong>：获取当前元素的父节点。</li>
<li><strong>语法</strong>：<code>element.parentNode</code></li>
</ul>
</li>
</ul>
<h4 id="子节点查找"><a href="#子节点查找" class="headerlink" title="子节点查找"></a>子节点查找</h4><ul>
<li><p>子节点查找</p>
<ul>
<li><p><strong>用途</strong>：获取当前元素的所有子节点（包括文本节点和元素节点）。</p>
<ul>
<li><strong>语法</strong>：<code>fatherElement.childNodes</code></li>
</ul>
</li>
<li><p><strong>用途</strong>：获取当前元素的第一个或最后一个子节点。</p>
<ul>
<li><strong>语法</strong>：<code>fatherElement.firstChild</code> 或 <code>fatherElement.lastChild</code></li>
</ul>
</li>
<li><p><strong>用途</strong>：获取所有的元素节点</p>
<ul>
<li><strong>语法</strong>：<code>fatherElement.children</code></li>
<li>该方法返回一个<strong>伪数组</strong>(1.<strong>索引访问</strong>：可以使用索引来访问元素，类似于数组的方式。2.<strong>长度属性</strong>：通常有一个 <code>length</code> 属性，表示对象中的元素数量。3.<strong>非数组</strong>：不是真正的 <code>Array</code> 类型对象，因此不支持数组的一些方法（如 <code>.push()</code>、<code>.pop()</code>、<code>.slice()</code> 等）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="兄弟节点查找"><a href="#兄弟节点查找" class="headerlink" title="兄弟节点查找"></a>兄弟节点查找</h4><ul>
<li><p>下一个兄弟节点：</p>
<ul>
<li><strong>用途</strong>：获取当前元素的下一个同级元素节点。</li>
<li><strong>语法</strong>：<code>element.nextElementSibling</code></li>
</ul>
</li>
<li><p>上一个兄弟节点：</p>
<ul>
<li><strong>用途</strong>：获取当前元素的上一个同级元素节点。</li>
<li><strong>语法</strong>： <code>element.previousElementSibling</code></li>
</ul>
</li>
</ul>
<h3 id="新增节点"><a href="#新增节点" class="headerlink" title="新增节点"></a>新增节点</h3><h4 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h4><p>使用 <code>document.createElement(&#39;标签名&#39;)</code> 方法来创建一个新的 HTML 元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newElement = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="设置属性和内容"><a href="#设置属性和内容" class="headerlink" title="设置属性和内容"></a>设置属性和内容</h4><p>你可以设置新元素的属性和内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newElement.<span class="property">id</span> = <span class="string">&#x27;newDiv&#x27;</span>;</span><br><span class="line">newElement.<span class="property">textContent</span> = <span class="string">&#x27;这是一个新的 div 元素。&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="添加节点到DOM中"><a href="#添加节点到DOM中" class="headerlink" title="添加节点到DOM中"></a>添加节点到DOM中</h4><p>将新元素添加到文档树中的某个位置。常见的方法有：</p>
<ul>
<li><strong><code>appendChild()</code><strong>：将新元素作为</strong>最后一个</strong>子节点添加到指定的父节点中。</li>
<li>**<code>insertBefore()</code>**：插入到父元素中某个子元素的前面，参数有两个：第一个是要插入的新元素，第二个参数是参考的元素</li>
<li>**<code>replaceChild()</code>**：替换父元素中某个子元素</li>
<li>**<code>removeChild()</code>**：移除指定的子节点。</li>
</ul>
<p>举个例子</p>
<p>示例：添加到文档末尾</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(newElement);</span><br></pre></td></tr></table></figure>

<p>在某个元素前插入</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> referenceElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;reference&#x27;</span>);</span><br><span class="line">referenceElement.<span class="property">parentNode</span>.<span class="title function_">insertBefore</span>(newElement, referenceElement);</span><br></pre></td></tr></table></figure>

<p>替换某一个元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oldElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;old&#x27;</span>);</span><br><span class="line">oldElement.<span class="property">parentNode</span>.<span class="title function_">replaceChild</span>(newElement, oldElement);</span><br></pre></td></tr></table></figure>

<h3 id="克隆节点"><a href="#克隆节点" class="headerlink" title="克隆节点"></a>克隆节点</h3><p><strong>使用背景</strong></p>
<ul>
<li>复制一个原有节点</li>
<li>把复制的节点放入到指定的元素内部</li>
</ul>
<p><strong>克隆节点</strong></p>
<ul>
<li>用途：复制出一个一模一样的节点</li>
<li>语法：<code>element.cloneNode()</code><ul>
<li>参数：若为true，则克隆时会包含后代节点以及内容一起克隆，若为false则不包含后代节点。</li>
<li>默认是false</li>
</ul>
</li>
</ul>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><ul>
<li>在JS中如要删除某个节点，必须通过其<strong>父元素进行删除</strong><ul>
<li>语法：<code>fatherElemnet.removeChild(要删除的元素)</code></li>
<li>若不存在父子关系，则无法删除</li>
<li>如果该节点被删除，那么就会从html中移除该节点。</li>
</ul>
</li>
</ul>
<h2 id="日期对象"><a href="#日期对象" class="headerlink" title="日期对象"></a>日期对象</h2><p>在JavaScript中，<code>Date</code> 对象用于处理日期和时间。这个内置对象可以用来获取、设置以及操作日期和时间数据。下面是一些关于 <code>Date</code> 对象的基本使用方法：</p>
<h3 id="创建-Date-对象"><a href="#创建-Date-对象" class="headerlink" title="创建 Date 对象"></a>创建 Date 对象</h3><ol>
<li><p><strong>无参数</strong> - 创建一个表示当前日期和时间的对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>带参数</strong> - 创建一个指定日期和时间的对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> specificDate = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">17</span>); <span class="comment">// 注意月份是从 0 开始的，所以 8 月是 7</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>毫秒数</strong> - 创建一个从1970年1月1日午夜开始经过的毫秒数所表示的日期：</p>
<ol>
<li>这里的参数是从<strong>开始时间~结束时间</strong>所经过的毫秒数。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> milliSecondsSinceEpoch = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1692278827000</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="日期对象的常用方法"><a href="#日期对象的常用方法" class="headerlink" title="日期对象的常用方法"></a>日期对象的常用方法</h3><h4 id="获取日期和时间的部分"><a href="#获取日期和时间的部分" class="headerlink" title="获取日期和时间的部分"></a>获取日期和时间的部分</h4><p>你可以使用 <code>Date</code> 对象的方法来获取日期和时间的不同部分，例如：</p>
<ul>
<li><code>getFullYear()</code>, <code>getMonth()</code>, <code>getDate()</code></li>
<li><code>getHours()</code>, <code>getMinutes()</code>, <code>getSeconds()</code>, <code>getMilliseconds()</code></li>
<li><code>getTime()</code> - 返回从1970年1月1日午夜开始经过的毫秒数。</li>
<li><code>getDay()</code>-返回星期，0~6</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> today = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(today.<span class="title function_">getFullYear</span>()); <span class="comment">// 输出当前年份</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(today.<span class="title function_">getMonth</span>());    <span class="comment">// 输出当前月份（0-11）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(today.<span class="title function_">getDate</span>());     <span class="comment">// 输出当前日期（1-31）</span></span><br></pre></td></tr></table></figure>

<h4 id="设置日期和时间的部分"><a href="#设置日期和时间的部分" class="headerlink" title="设置日期和时间的部分"></a>设置日期和时间的部分</h4><p>同样也可以设置日期和时间的不同部分，例如：</p>
<ul>
<li><code>setFullYear()</code>, <code>setMonth()</code>, <code>setDate()</code></li>
<li><code>setHours()</code>, <code>setMinutes()</code>, <code>setSeconds()</code>, <code>setMilliseconds()</code></li>
<li><code>setTime()</code> - 设置从1970年1月1日午夜开始经过的毫秒数。</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> today = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">today.<span class="title function_">setFullYear</span>(<span class="number">2025</span>);</span><br><span class="line">today.<span class="title function_">setDate</span>(<span class="number">1</span>);</span><br><span class="line">today.<span class="title function_">setMonth</span>(<span class="number">0</span>); <span class="comment">// 设置为一月</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(today);</span><br></pre></td></tr></table></figure>

<h4 id="格式化日期"><a href="#格式化日期" class="headerlink" title="格式化日期"></a>格式化日期</h4><p>JavaScript 中没有内置的日期格式化函数，但你可以使用第三方库如 Moment.js 或者使用模板字符串和计算来实现简单的格式化，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> today = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> formattedDate = <span class="string">`<span class="subst">$&#123;today.getFullYear()&#125;</span>-<span class="subst">$&#123;(<span class="string">&#x27;0&#x27;</span> + (today.getMonth() + <span class="number">1</span>)).slice(-<span class="number">2</span>)&#125;</span>-<span class="subst">$&#123;(<span class="string">&#x27;0&#x27;</span> + today.getDate()).slice(-<span class="number">2</span>)&#125;</span>`</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(formattedDate); <span class="comment">// 输出 &quot;2024-08-17&quot;</span></span><br></pre></td></tr></table></figure>

<p>在格式化日期中，遇到时分秒补<code>0</code>时，可以使用三元运算符</p>
<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>在JavaScript中，<code>Date</code> 对象提供了多个方法来格式化日期和时间。其中 <code>toLocaleString()</code> 是一个非常有用的内置方法，它返回一个表示日期&#x2F;时间的本地格式化的字符串。此外，还有其他一些相关的方法可以帮助你以不同的方式格式化日期。</p>
<h5 id="1-toLocaleString"><a href="#1-toLocaleString" class="headerlink" title="1. toLocaleString()"></a>1. <code>toLocaleString()</code></h5><p><code>toLocaleString()</code> 方法返回一个本地化格式的日期&#x2F;时间字符串。默认情况下，它会使用浏览器的语言环境设置来决定日期的格式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toLocaleString</span>()); <span class="comment">// 输出本地格式的日期和时间</span></span><br></pre></td></tr></table></figure>

<h5 id="2-toLocaleDateString"><a href="#2-toLocaleDateString" class="headerlink" title="2. toLocaleDateString()"></a>2. <code>toLocaleDateString()</code></h5><p><code>toLocaleDateString()</code> 方法仅返回日期部分的本地化格式字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toLocaleDateString</span>()); <span class="comment">// 输出本地格式的日期</span></span><br></pre></td></tr></table></figure>

<h5 id="3-toLocaleTimeString"><a href="#3-toLocaleTimeString" class="headerlink" title="3. toLocaleTimeString()"></a>3. <code>toLocaleTimeString()</code></h5><p><code>toLocaleTimeString()</code> 方法仅返回时间部分的本地化格式字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toLocaleTimeString</span>()); <span class="comment">// 输出本地格式的时间</span></span><br></pre></td></tr></table></figure>

<h5 id="参数选项"><a href="#参数选项" class="headerlink" title="参数选项"></a>参数选项</h5><p>这些方法都支持选项对象作为参数，允许你进一步定制输出格式。例如，你可以指定使用24小时制还是12小时制，是否显示秒等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123; <span class="attr">weekday</span>: <span class="string">&#x27;long&#x27;</span>, <span class="attr">year</span>: <span class="string">&#x27;numeric&#x27;</span>, <span class="attr">month</span>: <span class="string">&#x27;long&#x27;</span>, <span class="attr">day</span>: <span class="string">&#x27;numeric&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">toLocaleDateString</span>(<span class="string">&#x27;en-US&#x27;</span>, options)); <span class="comment">// 自定义格式</span></span><br></pre></td></tr></table></figure>

<h4 id="更多方法"><a href="#更多方法" class="headerlink" title="更多方法"></a>更多方法</h4><p>除了上面提到的方法外，<code>Date</code> 对象还提供了其他一些有用的方法：</p>
<ul>
<li><code>toString()</code>：返回日期&#x2F;时间的标准格式字符串。</li>
<li><code>toISOString()</code>：返回一个符合 ISO 标准的日期&#x2F;时间字符串。</li>
<li><code>toJSON()</code>：与 <code>toISOString()</code> 类似，用于 JSON 序列化。</li>
<li><code>toUTCString()</code>：返回日期&#x2F;时间的 UTC 字符串格式。</li>
<li><code>toLocaleDateString()</code> 和 <code>toLocaleTimeString()</code> 的更多选项：可以指定时区、时间格式等。</li>
</ul>
<h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><ul>
<li>使用场景：制作倒计时效果</li>
<li>什么是时间戳：指从1970年01月01日00时00分00秒起至现在的<strong>毫秒数</strong>。</li>
</ul>
<h5 id="获取时间戳"><a href="#获取时间戳" class="headerlink" title="获取时间戳"></a>获取时间戳</h5><p>要获取当前时间的时间戳，可以使用 <code>Date.now()</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timestamp = <span class="title class_">Date</span>.<span class="title function_">now</span>(); <span class="comment">// 获取当前时间的时间戳</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(timestamp);</span><br></pre></td></tr></table></figure>

<p>如果你已经有了一个 <code>Date</code> 对象，可以通过调用 <code>getTime()</code> 方法来获取该日期对应的时间戳：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> timestampFromDate = date.<span class="title function_">getTime</span>(); <span class="comment">// 获取Date对象对应的时间戳</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(timestampFromDate);</span><br></pre></td></tr></table></figure>

<p>同样，如果有了Date对象，可以通过在 <code>new Date()</code>前面加一个转换获得</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="comment">//通过隐式转换，把字符型转换为数字型来获取</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(+ <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></table></figure>

<p>第2,3中方法可以获取指定时间的时间戳。</p>
<h5 id="时间戳转换为日期"><a href="#时间戳转换为日期" class="headerlink" title="时间戳转换为日期"></a>时间戳转换为日期</h5><p>如果你有一个时间戳并想将其转换为 <code>Date</code> 对象，可以使用 <code>new Date(timestamp)</code> 构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timestamp = <span class="number">1692278827000</span>; <span class="comment">// 给定的时间戳</span></span><br><span class="line"><span class="keyword">const</span> dateFromTimestamp = <span class="keyword">new</span> <span class="title class_">Date</span>(timestamp); <span class="comment">// 将时间戳转换为Date对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dateFromTimestamp);</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240817125524914.png" alt="image-20240817125524914"></p>
<h5 id="使用时间戳"><a href="#使用时间戳" class="headerlink" title="使用时间戳"></a>使用时间戳</h5><p>时间戳在JavaScript中非常有用，尤其是在需要比较不同时间点或者执行定时任务时。例如，你可以使用时间戳来计算两个时间点之间的时间差：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> startTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"><span class="comment">// 执行某些操作...</span></span><br><span class="line"><span class="keyword">const</span> endTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"><span class="keyword">const</span> timeDifference = endTime - startTime;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`操作耗时 <span class="subst">$&#123;timeDifference&#125;</span> 毫秒`</span>);</span><br></pre></td></tr></table></figure>

<h5 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h5><p>这里是一个示例，展示如何使用时间戳来计算从1970年1月1日到2024年8月17日这段时间的时间戳：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算2024年8月17日的时间戳</span></span><br><span class="line"><span class="keyword">const</span> targetDate = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2024</span>, <span class="number">7</span>, <span class="number">17</span>); <span class="comment">// 注意月份是从0开始的</span></span><br><span class="line"><span class="keyword">const</span> targetTimestamp = targetDate.<span class="title function_">getTime</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(targetTimestamp); <span class="comment">// 输出时间戳</span></span><br></pre></td></tr></table></figure>





<h1 id="JS事件监听"><a href="#JS事件监听" class="headerlink" title="JS事件监听"></a>JS事件监听</h1><p>事件:HTML事件是发生在HTML元素上的“事情”。比如:</p>
<ul>
<li><p>按钮被点击</p>
</li>
<li><p>鼠标移动到元素上</p>
</li>
<li><p>按下键盘按键</p>
</li>
<li><p>事件监听:JavaScript可以在事件被侦测到时 执行代码。</p>
</li>
</ul>
<h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><ul>
<li><p>方式一：通过HTML标签中的时间属性进行绑定</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;on()&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">	function on()</span><br><span class="line">    &#123;</span><br><span class="line">		alert(&#x27;我被点击了!);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二：通过DOM元素属性绑定</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;button&quot;</span> <span class="attr">id</span> =<span class="string">&quot;btn1&quot;</span> <span class="attr">value</span> = <span class="string">&quot;按钮2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn1&quot;</span>).<span class="property">onclick</span> = 			<span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">	&#123;</span></span><br><span class="line"><span class="language-javascript">    	<span class="title function_">alert</span>(<span class="string">&quot;我被点击了！&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">	&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="常见事件"><a href="#常见事件" class="headerlink" title="常见事件"></a>常见事件</h2><p>在JavaScript中，事件是用户或浏览器的动作，它们可以触发预定义的函数或代码块。事件驱动的编程是现代Web开发的核心部分，允许网站对用户的交互作出反应。以下是在JavaScript中常见的几种事件类型：</p>
<h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><ul>
<li><code>click</code>：当用户点击鼠标左键时触发。</li>
<li><code>dblclick</code>：当用户双击鼠标左键时触发。</li>
<li><code>mousedown</code>：当鼠标按钮被按下时触发。</li>
<li><code>mouseup</code>：当鼠标按钮被释放时触发。</li>
<li><code>mousemove</code>：当鼠标在页面上移动时持续触发。</li>
<li><code>mouseenter</code> 和 <code>mouseleave</code>：当鼠标进入或离开一个元素时触发。这两个事件不会存在冒泡和捕获。</li>
<li><code>mouseover</code> 和 <code>mouseout</code>：类似于 <code>mouseenter</code> 和 <code>mouseleave</code>，会存在捕获和冒泡阶段</li>
<li><code>contextmenu</code>：当用户右击鼠标时触发。</li>
</ul>
<h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><ul>
<li><code>keydown</code>：当键盘上的一个键被按下时触发。</li>
<li><code>keypress</code>：当按下有字符输出的键时触发。</li>
<li><code>keyup</code>：当键盘上的一个键被释放时触发。</li>
</ul>
<h3 id="文档和窗口-window-事件"><a href="#文档和窗口-window-事件" class="headerlink" title="文档和窗口(window)事件"></a>文档和窗口(window)事件</h3><ul>
<li><code>load</code>：当页面或资源加载完成时触发。</li>
<li><code>unload</code>：当页面正在卸载时触发。</li>
<li><code>beforeunload</code>：页面即将卸载之前触发。</li>
<li><code>resize</code>：当窗口大小改变时触发。</li>
<li><code>scroll</code>：当页面滚动时触发。</li>
</ul>
<h3 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h3><ul>
<li><code>change</code>：当表单元素（如输入框、下拉列表）的内容被改变时触发。</li>
<li><code>focus</code> 和 <code>blur</code>：当元素获得或失去焦点时触发。</li>
<li><code>submit</code>：当表单被提交时触发。</li>
</ul>
<h3 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h3><ul>
<li><code>error</code>：当错误发生时触发，如图像加载失败。</li>
<li><code>resize</code> 和 <code>scroll</code>：分别在窗口尺寸变化或滚动时触发。</li>
<li><code>touchstart</code>, <code>touchend</code>, <code>touchmove</code>：触摸设备上的事件。</li>
</ul>
<p>事件处理可以通过直接在HTML标签中设置事件属性（如<code>onclick=&quot;someFunction()&quot;</code>），或者通过JavaScript的<code>addEventListener</code>来监听事件</p>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>事件处理器通常会接收到一个事件对象，这个对象包含了关于事件的所有信息，如事件类型、触发事件的元素、鼠标的位置、键盘按键等。事件对象通常作为函数的第一个参数传递，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">type</span>); <span class="comment">// 输出 &quot;click&quot;，这里的event指的是事件对象</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>事件对象在JavaScript中提供了一系列的属性，用于描述触发事件的详细信息。下面列出了事件对象中一些常用的属性：</p>
<ol>
<li><p><strong><code>type</code></strong></p>
<ul>
<li>描述事件的类型，如 ‘click’, ‘keydown’, ‘load’ 等。</li>
</ul>
</li>
<li><p><strong><code>target</code></strong></p>
<ul>
<li>指向事件最初触发的DOM元素。即使事件被冒泡到其他元素，<code>target</code>始终指向最初触发事件的元素。</li>
</ul>
</li>
<li><p><strong><code>currentTarget</code></strong></p>
<ul>
<li>指向当前正在处理事件的DOM元素。如果事件被冒泡或捕获，<code>currentTarget</code>将根据事件流而变化。</li>
</ul>
</li>
<li><p><strong><code>eventPhase</code></strong></p>
<ul>
<li>描述事件当前处于哪个阶段：<code>AT_TARGET</code> (2)，<code>CAPTURING_PHASE</code> (1)，或 <code>BUBBLING_PHASE</code> (3)。</li>
</ul>
</li>
<li><p><strong><code>timeStamp</code></strong></p>
<ul>
<li>事件发生的精确时间戳，单位通常是毫秒。</li>
</ul>
</li>
<li><p><strong><code>preventDefault()</code></strong></p>
<ul>
<li>方法，阻止事件的默认行为。例如，在链接上阻止页面跳转。</li>
</ul>
</li>
<li><p><strong><code>stopPropagation()</code></strong></p>
<ul>
<li>方法，阻止事件冒泡到父级元素。</li>
</ul>
</li>
<li><p><strong><code>stopImmediatePropagation()</code></strong></p>
<ul>
<li>类似于<code>stopPropagation()</code>, 但是它还会阻止事件处理函数队列中的后续函数执行。</li>
</ul>
</li>
<li><p><strong><code>clientX</code> 和 <code>clientY</code></strong></p>
<ul>
<li>对于鼠标事件，表示鼠标指针相对于视口的位置（不包括滚动条偏移）。</li>
</ul>
</li>
<li><p><strong><code>pageX</code> 和 <code>pageY</code></strong></p>
<ul>
<li>对于鼠标事件，表示鼠标指针相对于整个文档的位置（包括滚动条偏移）。</li>
</ul>
</li>
<li><p><strong><code>screenX</code> 和 <code>screenY</code></strong></p>
<ul>
<li>对于鼠标事件，表示鼠标指针相对于屏幕的位置。</li>
</ul>
</li>
<li><p><strong><code>button</code></strong></p>
<ul>
<li>对于鼠标事件，表示哪个鼠标按钮被按下：0（主按钮，通常是左键），1（中间按钮），2（次按钮，通常是右键）。</li>
</ul>
</li>
<li><p><strong><code>keyCode</code> 或 <code>key</code></strong></p>
<ul>
<li>对于键盘事件，<code>keyCode</code> 是一个数字，表示按下的键。在现代浏览器中，更推荐使用<code>key</code>属性，它是一个字符串，提供了更清晰的键标识。</li>
</ul>
</li>
<li><p><strong><code>which</code></strong></p>
<ul>
<li>类似于<code>keyCode</code>，但跨浏览器兼容性更好。</li>
</ul>
</li>
<li><p><strong><code>ctrlKey</code>, <code>altKey</code>, <code>shiftKey</code>, <code>metaKey</code></strong></p>
<ul>
<li>布尔值，表示是否同时按下了Ctrl, Alt, Shift, 或 Meta (Command) 键。</li>
</ul>
</li>
</ol>
<h2 id="环境对象"><a href="#环境对象" class="headerlink" title="环境对象"></a>环境对象</h2><p><strong>环境对象</strong>：指的是函数内部特殊的变量<code>this</code>，它代表着当函数运行时所处的环境</p>
<p>作用：弄清楚this的指向，this指代的对象也不同</p>
<ul>
<li>函数调用方式不同，this指代的对象也不同。</li>
<li>谁调用该函数，this就指向谁，这是判断this指向的粗略规则</li>
</ul>
<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p><strong>定义</strong>：<strong>事件流指定是一个事件完整执行过程中的流动路径</strong></p>
<p>在JavaScript中，<strong>事件流</strong>描述了事件是如何在文档对象模型（DOM）中传播的。事件流主要分为两个阶段：<strong>事件捕获</strong>和<strong>事件冒泡</strong>。还存在一个中间阶段，即<strong>目标阶段</strong>，在这个阶段事件直接作用于目标元素。</p>
<h3 id="事件捕获-Event-Capturing"><a href="#事件捕获-Event-Capturing" class="headerlink" title="事件捕获 (Event Capturing)"></a>事件捕获 (Event Capturing)</h3><p><strong>这是事件流第一阶段</strong>：从父到子</p>
<p>事件捕获是从DOM树的根节点（通常是<code>document</code>或<code>window</code>）开始，事件沿着元素层级向下传播，直到达到目标元素。在这一阶段，事件处理程序有机会在事件到达目标元素之前进行拦截和响应。</p>
<ul>
<li>给addEvenListener函数写入第三个参数，true，意味着开启了捕获机制。</li>
<li>事件要同名。</li>
</ul>
<h3 id="目标阶段-Target-Phase"><a href="#目标阶段-Target-Phase" class="headerlink" title="目标阶段 (Target Phase)"></a>目标阶段 (Target Phase)</h3><p>一旦事件到达目标元素，目标元素上的事件处理程序被调用。这是事件直接作用于触发事件的元素的阶段。</p>
<h3 id="事件冒泡-Event-Bubbling"><a href="#事件冒泡-Event-Bubbling" class="headerlink" title="事件冒泡 (Event Bubbling)"></a>事件冒泡 (Event Bubbling)</h3><p><strong>这是事件流第二阶段</strong>：从子到父</p>
<p>在事件冒泡阶段，事件从目标元素开始，沿DOM树向上逐级传播，直到达到DOM树的根节点。在这个过程中，事件处理程序可以被沿途的任何父元素捕获。</p>
<ul>
<li>给addEvenListener函数写入第三个参数，false(这也是默认值，所以一般不写)，意味着开启了冒泡机制。</li>
<li>当触发冒泡机制时，一个元素触发事件后，会一次从触发事件的子元素向上调用所有父级元素的<strong>同名事件</strong></li>
<li>事件冒泡默认存在。</li>
</ul>
<h3 id="事件流的传播方向"><a href="#事件流的传播方向" class="headerlink" title="事件流的传播方向"></a>事件流的传播方向</h3><ul>
<li><strong>事件捕获</strong>：从外部到内部（从根节点到目标节点）。</li>
<li><strong>事件冒泡</strong>：从内部到外部（从目标节点到根节点）。</li>
</ul>
<h3 id="使用事件处理程序"><a href="#使用事件处理程序" class="headerlink" title="使用事件处理程序"></a>使用事件处理程序</h3><p>你可以使用<code>addEventListener</code>方法来附加事件处理程序，并通过传递第三个布尔参数来选择事件流的哪个阶段来触发该处理程序：</p>
<ul>
<li>如果第三个参数为<code>true</code>，则事件处理程序会在<strong>事件捕获</strong>阶段被调用。</li>
<li>如果第三个参数为<code>false</code>（或省略），则事件处理程序会在<strong>事件冒泡</strong>阶段被调用。</li>
</ul>
<h2 id="阻止冒泡"><a href="#阻止冒泡" class="headerlink" title="阻止冒泡"></a>阻止冒泡</h2><p>目标:能够写出阻止冒泡的代码</p>
<ul>
<li><p>问题:因为默认就有冒泡模式的存在，所以容易导致事件影响到父级元素</p>
</li>
<li><p>需求:若想把事件就限制在当前元素内，就需要阻止事件冒泡</p>
</li>
<li><p>前提:阻止事件冒泡需要拿到事件对象</p>
</li>
<li><p>语法:</p>
<p><code>事件对象.stopPropagation()</code>，propagation有（动植物等的）繁殖，增殖，；（观点、理论等的）传播；（运动、光线、声音等的）传送的意思。</p>
</li>
<li><p>注意：此方法可以阻断事件流动传播，不光在冒泡阶段有效，捕获阶段也有效</p>
</li>
</ul>
<h2 id="事件解绑"><a href="#事件解绑" class="headerlink" title="事件解绑"></a>事件解绑</h2><ul>
<li><p>解绑：onxxxx事件，利用on定义的事件存在冒泡不存在捕获。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="title function_">alert</span>(<span class="string">&#x27;我被点击了&#x27;</span>)</span><br><span class="line">     <span class="comment">//通过赋值空对象来解绑</span></span><br><span class="line">     btn.<span class="property">onclick</span> = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解绑：通过addEvenListener添加的事件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;我是通过addEvenListener添加的事件，点击之后我就被解绑了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>,fn)</span><br><span class="line"><span class="comment">//由于第二个参数需要传入函数的名字，所以匿名函数无法移除</span></span><br><span class="line">btn.<span class="title function_">removeEventListener</span>(<span class="string">&quot;click&quot;</span>,fn)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意：匿名函数无法解绑！！！！</p>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>事件委托（Event Delegation）是一种在父元素上处理子元素事件的技术。它的核心思想是，而不是在每个子元素上单独添加事件监听器，你可以在一个共同的祖先元素上添加一个监听器，然后根据事件的目标（<code>event.target</code>）来确定哪个子元素触发了事件。这种方法可以显著减少事件监听器的数量，从而提升性能，特别是在处理大量动态生成的元素时。</p>
<h3 id="如何实现事件委托"><a href="#如何实现事件委托" class="headerlink" title="如何实现事件委托"></a>如何实现事件委托</h3><p>事件委托利用了事件冒泡的特性，即事件从最深层的触发元素开始，向上冒泡到DOM树的更高层。当事件冒泡至监听器所在的元素时，你可以检查事件的目标是否符合你的需求。</p>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol>
<li><strong>选择一个合适的祖先元素</strong>：选择一个包含所有相关子元素的共同祖先作为事件监听器的挂载点。</li>
<li><strong>添加事件监听器</strong>：在选定的祖先元素上添加事件监听器，通常是在<code>click</code>、<code>mouseover</code>等常见事件类型上。</li>
<li><strong>检查事件目标</strong>：在事件处理函数中，使用<code>event.target</code>来确定触发事件的实际元素，并根据需要做出响应。如果需要更确切的确定元素，可以通过元素的<code>tagName</code>来进一步判断</li>
</ol>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>假设你有一个列表，其中包含许多链接，你想要在这些链接被点击时执行某个操作，但是你不想为每个链接单独添加事件监听器。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Link 1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Link 2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Link 3<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>);</span><br><span class="line"></span><br><span class="line">list.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> target = event.<span class="property">target</span>;</span><br><span class="line">  <span class="comment">// 检查目标是否是我们感兴趣的元素</span></span><br><span class="line">  <span class="keyword">if</span> (target.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>() === <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Link clicked:&#x27;</span>, target.<span class="property">textContent</span>);</span><br><span class="line">    <span class="comment">// 阻止默认行为，例如链接跳转</span></span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们没有在每个<code>&lt;a&gt;</code>标签上添加事件监听器，而是将监听器添加到了<code>&lt;ul&gt;</code>元素上。当用户点击任何一个链接时，事件会冒泡到<code>&lt;ul&gt;</code>元素，然后我们检查<code>event.target</code>以确定哪个链接被点击。</p>
<h2 id="阻止事件的默认行为"><a href="#阻止事件的默认行为" class="headerlink" title="阻止事件的默认行为"></a>阻止事件的默认行为</h2><p>在JavaScript中，阻止元素的默认行为通常是在事件处理函数中完成的，这样可以防止与该事件相关的默认动作被执行。例如，阻止链接的导航、表单的提交、或阻止某些键盘快捷键的默认行为。</p>
<p>要阻止元素的默认行为，可以使用 <code>event.preventDefault()</code> 方法。这个方法是事件对象的一个属性，当在事件处理函数中被调用时，会取消事件的默认行为。</p>
<p>以下是一个阻止链接点击时默认跳转行为的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> link = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">link.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Link clicked, but default action prevented.&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，当链接被点击时，原本的跳转行为会被 <code>event.preventDefault()</code> 取消，而控制台将输出一条信息。</p>
<p>同样地，如果你想要阻止表单提交的默认行为，可以这样做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> form = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;form&#x27;</span>);</span><br><span class="line"></span><br><span class="line">form.<span class="title function_">addEventListener</span>(<span class="string">&#x27;submit&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Form submitted, but default action prevented.&#x27;</span>);</span><br><span class="line">    <span class="comment">// 在这里执行自定义的提交逻辑</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这个表单提交的例子中，<code>event.preventDefault()</code> 阻止了表单的默认提交动作，使页面不会重新加载或导航到表单的action URL。</p>
<p>需要注意的是，<code>preventDefault()</code> 并不影响事件的冒泡或捕获过程。如果你想阻止事件的进一步传播，可以使用 <code>event.stopPropagation()</code>。但通常，<code>preventDefault()</code> 用于取消事件的默认行为，而 <code>stopPropagation()</code> 用于阻止事件向父元素的传播。</p>
<p>在某些情况下，如阻止拖放行为或阻止某些键盘快捷键的默认行为，<code>preventDefault()</code> 也是必需的。例如，阻止用户使用 <code>Ctrl+C</code> 复制文本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keydown&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">ctrlKey</span> &amp;&amp; event.<span class="property">key</span> === <span class="string">&#x27;c&#x27;</span>) &#123;</span><br><span class="line">        event.<span class="title function_">preventDefault</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Copy operation prevented.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="元素在页面中的位置"><a href="#元素在页面中的位置" class="headerlink" title="元素在页面中的位置"></a>元素在页面中的位置</h1><h2 id="页面滚动"><a href="#页面滚动" class="headerlink" title="页面滚动"></a>页面滚动</h2><p>在JavaScript中，<code>scroll</code>通常指的是与滚动条和滚动位置相关的操作。浏览器窗口或元素的滚动可以通过以下几种方式来访问或修改：</p>
<ol>
<li><p><strong><code>window.scroll()</code></strong> 或 <strong><code>window.scrollTo()</code></strong><br>这些方法用于将浏览器窗口滚动到特定的位置。它们接受两个参数，第一个是水平位置（X坐标），第二个是垂直位置（Y坐标）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>, <span class="number">500</span>); <span class="comment">// 滚动到页面顶部以下500像素的位置</span></span><br></pre></td></tr></table></figure>

<p>或者使用 <code>scroll()</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">scroll</span>(&#123;<span class="attr">top</span>: <span class="number">500</span>, <span class="attr">left</span>: <span class="number">0</span>, <span class="attr">behavior</span>: <span class="string">&#x27;smooth&#x27;</span>&#125;); <span class="comment">// 平滑滚动到指定位置</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>window.scrollBy()</code></strong><br>此方法相对于当前位置移动窗口。同样接受两个参数，分别表示水平和垂直方向上的偏移量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollBy</span>(<span class="number">0</span>, <span class="number">100</span>); <span class="comment">// 向下滚动100像素</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>window.scrollX</code> 和 <code>window.scrollY</code></strong><br>这两个属性返回窗口当前的滚动位置。<code>scrollX</code>是水平滚动距离，<code>scrollY</code>是垂直滚动距离。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">scrollY</span>); <span class="comment">// 输出垂直滚动的距离</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>element.scrollTop</code> 和 <code>element.scrollLeft</code></strong><br>这些属性用于获取或设置特定元素的滚动位置。<code>scrollTop</code>表示垂直滚动距离，<code>scrollLeft</code>表示水平滚动距离。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;someElement&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(element.<span class="property">scrollTop</span>); <span class="comment">// 获取元素的垂直滚动距离</span></span><br><span class="line">element.<span class="property">scrollTop</span> = <span class="number">200</span>; <span class="comment">// 将元素的垂直滚动位置设置为200像素</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>element.scrollHeight</code> 和 <code>element.scrollWidth</code></strong><br>这些属性返回元素的内容高度和宽度，包括溢出的部分。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;someElement&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(element.<span class="property">scrollHeight</span>); <span class="comment">// 获取元素内容的高度，包括不可见部分</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>element.scrollIntoView()</code></strong><br>这个方法会将元素滚动到视图内，可选择性地使元素对齐到视口的顶部、中心或底部。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;someElement&#x27;</span>);</span><br><span class="line">element.<span class="title function_">scrollIntoView</span>(&#123;<span class="attr">behavior</span>: <span class="string">&#x27;smooth&#x27;</span>, <span class="attr">block</span>: <span class="string">&#x27;center&#x27;</span>&#125;); <span class="comment">// 平滑滚动并使元素居中显示</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="cliet家族"><a href="#cliet家族" class="headerlink" title="cliet家族"></a>cliet家族</h2><p>“client”家族的一系列属性提供了关于浏览器窗口可视区域的信息，而不包括工具栏、滚动条、菜单栏等非内容区域。</p>
<ol>
<li><strong>clientWidth</strong>: 返回元素的宽度，包括内边距（padding），但不包括边框（border）和滚动条。如果应用于 <code>window</code> 对象，它返回浏览器窗口的可视宽度（不包括滚动条）。</li>
<li><strong>clientHeight</strong>: 类似于 <code>clientWidth</code>，但返回高度。这包括元素的内边距，但不包括边框和滚动条。在 <code>window</code> 对象上，它返回浏览器窗口的可视高度。</li>
<li><strong>clientLeft</strong>: 返回元素左侧边框的宽度。如果元素没有边框，此值为0。</li>
<li><strong>clientTop</strong>: 返回元素顶部边框的宽度。如果元素没有边框，此值为0。</li>
<li><strong>clientX</strong>: 这个属性通常与鼠标事件一起使用，表示相对于视口的鼠标水平位置。例如，在 <code>mousedown</code>、<code>mousemove</code>、<code>mouseup</code> 等事件中，<code>event.clientX</code> 提供了鼠标的水平坐标。</li>
<li><strong>clientY</strong>: 与 <code>clientX</code> 类似，但表示垂直坐标。</li>
</ol>
<h2 id="offset家族"><a href="#offset家族" class="headerlink" title="offset家族"></a>offset家族</h2><p>在Web开发中，<code>offset</code> 家族的属性提供了一组与元素的位置和尺寸有关的信息。这些属性主要用于获取元素相对于其offset parent（偏移父元素）的位置和尺寸，<strong>而offset parent通常是元素最近的具有定位（positioned）的祖先元素或者是<code>&lt;body&gt;</code>元素本身（如果没有任何定位的祖先）。</strong></p>
<p><code>offset</code> 家族主要包括以下几个属性：</p>
<ol>
<li><strong>offsetWidth</strong>: 返回元素的宽度，包括元素的内容、内边距（padding）、边框（border），但不包括外边距（margin）。单位是像素。</li>
<li><strong>offsetHeight</strong>: 返回元素的高度，包括元素的内容、内边距、边框，但不包括外边距。单位是像素。</li>
<li><strong>offsetLeft</strong>: 返回元素左边缘相对于其offset parent的左边缘的偏移量。单位是像素。**(只读属性)**</li>
<li><strong>offsetTop</strong>: 返回元素顶边缘相对于其offset parent的顶边缘的偏移量。单位是像素。**(只读属性)**</li>
<li><strong>offsetParent</strong>: 返回元素的offset parent。这个元素是最近的具有定位（position）属性的祖先元素，或者是<code>&lt;body&gt;</code>元素（如果没有定位的祖先）。</li>
</ol>
<p>这些属性非常实用，尤其是在动态调整布局、响应式设计、元素对齐或动画效果中。由于它们返回的是实际的像素值，因此可以用于计算和调整元素的位置和大小。</p>
<p>值得注意的是，<code>offset</code> 家族的属性返回的值总是数值，而不是带有单位的字符串。<strong>这意味着，如果需要进行样式设置，你可能需要将这些数值转换为带有单位的字符串。</strong></p>
<p>图解：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240816090902709.png" alt="image-20240816090902709"></p>
<h2 id="获取元素大小位置的另外方法"><a href="#获取元素大小位置的另外方法" class="headerlink" title="获取元素大小位置的另外方法"></a>获取元素大小位置的另外方法</h2><ul>
<li>方法 ：<code>getBoundingClientRect()</code><ul>
<li>该方法返回元素的位置大小是相对于视口的位置来看的</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240816091457398.png" alt="image-20240816091457398"></li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>scrollLeft和scrollTop</td>
<td>被卷去的头部和左侧</td>
<td>配合页面滚动事件来使用，可读写</td>
</tr>
<tr>
<td>cilentWidth和clientHeight</td>
<td>获得元素的宽度和高度</td>
<td>不包含元素的border、padding、滚动条等，用于利用js读取元素大小，只读属性</td>
</tr>
<tr>
<td>offsetWidth和offsetHeight</td>
<td>获取元素的宽度和高度</td>
<td>包含元素的border、padding、滚动条等，只读属性</td>
</tr>
<tr>
<td>offsetLeft和offsetTop</td>
<td>获取元素距离自己已经拥有定位属性的父级元素的左、上方向的距离</td>
<td>获取元素位置的时候可以使用，只读属性</td>
</tr>
</tbody></table>
<h1 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h1><p>语法：let 变量名</p>
<h2 id="1-变量的赋值"><a href="#1-变量的赋值" class="headerlink" title="1.变量的赋值"></a>1.变量的赋值</h2><p>语法：变量 &#x3D; 要赋的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age</span><br><span class="line"></span><br><span class="line">age = <span class="number">18</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>；</span><br><span class="line"><span class="comment">//弹出输入框prompt(&quot;请输入姓名&quot;)</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="title function_">prompt</span>(<span class="string">&quot;请输入姓名&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2-var、const、let的区别"><a href="#2-var、const、let的区别" class="headerlink" title="2.var、const、let的区别"></a>2.var、const、let的区别</h2><p>在较旧的JavaScript，使用关键字 var 来声明变量 ，而不是 let。var现在开发中一般不再使用它，只是我们可能再老版程序中看到它。let 为了解决 var 的一些问题。</p>
<h3 id="为什么不用var-声明"><a href="#为什么不用var-声明" class="headerlink" title="为什么不用var 声明"></a>为什么不用var 声明</h3><ul>
<li><strong>可以先使用 在声明(不合理)</strong></li>
<li><strong>var 声明过的变量可以重复声明(不合理)</strong></li>
<li><strong>比如变量提升、全局变量、没有块级作用域等等</strong></li>
</ul>
<h3 id="推荐使用-let-的情况："><a href="#推荐使用-let-的情况：" class="headerlink" title="推荐使用 let 的情况："></a>推荐使用 <code>let</code> 的情况：</h3><ul>
<li>当你需要声明一个变量，且这个变量的值可能会发生变化时，使用 <code>let</code>。</li>
<li><code>let</code> 允许你在块级作用域内声明变量，这有助于避免变量之间的冲突和意外覆盖。</li>
</ul>
<h3 id="推荐使用-const-的情况："><a href="#推荐使用-const-的情况：" class="headerlink" title="推荐使用 const 的情况："></a>推荐使用 <code>const</code> 的情况：</h3><ul>
<li>当你声明一个变量并且知道它的值不会改变时，应该使用 <code>const</code>。</li>
<li>使用 <code>const</code> 可以明确表示该变量是不可变的，这有助于提高代码的可读性和可维护性。</li>
<li>即使是对象或数组，虽然你可以改变它们的内容，但 <code>const</code> 仍然有助于确保不会重新分配一个新的引用。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li>**默认使用 <code>const</code>**：尽可能地使用 <code>const</code> 来声明变量。这样可以确保在变量值不需要改变的情况下，它们不会被意外修改。</li>
<li>**只有当需要改变时使用 <code>let</code>**：当你确定某个变量的值会在后续的代码中发生改变时，才使用 <code>let</code> 来声明。</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240622165854723.png" alt="image-20240622165854723"></li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240622170552011.png" alt="image-20240622170552011"></li>
</ol>
<h1 id="webAPI基本认识"><a href="#webAPI基本认识" class="headerlink" title="webAPI基本认识"></a>webAPI基本认识</h1><h2 id="获取DOM元素"><a href="#获取DOM元素" class="headerlink" title="获取DOM元素"></a>获取DOM元素</h2><h3 id="根据CSS选择器来获取DOM元素"><a href="#根据CSS选择器来获取DOM元素" class="headerlink" title="根据CSS选择器来获取DOM元素"></a>根据CSS选择器来获取DOM元素</h3><ul>
<li><p>选择匹配的<strong>第一个元素</strong></p>
</li>
<li><p>语法</p>
<ul>
<li><pre><code class="javascript">document.querySelector(&#39;css选择器&#39;)

// 获取匹配的第一个元素(通过标签元素和类名来进行选择)
  const firstObj = document.querySelector(&#39;div&#39;)
  const firstObj2 = document.querySelector(&quot;.test&quot;)
  console.log(firstObj);
  console.log(firstObj2);

const nav = document.querySelector(&quot;#nav&quot;)
console.log(nav);

const li = document.querySelector(&quot;ul li:first-child&quot;)
console.log(li);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * 参数：包含一个或多个有效的CSS选择器字符串</span><br><span class="line"></span><br><span class="line">  * 返回值：CSS选择器匹配的**第一个元素**，一个HTMLElement对象</span><br><span class="line"></span><br><span class="line">* 选择多个元素</span><br><span class="line"></span><br><span class="line">* 语法：</span><br><span class="line"></span><br><span class="line">  ```javascript</span><br><span class="line">  const lis = document.querySelectorAll(&quot;ul li&quot;)</span><br><span class="line">  console.log(lis);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>返回值：返回一个数组</p>
<ul>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240622173913182.png" alt="image-20240622173913182"></li>
<li>得到的是一个伪数组有长度有索引号的数组，但是没有 pop()push()等数组方法，想要得到里面的每一个对象，则需要遍历(for)的方式获得。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="其他获取DOM元素的方法"><a href="#其他获取DOM元素的方法" class="headerlink" title="其他获取DOM元素的方法"></a>其他获取DOM元素的方法</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240622174536995.png" alt="image-20240622174536995"></p>
<h2 id="操作元素内容"><a href="#操作元素内容" class="headerlink" title="操作元素内容"></a>操作元素内容</h2><h3 id="对象-innerHtml属性"><a href="#对象-innerHtml属性" class="headerlink" title="对象.innerHtml属性"></a>对象.innerHtml属性</h3><ul>
<li>将文本内容添加&#x2F;更新到任意标签位置</li>
<li>能够解析标签，通常配合模板字符使用</li>
</ul>
<h3 id="对象-innerText属性"><a href="#对象-innerText属性" class="headerlink" title="对象.innerText属性"></a>对象.innerText属性</h3><ul>
<li>将文本内容添加&#x2F;更新到任意标签位置</li>
<li>显示纯文本，不能够解析标签</li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>修改元素内容.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>这是修改前的内容<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;changeDom1()&quot;</span>&gt;</span>点我修改dom内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test2&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: 10px;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>这是修改前的内容<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;changeDom2()&quot;</span>&gt;</span>点我修改dom内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">changeDom1</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> obj = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.test1&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        obj.<span class="property">innerHTML</span> = <span class="string">`&lt;span&gt;这是修改后的内容&lt;/span&gt;`</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">changeDom2</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> obj = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.test2&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        obj.<span class="property">innerText</span> = <span class="string">&quot;我是innerText，我只能修改文本，并不能识别HTML标签&quot;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="操作元素的属性"><a href="#操作元素的属性" class="headerlink" title="操作元素的属性"></a>操作元素的属性</h2><h3 id="操作元素常用属性"><a href="#操作元素常用属性" class="headerlink" title="操作元素常用属性"></a>操作元素常用属性</h3><ul>
<li>通过JS设置&#x2F;修改标签的元素属性，比如通过src更换图片</li>
<li>最常见的属性比如：href，title，src等</li>
<li>语法：<code>对象.属性 = 修改的值</code></li>
</ul>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>修改元素内容.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>这是修改前的内容<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;changeDom1()&quot;</span>&gt;</span>点我修改dom内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test2&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: 10px;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>这是修改前的内容<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;changeDom2()&quot;</span>&gt;</span>点我修改dom内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">changeDom1</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> obj = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.test1&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        obj.<span class="property">innerHTML</span> = <span class="string">`&lt;span&gt;这是修改后的内容&lt;/span&gt;`</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">changeDom2</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> obj = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.test2&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        obj.<span class="property">innerText</span> = <span class="string">&quot;我是innerText，我只能修改文本，并不能识别HTML标签&quot;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="操作元素样式属性"><a href="#操作元素样式属性" class="headerlink" title="操作元素样式属性"></a>操作元素样式属性</h3><ul>
<li>通过<code>style</code>属性来操作CSS</li>
<li>通过类名(className)来操作CSS</li>
<li>通过classList操作类控制CSS</li>
</ul>
<h4 id="通过style属性来操作CSS"><a href="#通过style属性来操作CSS" class="headerlink" title="通过style属性来操作CSS"></a>通过style属性来操作CSS</h4><ul>
<li>语法：<code>对象.style.属性 = 值</code></li>
<li>多单词采取小驼峰命名</li>
<li>注意单位</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象.style.属性 = 值</span></span><br><span class="line"><span class="keyword">let</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">box.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;400px&#x27;</span></span><br><span class="line">box.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;red&quot;</span></span><br><span class="line">box.<span class="property">style</span>.<span class="property">border</span> = <span class="string">&quot;2px solid blue&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="通过类名-className-来操作CSS"><a href="#通过类名-className-来操作CSS" class="headerlink" title="通过类名(className)来操作CSS"></a>通过类名(className)来操作CSS</h4><ul>
<li>语法：<code>dom对象.className = &quot;类名&quot;</code></li>
<li>修改较多样式，推荐使用该方法</li>
<li>因为class是关键字，所以这里要使用className来代替class。</li>
<li>通过这种方式是新值替换旧值，会顶替掉之前的类名。如果使用这种方法，要记得保留原来类名</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过类名(className)来操作CSS</span></span><br><span class="line"><span class="keyword">let</span> box1 = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;div:nth-child(2)&quot;</span>)</span><br><span class="line">box1.<span class="property">className</span> = <span class="string">&quot;testStyle&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="通过classList操作类控制CSS"><a href="#通过classList操作类控制CSS" class="headerlink" title="通过classList操作类控制CSS"></a>通过classList操作类控制CSS</h4><ul>
<li>追加一个类：<ul>
<li><code>对象.classList.add(&quot;类名&quot;)</code></li>
</ul>
</li>
<li>删除一个类：<ul>
<li><code>对象.classList.remove(&quot;类名&quot;)</code></li>
</ul>
</li>
<li>切换一个类：<ul>
<li><code>对象.classList.toggle(&quot;类名&quot;)</code></li>
<li>如果原来有切换的类，那么这个类通过切换就会被移除</li>
<li>如果没有，那么就会添加这个类</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过classList操作类控制CSS</span></span><br><span class="line"><span class="keyword">let</span> box2 = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;div:nth-child(3)&quot;</span>)</span><br><span class="line">box2.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;testStyle2&quot;</span>)</span><br><span class="line">    <span class="comment">//添加这行代码。会让第三个盒子背景变为红色</span></span><br><span class="line">box2.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&quot;test&quot;</span>) </span><br><span class="line">box2.<span class="property">classList</span>.<span class="title function_">toggle</span>(<span class="string">&quot;test&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="操作表单元素属性"><a href="#操作表单元素属性" class="headerlink" title="操作表单元素属性"></a>操作表单元素属性</h3><p>操作HTML表单及其元素的属性可以通过DOM（Document Object Model）来实现。以下是一些常见的操作，比如获取或设置表单元素的属性、值、样式等：</p>
<h4 id="获取和设置表单元素的值"><a href="#获取和设置表单元素的值" class="headerlink" title="获取和设置表单元素的值"></a>获取和设置表单元素的值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文本框的值</span></span><br><span class="line"><span class="keyword">var</span> value = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myInput&#x27;</span>).<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置文本框的值</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myInput&#x27;</span>).<span class="property">value</span> = <span class="string">&#x27;Hello World&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="检查复选框的状态"><a href="#检查复选框的状态" class="headerlink" title="检查复选框的状态"></a>检查复选框的状态</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查复选框是否被选中</span></span><br><span class="line"><span class="keyword">var</span> isChecked = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCheckbox&#x27;</span>).<span class="property">checked</span>;</span><br></pre></td></tr></table></figure>

<h4 id="设置复选框的状态"><a href="#设置复选框的状态" class="headerlink" title="设置复选框的状态"></a>设置复选框的状态</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置复选框为选中状态</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCheckbox&#x27;</span>).<span class="property">checked</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h4 id="操作选择框（下拉列表）"><a href="#操作选择框（下拉列表）" class="headerlink" title="操作选择框（下拉列表）"></a>操作选择框（下拉列表）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取选择框的选中项的值</span></span><br><span class="line"><span class="keyword">var</span> selectedValue = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mySelect&#x27;</span>).<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置选择框的选中项</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mySelect&#x27;</span>).<span class="property">value</span> = <span class="string">&#x27;option2&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="添加和删除表单元素"><a href="#添加和删除表单元素" class="headerlink" title="添加和删除表单元素"></a>添加和删除表单元素</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的输入元素</span></span><br><span class="line"><span class="keyword">var</span> newInput = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置新输入元素的类型和ID</span></span><br><span class="line">newInput.<span class="property">type</span> = <span class="string">&#x27;text&#x27;</span>;</span><br><span class="line">newInput.<span class="property">id</span> = <span class="string">&#x27;newInput&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将新输入元素添加到表单中</span></span><br><span class="line"><span class="keyword">var</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myForm&#x27;</span>);</span><br><span class="line">form.<span class="title function_">appendChild</span>(newInput);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从表单中移除一个元素</span></span><br><span class="line">form.<span class="title function_">removeChild</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;someElementId&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="设置和获取表单元素的CSS样式"><a href="#设置和获取表单元素的CSS样式" class="headerlink" title="设置和获取表单元素的CSS样式"></a>设置和获取表单元素的CSS样式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置元素的背景颜色</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myInput&#x27;</span>).<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;#f0f0f0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取元素的背景颜色（注意这将返回计算后的样式，可能与设置的不同）</span></span><br><span class="line"><span class="keyword">var</span> bgColor = <span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myInput&#x27;</span>)).<span class="property">backgroundColor</span>;</span><br></pre></td></tr></table></figure>

<h4 id="监听表单事件"><a href="#监听表单事件" class="headerlink" title="监听表单事件"></a>监听表单事件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当提交按钮被点击时，执行某些操作</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;submitButton&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;表单已提交&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><h3 id="localStorage-对象"><a href="#localStorage-对象" class="headerlink" title="localStorage 对象"></a>localStorage 对象</h3><p>localStorage 对象提供对特定网站的本地存储的访问。它允许您存储、读取、添加、修改和删除该域的数据项。存储的数据没有到期日期，并且在浏览器关闭时不会被删除。这些数据将在几天、几周和几年内均可用。<strong>本地存储只能存为字符串</strong>。</p>
<p>！温馨提示：本地存储在进行增删改等业务推荐使用同一个键，值推荐用数组存储多个，方便处理。</p>
<h4 id="setItem-key-value"><a href="#setItem-key-value" class="headerlink" title="setItem(key,value)"></a><strong>setItem(key,value)</strong></h4><ul>
<li>用途：用于将数据项存储在 storage 中。<ul>
<li>参数：它接受一个名称和一个值作为参数：</li>
</ul>
</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//利用localStorage存储数据 以K-V形式存储</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;小李&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="getItem-key"><a href="#getItem-key" class="headerlink" title="getItem(key)"></a>getItem(key)</h4><ul>
<li>用途：用于从localStorage中读取相应键对应的值<ul>
<li>参数：接收一个键值，字符串形式。</li>
</ul>
</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name);<span class="comment">//小李</span></span><br></pre></td></tr></table></figure>

<h4 id="removeItem-key"><a href="#removeItem-key" class="headerlink" title="removeItem(key)"></a>removeItem(key)</h4><ul>
<li>用途：删除对应键的值<ul>
<li>参数：接收一个key值</li>
</ul>
</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从localStorage中删除数据</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;name&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="sessionStorage-对象"><a href="#sessionStorage-对象" class="headerlink" title="sessionStorage 对象"></a>sessionStorage 对象</h3><p>sessionStorage 对象与 localStorage 对象相同。</p>
<p>不同之处在于 sessionStorage 对象存储会话的数据。</p>
<p><strong>当浏览器关闭时，数据会被删除。</strong></p>
<h4 id="setItem-key-value-1"><a href="#setItem-key-value-1" class="headerlink" title="setItem(key,value)"></a>setItem(key,value)</h4><ul>
<li>用途：sessionStorage.setItem() 方法将数据项存储在存储（storage）中。<ul>
<li>参数：它接受一个名称和一个值作为参数</li>
</ul>
</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Bill Gates&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="getItem-key-1"><a href="#getItem-key-1" class="headerlink" title="getItem(key)"></a>getItem(key)</h4><ul>
<li>用途：sessionStorage.getItem() 方法从存储（storage）中检索数据项。<ul>
<li>参数：它接受一个名称作为参数</li>
</ul>
</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;name&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="removeItem-key-1"><a href="#removeItem-key-1" class="headerlink" title="removeItem(key)"></a>removeItem(key)</h4><ul>
<li>用途：删除对应键的值<ul>
<li>参数：接收一个key值</li>
</ul>
</li>
</ul>
<h3 id="存储复杂类型的数据"><a href="#存储复杂类型的数据" class="headerlink" title="存储复杂类型的数据"></a>存储复杂类型的数据</h3><p>这里以<strong>对象</strong>类型举例</p>
<p>如果要<strong>存储</strong>一个对象类型的数据，步骤如下</p>
<ol>
<li>把对象类型转换成JSON字符串类型<ol>
<li>语法：JSON.stringify(对象)</li>
</ol>
</li>
<li>使用本地存储的存储方法存储数据</li>
</ol>
<p>如果要取出一个字符串类型的对象数据，步骤如下</p>
<ol>
<li>通过方法取出JSON字符串类型的对象数据</li>
<li>把取出来的JSON字符串类型数据转换成对象类型<ol>
<li>语法：JSON.parse()</li>
</ol>
</li>
</ol>
<h3 id="Storage-对象属性和方法"><a href="#Storage-对象属性和方法" class="headerlink" title="Storage 对象属性和方法"></a>Storage 对象属性和方法</h3><table>
<thead>
<tr>
<th align="left">属性&#x2F;方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/met_storage_key.asp">key(n)</a></td>
<td align="left">返回存储中第 n 个键的名称。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/prop_storage_length.asp">length</a></td>
<td align="left">返回存储在 Storage 对象中的数据项数。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/met_storage_getitem.asp">getItem(keyname)</a></td>
<td align="left">返回指定的键名的值。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/met_storage_setitem.asp">setItem(keyname, value)</a></td>
<td align="left">将键添加到存储中，或者如果键已经存在，则更新该键的值。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/met_storage_removeitem.asp">removeItem(keyname)</a></td>
<td align="left">从存储中删除该键。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/met_storage_clear.asp">clear()</a></td>
<td align="left">清空所有键。</td>
</tr>
</tbody></table>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>在JavaScript中，正则表达式（Regular Expression）是一种用于匹配字符串中字符组合的强大工具。它们可以用来执行复杂的文本处理任务，如搜索、替换和提取文本。</p>
<ul>
<li>使用场景：<ul>
<li>来进行表单验证，过滤敏感词等等。</li>
</ul>
</li>
</ul>
<h2 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h2><ol>
<li><p>字面量表示法：flags是修饰符，详见修饰符小结</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/pattern/</span>flags;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>构造函数方式</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;pattern&#x27;</span>, <span class="string">&#x27;flags&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="常用的正则表达式模式"><a href="#常用的正则表达式模式" class="headerlink" title="常用的正则表达式模式"></a>常用的正则表达式模式</h2><ul>
<li><p><strong>匹配特定字符</strong>:</p>
<ul>
<li><code>.</code> 匹配任何单个字符（除了换行符）。</li>
<li><code>\d</code> 匹配数字。</li>
<li><code>\w</code> 匹配字母或数字。</li>
<li><code>\s</code> 匹配空白字符。</li>
</ul>
</li>
<li><p><strong>重复</strong>:</p>
<ul>
<li><code>*</code> 匹配前面的子表达式零次或多次。</li>
<li><code>+</code> 匹配前面的子表达式一次或多次。</li>
<li><code>?</code> 匹配前面的子表达式零次或一次。</li>
<li><code>&#123;n&#125;</code> 匹配前面的子表达式恰好 n 次。</li>
<li><code>&#123;n,&#125;</code> 匹配前面的子表达式至少 n 次。</li>
<li><code>&#123;n,m&#125;</code> 匹配前面的子表达式至少 n 次但不超过 m 次。</li>
</ul>
</li>
<li><p><strong>选择</strong>:</p>
<ul>
<li><code>|</code> 或运算符用于匹配多个表达式中的任意一个。</li>
</ul>
</li>
<li><p><strong>边界</strong>:</p>
<ul>
<li><code>^</code> 表示行的开始。</li>
<li><code>$</code> 表示行的结束。</li>
<li><code>\b</code> 表示单词边界。</li>
</ul>
</li>
</ul>
<h2 id="使用正则表达式的常见方法"><a href="#使用正则表达式的常见方法" class="headerlink" title="使用正则表达式的常见方法"></a>使用正则表达式的常见方法</h2><ol>
<li><p><strong>test()</strong> 方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/abc/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regex.<span class="title function_">test</span>(<span class="string">&#x27;abcdef&#x27;</span>)); <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>exec()</strong> 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/(\d+)/</span>;</span><br><span class="line"><span class="keyword">let</span> result = regex.<span class="title function_">exec</span>(<span class="string">&#x27;The year is 2023.&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result[<span class="number">0</span>]); <span class="comment">// 输出 &quot;2023&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result[<span class="number">1</span>]); <span class="comment">// 输出 &quot;2023&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>在JavaScript的正则表达式中，元字符（Metacharacters）是一些具有特殊含义的字符，它们被用来定义复杂的搜索模式。下面列出了一些常用的元字符及其功能：</p>
<h3 id="常见元字符"><a href="#常见元字符" class="headerlink" title="常见元字符"></a>常见元字符</h3><h4 id="边界符"><a href="#边界符" class="headerlink" title="边界符"></a>边界符</h4><ol>
<li><strong><code>^</code> (caret)</strong>  <ul>
<li>在方括号 <code>[ ]</code> 内表示取反，即匹配不在方括号内的字符。</li>
<li>不在方括号内时，如果位于正则表达式的开头，则表示匹配字符串的开始。</li>
</ul>
</li>
<li><strong><code>$</code> (美元符号)</strong>  <ul>
<li>如果位于正则表达式的末尾，则表示匹配字符串的结尾。</li>
</ul>
</li>
</ol>
<h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><ol>
<li><strong><code>*</code> (星号)</strong>  <ul>
<li>表示匹配前面的字符零次或多次。</li>
</ul>
</li>
<li><strong><code>+</code> (加号)</strong>  <ul>
<li>表示匹配前面的字符一次或多次。</li>
</ul>
</li>
<li><strong><code>?</code> (问号)</strong>  <ul>
<li>表示匹配前面的字符零次或一次。</li>
</ul>
</li>
<li><strong><code>&#123;n&#125;</code> (花括号)</strong>  <ul>
<li>表示重复前面的字符 n 次。</li>
</ul>
</li>
<li><strong><code>&#123;n,&#125;</code> (花括号)</strong>  <ul>
<li>表示重复前面的字符至少 n 次。</li>
</ul>
</li>
<li><strong><code>&#123;n,m&#125;</code> (花括号)</strong>  <ul>
<li>表示重复前面的字符至少 n 次但不超过 m 次。</li>
</ul>
</li>
</ol>
<h4 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h4><ol>
<li><strong><code>[]</code> (方括号)</strong>  <ul>
<li>定义字符集，匹配方括号中的任何一个字符。</li>
</ul>
</li>
<li><strong><code>.</code> (点)</strong>  <ul>
<li>表示匹配任何单个字符（除了换行符）。</li>
</ul>
</li>
<li><strong><code>[^...]</code> (取反方括号)</strong>  <ul>
<li>定义非字符集，匹配不属于方括号中的任何字符。</li>
</ul>
</li>
<li><strong><code>()</code> (圆括号)</strong>  <ul>
<li>定义捕获组，用于对匹配进行分组并捕获匹配的部分。</li>
</ul>
</li>
<li><strong><code>|</code> (管道符号)</strong>  <ul>
<li>表示逻辑“或”，匹配两个或多个选项中的任意一个。</li>
</ul>
</li>
<li><strong><code>\b</code> (单词边界)</strong>  <ul>
<li>匹配单词边界，即单词字符和非单词字符之间的边界。</li>
</ul>
</li>
<li><strong><code>\B</code> (非单词边界)</strong>  <ul>
<li>匹配非单词边界，即两个单词字符或两个非单词字符之间的地方。</li>
</ul>
</li>
<li><strong><code>\d</code> (数字)</strong>  <ul>
<li>匹配任何十进制数字等同于 <code>[0-9]</code>。</li>
</ul>
</li>
<li><strong><code>\D</code> (非数字)</strong>  <ul>
<li>匹配任何非数字字符等同于 <code>[^0-9]</code>。</li>
</ul>
</li>
<li><strong><code>\w</code> (单词字符)</strong>  <ul>
<li>匹配任何单词字符等同于 <code>[a-zA-Z0-9_]</code>。</li>
</ul>
</li>
<li><strong><code>\W</code> (非单词字符)</strong>  <ul>
<li>匹配任何非单词字符等同于 <code>[^a-zA-Z0-9_]</code>。</li>
</ul>
</li>
<li><strong><code>\s</code> (空白字符)</strong>  <ul>
<li>匹配任何空白字符等同于 <code>[ \t\n\r\f\v]</code>。</li>
</ul>
</li>
<li><strong><code>\S</code> (非空白字符)</strong>  <ul>
<li>匹配任何非空白字符等同于 <code>[^ \t\n\r\f\v]</code>。</li>
</ul>
</li>
<li><strong><code>\A</code> (字符串开始)</strong>  <ul>
<li>表示匹配字符串的开始。</li>
</ul>
</li>
<li><strong><code>\Z</code> (字符串结束)</strong>  <ul>
<li>表示匹配字符串的结束。</li>
</ul>
</li>
<li><strong><code>\z</code> (字符串结束)</strong>  <ul>
<li>同样表示匹配字符串的结束。</li>
</ul>
</li>
<li><strong><code>\G</code> (上次匹配结束处)</strong>  <ul>
<li>表示从上次匹配的结束位置开始匹配。</li>
</ul>
</li>
<li><strong><code>\n</code>, <code>\r</code>, <code>\t</code>, <code>\f</code>, <code>\v</code> (转义字符)</strong>  <ul>
<li>分别代表新行、回车、制表符、换页符和垂直制表符。</li>
</ul>
</li>
</ol>
<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>语法：<code>/正则表达式/修饰符</code>，也就是在正则表达式后面的就是修饰符</p>
<ol>
<li><strong><code>g</code> (全局匹配)</strong><ul>
<li>这个标志告诉正则表达式引擎在整个字符串中查找所有匹配项，而不仅仅是找到第一个匹配后就停止。如果没有使用这个标志，正则表达式默认是从左向右只匹配第一个符合条件的结果。</li>
</ul>
</li>
<li><strong><code>i</code> (忽略大小写)</strong><ul>
<li>当使用此标志时，正则表达式在进行匹配时不区分大小写。例如，<code>/abc/i</code> 将会匹配 <code>&quot;ABC&quot;</code>, <code>&quot;AbC&quot;</code> 等。</li>
</ul>
</li>
<li><strong><code>m</code> (多行模式)</strong><ul>
<li>此标志使 <code>^</code> 和 <code>$</code> 能够分别匹配每行的开始和结束，而不仅仅是整个字符串的开始和结束。例如，在多行文本中，<code>/^abc/m</code> 将匹配每一行的开头为 “abc” 的部分。</li>
</ul>
</li>
<li><strong><code>s</code> (单行模式)</strong><ul>
<li>也被称为 “dotall” 模式。此标志使得 <code>.</code> 可以匹配任何字符，包括换行符。没有此标志时，<code>.</code> 不匹配换行符。</li>
</ul>
</li>
<li><strong><code>u</code> (Unicode 模式)</strong><ul>
<li>此标志使得正则表达式支持完整的 Unicode 字符范围。当使用 <code>\w</code>, <code>\d</code>, <code>\s</code> 等预定义类时，将考虑所有 Unicode 字符，而不仅仅是 ASCII 字符。</li>
</ul>
</li>
<li><strong><code>y</code> (粘贴模式)</strong><ul>
<li>该标志使得正则表达式只能从上次匹配的位置开始匹配。这通常与全局标志 <code>g</code> 一起使用，以便在连续的调用中保持匹配的位置。</li>
</ul>
</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>让我们通过一些例子来看看这些元字符是如何使用的：</p>
<h4 id="匹配任何数字"><a href="#匹配任何数字" class="headerlink" title="匹配任何数字"></a>匹配任何数字</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/\d/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regex.<span class="title function_">test</span>(<span class="string">&#x27;123&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="匹配以数字开头的字符串"><a href="#匹配以数字开头的字符串" class="headerlink" title="匹配以数字开头的字符串"></a>匹配以数字开头的字符串</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/^\d/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regex.<span class="title function_">test</span>(<span class="string">&#x27;123abc&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="匹配以数字结尾的字符串"><a href="#匹配以数字结尾的字符串" class="headerlink" title="匹配以数字结尾的字符串"></a>匹配以数字结尾的字符串</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/\d$/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regex.<span class="title function_">test</span>(<span class="string">&#x27;abc123&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="匹配连续三个或更多的字符"><a href="#匹配连续三个或更多的字符" class="headerlink" title="匹配连续三个或更多的字符"></a>匹配连续三个或更多的字符</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/a+/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regex.<span class="title function_">test</span>(<span class="string">&#x27;aaa&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="匹配连续一个到三次的字符"><a href="#匹配连续一个到三次的字符" class="headerlink" title="匹配连续一个到三次的字符"></a>匹配连续一个到三次的字符</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/a&#123;1,3&#125;/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regex.<span class="title function_">test</span>(<span class="string">&#x27;aaa&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regex.<span class="title function_">test</span>(<span class="string">&#x27;aa&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regex.<span class="title function_">test</span>(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regex.<span class="title function_">test</span>(<span class="string">&#x27;aaaa&#x27;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="匹配任何数字或字母"><a href="#匹配任何数字或字母" class="headerlink" title="匹配任何数字或字母"></a>匹配任何数字或字母</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/[a-zA-Z0-9]/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regex.<span class="title function_">test</span>(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regex.<span class="title function_">test</span>(<span class="string">&#x27;9&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="匹配任何非数字"><a href="#匹配任何非数字" class="headerlink" title="匹配任何非数字"></a>匹配任何非数字</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/\D/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regex.<span class="title function_">test</span>(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regex.<span class="title function_">test</span>(<span class="string">&#x27;9&#x27;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h1 id="JavaScript异步"><a href="#JavaScript异步" class="headerlink" title="JavaScript异步"></a>JavaScript异步</h1><h2 id="JS中的Promise-更详细请移步笔记Vue前置知识-md"><a href="#JS中的Promise-更详细请移步笔记Vue前置知识-md" class="headerlink" title="JS中的Promise(更详细请移步笔记Vue前置知识.md)"></a>JS中的Promise(更详细请移步笔记Vue前置知识.md)</h2><ul>
<li><strong>概念</strong>：Promise 是一种处理异步操作的更优雅的方法。Promise 对象代表了一个最终会在未来完成（或失败）的值的初次计算结果。</li>
</ul>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.promise的基本语法</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve,reject</span>)&#123;</span><br><span class="line">    <span class="comment">//2.这里是用来执行异步任务的代码块</span></span><br><span class="line">    <span class="comment">// 异步任务执行成功调用resolve() 此时可以通过 .then 方法访问结果。</span></span><br><span class="line">    <span class="comment">//异步任务执行失败调用reject() 此时可以通过 .catch 方法处理错误。</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//3.接收结果</span></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//成功后获得数据</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//处理失败</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="promise的三种状态"><a href="#promise的三种状态" class="headerlink" title="promise的三种状态"></a>promise的三种状态</h3><p>Promise 有三种状态：</p>
<ul>
<li><strong>pending</strong>：初始状态，既未成功也未失败。对应 <code>new Promise()</code></li>
<li><strong>fulfilled</strong>：成功完成，此时可以通过 <code>.then</code> 方法访问结果。  ——调用了resolve()函数</li>
<li><strong>rejected</strong>：操作失败，此时可以通过 <code>.catch</code> 方法处理错误。——调用了reject()函数</li>
</ul>
<h3 id="promise对象的使用"><a href="#promise对象的使用" class="headerlink" title="promise对象的使用"></a>promise对象的使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myPromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">myResolve, myReject</span>) &#123;</span><br><span class="line"><span class="comment">// 执行某些异步任务</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">myResolve</span>(); <span class="comment">// 成功时</span></span><br><span class="line">  <span class="title function_">myReject</span>();  <span class="comment">// 出错时</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面就是对promise对象的使用</span></span><br><span class="line">myPromise.<span class="title function_">then</span>(</span><br><span class="line">  <span class="keyword">function</span>(<span class="params">value</span>) &#123; <span class="comment">/* 成功时的代码 */</span> &#125;</span><br><span class="line">).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123; <span class="comment">/* 出错时的代码 */</span> &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h3><p><strong>多个回调函数形成嵌套，形成回调地狱。</strong></p>
<p>缺点：</p>
<ul>
<li>可读性差</li>
<li>异常捕获困难</li>
<li>耦合性差、</li>
</ul>
<h3 id="promise链式调用"><a href="#promise链式调用" class="headerlink" title="promise链式调用"></a>promise链式调用</h3><ul>
<li><p>原理：promise对象.then()方法，利用then方法返回新的promise对象。和上一个对象不相同</p>
</li>
<li><p>概念：依靠then()方法返回一个新的promise对象特性，继续串联下一环任务，直到结束。</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240827155942150.png" alt="image-20240827155942150"></p>
<p><strong>简单示例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;北京市&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line"><span class="comment">//查看p.then()返回对象</span></span><br><span class="line"><span class="comment">//函数返回了一个新的promise对象，</span></span><br><span class="line"><span class="keyword">const</span> p2 = p.<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//then方法返回一个新的promise对象。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(result + <span class="string">&#x27;-----北京市&#x27;</span>)</span><br><span class="line">        &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">p2.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">//北京市-----北京市</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>结合Axios来使用链式调用</strong>(重点)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于每发起一次请求，就会有一个新的promise对象所以可以下向下面这样写</span></span><br><span class="line"><span class="title function_">axios</span>(&#123; <span class="attr">url</span>: <span class="string">&#x27;http://hmajax.itheima.net/api/province&#x27;</span> &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> pname = result.<span class="property">data</span>.<span class="property">list</span>[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">//在then函数中，继续向外层return一个新的promise对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">axios</span>(&#123; <span class="attr">url</span>: <span class="string">&#x27;http://hmajax.itheima.net/api/city&#x27;</span>, <span class="attr">params</span>: &#123; <span class="attr">pname</span>: pname &#125; &#125;)</span><br><span class="line">    <span class="comment">//.then的位置要写在then函数外，因为利用的是该函数的返回值。</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> pname = result.<span class="property">config</span>.<span class="property">params</span>.<span class="property">pname</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(pname);<span class="comment">//北京</span></span><br><span class="line">    <span class="keyword">const</span> cname = result.<span class="property">data</span>.<span class="property">list</span>[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">axios</span>(&#123; <span class="attr">url</span>: <span class="string">&#x27;http://hmajax.itheima.net/api/area&#x27;</span>, <span class="attr">params</span>: &#123; <span class="attr">pname</span>: pname, <span class="attr">cname</span>: cname &#125; &#125;)</span><br><span class="line">    <span class="comment">//.then的位置要写在then函数外，因为利用的是该函数的返回值。</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">//返回北京市下的城市名称</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-Async-异步"><a href="#JavaScript-Async-异步" class="headerlink" title="JavaScript Async(异步)"></a>JavaScript Async(异步)</h2><p>“async and await make promises easier to write”</p>
<p><em>async</em> 使函数返回 Promise</p>
<p><em>await</em> 使函数等待 Promise</p>
<h3 id="Async-语法"><a href="#Async-语法" class="headerlink" title="Async 语法"></a>Async 语法</h3><p>函数前的关键字 <code>async</code> 使函数返回 promise：</p>
<p><strong>实例1</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等同于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是使用 Promise 的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">myFunction</span>().<span class="title function_">then</span>(</span><br><span class="line">  <span class="keyword">function</span>(<span class="params">value</span>) &#123; <span class="comment">/* 成功时的代码 */</span> &#125;,</span><br><span class="line">).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123; <span class="comment">/* 出错时的代码 */</span> &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>实例2</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>JavaScript async / await<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">myDisplayer</span>(<span class="params">some</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span> = some;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="comment">//async 使函数返回promise</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;<span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="comment">//在这里调用promise返回时的动作</span></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">myFunction</span>().<span class="title function_">then</span>(</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span>(<span class="params">value</span>) &#123;<span class="title function_">myDisplayer</span>(value);&#125;, <span class="comment">//成功的回调</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span>(<span class="params">error</span>) &#123;<span class="title function_">myDisplayer</span>(error);&#125; <span class="comment">//失败的回调</span></span></span><br><span class="line"><span class="language-javascript">);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Await-语法"><a href="#Await-语法" class="headerlink" title="Await 语法"></a>Await 语法</h3><p>函数前的关键字 <code>await</code> 使函数获得Promise对象”成功状态”的结果值。</p>
<ul>
<li>await只能获取请求成功时，得到的结果。</li>
<li>await只能使用在被Async修饰的函数内部。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="keyword">await</span> promise;</span><br></pre></td></tr></table></figure>

<p><code>await</code> 关键字只能在 <code>async</code> 函数中使用。</p>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p><strong>实例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//await只能获取请求成功时，得到的结果。</span></span><br><span class="line"><span class="comment">//await只能使用在被Async修饰的函数内部。</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">//await等待请求成功时，将数据赋值给变量。</span></span><br><span class="line"><span class="keyword">const</span> provinceName = <span class="keyword">await</span> <span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&#x27;http://hmajax.itheima.net/api/province&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(provinceName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getData</span>()</span><br></pre></td></tr></table></figure>

<h3 id="async和await捕获错误"><a href="#async和await捕获错误" class="headerlink" title="async和await捕获错误"></a>async和await捕获错误</h3><ul>
<li>使用try{} catch(error){}来捕获错误。</li>
<li>try包裹可能出现错误的代码块</li>
<li>如果在某一环节捕获到了错误，那么剩余的代码不会执行</li>
<li>catch来处理错误</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//捕获错误 ——利用try ....catch</span></span><br><span class="line">        <span class="comment">//try包裹可能出现错误的代码</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//await等待请求成功时，将数据赋值给变量。</span></span><br><span class="line">            <span class="keyword">const</span> provinceName = <span class="keyword">await</span> <span class="title function_">axios</span>(&#123;</span><br><span class="line">                <span class="attr">url</span>: <span class="string">&#x27;http://hmajax.itheima.net/api/provinc&#x27;</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(provinceName);</span><br><span class="line">            <span class="comment">//利用catch来接收错误信息</span></span><br><span class="line">            <span class="comment">//如果在某一环节捕获到了错误，那么剩余的代码不会执行</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1111&#x27;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="title function_">getData</span>()</span><br></pre></td></tr></table></figure>



<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><ul>
<li>概念:Asynchronous JavaScript And XML，异步的JavaScript和XML。</li>
<li>作用:<ul>
<li>AJAX 是开发者的梦想，因为您能够：<ul>
<li>不刷新页面更新网页</li>
<li>在页面加载后从服务器请求数据</li>
<li>在页面加载后从服务器接收数据</li>
<li>在后台向服务器发送数据</li>
</ul>
</li>
<li>数据交换:通过Ajax可以给服务器发送请求，并获取服务器响应的数据。</li>
<li>异步交互:可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如:搜索联想、用户名是否可用的校验等等。</li>
</ul>
</li>
</ul>
<h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>Axios 是一个基于 promise 的 HTTP 库，可以用于浏览器和 node.js 中。它被广泛用于与 RESTful APIs 进行交互，特别是在前端开发中，用来发送 AJAX 请求。</p>
<h3 id="基础语法-1"><a href="#基础语法-1" class="headerlink" title="基础语法"></a>基础语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="comment">//请求方式</span></span><br><span class="line">    <span class="attr">method</span>:</span><br><span class="line">    <span class="comment">//请求地址</span></span><br><span class="line">    <span class="attr">url</span>:</span><br><span class="line">    <span class="comment">//请求参数</span></span><br><span class="line">    <span class="attr">data</span>:&#123;<span class="comment">/*向服务器发送数据用data选项，一般是post请求*/</span>&#125;</span><br><span class="line">    <span class="attr">params</span>:&#123;</span><br><span class="line">      <span class="comment">/*携带查询参数用params*/</span></span><br><span class="line">      参数名：参数值</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//回调函数</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">loh</span>(res.<span class="property">data</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="请求配置"><a href="#请求配置" class="headerlink" title="请求配置"></a>请求配置</h3><h4 id="常用配置项"><a href="#常用配置项" class="headerlink" title="常用配置项"></a>常用配置项</h4><ol>
<li><strong>url</strong>: (必需) 发送请求的 URL 地址。</li>
<li><strong>method</strong>: (必需) 请求方法，如 <code>&#39;get&#39;</code>, <code>&#39;post&#39;</code>, <code>&#39;put&#39;</code>, <code>&#39;delete&#39;</code>, <code>&#39;patch&#39;</code>, <code>&#39;head&#39;</code>, <code>&#39;options&#39;</code>。</li>
<li><strong>data</strong>: (可选) <strong>发送到服务器的数据</strong>。对于 <code>POST</code>, <code>PUT</code>, <code>PATCH</code> 等方法来说，这个数据会被序列化并发送到服务器。</li>
<li><strong>params</strong>: (可选) <strong>发送到服务器的查询字符串参数。</strong></li>
<li><strong>headers</strong>: (可选) 自定义请求头。</li>
<li><strong>timeout</strong>: (可选) 请求超时时间，单位为毫秒。如果请求超过了指定的时间，将抛出一个 <code>Timeout</code> 错误。</li>
<li><strong>withCredentials</strong>: (可选) 是否携带 cookie，这对于跨域请求非常重要，默认为 <code>false</code>。</li>
<li><strong>responseType</strong>: (可选) 指定响应的数据类型，如 <code>&#39;arraybuffer&#39;</code>, <code>&#39;blob&#39;</code>, <code>&#39;json&#39;</code>, <code>&#39;text&#39;</code>, <code>&#39;stream&#39;</code>。</li>
<li><strong>validateStatus</strong>: (可选) 验证服务器响应的状态码是否成功。默认情况下，只有状态码在 <code>2xx</code> 范围内的才会被认为是成功的。</li>
<li><strong>maxRedirects</strong>: (可选) 最大重定向次数，默认为 <code>5</code>。</li>
<li><strong>cancelToken</strong>: (可选) 取消请求的 token，用于取消正在进行的请求。</li>
<li><strong>auth</strong>: (可选) 包含用户名和密码的对象，用于 HTTP 基本身份验证。</li>
</ol>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p><strong>错误处理的基本方式</strong></p>
<ol>
<li><p><strong>使用 <code>.catch()</code> 处理错误</strong>： 当请求失败时，<code>.catch()</code> 函数会捕获错误，并允许你执行相应的错误处理逻辑。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Error:&quot;</span>, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p>下面是一些基本请求方法：</p>
<ol>
<li><strong>GET</strong> - 用于获取资源。</li>
<li><strong>POST</strong> - 用于创建资源。</li>
<li><strong>PUT</strong> - 用于更新资源。</li>
<li><strong>DELETE</strong> - 用于删除资源。</li>
<li><strong>PATCH</strong> - 用于局部更新资源。</li>
<li><strong>HEAD</strong> - 用于获取资源的元信息。</li>
<li><strong>OPTIONS</strong> - 用于获取服务器支持的通信选项。</li>
</ol>
<h3 id="HTTP响应状态码"><a href="#HTTP响应状态码" class="headerlink" title="HTTP响应状态码"></a>HTTP响应状态码</h3><p>下面是一些常用的状态码</p>
<h4 id="成功状态码"><a href="#成功状态码" class="headerlink" title="成功状态码"></a>成功状态码</h4><ul>
<li><strong>200 OK</strong>：请求已成功，这是最常见的成功状态码。</li>
<li><strong>201 Created</strong>：请求被成功创建，通常用于 POST 请求。</li>
<li><strong>204 No Content</strong>：服务器成功处理了请求，但不需要返回任何内容。</li>
</ul>
<h4 id="重定向状态码"><a href="#重定向状态码" class="headerlink" title="重定向状态码"></a>重定向状态码</h4><ul>
<li><strong>301 Moved Permanently</strong>：请求的资源已被永久移动到新位置。</li>
<li><strong>302 Found</strong>（临时重定向）：请求的资源现在临时位于不同的 URI。</li>
<li><strong>304 Not Modified</strong>：请求的资源未被修改，因此返回 304 并不包含资源的实体部分。</li>
</ul>
<h4 id="客户端错误状态码"><a href="#客户端错误状态码" class="headerlink" title="客户端错误状态码"></a>客户端错误状态码</h4><ul>
<li><strong>400 Bad Request</strong>：服务器无法理解请求的格式。</li>
<li><strong>401 Unauthorized</strong>：请求需要用户身份验证。</li>
<li><strong>403 Forbidden</strong>：服务器理解请求客户端的请求，但是拒绝执行此请求。</li>
<li><strong>404 Not Found</strong>：请求的资源不存在。</li>
<li><strong>405 Method Not Allowed</strong>：请求的方法不允许对请求的资源使用。</li>
</ul>
<h4 id="服务器错误状态码"><a href="#服务器错误状态码" class="headerlink" title="服务器错误状态码"></a>服务器错误状态码</h4><ul>
<li><strong>500 Internal Server Error</strong>：服务器遇到一个未曾预料的状况，导致它无法完成对请求的处理。</li>
<li><strong>502 Bad Gateway</strong>：作为网关或代理工作的服务器收到了来自上游服务器的有效响应，但是无效的最终响应。</li>
<li><strong>503 Service Unavailable</strong>：服务器目前无法使用，可能是由于服务器过载或维护。</li>
</ul>
<h2 id="什么是-Ajax"><a href="#什么是-Ajax" class="headerlink" title="什么是 Ajax"></a>什么是 Ajax</h2><p>AJAX &#x3D; <em>A</em>synchronous <em>J</em>avaScript <em>A</em>nd <em>X</em>ML.</p>
<p>AJAX 并非编程语言。</p>
<p>AJAX 仅仅组合了：</p>
<ul>
<li>浏览器内建的 XMLHttpRequest 对象（从 web 服务器请求数据）</li>
<li>JavaScript 和 HTML DOM（显示或使用数据）</li>
</ul>
<p>Ajax 是一个令人误导的名称。Ajax 应用程序可能使用 XML 来传输数据，但将数据作为纯文本或 JSON 文本传输也同样常见。</p>
<p>Ajax 允许通过与场景后面的 Web 服务器交换数据来异步更新网页。这意味着可以更新网页的部分，而不需要重新加载整个页面。</p>
<h2 id="Ajax如何工作"><a href="#Ajax如何工作" class="headerlink" title="Ajax如何工作"></a>Ajax如何工作</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/ajax.gif" alt="AJAX"></p>
<ol>
<li>网页中发生一个事件（页面加载、按钮点击）</li>
<li>由 JavaScript 创建 XMLHttpRequest 对象</li>
<li>XMLHttpRequest 对象向 web 服务器发送请求</li>
<li>服务器处理该请求</li>
<li>服务器将响应发送回网页</li>
<li>由 JavaScript 读取响应</li>
<li>由 JavaScript 执行正确的动作（比如更新页面）</li>
</ol>
<h2 id="Ajax基础语法"><a href="#Ajax基础语法" class="headerlink" title="Ajax基础语法"></a>Ajax基础语法</h2><ol>
<li><strong>创建 XMLHttpRequest 对象</strong> - 用于在后台与服务器交换数据。</li>
<li><strong>定义回调函数</strong> - 当从服务器请求数据返回后执行的函数。</li>
<li><strong>发送请求到服务器</strong> - 通常使用 <code>GET</code> 或 <code>POST</code> 方法。</li>
<li><strong>处理服务器响应</strong> - 在回调函数中处理数据。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 XMLHttpRequest 对象</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求完成后的回调函数 --------------写法1</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>) &#123; <span class="comment">// 请求完成并且成功</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>); <span class="comment">// 输出服务器响应的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//当然了，上面的回调函数也可以写成下面这样  --------------写法2</span></span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;loadend&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//对响应回来的结果进行处理</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 初始化请求</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;https://api.example.com/data&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送请求</span></span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure>

<h2 id="Ajax传递参数"><a href="#Ajax传递参数" class="headerlink" title="Ajax传递参数"></a>Ajax传递参数</h2><h3 id="携带查询参数"><a href="#携带查询参数" class="headerlink" title="携带查询参数"></a>携带查询参数</h3><p><strong>查询参数直接拼接在URL后面</strong>，利用**?<strong>，来把查询参数以</strong>‘k &#x3D; v’**的形式写在后面</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"><span class="comment">//参数直接拼接在url后面，利用?，来把查询参数以&#x27;k = v&#x27;的形式写在后面</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>,<span class="string">&#x27;http://hmajax.itheima.net/api/city?pname=辽宁省&#x27;</span>)</span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(xhr.<span class="property">responseText</span>));</span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="title function_">send</span>()</span><br></pre></td></tr></table></figure>

<h3 id="携带要提交的数据"><a href="#携带要提交的数据" class="headerlink" title="携带要提交的数据"></a>携带要提交的数据</h3><ul>
<li><p>设置请求头(Content-Type)为<code>application/json</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置请求头为application/json</span></span><br><span class="line">        xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>,<span class="string">&#x27;application/json&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>准备数据，并转为JSON格式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userObj = &#123;<span class="attr">username</span>:<span class="string">&#x27;lizewei111&#x27;</span>,<span class="attr">password</span>:<span class="string">&#x27;123456789&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> userStr = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(userObj)</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送请求 - 并把要发送的数据携带上</span></span><br><span class="line">xhr.<span class="title function_">send</span>(userStr)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>完整逻辑如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr  = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;post&#x27;</span>,<span class="string">&#x27;http://hmajax.itheima.net/api/register&#x27;</span>)</span><br><span class="line"><span class="comment">//设置请求头为application/json</span></span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>,<span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line"><span class="comment">//把准备的数据转为JSON字符串</span></span><br><span class="line"><span class="keyword">const</span> userObj = &#123;<span class="attr">username</span>:<span class="string">&#x27;lizewei111&#x27;</span>,<span class="attr">password</span>:<span class="string">&#x27;123456789&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> userStr = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(userObj)</span><br><span class="line"><span class="comment">//设置回调函数</span></span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;loadend&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//回调后执行的逻辑</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(xhr.<span class="property">responseText</span>));</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//发送请求 - 并把要发送的数据携带上</span></span><br><span class="line">xhr.<span class="title function_">send</span>(userStr)</span><br></pre></td></tr></table></figure>

<h2 id="xhr对象"><a href="#xhr对象" class="headerlink" title="xhr对象"></a>xhr对象</h2><h3 id="获得xhr对象"><a href="#获得xhr对象" class="headerlink" title="获得xhr对象"></a>获得xhr对象</h3><ol>
<li><p>xhr对象通过构造函数创建</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="xhr对象方法"><a href="#xhr对象方法" class="headerlink" title="xhr对象方法"></a>xhr对象方法</h2><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">new XMLHttpRequest()</td>
<td align="left">创建新的 XMLHttpRequest 对象。</td>
</tr>
<tr>
<td align="left">abort()</td>
<td align="left">取消当前请求。</td>
</tr>
<tr>
<td align="left">getAllResponseHeaders()</td>
<td align="left">返回头部信息。</td>
</tr>
<tr>
<td align="left">getResponseHeader()</td>
<td align="left">返回特定的头部信息。</td>
</tr>
<tr>
<td align="left">open(<em>method</em>, <em>url</em>, <em>async</em>, <em>user</em>, <em>psw</em>)</td>
<td align="left">规定请求。<em>method</em>：请求类型 GET 或 POST<em>url</em>：文件位置<em>async</em>：true（异步）或 false（同步）<em>user</em>：可选的用户名<em>psw</em>：可选的密码</td>
</tr>
<tr>
<td align="left">send()</td>
<td align="left">向服务器发送请求，用于 GET 请求。</td>
</tr>
<tr>
<td align="left">send(string)</td>
<td align="left">向服务器发送请求，用于 POST 请求。</td>
</tr>
<tr>
<td align="left">setRequestHeader()</td>
<td align="left">将标签&#x2F;值对添加到要发送的标头。</td>
</tr>
</tbody></table>
<h2 id="xhr对象属性"><a href="#xhr对象属性" class="headerlink" title="xhr对象属性"></a>xhr对象属性</h2><table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">onload</td>
<td align="left">定义接收到（加载）请求时要调用的函数。</td>
</tr>
<tr>
<td align="left">onreadystatechange</td>
<td align="left">定义当 readyState 属性发生变化时调用的函数。</td>
</tr>
<tr>
<td align="left">readyState</td>
<td align="left">保存 XMLHttpRequest 的状态。0：请求未初始化1：服务器连接已建立2：请求已收到3：正在处理请求4：请求已完成且响应已就绪</td>
</tr>
<tr>
<td align="left">responseText</td>
<td align="left">以字符串形式返回响应数据。</td>
</tr>
<tr>
<td align="left">responseXML</td>
<td align="left">以 XML 数据返回响应数据。</td>
</tr>
<tr>
<td align="left">status</td>
<td align="left">返回请求的状态号200: “OK”403: “Forbidden”404: “Not Found”如需完整列表请访问 <a target="_blank" rel="noopener" href="https://www.w3school.com.cn/tags/html_ref_httpmessages.asp">Http 消息参考手册</a></td>
</tr>
<tr>
<td align="left">statusText</td>
<td align="left">返回状态文本（比如 “OK” 或 “Not Found”</td>
</tr>
</tbody></table>
<h2 id="同步请求-异步请求"><a href="#同步请求-异步请求" class="headerlink" title="同步请求&#x2F;异步请求"></a>同步请求&#x2F;异步请求</h2><ul>
<li>同步代码：逐行执行，需原地等待结果，才继续向下执行。</li>
<li>异步代码：调用会耗用事件，不阻塞代码继续执行，完成后会执行一个回调函数。(耗时任务)</li>
</ul>
<p>如需执行同步的请求，请把 <code>open()</code> 方法中的第三个参数设置为 <code>false</code>，默认执行异步请求，也就是true</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;ajax_info.txt&quot;</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>有时 async &#x3D; false 用于快速测试。你也会在更老的 JavaScript 代码中看到同步请求。</p>
<p>由于代码将等待服务器完成，所以不需要 onreadystatechange 函数：</p>
<p><strong>实例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xhttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;ajax_info.txt&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">xhttp.<span class="title function_">send</span>();</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span> = xhttp.<span class="property">responseText</span>;</span><br></pre></td></tr></table></figure>

<p>我们不推荐同步的 XMLHttpRequest (async &#x3D; false)，因为 JavaScript 将停止执行直到服务器响应就绪。如果服务器繁忙或缓慢，应用程序将挂起或停止。</p>
<p>同步 XMLHttpRequest 正在从 Web 标准中移除，但是这个过程可能需要很多年。</p>
<p>现代开发工具被鼓励对使用同步请求做出警告，并且当这种情况发生时，可能会抛出 InvalidAccessError 异常。</p>
<p>同步和异步：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240504154717543.png" alt="image-20240504154717543"></p>
<h2 id="服务器响应请求"><a href="#服务器响应请求" class="headerlink" title="服务器响应请求"></a>服务器响应请求</h2><h3 id="服务器响应属性"><a href="#服务器响应属性" class="headerlink" title="服务器响应属性"></a>服务器响应属性</h3><table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">responseText</td>
<td align="left">获取字符串形式的响应数据</td>
</tr>
<tr>
<td align="left">responseXML</td>
<td align="left">获取 XML 数据形式的响应数据</td>
</tr>
</tbody></table>
<h4 id="responseText-属性"><a href="#responseText-属性" class="headerlink" title="responseText 属性"></a>responseText 属性</h4><p><code>responseText</code> 属性以 JavaScript 字符串的形式返回服务器响应，因此您可以这样使用它：</p>
<p><strong>实例</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span> = xhttp.<span class="property">responseText</span>;</span><br></pre></td></tr></table></figure>

<h4 id="responseXML-属性"><a href="#responseXML-属性" class="headerlink" title="responseXML 属性"></a>responseXML 属性</h4><p>XML HttpRequest 对象有一个內建的 XML 解析器。</p>
<p><code>ResponseXML</code> 属性以 XML DOM 对象返回服务器响应。</p>
<h3 id="服务器响应方法"><a href="#服务器响应方法" class="headerlink" title="服务器响应方法"></a>服务器响应方法</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">getResponseHeader()</td>
<td align="left">从服务器返回特定的头部信息</td>
</tr>
<tr>
<td align="left">getAllResponseHeaders()</td>
<td align="left">从服务器返回所有头部信息</td>
</tr>
</tbody></table>
<h4 id="getAllResponseHeaders-方法"><a href="#getAllResponseHeaders-方法" class="headerlink" title="getAllResponseHeaders() 方法"></a>getAllResponseHeaders() 方法</h4><p><code>getAllResponseHeaders()</code> 方法返回所有来自服务器响应的头部信息。</p>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhttp = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhttp.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span> = <span class="variable language_">this</span>.<span class="title function_">getAllResponseHeaders</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="getResponseHeader-方法"><a href="#getResponseHeader-方法" class="headerlink" title="getResponseHeader() 方法"></a>getResponseHeader() 方法</h4><p><code>getResponseHeader()</code> 方法返回来自服务器响应的特定头部信息。</p>
<h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhttp = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhttp.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span> = <span class="variable language_">this</span>.<span class="title function_">getResponseHeader</span>(<span class="string">&quot;Last-Modified&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;ajax_info.txt&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">xhttp.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure>

<h1 id="JavaScript进阶"><a href="#JavaScript进阶" class="headerlink" title="JavaScript进阶"></a>JavaScript进阶</h1><h2 id="JS中的堆和栈"><a href="#JS中的堆和栈" class="headerlink" title="JS中的堆和栈"></a>JS中的堆和栈</h2><h3 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h3><p>栈是一种先进后出（Last In First Out, LIFO）的数据结构。在JavaScript中，<strong>栈主要用来存储基本类型的值（也称为原始类型，如数字、字符串、布尔值、null、undefined）和对象的引用。</strong></p>
<ul>
<li><strong>特点</strong>:<ul>
<li>栈中的数据存取非常快，因为它是按照LIFO原则操作的。</li>
<li>栈空间的大小通常是固定的，超出范围会导致栈溢出错误。</li>
<li>栈中的数据一旦不再需要就会被自动释放。</li>
</ul>
</li>
</ul>
<h3 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h3><p>堆是一种无序的、动态的数据结构，在JavaScript中用于存储对象和数组的实际内容。</p>
<ul>
<li><strong>特点</strong>:<ul>
<li>堆中的数据可以动态分配和释放，这意味着可以在运行时增加或减少内存。</li>
<li>堆中的数据访问速度比栈慢，因为它涉及到指针查找和间接访问。</li>
<li>堆中的数据不会自动释放，而是通过垃圾回收机制来清理不再使用的数据。</li>
</ul>
</li>
</ul>
<h3 id="关键区别"><a href="#关键区别" class="headerlink" title="关键区别"></a>关键区别</h3><ul>
<li><strong>存储位置</strong>:<ul>
<li>栈存储基本类型的值和对象的引用。</li>
<li>堆存储对象本身及其属性。</li>
</ul>
</li>
<li><strong>内存管理</strong>:<ul>
<li>栈中的数据通常在创建时就已经确定了大小，并且当作用域结束时自动释放。</li>
<li>堆中的数据会在运行时动态分配，并由垃圾回收器管理，当对象不再被引用时会被回收。</li>
</ul>
</li>
</ul>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ul>
<li>规定了变量能够被访问的范围，离开这个范围，变量无法被访问<ul>
<li>作用域分为：局部作用域和全局作用域</li>
</ul>
</li>
</ul>
<h3 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h3><p>在JavaScript中，局部作用域指的是变量在一个特定的代码块（如函数内部）内可见和可访问的范围。当变量在一个函数内部被声明时，它只能在该函数内部被访问，这就是局部作用域的概念。</p>
<h4 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h4><ul>
<li>使用 <code>var</code> 关键字声明的变量在整个函数体内都是可见的。</li>
<li>这种作用域适用于整个函数，而不是某个具体的代码块。</li>
</ul>
<h4 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h4><p>块：被{}包裹的就是块</p>
<ul>
<li>使用 <code>let</code> 和 <code>const</code> 关键字声明的变量只在声明它们的代码块内可见。</li>
<li>这种作用域适用于像循环或条件语句这样的代码块。</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">exampleFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> varExample = <span class="string">&quot;I am visible in the entire function scope&quot;</span>; <span class="comment">// 函数作用域</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> letExample = <span class="string">&quot;I am visible only in this block scope&quot;</span>; <span class="comment">// 块作用域</span></span><br><span class="line">        <span class="keyword">const</span> constExample = <span class="string">&quot;I am also visible only in this block scope&quot;</span>; <span class="comment">// 块作用域</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(varExample); <span class="comment">// 输出: &quot;I am visible in the entire function scope&quot;</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(letExample); <span class="comment">// 输出: &quot;I am visible only in this block scope&quot;</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(constExample); <span class="comment">// 输出: &quot;I am also visible only in this block scope&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(varExample); <span class="comment">// 输出: &quot;I am visible in the entire function scope&quot;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(letExample); <span class="comment">// ReferenceError: letExample is not defined</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(constExample); <span class="comment">// ReferenceError: constExample is not defined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">exampleFunction</span>();</span><br></pre></td></tr></table></figure>

<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>script标签和js文件是全局作用域，全局作用域内声明的变量可以被局部作用域访问</p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>作用域链本质上是底层的<strong>变量查找机制</strong></p>
<ul>
<li>在函数执行时，会<strong>优先查找当前</strong>函数作用域中查找变量</li>
<li>如果当前作用域查找不到则会一次<strong>逐级查找父级作用域</strong>，直到全局作用域</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240820150519335.png" alt="image-20240820150519335"></p>
<h2 id="JS垃圾回收机制"><a href="#JS垃圾回收机制" class="headerlink" title="JS垃圾回收机制"></a>JS垃圾回收机制</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240820153438781.png" alt="image-20240820153438781"></p>
<p>JavaScript 的垃圾回收机制（Garbage Collection, GC）是一种自动管理内存的过程，它负责释放不再使用的内存空间。这使得开发者无需手动管理内存分配和释放，从而降低了内存泄漏的风险。以下是 JavaScript 垃圾回收机制的一些关键方面：</p>
<h3 id="标记与清除（Mark-and-Sweep）"><a href="#标记与清除（Mark-and-Sweep）" class="headerlink" title="标记与清除（Mark and Sweep）"></a>标记与清除（Mark and Sweep）</h3><p>这是最基本的垃圾收集算法之一。它分为两个阶段：</p>
<ul>
<li><strong>标记（Mark）</strong>：垃圾收集器标记所有从<strong>根节点</strong>开始能够寻找到的对象。</li>
<li><strong>清除（Sweep）</strong>：清理未被标记的对象，这些对象被认为是垃圾，可以被释放。</li>
</ul>
<h3 id="引用计数（Reference-Counting）"><a href="#引用计数（Reference-Counting）" class="headerlink" title="引用计数（Reference Counting）"></a>引用计数（Reference Counting）</h3><p>早期的 JavaScript 引擎还使用了引用计数的方法来跟踪对象的引用数量。当一个对象的引用计数变为 0 时，该对象就可以被回收。这种方法简单快速，但是容易导致循环引用的问题，即两个或多个对象相互引用而无法被垃圾收集器识别为垃圾。</p>
<h3 id="分代收集（Generational-Collection）"><a href="#分代收集（Generational-Collection）" class="headerlink" title="分代收集（Generational Collection）"></a>分代收集（Generational Collection）</h3><p>现代 JavaScript 引擎使用了一种称为分代收集的技术。这种技术基于观察到的事实：新创建的对象往往很快就会被丢弃，而存活时间较长的对象则很可能继续存活下去。因此，JavaScript 对象被划分为几代，不同代的对象使用不同的策略进行垃圾回收。</p>
<ul>
<li><strong>年轻代（Young Generation）</strong>：新创建的对象通常放在这一代中。年轻代的垃圾回收频率较高，但每次回收的时间较短。</li>
<li><strong>老年代（Old Generation）</strong>：经过多次年轻代垃圾回收后仍然存活的对象会被移动到老年代。老年代的垃圾回收频率较低，但每次回收可能需要更长的时间。</li>
</ul>
<h3 id="增量收集（Incremental-Collection）"><a href="#增量收集（Incremental-Collection）" class="headerlink" title="增量收集（Incremental Collection）"></a>增量收集（Incremental Collection）</h3><p>增量收集将垃圾回收过程分成多个小步骤，这样可以在应用程序执行之间进行，从而减少长时间的暂停。</p>
<h3 id="压缩（Compaction）"><a href="#压缩（Compaction）" class="headerlink" title="压缩（Compaction）"></a>压缩（Compaction）</h3><p>随着垃圾回收的进行，内存中的空闲空间可能会变得碎片化。压缩是一种技术，它将存活的对象移动到连续的内存区域，从而消除内存碎片。</p>
<h3 id="如何避免内存泄漏"><a href="#如何避免内存泄漏" class="headerlink" title="如何避免内存泄漏"></a>如何避免内存泄漏</h3><p>尽管 JavaScript 自动管理内存，但在某些情况下仍可能出现内存泄漏。以下是一些避免内存泄漏的方法：</p>
<ul>
<li><strong>解除事件监听器</strong>：确保在不再需要时移除事件监听器。</li>
<li><strong>断开DOM引用</strong>：如果一个DOM元素被移除，确保断开与它的所有引用。</li>
<li><strong>使用弱引用</strong>：在某些现代JavaScript引擎中支持弱引用，可以用来避免循环引用导致的内存泄漏。</li>
<li><strong>清理定时器和回调</strong>：确保在不再需要时清除定时器和回调函数。</li>
<li><strong>避免闭包中的大对象</strong>：闭包可以维持对大对象的引用，确保它们在不再需要时被正确释放。</li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包（Closure）是 JavaScript 中一个非常重要的概念，简单来说，闭包就是函数和它所能访问的外部作用域变量的组合。</p>
<p>也就是闭包 &#x3D; 内层函数 + 外层函数的变量，也就是<strong>内层函数要用到外层函数的变量</strong>。</p>
<h3 id="闭包的形成"><a href="#闭包的形成" class="headerlink" title="闭包的形成"></a>闭包的形成</h3><p>闭包的形成通常涉及到以下三个要素：</p>
<ol>
<li><strong>函数</strong>：必须有一个函数。</li>
<li><strong>外部作用域</strong>：函数必须访问其外部作用域中的变量。</li>
<li><strong>返回值</strong>：通常返回一个函数或者使外部作用域能够通过某种方式访问。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> externalVariable = <span class="string">&quot;Hello, world!&quot;</span>; <span class="comment">// 外部作用域变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">innerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(externalVariable); <span class="comment">// 访问外部作用域变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> innerFunction; <span class="comment">// 返回内部函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> closure = <span class="title function_">outerFunction</span>(); <span class="comment">// 创建闭包</span></span><br><span class="line"><span class="title function_">closure</span>(); <span class="comment">// 输出: &quot;Hello, world!&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h3><ol>
<li><strong>保持数据私有</strong>：闭包可以用来隐藏变量，不让外部代码直接访问。</li>
<li><strong>持久存储</strong>：闭包可以让变量在函数执行完毕后依然存在。</li>
<li><strong>模拟私有成员</strong>：在面向对象编程中，闭包可以用来实现类的私有方法和属性。</li>
</ol>
<p><strong>闭包可能会造成内存泄漏</strong>这和它的持久存储有关系。</p>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>了解：仅针对于var来声明的变量。</p>
<p>机制：</p>
<ul>
<li>把所有var声明的变量提升到当前作用域的最前面</li>
<li>只提升，不进行赋值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出 undefined</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，虽然<code>x</code>在使用之前被声明了，但由于变量提升的作用，<code>var x;</code>这一行被移到了作用域的顶部，而赋值操作<code>x = 5;</code>则保持原位。因此，在输出<code>x</code>的时候它还没有被赋值，所以输出的是<code>undefined</code>。</p>
<h2 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h2><h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><p>机制：</p>
<ul>
<li>会把所有函数声明提升到当前作用域的最前面</li>
<li>只提升函数声明，不提升调用</li>
</ul>
<p>函数提升例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">helloWorld</span>()); <span class="comment">// 输出 &quot;Hello, World!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">helloWorld</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，尽管函数<code>helloWorld</code>是在它被调用之后才被定义的，但是因为函数声明被提升到了作用域的顶部，所以可以正确地调用并返回结果。</p>
<p><strong>警惕var定义的变量后给改该变量赋值。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">goodbyeWorld</span>()); <span class="comment">// TypeError: goodbyeWorld is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> goodbyeWorld = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Goodbye, World!&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，尽管<code>goodbyeWorld</code>看起来像是一个函数，但实际上它是一个赋值给变量的函数表达式。因此，只有变量名<code>goodbyeWorld</code>被提升到了作用域的顶部，而函数体没有被提升。试图在定义之前调用<code>goodbyeWorld</code>会导致一个类型错误。</p>
<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>ES6还支持默认参数，允许你在函数定义时为参数指定默认值。当调用函数时如果没有提供某些参数，那么这些参数就会使用默认值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name, greeting = <span class="string">&quot;Hello&quot;</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting + <span class="string">&quot;, &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">greet</span>(<span class="string">&quot;John&quot;</span>);          <span class="comment">// 输出 &quot;Hello, John&quot;</span></span><br><span class="line"><span class="title function_">greet</span>(<span class="string">&quot;Jane&quot;</span>, <span class="string">&quot;Hi&quot;</span>);    <span class="comment">// 输出 &quot;Hi, Jane&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h4><ol>
<li>使用 <code>arguments</code> 对象</li>
</ol>
<p>场景：参数个数不确定。</p>
<p>该对象返回了一个伪数组，该数据并没有真正数组的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        total += <span class="variable language_">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)); <span class="comment">// 输出 15</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用<strong>剩余参数</strong>(…)：<strong>剩余参数必须位于参数列表的最后。</strong></li>
</ol>
<p>从ES6开始，JavaScript引入了一种新的语法——剩余参数语法（Rest Parameters Syntax），它可以用于收集传递给函数的多余参数，并将它们作为一个数组来处理。</p>
<p>注意点：</p>
<ul>
<li><p>该语法获取的是<strong>剩余</strong>的参数</p>
<ul>
<li><p>比如：getSum(1,2,3)，传递三个参数，</p>
</li>
<li><pre><code class="js">function getSum(a,b,...arr)&#123;
    
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 在上面这个函数中，a是1，b是2，那么通过剩余参数获得参数将会被放在一个数组中，也就是3会出现在数组中。</span><br><span class="line"></span><br><span class="line">注意：要与展开运算符(...)，做一个区分：</span><br><span class="line"></span><br><span class="line">展开运算符，可以用来展开数组</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">const arr = [1,2,3];</span><br><span class="line">console.log(...arr) // 输出1,2,3</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li>求数组最大值、合并数组等。</li>
</ul>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数有着更简洁的函数写法并且不绑定this，箭头函数语法要比函数表达式简洁</p>
<p><strong>基本语法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是箭头函数&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>箭头函数可以传递参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params">x</span>)=&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是箭头函数,这是传递的参数&#x27;</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>只有一个形参时，可以省略参数的括号</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = x=&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是箭头函数,这是传递的参数&#x27;</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数体只有一行，可以省略大括号</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = x =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是箭头函数,这是传递的参数&#x27;</span>,x);</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数体只有一行代码，可以省略return</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = x =&gt; x</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(<span class="number">1</span>)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>箭头函数可以直接返回一个对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">uname</span> = (<span class="params">uname</span>) =&gt; (&#123;<span class="attr">uname</span>:uname&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">uname</span>(<span class="string">&#x27;刘德华&#x27;</span>));</span><br><span class="line"><span class="comment">//上面这种写法相当于下面这样写</span></span><br><span class="line">     <span class="keyword">const</span> <span class="title function_">uname</span> = (<span class="params">uname</span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">uname</span>:uname</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">uname</span>(<span class="string">&#x27;刘德华&#x27;</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="箭头函数的参数"><a href="#箭头函数的参数" class="headerlink" title="箭头函数的参数"></a>箭头函数的参数</h4><p>普通形参，和剩余参数。注意：箭头函数里面没有<strong>arguments</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用箭头函数求和,这里用剩余参数去写</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getSum</span> = (<span class="params">...arr</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">getSum</span>(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure>

<h4 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的<code>this</code></h4><p>箭头函数不绑定自己的<code>this</code>，它使作用域中的<code>this</code>值。这意味着箭头函数内部的<code>this</code>值是根据它被定义的位置来决定的，而不是根据它被调用的位置。</p>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><h3 id="数组结构"><a href="#数组结构" class="headerlink" title="数组结构"></a>数组结构</h3><ul>
<li>作用：快速批量赋值变量。</li>
</ul>
<p>基本语法：</p>
<p>const [变量名] &#x3D; arr;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">100</span>,<span class="number">3</span>,<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//使用数组解构 - 会把数组中的值，按照声明变量的顺序依次赋值,相当于</span></span><br><span class="line">    <span class="comment">// a = 100,b=3,c=2</span></span><br><span class="line">    <span class="keyword">const</span> [a,b,c] = arr;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a,b,c);</span><br></pre></td></tr></table></figure>

<h4 id="忽略某些值"><a href="#忽略某些值" class="headerlink" title="忽略某些值"></a>忽略某些值</h4><p>有时你可能只想解构数组中的部分值。你可以通过在解构模式中留空来忽略某些值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> [firstColor, , thirdColor] = colors;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(firstColor);  <span class="comment">// 输出 &quot;red&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(thirdColor);  <span class="comment">// 输出 &quot;blue&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用默认值"><a href="#使用默认值" class="headerlink" title="使用默认值"></a>使用默认值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> [firstColor, secondColor, thirdColor = <span class="string">&#x27;default&#x27;</span>] = colors;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(firstColor);  <span class="comment">// 输出 &quot;red&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(secondColor); <span class="comment">// 输出 &quot;green&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(thirdColor);  <span class="comment">// 输出 &quot;default&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="解构嵌套数组"><a href="#解构嵌套数组" class="headerlink" title="解构嵌套数组"></a>解构嵌套数组</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nestedColors = [[<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>], [<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>]];</span><br><span class="line"><span class="keyword">let</span> [[firstColor, secondColor], [thirdColor, fourthColor]] = nestedColors;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(firstColor);  <span class="comment">// 输出 &quot;red&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(secondColor); <span class="comment">// 输出 &quot;green&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(thirdColor);  <span class="comment">// 输出 &quot;blue&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fourthColor); <span class="comment">// 输出 &quot;yellow&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="对象结构"><a href="#对象结构" class="headerlink" title="对象结构"></a>对象结构</h3><p>在JavaScript中，对象解构（Object Destructuring）是一种从对象中提取值并将其分配给变量的简洁方式。这种方法可以让你以更直观的方式处理对象中的属性，特别是当你需要从对象中提取特定的属性时非常有用。</p>
<p>对象解构的基本语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; key1, key2 &#125; = object;</span><br></pre></td></tr></table></figure>

<p>这里，<code>&#123; key1, key2 &#125;</code>是用于接收对象中属性值的变量列表，而<code>object</code>是要解构的对象。</p>
<h4 id="解构基本对象"><a href="#解构基本对象" class="headerlink" title="解构基本对象"></a>解构基本对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Doe&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; firstName, lastName, age &#125; = person;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(firstName);  <span class="comment">// 输出 &quot;John&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lastName);   <span class="comment">// 输出 &quot;Doe&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age);        <span class="comment">// 输出 30</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个包含姓名和年龄的对象<code>person</code>，然后通过解构将对象中的属性分别赋值给了三个变量。</p>
<h4 id="忽略某些属性"><a href="#忽略某些属性" class="headerlink" title="忽略某些属性"></a>忽略某些属性</h4><p>有时你可能只想解构对象中的部分属性。你可以通过在解构模式中留空来忽略某些属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Doe&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; firstName, , age &#125; = person;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(firstName);  <span class="comment">// 输出 &quot;John&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age);        <span class="comment">// 输出 30</span></span><br></pre></td></tr></table></figure>

<p>这里，<code>lastName</code>属性被忽略了，因为它对应的解构位置为空。</p>
<h4 id="使用默认值-1"><a href="#使用默认值-1" class="headerlink" title="使用默认值"></a>使用默认值</h4><p>如果你希望在解构时为未提供的属性设置默认值，可以这样做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Doe&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; firstName, lastName, age = <span class="number">25</span> &#125; = person;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(firstName);  <span class="comment">// 输出 &quot;John&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lastName);   <span class="comment">// 输出 &quot;Doe&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age);        <span class="comment">// 输出 25</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>age</code>属性没有在原始对象中提供，所以我们为它指定了一个默认值<code>25</code>。</p>
<h4 id="解构嵌套对象"><a href="#解构嵌套对象" class="headerlink" title="解构嵌套对象"></a>解构嵌套对象</h4><p>你还可以解构嵌套的对象：注意：要在前面写上要结构对象的名字</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">first</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">        <span class="attr">last</span>: <span class="string">&#x27;Doe&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: &#123; first, last &#125;, age &#125; = person;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(first);  <span class="comment">// 输出 &quot;John&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(last);   <span class="comment">// 输出 &quot;Doe&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age);    <span class="comment">// 输出 30</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们有两个嵌套的对象，我们通过解构来分别获取每个对象中的属性。</p>
<h4 id="解构并重命名属性"><a href="#解构并重命名属性" class="headerlink" title="解构并重命名属性"></a>解构并重命名属性</h4><p>如果你想在解构的同时给变量重新命名，可以这样做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Doe&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">firstName</span>: givenName, <span class="attr">lastName</span>: familyName, age &#125; = person;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(givenName);    <span class="comment">// 输出 &quot;John&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(familyName);   <span class="comment">// 输出 &quot;Doe&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age);          <span class="comment">// 输出 30</span></span><br></pre></td></tr></table></figure>

<h2 id="深入对象"><a href="#深入对象" class="headerlink" title="深入对象"></a>深入对象</h2><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>1.通过字面量方式创建：直接使用大括号 <code>&#123;&#125;</code> 来定义一个对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">    <span class="attr">sayHello</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, my name is &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.<span class="title function_">sayHello</span>();  <span class="comment">// 输出: Hello, my name is Alice</span></span><br></pre></td></tr></table></figure>

<p>2.使用new Object创建对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>(&#123;<span class="attr">name</span>:佩奇&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o) <span class="comment">// &#123;name:佩奇&#125;</span></span><br></pre></td></tr></table></figure>

<p>3.使用构造函数来创建</p>
<p>通过定义一个构造函数来创建对象。这种方式可以用来创建多个具有相同属性和方法的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, my name is &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> alice = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>);</span><br><span class="line">alice.<span class="title function_">sayHello</span>();  <span class="comment">// 输出: Hello, my name is Alice</span></span><br></pre></td></tr></table></figure>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li>这是一种特殊的函数，主要用来初始化对象。</li>
<li>通过构造函数可以快速创建多个类似的对象。</li>
</ul>
<p>一般构造函数有两个约定：</p>
<ol>
<li>命名以<strong>大写字母</strong>开头。</li>
<li>他们只能由’new’操作符来执行。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Pig</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用构造函数</span></span><br><span class="line"><span class="keyword">const</span> pig = <span class="keyword">new</span> <span class="title class_">Pig</span>(<span class="string">&#x27;佩奇&#x27;</span>, <span class="number">6</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pig);</span><br></pre></td></tr></table></figure>

<h3 id="实例成员-静态成员"><a href="#实例成员-静态成员" class="headerlink" title="实例成员&amp;静态成员"></a>实例成员&amp;静态成员</h3><p>这里要注意与java进行区别</p>
<p>1.实例成员：实例对象上的属性和方法就是实例属性和实例方法，被称为实例成员</p>
<p>2.静态成员：构造函数上的属性和方法就是静态属性和静态方法，称为静态成员。</p>
<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>存在浪费内存的问题。</p>
<h2 id="内置构造函数"><a href="#内置构造函数" class="headerlink" title="内置构造函数"></a>内置构造函数</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240824164156519.png" alt="image-20240824164156519"></p>
<h3 id="Object—对象"><a href="#Object—对象" class="headerlink" title="Object—对象"></a>Object—对象</h3><p>学习三个常用的静态方法（静态方法就是只有构造函数Object可以调用）</p>
<ol>
<li><p><code>Object.keys()</code>静态方法获取对象中所有的属性 </p>
<p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">name</span>:<span class="string">&#x27;佩奇&#x27;</span>,<span class="attr">age</span>:<span class="number">6</span>&#125;</span><br><span class="line"><span class="comment">//获取对象的所有属性名，并且返回是一个数组</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="title class_">Object</span>.<span class="title function_">keys</span>(o)</span><br></pre></td></tr></table></figure>

<p>注意：返回的是一个数组。</p>
</li>
<li><p><code>Object.values()</code>静态方法获取对象中所有的属性值</p>
<p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">name</span>:<span class="string">&#x27;佩奇&#x27;</span>,<span class="attr">age</span>:<span class="number">6</span>&#125;</span><br><span class="line"><span class="comment">//获取对象的所有属性名，并且返回是一个数组</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="title class_">Object</span>.<span class="title function_">values</span>(o) <span class="comment">//[&#x27;佩奇&#x27;,6]</span></span><br></pre></td></tr></table></figure>

<p>注意：返回的是一个数组。</p>
</li>
<li><p><code>Object.assign()</code>静态方法常用于对象拷贝</p>
<p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">name</span>:<span class="string">&#x27;佩奇&#x27;</span>,<span class="attr">age</span>:<span class="number">6</span>&#125;</span><br><span class="line"><span class="comment">//获取对象的所有属性名，并且返回是一个数组</span></span><br><span class="line"><span class="keyword">const</span> cloneObj = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">CloneObj</span>,o) <span class="comment">//把对象o的属性和属性值拷贝给对象cloneObj</span></span><br></pre></td></tr></table></figure>

<p>注意：返回的是一个数组。</p>
<p>使用场景：一般用来给某个对象追加新属性，特别适用。</p>
</li>
</ol>
<h3 id="Array—数组"><a href="#Array—数组" class="headerlink" title="Array—数组"></a>Array—数组</h3><p>详细用法请见：JS对象—数组对象小结</p>
<p>基本语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&#x27;这是通过构造函数创建的字符串&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>下面是一些字符串的基本方法。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240824170050222.png" alt="image-20240824170050222"></p>
<h3 id="Number—数值"><a href="#Number—数值" class="headerlink" title="Number—数值"></a>Number—数值</h3><ul>
<li>作用：用于创建数组，是一个内置构造函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Number</span>(<span class="string">&#x27;123&#x27;</span>)); <span class="comment">// 123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Number</span>(<span class="string">&#x27;45.67&#x27;</span>)); <span class="comment">// 45.67</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Number</span>(<span class="literal">true</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Number</span>(<span class="literal">false</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Number</span>(<span class="string">&#x27;abc&#x27;</span>)); <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Number</span>(<span class="string">&#x27;100px&#x27;</span>)); <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Number</span>(<span class="literal">null</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Number</span>(<span class="literal">undefined</span>)); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p><strong>一些常用方法</strong>：</p>
<ol>
<li><p><code>toFixed()</code>：设置保留小数位的长度</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> price = <span class="number">12.345</span>;</span><br><span class="line"><span class="comment">//保留两位小数,四舍五入</span></span><br><span class="line">price.<span class="title function_">toFixed</span>(<span class="number">2</span>) <span class="comment">// 12.35</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="两种编程思想"><a href="#两种编程思想" class="headerlink" title="两种编程思想"></a>两种编程思想</h2><p>面向过程编程（Procedural Programming）和面向对象编程（Object-Oriented Programming）。</p>
<h3 id="1-面向过程编程（Procedural-Programming）"><a href="#1-面向过程编程（Procedural-Programming）" class="headerlink" title="1. 面向过程编程（Procedural Programming）"></a>1. 面向过程编程（Procedural Programming）</h3><p>面向过程编程是一种以过程为中心的编程范式。它将程序视为一系列的过程或函数调用，每个过程或函数完成特定的任务。这种编程方式强调的是如何一步步地解决问题。</p>
<p><strong>特点包括：</strong></p>
<ul>
<li><strong>代码组织</strong>：通过函数或子程序来组织代码，使得代码更易于理解和复用。</li>
<li><strong>数据处理</strong>：数据通常作为参数传递给函数，并且结果也通过函数返回。</li>
<li><strong>控制流</strong>：使用流程控制结构（如循环和条件语句）来控制程序执行的顺序。</li>
</ul>
<h3 id="2-面向对象编程（Object-Oriented-Programming-OOP）"><a href="#2-面向对象编程（Object-Oriented-Programming-OOP）" class="headerlink" title="2. 面向对象编程（Object-Oriented Programming, OOP）"></a>2. 面向对象编程（Object-Oriented Programming, OOP）</h3><p>面向对象编程是一种以对象为中心的编程范式。它将程序视为对象的集合，这些对象可以包含数据（属性）和行为（方法）。OOP 强调的是对象之间的交互。</p>
<p><strong>特点包括(三大特性)：</strong></p>
<ul>
<li><strong>封装</strong>：将数据和操作数据的方法绑定在一起，隐藏内部细节，只对外提供接口。</li>
<li><strong>继承</strong>：允许创建现有类的新版本，新版本可以继承原始类的特性并添加新的功能。</li>
<li><strong>多态</strong>：允许一个接口代表多种类型，也就是说，同一个接口可以有多种不同的实现方式。</li>
</ul>
<h2 id="原型-重要"><a href="#原型-重要" class="headerlink" title="原型(重要)"></a>原型(重要)</h2><h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><ul>
<li>构造函数通过原型分配的函数是所有对象所共享的。</li>
<li>JS规定，<strong>每一个构造函数都有一个prototype属性</strong>，指向另一个对象，所以我们也成为原型对象</li>
<li>该对象可以挂载函数，对象实例化不会多次创建原型上函数，节约内存</li>
<li><strong>我们可以吧那些不变的方法，直接定义在prototype对象上，这样索引对象的实例就可以共享该方法</strong></li>
<li><strong>构造函数和原型对象中的this指向实例化对象。</strong></li>
</ul>
<p>示例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自己定义数组拓展方法 - 求和 和 最大值</span></span><br><span class="line"><span class="comment">//1.定义的方法，任何数组都可以使用，所以定义在数组的原型对象上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//求最大值</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">max</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//this在这里指向实例对象，也就是arr</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(...<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">max</span>());<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//求和</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sum</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//this在这里指向实例对象，也就是arr</span></span><br><span class="line">  <span class="keyword">return</span>  <span class="variable language_">this</span>.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">prev,current</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> prev + current</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">sum</span>());  <span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<h3 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h3><p>每个原型对象中都有<strong>construtor</strong>属性(该属性也被成为construtor构造函数)</p>
<ul>
<li>作用：该属性指向该原型对象的构造函数，一图理解。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240825144903233.png" alt="image-20240825144903233"></p>
<h3 id="对象原型"><a href="#对象原型" class="headerlink" title="对象原型"></a>对象原型</h3><p>每个实例化的对象，都会有一个属性<code>__proto__</code>指向构造函数的prototype的原型对象，之所以我们的实例化对象可以使用构造函数原型对象的方法和属性，就是因为有<code>__proto__</code>对象原型的存在。</p>
<p>一图理解</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240825150040171.png" alt="image-20240825150040171"></p>
<p>注意：</p>
<ul>
<li><code>__proto__</code>是JS非标准属性。</li>
<li><code>__proto__</code>是只读属性。</li>
<li>[[prototype]] 和<code>__proto__</code>意义相同。</li>
<li>用来表示当前实例对象指向那个原型对象</li>
<li>最后一点：<code>__proto__</code>对象原型里面也有一个<code>constructor</code>属性，该属性指向创建该实例对象的构造函数。</li>
</ul>
<p><strong>三者最终关系，如下</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240825151653650.png" alt="image-20240825151653650"></p>
<h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><p>假设我们有两个构造函数<code>Parent</code>和<code>Child</code>，我们想要让<code>Child</code>继承<code>Parent</code>的属性和方法。这可以通过将<code>Child</code>的<code>prototype</code>属性设置为<code>Parent</code>的实例来实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">&#x27;Hello from Parent&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">showMessage</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">message</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">&#x27;Hello from Child&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 Child 的 prototype 为 Parent 的实例，这句代码是核心，继承就是通过这样实现。</span></span><br><span class="line"><span class="comment">//但是切记要写成下面这种格式。</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修正 constructor 指向 Child</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> childInstance = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">childInstance.<span class="title function_">showMessage</span>(); <span class="comment">// 输出 &quot;Hello from Parent&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h4><ul>
<li>当你直接将<code>Child.prototype</code>设置为<code>Parent</code>时，所有<code>Child</code>实例共享<code>Parent</code>原型上的属性。这意味着如果你在一个实例中修改了原型上的属性，那么这个变化会影响到其他所有实例。</li>
<li>要注意修正 <strong>constructor</strong> 指向。不能丢失了constructor属性。</li>
</ul>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>JS的查找规则：</p>
<p><strong>当我们在JavaScript中访问一个对象的属性时，如果该对象本身没有这个属性，JavaScript引擎会沿着该对象的原型链继续查找。</strong>更具体的查找规则如下：</p>
<ul>
<li>当访问一个对象属性&#x2F;方法时，第一步查找该对象本身有没有该属性&#x2F;方法</li>
<li>如果没有，那么就查找它的原型(也就是<code>__proto__</code>指向的prototype原型对象)。</li>
<li>如果还没有那就查找原型对象的原型（也就Object的原型对象）。</li>
<li>依次类推一直找到Object为止，因为在往上找就是<code>null</code>了</li>
</ul>
<ol>
<li><code>__proto__</code>对象原型存在的意义就在于为对象成员查找机制提供一个方向。或者说一条路线。</li>
<li>可以使用instanceof运算符用于检测构造函数中的prototype属性是否出现在某个实例对象的原型链上</li>
</ol>
<p>原型链是由一系列<strong>原型对象</strong>组成的链式结构，最终会指向<code>null</code>，因为<code>null</code>没有原型。</p>
<p><strong>原型链的工作原理</strong></p>
<ol>
<li><strong>对象创建&#x2F;原型对象的概念</strong>：当使用<code>new</code>关键字创建一个对象时，该对象会自动获得一个原型对象，<strong>通常是构造函数的<code>prototype</code>属性所指向的对象。</strong></li>
<li><strong>属性查找</strong>：当访问一个对象的属性或方法时，JavaScript引擎首先会在该对象自身查找该属性。如果没有找到，它会沿着原型链向上查找，直到找到该属性或到达原型链的末端。</li>
<li><strong>原型链的末端</strong>：原型链的末端是一个没有任何属性的空对象，即<code>null</code>。</li>
</ol>
<p><strong>原型链的构造</strong></p>
<ol>
<li><strong>内置原型</strong>：每个内置的构造函数都有一个<code>prototype</code>属性，如<code>Function.prototype</code>、<code>Array.prototype</code>等。</li>
<li><strong>自定义构造函数</strong>：自定义的构造函数同样拥有<code>prototype</code>属性，用于继承的目的。</li>
<li><strong>原型链的构建</strong>：当创建一个新对象时，该对象的<code>__proto__</code>属性被设置为构造函数的<code>prototype</code>属性所指向的对象。</li>
</ol>
<p><strong>一图理解</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240825181428296.png" alt="image-20240825181428296"></p>
<p>上述红线的方向就是原型链的查找方向，也是原型链的方向</p>
<h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><p>在JavaScript中，对象的复制通常分为两种类型：浅拷贝（shallow copy）和深拷贝（deep copy）。这两种拷贝方式的主要区别在于它们处理对象内部可变数据结构的方式不同。</p>
<h3 id="浅拷贝-Shallow-Copy"><a href="#浅拷贝-Shallow-Copy" class="headerlink" title="浅拷贝 (Shallow Copy)"></a>浅拷贝 (Shallow Copy)</h3><p>浅拷贝会创建一个新的对象，并尽可能地把原对象中的所有可枚举属性值复制到新对象中。如果原对象中有引用类型的属性（如数组、对象等），那么浅拷贝只会复制这些<strong>引用类型的地址</strong>而不是其内容。<strong>这意味着，对于引用类型的属性，浅拷贝后的对象和原对象指向的是同一个内存地址，因此改变其中一个对象会影响到另一个。</strong></p>
<p>实现方法</p>
<ul>
<li>使用 <code>Object.assign()</code>: 可以用来创建一个新对象，并将一个或多个现有对象的可枚举属性拷贝到新对象中。</li>
<li>使用扩展运算符 <code>...</code>: 也可以用来实现对象的浅拷贝。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: &#123; <span class="attr">nested</span>: <span class="number">2</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj1);</span><br><span class="line"><span class="keyword">let</span> obj3 = &#123; ...obj1 &#125;;</span><br><span class="line"></span><br><span class="line">obj1.<span class="property">b</span>.<span class="property">nested</span> = <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">b</span>.<span class="property">nested</span>); <span class="comment">// 输出 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj3.<span class="property">b</span>.<span class="property">nested</span>); <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure>

<h3 id="深拷贝-Deep-Copy"><a href="#深拷贝-Deep-Copy" class="headerlink" title="深拷贝 (Deep Copy)"></a>深拷贝 (Deep Copy)</h3><p>深拷贝会创建一个新的对象，并递归地复制原对象的所有属性，包括引用类型的数据也会被完全复制，从而保证了新对象与原对象不共享任何数据。这使得修改新对象不会影响到原对象。</p>
<p>实现方法</p>
<ul>
<li>使用 <code>JSON.parse()</code> 和 <code>JSON.stringify()</code>: 这种方法可以简单地实现深拷贝，但不适用于循环引用的对象、函数、<code>undefined</code>、<code>Symbol</code> 等。</li>
<li>使用第三方库如 Lodash 的 <code>_().cloneDeep()</code> 方法。</li>
<li>手动实现递归深拷贝。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: &#123; <span class="attr">nested</span>: <span class="number">2</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj1));</span><br><span class="line">obj1.<span class="property">b</span>.<span class="property">nested</span> = <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">b</span>.<span class="property">nested</span>); <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，使用 <code>JSON.parse()</code> 和 <code>JSON.stringify()</code> 方法有一些限制，比如不能处理函数、日期、正则表达式等特殊类型的对象。</p>
<p>如果你需要处理更复杂的数据结构或者有特殊需求，可以考虑使用一些成熟的库，例如 Lodash 的 <code>_.cloneDeep()</code> 方法。</p>
<p><strong>手写深拷贝</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.深拷贝</span></span><br><span class="line"><span class="comment">//1.利用递归实现，手写一个拷贝递归函数</span></span><br><span class="line"><span class="keyword">const</span> testObj = &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">newObj, oldObj</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> oldObj) &#123;</span><br><span class="line">        <span class="comment">//判断是否存在数组对象</span></span><br><span class="line">        <span class="keyword">if</span> (oldObj[k] <span class="keyword">instanceof</span> <span class="title class_">Array</span>) &#123;</span><br><span class="line">            <span class="comment">//给新对象，创建一个新数组</span></span><br><span class="line">            newObj[k] = []</span><br><span class="line">            <span class="comment">//接收方是新对象当中的新建的空数组，送的一方就是旧数组</span></span><br><span class="line">            <span class="title function_">deepClone</span>(newObj[k], oldObj[k])</span><br><span class="line">            <span class="comment">//处理对象类型的引用数据</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldObj[k] <span class="keyword">instanceof</span> <span class="title class_">Object</span>) &#123;</span><br><span class="line">            <span class="comment">//创建一个新对象</span></span><br><span class="line">            newObj[k] = &#123;&#125;</span><br><span class="line">            <span class="comment">//接收方是新建的空对象，送的一方就是旧对象</span></span><br><span class="line">            <span class="title function_">deepClone</span>(newObj[k], oldObj[k])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> (k)); <span class="comment">//k是String类型的。</span></span><br><span class="line">            <span class="comment">//这种写法不可取newObj.k，会被认为是像对象newObj中追加一个属性名为K的属性。</span></span><br><span class="line">            <span class="comment">//要采取下面这种写法，</span></span><br><span class="line">            newObj[k] = oldObj[k]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">deepClone</span>(testObj, obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(testObj);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>在JavaScript中，异常处理是一种控制流结构，用于捕获和处理程序执行过程中发生的错误或异常情况。异常处理主要包括以下几个关键部分：<code>try</code>, <code>catch</code>, 和 <code>finally</code> 块。</p>
<h3 id="异常处理语法"><a href="#异常处理语法" class="headerlink" title="异常处理语法"></a>异常处理语法</h3><ol>
<li><p><strong><code>try</code> 块</strong>:</p>
<ul>
<li><code>try</code> 块包含了可能会抛出异常的代码。</li>
<li>如果 <code>try</code> 块中的代码执行正常，则 <code>catch</code> 块将被跳过。</li>
</ul>
</li>
<li><p><strong><code>catch</code> 块</strong>:</p>
<ul>
<li><code>catch</code> 块用于处理 <code>try</code> 块中抛出的异常。</li>
<li><code>catch</code> 块接收一个参数，通常命名为 <code>error</code> 或 <code>e</code>，这个参数包含了异常信息。</li>
</ul>
</li>
<li><p><strong><code>finally</code> 块</strong>:</p>
<ul>
<li><code>finally</code> 块是可选的，它包含了无论是否发生异常都需要执行的代码。</li>
<li><code>finally</code> 块在 <code>try</code> 和 <code>catch</code> 块之后执行。</li>
</ul>
</li>
</ol>
<p><strong>使用 <code>try-catch-finally</code> 处理异常</strong></p>
<p>下面是一个简单的示例，演示如何使用 <code>try-catch-finally</code> 结构来处理可能的异常：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试执行可能会抛出异常的代码</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">10</span> / <span class="number">0</span>; <span class="comment">// 这里会抛出异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;捕获到了异常:&quot;</span>, error.<span class="property">message</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 不管是否有异常，都会执行这里的代码</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;执行 finally 块&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用 <code>throw</code> 抛出异常</strong></p>
<p>你还可以使用 <code>throw</code> 语句手动抛出异常：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x,y</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!x || !y)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;没有参数传递进来&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>());</span><br></pre></td></tr></table></figure>

<p><strong>自定义异常</strong></p>
<p>在JavaScript中，你还可以创建自定义异常类来处理特定类型的错误。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ValidationError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">message</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(message);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;ValidationError&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">validateEmail</span>(<span class="params">email</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!email.<span class="title function_">includes</span>(<span class="string">&quot;@&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ValidationError</span>(<span class="string">&quot;无效的电子邮件地址&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;电子邮件验证成功！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title function_">validateEmail</span>(<span class="string">&quot;example.com&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error <span class="keyword">instanceof</span> <span class="title class_">ValidationError</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;验证错误:&quot;</span>, error.<span class="property">message</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;未知错误:&quot;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;验证完成！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="深度学习this"><a href="#深度学习this" class="headerlink" title="深度学习this"></a>深度学习<code>this</code></h2><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p>this的指向在js中非常重要，下面就更加深层的理解this指向</p>
<h4 id="针对普通函数"><a href="#针对普通函数" class="headerlink" title="针对普通函数"></a>针对普通函数</h4><p>总结一句话：普通函数的调用方式决定了this的指向，即谁调用函数，this就指向谁</p>
<p>普通函数没有明确调用者时，this指向window，严格模式下没有调用者this指向<code>undefined</code></p>
<h4 id="针对箭头函数"><a href="#针对箭头函数" class="headerlink" title="针对箭头函数"></a>针对箭头函数</h4><p>事实上，箭头函数并不存在<code>this</code>！</p>
<ol>
<li>箭头函数会默认帮我们绑定外层this的值，所以在箭头函数中this的值和外层的this是一样的。</li>
<li>箭头函数中后的this引用的就是最近作用域中的this。</li>
<li>向外层作用域中，一层一层查找this，直到找到this。</li>
</ol>
<p>需求：看需要不需要使用this，不需要this使用箭头函数更简洁方便。</p>
<h3 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变this指向</h3><p>当然可以。下面是JavaScript中用于改变 <code>this</code> 指向的一些常用方法及其语法格式：</p>
<p>下面的参数中：thisArg，就是规定this指向谁，如果不需要指向，则可以写<code>null</code></p>
<h4 id="使用-call"><a href="#使用-call" class="headerlink" title="使用 .call()"></a>使用 <code>.call()</code></h4><p><strong>！该方法会调用函数</strong></p>
<p><code>.call()</code> 方法调用一个函数，并传入指定的 <code>this</code> 值和参数列表。</p>
<p><strong>语法</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">functionName.<span class="title function_">call</span>(thisArg, arg1, arg2, ...);</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">greeting</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting + <span class="string">&#x27;, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">greet.<span class="title function_">call</span>(person, <span class="string">&#x27;Hello&#x27;</span>); <span class="comment">// 输出: Hello, Alice</span></span><br></pre></td></tr></table></figure>

<h4 id="使用-apply"><a href="#使用-apply" class="headerlink" title="使用 .apply()"></a>使用 <code>.apply()</code></h4><p><strong>！该方法会调用函数</strong></p>
<p><code>.apply()</code> 方法与 <code>.call()</code> 类似，但是它接受一个参数数组。</p>
<p><strong>语法</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">functionName.<span class="title function_">apply</span>(thisArg, [arg1, arg2, ...]);</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">greeting</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting + <span class="string">&#x27;, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">greet.<span class="title function_">apply</span>(person, [<span class="string">&#x27;Hello&#x27;</span>]); <span class="comment">// 输出: Hello, Alice</span></span><br></pre></td></tr></table></figure>

<h4 id="使用-bind"><a href="#使用-bind" class="headerlink" title="使用 .bind()"></a>使用 <code>.bind()</code></h4><p><strong>注意：bind()方法不会调用函数。</strong></p>
<p><code>.bind()</code> 方法创建一个新的函数，这个新的函数的 <code>this</code> 被绑定到提供的值上。</p>
<p>该方法的返回值是一个新函数。</p>
<p><strong>语法</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">functionName.<span class="title function_">bind</span>(thisArg, arg1, arg2, ...);</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">greeting</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting + <span class="string">&#x27;, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boundGreet = greet.<span class="title function_">bind</span>(person);</span><br><span class="line"><span class="title function_">boundGreet</span>(<span class="string">&#x27;Hello&#x27;</span>); <span class="comment">// 输出: Hello, Alice</span></span><br></pre></td></tr></table></figure>

<h4 id="理解图"><a href="#理解图" class="headerlink" title="理解图"></a>理解图</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240826115208398.png" alt="image-20240826115208398"></p>
<h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h4><p>单位时间内，频繁触发事件，但只执行最后一次触发。</p>
<p>简单理解：王者荣耀的回城。</p>
<p><strong>使用场景</strong></p>
<ul>
<li>输入框的搜索建议</li>
<li>窗口尺寸变化时重新布局</li>
<li>鼠标移动时获取位置</li>
</ul>
<p><strong>实现方式</strong></p>
<ol>
<li>使用lodash提供的防抖来处理</li>
<li>手写防抖函数</li>
</ol>
<p><strong>手写防抖函数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防抖的概念：单位时间内，频繁触发事件，但只执行最后一次触发。</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">addNum</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>).<span class="property">innerHTML</span> = i++;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;111&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//2.手写防抖函数:底层是使用定时器实现的。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, time</span>) &#123;</span><br><span class="line">    <span class="comment">//定义一个定时器变量</span></span><br><span class="line">    <span class="keyword">let</span> timer</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//每次触发判断有没有定时器，如果有清除</span></span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        <span class="comment">//没有就开启定时器，存入到定时器变量</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">//在定时器里面调用函数</span></span><br><span class="line">            <span class="title function_">fn</span>()</span><br><span class="line">        &#125;, time)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="title function_">debounce</span>(addNum, <span class="number">500</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><p>节流的目的则是确保一个函数在指定的时间间隔内最多只被调用一次。即使该函数被频繁触发，它也只会在上一次调用之后等待指定的时间间隔再次执行。</p>
<p>单位时间内，频繁触发事件，只执行一次</p>
<p>类似王者荣耀的技能，是存在CD的，CD时间内只执行一次。</p>
<p><strong>使用场景</strong></p>
<ul>
<li>鼠标滚轮滚动</li>
<li>滚动事件</li>
<li>定时任务</li>
</ul>
<p><strong>手写节流函数</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240826125802996.png" alt="image-20240826125802996"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防抖的概念：单位时间内，频繁触发事件，只执行一次</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">addNum</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>).<span class="property">innerHTML</span> = i++;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;111&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//2.手写节流函数:底层是使用定时器实现的。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, time</span>) &#123;</span><br><span class="line">    <span class="comment">//定义一个定时器变量</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//每次触发判断有没有定时器，如果有定时，不做任何操作</span></span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            <span class="comment">//没有就开启定时器，存入到定时器变量</span></span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="comment">//在定时器里面调用函数</span></span><br><span class="line">                <span class="title function_">fn</span>()</span><br><span class="line">                <span class="comment">//清空定时器 - 需要注意的是，在定时器内部清除定时器不能使用clearTimeout，而是要重新给定时器赋值为空才行</span></span><br><span class="line">                timer = <span class="literal">null</span></span><br><span class="line">            &#125;, time)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="title function_">throttle</span>(addNum, <span class="number">1000</span>))</span><br></pre></td></tr></table></figure>

<h4 id="防抖和节流的总结"><a href="#防抖和节流的总结" class="headerlink" title="防抖和节流的总结"></a>防抖和节流的总结</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/JavaScript/image-20240826130750397.png" alt="image-20240826130750397"></p>
<h1 id="JS插件"><a href="#JS插件" class="headerlink" title="JS插件"></a>JS插件</h1><h2 id="制作轮播图"><a href="#制作轮播图" class="headerlink" title="制作轮播图"></a>制作轮播图</h2><p>建议使用swiper插件</p>
<p>swiper官网：<a target="_blank" rel="noopener" href="https://swiperjs.com/get-started(%E8%8B%B1%E6%96%87)">https://swiperjs.com/get-started(英文)</a></p>
<p>swiper中文网：<a target="_blank" rel="noopener" href="https://www.swiper.com.cn/">https://www.swiper.com.cn/</a></p>
<h2 id="快速收集表单内容"><a href="#快速收集表单内容" class="headerlink" title="快速收集表单内容"></a>快速收集表单内容</h2><p>建议使用<strong>form-serialize</strong>插件</p>
<p>该插件传递<strong>两个参数</strong></p>
<ol>
<li>要收集那个表单的数据<ol>
<li>表单中的name属性会被作为属性名来展示在收集的数据中</li>
<li>建议name的值最好和接口文档一致。</li>
</ol>
</li>
<li>配置对象<code>&#123;hash:true,empty:true&#125;</code><ol>
<li>hash设置获取数据的结构<ul>
<li>true：JS对象(推荐使用)，一般请求体里提交给服务器。</li>
<li>false：获取的是查询字符串。</li>
</ul>
</li>
<li>empty设置是否获取表单中的空值。<ul>
<li>true：获取表单中的空值。</li>
<li>false：不获取表单中的空值。</li>
</ul>
</li>
</ol>
</li>
</ol>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/touxiang.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/touxiang.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">LiSir</div><div class="post-copyright__author_desc">心怀远方</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2024/07/30/JavaScript/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2024/07/30/JavaScript/')">JavaScript</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2024/07/30/JavaScript/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=JavaScript&amp;url=http://example.com/2024/07/30/JavaScript/&amp;pic=/img/default_cover.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LiSir</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/JS/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>JS<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/img/default_cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/26/uni-app%E6%A1%86%E6%9E%B6%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/default_cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">uni-app框架之网易云音乐</div></div></a></div><div class="next-post pull-right"><a href="/2024/08/09/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/default_cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">移动端开发+less+BSP</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JS%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">JS引入方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JS%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">JS基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A6%E5%86%99%E8%AF%AD%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">书写语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.1.</span> <span class="toc-text">原始类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.3.2.</span> <span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E4%B8%8E-%E4%B8%8E%E9%80%BB%E8%BE%91%E6%88%96"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">逻辑与(&amp;&amp;)与逻辑或(||)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E4%B8%8E"><span class="toc-number">2.3.2.1.1.</span> <span class="toc-text">逻辑与 (&amp;&amp;)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%88%96"><span class="toc-number">2.3.2.1.2.</span> <span class="toc-text">逻辑或 (||)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9F%AD%E8%B7%AF%E6%B1%82%E5%80%BC-%E9%87%8D%E8%A6%81"><span class="toc-number">2.3.2.1.3.</span> <span class="toc-text">短路求值(重要)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">非运算符(!)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">2.3.3.</span> <span class="toc-text">流程控制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JS%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">JS函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">函数的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">匿名函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">回调函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.3.1.</span> <span class="toc-text">回调函数的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.3.2.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.</span> <span class="toc-text">递归函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E8%8C%83%E5%9B%B4%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">生成一个范围随机数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JS%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.</span> <span class="toc-text">JS对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Array-%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.1.</span> <span class="toc-text">Array(数组对象)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript-%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.1.</span> <span class="toc-text">JavaScript 数组方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.2.</span> <span class="toc-text">String对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.1.</span> <span class="toc-text">JavaScript 字符串方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">查找字符串中的字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E7%BB%84"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">把字符串转换为数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-includes"><span class="toc-number">5.2.1.3.</span> <span class="toc-text">String.includes()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-startsWith"><span class="toc-number">5.2.1.4.</span> <span class="toc-text">String.startsWith()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-endsWith"><span class="toc-number">5.2.1.5.</span> <span class="toc-text">String.endsWith()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BA%86%E5%BE%88%E5%A5%BD%E8%AE%B0%E5%BF%86%E5%81%9A%E5%87%BA%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">5.3.</span> <span class="toc-text">为了很好记忆做出的总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#json%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.4.</span> <span class="toc-text">json对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BOM%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.5.</span> <span class="toc-text">BOM对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Window%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.5.0.1.</span> <span class="toc-text">Window对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Location%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.5.0.2.</span> <span class="toc-text">Location对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#navigator%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.5.0.3.</span> <span class="toc-text">navigator对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#history%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.5.0.4.</span> <span class="toc-text">history对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.6.</span> <span class="toc-text">DOM对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDOM"><span class="toc-number">5.6.1.</span> <span class="toc-text">什么是DOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM%E8%8A%82%E7%82%B9"><span class="toc-number">5.6.2.</span> <span class="toc-text">DOM节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E8%8A%82%E7%82%B9%EF%BC%88Document-Node%EF%BC%89"><span class="toc-number">5.6.2.1.</span> <span class="toc-text">文档节点（Document Node）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9%EF%BC%88Element-Node%EF%BC%89"><span class="toc-number">5.6.2.2.</span> <span class="toc-text">元素节点（Element Node）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%8A%82%E7%82%B9%EF%BC%88Attribute-Node%EF%BC%89"><span class="toc-number">5.6.2.3.</span> <span class="toc-text">属性节点（Attribute Node）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E8%8A%82%E7%82%B9%EF%BC%88Text-Node%EF%BC%89"><span class="toc-number">5.6.2.4.</span> <span class="toc-text">文本节点（Text Node）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A%E8%8A%82%E7%82%B9%EF%BC%88Comment-Node%EF%BC%89"><span class="toc-number">5.6.2.5.</span> <span class="toc-text">注释节点（Comment Node）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9"><span class="toc-number">5.6.3.</span> <span class="toc-text">查找节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%88%B6%E8%8A%82%E7%82%B9%E6%9F%A5%E6%89%BE-%E5%8F%AA%E8%83%BD%E6%89%BE%E5%88%B0%E6%9C%80%E8%BF%91%E4%B8%80%E7%BA%A7"><span class="toc-number">5.6.3.1.</span> <span class="toc-text">父节点查找(只能找到最近一级)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E8%8A%82%E7%82%B9%E6%9F%A5%E6%89%BE"><span class="toc-number">5.6.3.2.</span> <span class="toc-text">子节点查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9%E6%9F%A5%E6%89%BE"><span class="toc-number">5.6.3.3.</span> <span class="toc-text">兄弟节点查找</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E8%8A%82%E7%82%B9"><span class="toc-number">5.6.4.</span> <span class="toc-text">新增节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9"><span class="toc-number">5.6.4.1.</span> <span class="toc-text">创建节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%92%8C%E5%86%85%E5%AE%B9"><span class="toc-number">5.6.4.2.</span> <span class="toc-text">设置属性和内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9%E5%88%B0DOM%E4%B8%AD"><span class="toc-number">5.6.4.3.</span> <span class="toc-text">添加节点到DOM中</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%8B%E9%9A%86%E8%8A%82%E7%82%B9"><span class="toc-number">5.6.5.</span> <span class="toc-text">克隆节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-number">5.6.6.</span> <span class="toc-text">删除节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.7.</span> <span class="toc-text">日期对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-Date-%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.7.1.</span> <span class="toc-text">创建 Date 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">5.7.2.</span> <span class="toc-text">日期对象的常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%9A%84%E9%83%A8%E5%88%86"><span class="toc-number">5.7.2.1.</span> <span class="toc-text">获取日期和时间的部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%9A%84%E9%83%A8%E5%88%86"><span class="toc-number">5.7.2.2.</span> <span class="toc-text">设置日期和时间的部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F"><span class="toc-number">5.7.2.3.</span> <span class="toc-text">格式化日期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-number">5.7.2.4.</span> <span class="toc-text">其他方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-toLocaleString"><span class="toc-number">5.7.2.4.1.</span> <span class="toc-text">1. toLocaleString()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-toLocaleDateString"><span class="toc-number">5.7.2.4.2.</span> <span class="toc-text">2. toLocaleDateString()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-toLocaleTimeString"><span class="toc-number">5.7.2.4.3.</span> <span class="toc-text">3. toLocaleTimeString()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E9%80%89%E9%A1%B9"><span class="toc-number">5.7.2.4.4.</span> <span class="toc-text">参数选项</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E6%96%B9%E6%B3%95"><span class="toc-number">5.7.2.5.</span> <span class="toc-text">更多方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-number">5.7.3.</span> <span class="toc-text">时间戳</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-number">5.7.3.0.1.</span> <span class="toc-text">获取时间戳</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%97%A5%E6%9C%9F"><span class="toc-number">5.7.3.0.2.</span> <span class="toc-text">时间戳转换为日期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-number">5.7.3.0.3.</span> <span class="toc-text">使用时间戳</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="toc-number">5.7.3.0.4.</span> <span class="toc-text">实际应用</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JS%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC"><span class="toc-number">6.</span> <span class="toc-text">JS事件监听</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A"><span class="toc-number">6.1.</span> <span class="toc-text">事件绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E4%BA%8B%E4%BB%B6"><span class="toc-number">6.2.</span> <span class="toc-text">常见事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6"><span class="toc-number">6.2.1.</span> <span class="toc-text">鼠标事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6"><span class="toc-number">6.2.2.</span> <span class="toc-text">键盘事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E5%92%8C%E7%AA%97%E5%8F%A3-window-%E4%BA%8B%E4%BB%B6"><span class="toc-number">6.2.3.</span> <span class="toc-text">文档和窗口(window)事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E4%BA%8B%E4%BB%B6"><span class="toc-number">6.2.4.</span> <span class="toc-text">表单事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E4%BA%8B%E4%BB%B6"><span class="toc-number">6.2.5.</span> <span class="toc-text">其他事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.3.</span> <span class="toc-text">事件对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.4.</span> <span class="toc-text">环境对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-number">6.5.</span> <span class="toc-text">事件流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7-Event-Capturing"><span class="toc-number">6.5.1.</span> <span class="toc-text">事件捕获 (Event Capturing)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E9%98%B6%E6%AE%B5-Target-Phase"><span class="toc-number">6.5.2.</span> <span class="toc-text">目标阶段 (Target Phase)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1-Event-Bubbling"><span class="toc-number">6.5.3.</span> <span class="toc-text">事件冒泡 (Event Bubbling)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%9A%84%E4%BC%A0%E6%92%AD%E6%96%B9%E5%90%91"><span class="toc-number">6.5.4.</span> <span class="toc-text">事件流的传播方向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">6.5.5.</span> <span class="toc-text">使用事件处理程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1"><span class="toc-number">6.6.</span> <span class="toc-text">阻止冒泡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E8%A7%A3%E7%BB%91"><span class="toc-number">6.7.</span> <span class="toc-text">事件解绑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">6.8.</span> <span class="toc-text">事件委托</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">6.8.1.</span> <span class="toc-text">如何实现事件委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">6.8.2.</span> <span class="toc-text">实现步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">6.8.3.</span> <span class="toc-text">示例代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E7%9A%84%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA"><span class="toc-number">6.9.</span> <span class="toc-text">阻止事件的默认行为</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">7.</span> <span class="toc-text">元素在页面中的位置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8"><span class="toc-number">7.1.</span> <span class="toc-text">页面滚动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cliet%E5%AE%B6%E6%97%8F"><span class="toc-number">7.2.</span> <span class="toc-text">cliet家族</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#offset%E5%AE%B6%E6%97%8F"><span class="toc-number">7.3.</span> <span class="toc-text">offset家族</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%A4%A7%E5%B0%8F%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%8F%A6%E5%A4%96%E6%96%B9%E6%B3%95"><span class="toc-number">7.4.</span> <span class="toc-text">获取元素大小位置的另外方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F-1"><span class="toc-number">8.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8F%98%E9%87%8F%E7%9A%84%E8%B5%8B%E5%80%BC"><span class="toc-number">8.1.</span> <span class="toc-text">1.变量的赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-var%E3%80%81const%E3%80%81let%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.2.</span> <span class="toc-text">2.var、const、let的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8var-%E5%A3%B0%E6%98%8E"><span class="toc-number">8.2.1.</span> <span class="toc-text">为什么不用var 声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8-let-%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9A"><span class="toc-number">8.2.2.</span> <span class="toc-text">推荐使用 let 的情况：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8-const-%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9A"><span class="toc-number">8.2.3.</span> <span class="toc-text">推荐使用 const 的情况：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">8.2.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#webAPI%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86"><span class="toc-number">9.</span> <span class="toc-text">webAPI基本认识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96DOM%E5%85%83%E7%B4%A0"><span class="toc-number">9.1.</span> <span class="toc-text">获取DOM元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AECSS%E9%80%89%E6%8B%A9%E5%99%A8%E6%9D%A5%E8%8E%B7%E5%8F%96DOM%E5%85%83%E7%B4%A0"><span class="toc-number">9.1.1.</span> <span class="toc-text">根据CSS选择器来获取DOM元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%8E%B7%E5%8F%96DOM%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">9.1.2.</span> <span class="toc-text">其他获取DOM元素的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0%E5%86%85%E5%AE%B9"><span class="toc-number">9.2.</span> <span class="toc-text">操作元素内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1-innerHtml%E5%B1%9E%E6%80%A7"><span class="toc-number">9.2.1.</span> <span class="toc-text">对象.innerHtml属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1-innerText%E5%B1%9E%E6%80%A7"><span class="toc-number">9.2.2.</span> <span class="toc-text">对象.innerText属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">9.2.3.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">9.3.</span> <span class="toc-text">操作元素的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">9.3.1.</span> <span class="toc-text">操作元素常用属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B"><span class="toc-number">9.3.1.1.</span> <span class="toc-text">举例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0%E6%A0%B7%E5%BC%8F%E5%B1%9E%E6%80%A7"><span class="toc-number">9.3.2.</span> <span class="toc-text">操作元素样式属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87style%E5%B1%9E%E6%80%A7%E6%9D%A5%E6%93%8D%E4%BD%9CCSS"><span class="toc-number">9.3.2.1.</span> <span class="toc-text">通过style属性来操作CSS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%B1%BB%E5%90%8D-className-%E6%9D%A5%E6%93%8D%E4%BD%9CCSS"><span class="toc-number">9.3.2.2.</span> <span class="toc-text">通过类名(className)来操作CSS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87classList%E6%93%8D%E4%BD%9C%E7%B1%BB%E6%8E%A7%E5%88%B6CSS"><span class="toc-number">9.3.2.3.</span> <span class="toc-text">通过classList操作类控制CSS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7"><span class="toc-number">9.3.3.</span> <span class="toc-text">操作表单元素属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AE%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0%E7%9A%84%E5%80%BC"><span class="toc-number">9.3.3.1.</span> <span class="toc-text">获取和设置表单元素的值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E5%A4%8D%E9%80%89%E6%A1%86%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">9.3.3.2.</span> <span class="toc-text">检查复选框的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%A4%8D%E9%80%89%E6%A1%86%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">9.3.3.3.</span> <span class="toc-text">设置复选框的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E9%80%89%E6%8B%A9%E6%A1%86%EF%BC%88%E4%B8%8B%E6%8B%89%E5%88%97%E8%A1%A8%EF%BC%89"><span class="toc-number">9.3.3.4.</span> <span class="toc-text">操作选择框（下拉列表）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0"><span class="toc-number">9.3.3.5.</span> <span class="toc-text">添加和删除表单元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%92%8C%E8%8E%B7%E5%8F%96%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0%E7%9A%84CSS%E6%A0%B7%E5%BC%8F"><span class="toc-number">9.3.3.6.</span> <span class="toc-text">设置和获取表单元素的CSS样式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E8%A1%A8%E5%8D%95%E4%BA%8B%E4%BB%B6"><span class="toc-number">9.3.3.7.</span> <span class="toc-text">监听表单事件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="toc-number">9.4.</span> <span class="toc-text">本地存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#localStorage-%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.4.1.</span> <span class="toc-text">localStorage 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#setItem-key-value"><span class="toc-number">9.4.1.1.</span> <span class="toc-text">setItem(key,value)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getItem-key"><span class="toc-number">9.4.1.2.</span> <span class="toc-text">getItem(key)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#removeItem-key"><span class="toc-number">9.4.1.3.</span> <span class="toc-text">removeItem(key)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sessionStorage-%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.4.2.</span> <span class="toc-text">sessionStorage 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#setItem-key-value-1"><span class="toc-number">9.4.2.1.</span> <span class="toc-text">setItem(key,value)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getItem-key-1"><span class="toc-number">9.4.2.2.</span> <span class="toc-text">getItem(key)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#removeItem-key-1"><span class="toc-number">9.4.2.3.</span> <span class="toc-text">removeItem(key)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">9.4.3.</span> <span class="toc-text">存储复杂类型的数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Storage-%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">9.4.4.</span> <span class="toc-text">Storage 对象属性和方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">10.</span> <span class="toc-text">正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">10.1.</span> <span class="toc-text">创建正则表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.2.</span> <span class="toc-text">常用的正则表达式模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-number">10.3.</span> <span class="toc-text">使用正则表达式的常见方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E5%AD%97%E7%AC%A6"><span class="toc-number">10.4.</span> <span class="toc-text">元字符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%85%83%E5%AD%97%E7%AC%A6"><span class="toc-number">10.4.1.</span> <span class="toc-text">常见元字符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E7%AC%A6"><span class="toc-number">10.4.1.1.</span> <span class="toc-text">边界符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8F%E8%AF%8D"><span class="toc-number">10.4.1.2.</span> <span class="toc-text">量词</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%B1%BB"><span class="toc-number">10.4.1.3.</span> <span class="toc-text">字符类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">10.4.1.4.</span> <span class="toc-text">修饰符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">10.4.2.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E4%BB%BB%E4%BD%95%E6%95%B0%E5%AD%97"><span class="toc-number">10.4.2.1.</span> <span class="toc-text">匹配任何数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E4%BB%A5%E6%95%B0%E5%AD%97%E5%BC%80%E5%A4%B4%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">10.4.2.2.</span> <span class="toc-text">匹配以数字开头的字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E4%BB%A5%E6%95%B0%E5%AD%97%E7%BB%93%E5%B0%BE%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">10.4.2.3.</span> <span class="toc-text">匹配以数字结尾的字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E8%BF%9E%E7%BB%AD%E4%B8%89%E4%B8%AA%E6%88%96%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-number">10.4.2.4.</span> <span class="toc-text">匹配连续三个或更多的字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E8%BF%9E%E7%BB%AD%E4%B8%80%E4%B8%AA%E5%88%B0%E4%B8%89%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-number">10.4.2.5.</span> <span class="toc-text">匹配连续一个到三次的字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E4%BB%BB%E4%BD%95%E6%95%B0%E5%AD%97%E6%88%96%E5%AD%97%E6%AF%8D"><span class="toc-number">10.4.2.6.</span> <span class="toc-text">匹配任何数字或字母</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E4%BB%BB%E4%BD%95%E9%9D%9E%E6%95%B0%E5%AD%97"><span class="toc-number">10.4.2.7.</span> <span class="toc-text">匹配任何非数字</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript%E5%BC%82%E6%AD%A5"><span class="toc-number">11.</span> <span class="toc-text">JavaScript异步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E4%B8%AD%E7%9A%84Promise-%E6%9B%B4%E8%AF%A6%E7%BB%86%E8%AF%B7%E7%A7%BB%E6%AD%A5%E7%AC%94%E8%AE%B0Vue%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-md"><span class="toc-number">11.1.</span> <span class="toc-text">JS中的Promise(更详细请移步笔记Vue前置知识.md)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">11.1.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#promise%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">11.1.2.</span> <span class="toc-text">promise的三种状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#promise%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">11.1.3.</span> <span class="toc-text">promise对象的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1"><span class="toc-number">11.1.4.</span> <span class="toc-text">回调地狱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#promise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8"><span class="toc-number">11.1.5.</span> <span class="toc-text">promise链式调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-Async-%E5%BC%82%E6%AD%A5"><span class="toc-number">11.2.</span> <span class="toc-text">JavaScript Async(异步)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Async-%E8%AF%AD%E6%B3%95"><span class="toc-number">11.2.1.</span> <span class="toc-text">Async 语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Await-%E8%AF%AD%E6%B3%95"><span class="toc-number">11.2.2.</span> <span class="toc-text">Await 语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">11.2.3.</span> <span class="toc-text">基础语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async%E5%92%8Cawait%E6%8D%95%E8%8E%B7%E9%94%99%E8%AF%AF"><span class="toc-number">11.2.4.</span> <span class="toc-text">async和await捕获错误</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ajax"><span class="toc-number">12.</span> <span class="toc-text">Ajax</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Axios"><span class="toc-number">12.1.</span> <span class="toc-text">Axios</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-1"><span class="toc-number">12.1.1.</span> <span class="toc-text">基础语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E9%85%8D%E7%BD%AE"><span class="toc-number">12.1.2.</span> <span class="toc-text">请求配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="toc-number">12.1.2.1.</span> <span class="toc-text">常用配置项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">12.1.3.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="toc-number">12.1.4.</span> <span class="toc-text">请求方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">12.1.5.</span> <span class="toc-text">HTTP响应状态码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%8A%9F%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">12.1.5.1.</span> <span class="toc-text">成功状态码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">12.1.5.2.</span> <span class="toc-text">重定向状态码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">12.1.5.3.</span> <span class="toc-text">客户端错误状态码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">12.1.5.4.</span> <span class="toc-text">服务器错误状态码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Ajax"><span class="toc-number">12.2.</span> <span class="toc-text">什么是 Ajax</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ajax%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C"><span class="toc-number">12.3.</span> <span class="toc-text">Ajax如何工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ajax%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">12.4.</span> <span class="toc-text">Ajax基础语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ajax%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-number">12.5.</span> <span class="toc-text">Ajax传递参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%BA%E5%B8%A6%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0"><span class="toc-number">12.5.1.</span> <span class="toc-text">携带查询参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%BA%E5%B8%A6%E8%A6%81%E6%8F%90%E4%BA%A4%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">12.5.2.</span> <span class="toc-text">携带要提交的数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xhr%E5%AF%B9%E8%B1%A1"><span class="toc-number">12.6.</span> <span class="toc-text">xhr对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97xhr%E5%AF%B9%E8%B1%A1"><span class="toc-number">12.6.1.</span> <span class="toc-text">获得xhr对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xhr%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">12.7.</span> <span class="toc-text">xhr对象方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xhr%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7"><span class="toc-number">12.8.</span> <span class="toc-text">xhr对象属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82-%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="toc-number">12.9.</span> <span class="toc-text">同步请求&#x2F;异步请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E8%AF%B7%E6%B1%82"><span class="toc-number">12.10.</span> <span class="toc-text">服务器响应请求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E5%B1%9E%E6%80%A7"><span class="toc-number">12.10.1.</span> <span class="toc-text">服务器响应属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#responseText-%E5%B1%9E%E6%80%A7"><span class="toc-number">12.10.1.1.</span> <span class="toc-text">responseText 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#responseXML-%E5%B1%9E%E6%80%A7"><span class="toc-number">12.10.1.2.</span> <span class="toc-text">responseXML 属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E6%96%B9%E6%B3%95"><span class="toc-number">12.10.2.</span> <span class="toc-text">服务器响应方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#getAllResponseHeaders-%E6%96%B9%E6%B3%95"><span class="toc-number">12.10.2.1.</span> <span class="toc-text">getAllResponseHeaders() 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">12.10.2.1.1.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getResponseHeader-%E6%96%B9%E6%B3%95"><span class="toc-number">12.10.2.2.</span> <span class="toc-text">getResponseHeader() 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-1"><span class="toc-number">12.10.2.2.1.</span> <span class="toc-text">实例</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript%E8%BF%9B%E9%98%B6"><span class="toc-number">13.</span> <span class="toc-text">JavaScript进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E4%B8%AD%E7%9A%84%E5%A0%86%E5%92%8C%E6%A0%88"><span class="toc-number">13.1.</span> <span class="toc-text">JS中的堆和栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%EF%BC%88Stack%EF%BC%89"><span class="toc-number">13.1.1.</span> <span class="toc-text">栈（Stack）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%EF%BC%88Heap%EF%BC%89"><span class="toc-number">13.1.2.</span> <span class="toc-text">堆（Heap）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB"><span class="toc-number">13.1.3.</span> <span class="toc-text">关键区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">13.2.</span> <span class="toc-text">作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">13.2.1.</span> <span class="toc-text">局部作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">13.2.1.1.</span> <span class="toc-text">函数作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">13.2.1.2.</span> <span class="toc-text">块作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">13.2.1.3.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">13.2.2.</span> <span class="toc-text">全局作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">13.2.3.</span> <span class="toc-text">作用域链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">13.3.</span> <span class="toc-text">JS垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E4%B8%8E%E6%B8%85%E9%99%A4%EF%BC%88Mark-and-Sweep%EF%BC%89"><span class="toc-number">13.3.1.</span> <span class="toc-text">标记与清除（Mark and Sweep）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%EF%BC%88Reference-Counting%EF%BC%89"><span class="toc-number">13.3.2.</span> <span class="toc-text">引用计数（Reference Counting）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%EF%BC%88Generational-Collection%EF%BC%89"><span class="toc-number">13.3.3.</span> <span class="toc-text">分代收集（Generational Collection）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%EF%BC%88Incremental-Collection%EF%BC%89"><span class="toc-number">13.3.4.</span> <span class="toc-text">增量收集（Incremental Collection）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%EF%BC%88Compaction%EF%BC%89"><span class="toc-number">13.3.5.</span> <span class="toc-text">压缩（Compaction）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">13.3.6.</span> <span class="toc-text">如何避免内存泄漏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">13.4.</span> <span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%BD%A2%E6%88%90"><span class="toc-number">13.4.1.</span> <span class="toc-text">闭包的形成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">13.4.2.</span> <span class="toc-text">闭包的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="toc-number">13.5.</span> <span class="toc-text">变量提升</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6"><span class="toc-number">13.6.</span> <span class="toc-text">函数进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87"><span class="toc-number">13.6.1.</span> <span class="toc-text">函数提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">13.6.2.</span> <span class="toc-text">函数参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">13.6.2.1.</span> <span class="toc-text">默认参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0"><span class="toc-number">13.6.2.2.</span> <span class="toc-text">动态参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">13.6.3.</span> <span class="toc-text">箭头函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">13.6.3.1.</span> <span class="toc-text">箭头函数的参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84this"><span class="toc-number">13.6.3.2.</span> <span class="toc-text">箭头函数中的this</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">13.7.</span> <span class="toc-text">解构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%BB%93%E6%9E%84"><span class="toc-number">13.7.1.</span> <span class="toc-text">数组结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%BD%E7%95%A5%E6%9F%90%E4%BA%9B%E5%80%BC"><span class="toc-number">13.7.1.1.</span> <span class="toc-text">忽略某些值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">13.7.1.2.</span> <span class="toc-text">使用默认值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E5%B5%8C%E5%A5%97%E6%95%B0%E7%BB%84"><span class="toc-number">13.7.1.3.</span> <span class="toc-text">解构嵌套数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84"><span class="toc-number">13.7.2.</span> <span class="toc-text">对象结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E5%9F%BA%E6%9C%AC%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.7.2.1.</span> <span class="toc-text">解构基本对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%BD%E7%95%A5%E6%9F%90%E4%BA%9B%E5%B1%9E%E6%80%A7"><span class="toc-number">13.7.2.2.</span> <span class="toc-text">忽略某些属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E5%80%BC-1"><span class="toc-number">13.7.2.3.</span> <span class="toc-text">使用默认值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E5%B5%8C%E5%A5%97%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.7.2.4.</span> <span class="toc-text">解构嵌套对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E5%B9%B6%E9%87%8D%E5%91%BD%E5%90%8D%E5%B1%9E%E6%80%A7"><span class="toc-number">13.7.2.5.</span> <span class="toc-text">解构并重命名属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.8.</span> <span class="toc-text">深入对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.8.1.</span> <span class="toc-text">创建对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">13.8.2.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">13.8.3.</span> <span class="toc-text">实例成员&amp;静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">13.8.4.</span> <span class="toc-text">存在的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">13.9.</span> <span class="toc-text">内置构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object%E2%80%94%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.9.1.</span> <span class="toc-text">Object—对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array%E2%80%94%E6%95%B0%E7%BB%84"><span class="toc-number">13.9.2.</span> <span class="toc-text">Array—数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Number%E2%80%94%E6%95%B0%E5%80%BC"><span class="toc-number">13.9.3.</span> <span class="toc-text">Number—数值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3"><span class="toc-number">13.10.</span> <span class="toc-text">两种编程思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%EF%BC%88Procedural-Programming%EF%BC%89"><span class="toc-number">13.10.1.</span> <span class="toc-text">1. 面向过程编程（Procedural Programming）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88Object-Oriented-Programming-OOP%EF%BC%89"><span class="toc-number">13.10.2.</span> <span class="toc-text">2. 面向对象编程（Object-Oriented Programming, OOP）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B-%E9%87%8D%E8%A6%81"><span class="toc-number">13.11.</span> <span class="toc-text">原型(重要)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.11.1.</span> <span class="toc-text">原型对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constructor%E5%B1%9E%E6%80%A7"><span class="toc-number">13.11.2.</span> <span class="toc-text">constructor属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B"><span class="toc-number">13.11.3.</span> <span class="toc-text">对象原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF"><span class="toc-number">13.11.4.</span> <span class="toc-text">原型继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">13.11.4.1.</span> <span class="toc-text">出现的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">13.11.5.</span> <span class="toc-text">原型链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">13.12.</span> <span class="toc-text">深浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D-Shallow-Copy"><span class="toc-number">13.12.1.</span> <span class="toc-text">浅拷贝 (Shallow Copy)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D-Deep-Copy"><span class="toc-number">13.12.2.</span> <span class="toc-text">深拷贝 (Deep Copy)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">13.13.</span> <span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E8%AF%AD%E6%B3%95"><span class="toc-number">13.13.1.</span> <span class="toc-text">异常处理语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0this"><span class="toc-number">13.14.</span> <span class="toc-text">深度学习this</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E6%8C%87%E5%90%91"><span class="toc-number">13.14.1.</span> <span class="toc-text">this指向</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0"><span class="toc-number">13.14.1.1.</span> <span class="toc-text">针对普通函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">13.14.1.2.</span> <span class="toc-text">针对箭头函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E5%8F%98this%E6%8C%87%E5%90%91"><span class="toc-number">13.14.2.</span> <span class="toc-text">改变this指向</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-call"><span class="toc-number">13.14.2.1.</span> <span class="toc-text">使用 .call()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-apply"><span class="toc-number">13.14.2.2.</span> <span class="toc-text">使用 .apply()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-bind"><span class="toc-number">13.14.2.3.</span> <span class="toc-text">使用 .bind()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%9B%BE"><span class="toc-number">13.14.2.4.</span> <span class="toc-text">理解图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="toc-number">13.15.</span> <span class="toc-text">防抖和节流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%8A%96"><span class="toc-number">13.15.0.1.</span> <span class="toc-text">防抖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E6%B5%81"><span class="toc-number">13.15.0.2.</span> <span class="toc-text">节流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">13.15.0.3.</span> <span class="toc-text">防抖和节流的总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JS%E6%8F%92%E4%BB%B6"><span class="toc-number">14.</span> <span class="toc-text">JS插件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%B6%E4%BD%9C%E8%BD%AE%E6%92%AD%E5%9B%BE"><span class="toc-number">14.1.</span> <span class="toc-text">制作轮播图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E5%86%85%E5%AE%B9"><span class="toc-number">14.2.</span> <span class="toc-text">快速收集表单内容</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构">数据结构</a><time datetime="2024-09-15T03:57:19.000Z" title="发表于 2024-09-15 11:57:19">2024-09-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/12/%E7%AE%97%E6%B3%95%E8%B7%9F%E5%AD%A6/" title="算法跟学">算法跟学</a><time datetime="2024-09-12T13:58:11.000Z" title="发表于 2024-09-12 21:58:11">2024-09-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/04/%E9%A1%B9%E7%9B%AEAI%E7%BB%98%E7%94%BB%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/" title="项目AI绘画开发总结">项目AI绘画开发总结</a><time datetime="2024-09-04T00:25:48.000Z" title="发表于 2024-09-04 08:25:48">2024-09-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/02/TypeScript/" title="TypeScript">TypeScript</a><time datetime="2024-09-02T01:29:05.000Z" title="发表于 2024-09-02 09:29:05">2024-09-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/09/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/" title="移动端开发+less+BSP">移动端开发+less+BSP</a><time datetime="2024-08-09T10:44:43.000Z" title="发表于 2024-08-09 18:44:43">2024-08-09</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="LiSir" target="_blank">LiSir</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">2</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://newerproduct.github.io/" title="我的博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/touxiang.jpg" alt="我的博客"/><span class="back-menu-item-text">我的博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="鱼图床"/><span class="back-menu-item-text">鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/HTML-CSS/" style="font-size: 0.88rem;">HTML,CSS<sup>1</sup></a><a href="/tags/JS/" style="font-size: 0.88rem;">JS<sup>1</sup></a><a href="/tags/JavaWeb/" style="font-size: 0.88rem;">JavaWeb<sup>1</sup></a><a href="/tags/Java%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">Java学习<sup>1</sup></a><a href="/tags/TypeScript/" style="font-size: 0.88rem;">TypeScript<sup>1</sup></a><a href="/tags/git%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">git学习<sup>1</sup></a><a href="/tags/jQuery/" style="font-size: 0.88rem;">jQuery<sup>1</sup></a><a href="/tags/java%E5%92%8Cvue%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E6%94%B9%E6%AD%A3%E5%92%8C%E5%AF%B9%E4%BB%96%E4%BB%AC%E7%9A%84%E7%90%86%E8%A7%A3%E6%95%B4%E7%90%86-%E5%8F%82%E5%8A%A0%E7%9A%84%E9%A1%B9%E7%9B%AE/" style="font-size: 0.88rem;">java和vue开发中遇到的错误以及如何改正和对他们的理解整理(参加的项目)<sup>1</sup></a><a href="/tags/js-node-js/" style="font-size: 0.88rem;">js-node.js<sup>1</sup></a><a href="/tags/jwt-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81-cookie/" style="font-size: 0.88rem;">jwt,身份认证,cookie<sup>1</sup></a><a href="/tags/nginx%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">nginx学习<sup>1</sup></a><a href="/tags/uni-app%E6%A1%86%E6%9E%B6/" style="font-size: 0.88rem;">uni-app框架<sup>1</sup></a><a href="/tags/vue-js/" style="font-size: 0.88rem;">vue.js<sup>1</sup></a><a href="/tags/vue-js%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/" style="font-size: 0.88rem;">vue.js前置知识<sup>1</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF-web-%E6%A1%86%E6%9E%B6/" style="font-size: 0.88rem;">前端,web,框架<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/" style="font-size: 0.88rem;">开发总结<sup>1</sup></a><a href="/tags/%E6%89%8B%E6%9C%BA%EF%BC%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%8Cless/" style="font-size: 0.88rem;">手机，移动端，less<sup>1</sup></a><a href="/tags/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%EF%BC%8C%E6%A8%A1%E5%9D%97/" style="font-size: 0.88rem;">打包工具，模块<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>1</sup></a><a href="/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-vue2-js/" style="font-size: 0.88rem;">状态管理工具(vue2.js)<sup>1</sup></a><a href="/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-vue3-js/" style="font-size: 0.88rem;">状态管理工具(vue3.js)<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 LiSir 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>
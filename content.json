{"meta":{"title":"LiSir","subtitle":"心怀远方","description":"","author":"李泽伟","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2024-07-08T10:04:11.000Z","updated":"2024-07-08T11:39:20.851Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"categories","date":"2024-07-08T11:34:48.000Z","updated":"2024-07-08T11:39:30.431Z","comments":true,"path":"categories/index-1.html","permalink":"http://example.com/categories/index-1.html","excerpt":"","text":""},{"title":"","date":"2024-07-08T11:01:05.658Z","updated":"2024-07-08T11:01:05.658Z","comments":true,"path":"json/music.json","permalink":"http://example.com/json/music.json","excerpt":"","text":"[{\"name\":\"青花瓷\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.4/青花瓷/青花瓷.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000002eFUFm2XYZ7z_2.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.4/青花瓷/青花瓷.lrc\"},{\"name\":\"稻香\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/稻香/稻香.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/稻香/稻香.lrc\"},{\"name\":\"晴天\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/晴天/晴天.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000000MkMni19ClKG_3.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/晴天/晴天.lrc\"},{\"name\":\"七里香\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/七里香/七里香.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000003DFRzD192KKD_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/七里香/七里香.lrc\"},{\"name\":\"花海\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/花海/花海.flac\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/花海/花海.lrc\"},{\"name\":\"反方向的钟\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/反方向的钟/反方向的钟.flac\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000000f01724fd7TH_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/反方向的钟/反方向的钟.lrc\"},{\"name\":\"兰亭序\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/兰亭序/兰亭序.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/兰亭序/兰亭序.lrc\"},{\"name\":\"说好的辛福呢\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/说好的辛福呢/说好的辛福呢.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/说好的辛福呢/说好的幸福呢.lrc\"},{\"name\":\"等你下课 (with 杨瑞代)\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/等你下课/等你下课.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000003bSL0v4bpKAx_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/等你下课/等你下课.lrc\"},{\"name\":\"我落泪情绪零碎\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/我落泪情绪零碎/我落泪情绪零碎.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000000bviBl4FjTpO_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/我落泪情绪零碎/我落泪情绪零碎.lrc\"},{\"name\":\"听妈妈的话\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/听妈妈的话/听妈妈的话.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000002jLGWe16Tf1H_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/听妈妈的话/听妈妈的话.lrc\"},{\"name\":\"明明就\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/明明就/明明就.flac\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000003Ow85E3pnoqi_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/明明就/明明就.lrc\"},{\"name\":\"我是如此相信\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/我是如此相信/我是如此相信.flac\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000001hGx1Z0so1YX_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/我是如此相信/我是如此相信.lrc\"},{\"name\":\"发如雪\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.3/发如雪/发如雪.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M0000024bjiL2aocxT_3.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.3/发如雪/发如雪.lrc\"},{\"name\":\"以父之名\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.3/以父之名/以父之名.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000000MkMni19ClKG_3.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.3/以父之名/以父之名.lrc\"},{\"name\":\"园游会\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.3/园游会/园游会.flac\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000003DFRzD192KKD_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.3/园游会/园游会.lrc\"},{\"name\":\"本草纲目\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.4/本草纲目/本草纲目.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000002jLGWe16Tf1H_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.4/本草纲目/本草纲目.lrc\"},{\"name\":\"龙卷风\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.4/龙卷风/龙卷风.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000000f01724fd7TH_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.4/龙卷风/龙卷风.lrc\"}]"},{"title":"tags","date":"2024-05-20T09:20:46.000Z","updated":"2024-05-20T09:21:28.598Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"music","date":"2024-07-08T10:59:36.000Z","updated":"2024-07-08T11:00:14.773Z","comments":false,"path":"music/index.html","permalink":"http://example.com/music/index.html","excerpt":"","text":""}],"posts":[{"title":"Git的基本使用","slug":"Git的基本使用","date":"2024-07-08T07:53:36.000Z","updated":"2024-07-08T15:49:49.079Z","comments":true,"path":"2024/07/08/Git的基本使用/","permalink":"http://example.com/2024/07/08/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"","text":"1.了解GitGit是目前最流行的版本控制系统 快照： Git的快照记录类似于备份，是在原有文件版本上重新生成一份新的文件。如果文件没有修改，Git不再重新存储该文件，而是保留一个链接指向之前存储的文件。 本地执行： Git中的三个区域 1.工作区 2.暂存区 3.Git仓库 Git中的三种状态 1.已修改(modified) 2.已暂存(staged) 3.已提交(committed) Git基本工作流程 1.在工作区中修改文件 2.将你想要下次提交的更改进行暂存 3.提交更新，找到暂存区的文件，将快照永久性存储到Git仓库 2.Git的基本操作1.获取Git仓库的两种方式 2.在现有目录中初始化Git仓库对于一个尚未进行版本控制的项目，想用Git控制他，步骤如下 （1）项目根目录中鼠标右键打开”GitBash“ （2）执行git init命令将当前目录转为Git仓库 git init 命令会创建一个名字为.git的隐藏目录，这个.git目录就当前项目的Git仓库。不可删除 3.检查文件状态命令：git status 或 git status -s &#x2F; git status –short 状态1：未跟踪 状态2：已跟踪{ 1.已修改 2.已暂存 3.已提交 } 4.跟踪新文件命令：git add + 文件名 如果文件被跟踪，可以显示绿色A标记（精简查看文件状态） 5.提交更新命令：git commit [-m] 比如： git commit -m ‘测试提交更新’ -m是可选项，可以说明本次提交的简短说明 基本上一套流程是把未跟踪的文件添加到暂存区(git add +文件名)然后通过git commit 往仓库提交 6.对已提交的文件进行修改如果对已经提交的文件进行修改，那么它的状态会变成已修改但未提交。简短状态是文件名前面有个红色M 命令：git status -s 7.暂存已修改文件如果对于已提交的文件进行了修改，若是暂存这个修改的话需要再次运行 git add 命令，该命令有如下功效： 此时查看文件状态应该是一个绿色的M 8.提交已暂存的文件","categories":[],"tags":[{"name":"git学习","slug":"git学习","permalink":"http://example.com/tags/git%E5%AD%A6%E4%B9%A0/"}]},{"title":"jQuery学习","slug":"jQuery学习","date":"2024-07-06T10:12:07.000Z","updated":"2024-07-08T07:53:54.250Z","comments":true,"path":"2024/07/06/jQuery学习/","permalink":"http://example.com/2024/07/06/jQuery%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"jQuery第一部分1.使用准备首先来对比一下jQ语法和原生Dom语法 1234567// 原生js let liArr = document.querySelectorAll(&#x27;li&#x27;) for (let i = 0; i &lt; liArr.length; i++) &#123; liArr[i].onclick = function () &#123; this.style.backgroundColor = &#x27;orange&#x27; &#125; &#125; 1234// jQuery $(&#x27;li&#x27;).click(function () &#123; $(this).css(&#x27;backgroundColor&#x27;, &#x27;orange&#x27;)&#125;) 可以发现，通过jQ语法操作样式要比原生操作Dom简单不少，那么如何使用jQ呢？下面介绍 下包:你得先把这个别人写好js文件下载到本地 导包:下载完毕之后需要导入到使用的页面中 另起一行script输出一下$,看看是否输出了下图内容: 确保上一步做完之后,我们写一段测试代码 $(&#39;body&#39;).css(&#39;backgroundColor&#39;,&#39;yellowgreen&#39;) 123456789101112 2. 可以看出，操作的元素是body标签，设置的样式是背景色，且颜色为黄绿色。jQ官方网站：https://jquery.com/## 2.选择器jQuery中如何获取需要操纵的元素?在我们学习Dom的时候，想要操作这个元素，第一步也是先获取元素，所以在jQ学习中也是一样的，下面来介绍如何通过jQ的方式来获取元素，语法很简单:```js// 基本用法$(&#x27;选择器&#x27;) 直接调用$方法即可，选择器通过字符串的方式传递进去,基本上兼容所有css的选择器，比如标签选择器，类选择器，后代选择器等。导入了jQuery之后我们通过console的方式了$这个全局变量，打印的是一个函数。既然是函数加括号就是调用他。只不过之前的函数名都不是$而已。 标签选择： 12// 标签选择器$(&#x27;p&#x27;) 类选择器(在css中选择类就是.)： 12// 类选择器$(&#x27;.p&#x27;) id选择器 12// id 选择器$(&#x27;#p&#x27;) 后代选择器(这里选择body中的所有p标签为例子)： 12// 后代选择器$(&#x27;body p&#x27;) 小结: 选择器的语法咋写来着？ ​ 调用$方法然后以字符串的方式传入css的选择器即可。 3.jQuery对象jQuery 中利用选择器获取到的并非原生的 DOM 对象，而是 jQuery 对象，我们在学习jQ选择器的时候，调用$方法获取到的返回值就是jQuery对象，jQuery提供的绝大多数方法都需要通过jQuery对象才可以访问。 12// jQuery$(&#x27;p&#x27;) 然后我们通过css方法把元素的背景色变成了粉色 12// jQuery$(&#x27;p&#x27;).css(&#x27;backgroundColor&#x27;,&#x27;pink&#x27;) 如果使用Dom对象来实现，是这样的,先获取到dom对象，然后通过点语法访问style属性，接着为backgroundColor赋值. 1document.querySelector(&#x27;p&#x27;).style.backgroundColor = &#x27;pink&#x27; 注意：两者的写法不能混淆。 除了通过选择器以外，我们还可以把dom对象直接丢到$方法中，他返回的也是一个jQ对象，就可以使用jQuery提供的那些高级方法。 12$(&#x27;选择器&#x27;)$(dom对象) 就比如 123// 4. dom对象转jQ对象，li是一个dom对象 let $li2 = $(li) $li2.css(&#x27;backgroundColor&#x27;, &#x27;skyblue&#x27;) jQuery对象 调用$方法传入选择器或dom元素获取到的是什么对象 ？ jQuery对象 jQuery对象的方法,比如css方法放在什么位置？ 原型上 4.事件绑定语法是这样的：先通过选择器找到希望绑定的元素，然后然后调用对应的事件名方法，传入回调函数，逻辑直接写在回调函数里面即可。 123$(&#x27;选择器&#x27;).事件名(function () &#123; // 逻辑....&#125;) 注意：在操作dom元素时，我们在绑定事件的时候一是要在事件名称前面加上on，二是通过赋值号=来写对应事件的回调函数(触发事件时要做的逻辑),然而jQ语法是不一样的，这要注意了。 1234567891011// 1.为 li 添加点击事件$(&#x27;li&#x27;).click(function()&#123; console.log(&#x27;这是点击事件！&#x27;); //当触发点击事件时，把背景颜色变成红色 console.log(this) //这里的this是dom对象，你可以通过以下方法实现变红 this.style.background = &#x27;red&#x27; //也可以通过jQ语法变红，但是需要进行转换 let jqObj = $(this) jqObj.css(&#x27;background&#x27;,&#x27;red&#x27;);&#125;) 从上面可以看到，当我们操作jQ对象进行操作绑定事件时，不需要在加onxxxx 和 =，方便许多，这点注意。 其他事件，比如聚焦(focus)，失焦(blur)，鼠标移入移出等等，如下所示 123456789101112131415161718192021// 2.为 .text 添加获得焦点事件 $(&#x27;.text&#x27;).focus(function () &#123; console.log(&#x27;focus&#x27;) &#125;) // 3.为 .text 添加失去焦点事件 $(&#x27;.text&#x27;).blur(function () &#123; console.log(&#x27;blur&#x27;) &#125;) // 4.为 .box 添加鼠标移入事件 $(&#x27;.box&#x27;).mouseenter(function () &#123; console.log(&#x27;mouseenter&#x27;) $(this).css(&#x27;backgroundColor&#x27;, &#x27;pink&#x27;) &#125;) // 5.为 .box 添加鼠标移出事件 $(&#x27;.box&#x27;).mouseleave(function () &#123; console.log(&#x27;mouseleave&#x27;) $(this).css(&#x27;backgroundColor&#x27;, &#x27;yellowgreen&#x27;) &#125;) jQuery中的事件绑定。 为jQuery对象绑定事件时，方法名字中有没有on？ 没有，$(‘选择器’). 传入的回调函数中，如何获取触发事件的dom元素? this,可以调用$方法将他转为jQuery对象，从而使用jQuery对象强大的方法 5.链式编程指的是通过点把多个操作（方法）连续的写下去，这样形成的结构和链子一样，所以叫做链式编程。 上一节中的对于text类的操作方法，写了两部分重复了，下面来展示链式编程的写法： 1234567$(&#x27;.text&#x27;) .focus(function () &#123; console.log(&#x27;获取焦点&#x27;) &#125;) .blur(function () &#123; console.log(&#x27;失去焦点&#x27;) &#125;) 我们在.focus方法的后面继续点.blur就可以再为他绑定失去焦点事件。形式上看去就好比下面这样： 1$(&#x27;.text&#x27;).focus(回调函数).blur(回调函数) 甚至是： 1$(&#x27;.text&#x27;).focus(回调函数).blur(回调函数).change(回调函数) 为什么可以这么写？答：因为通过jQ对象调用的大部分方法返回的还是同一个jQ对象。 链式编程 链式编程的含义是? 通过 点 把多个操作连续的写下去, 形成和 链子 一样的结构 有没有特殊情况? 有 6.内容操纵如何通过jQuery操纵元素的内容 jQuery封装了2个方法让我们对元素的文本进行设置或者,根据是否传参功能是不一样的,如何使用呢? 传递参数就是设置,不传递参数就是取值 123456// 设置$(&#x27;选择器&#x27;).html(&#x27;内容&#x27;)$(&#x27;选择器&#x27;).text(&#x27;内容&#x27;)// 取值$(&#x27;选择器&#x27;).html()$(&#x27;选择器&#x27;).text() 如果，我们要设置的内容中包含标签，那么就用.html()方法。如果要获取的内容只希望获取文本内容，不包含标签，那么推荐使用.text()方法 举例，设置普通文本： 123// 1. 设置普通文本$(&#x27;.box1&#x27;).html(&#x27;测试内容&#x27;)$(&#x27;.box2&#x27;).text(&#x27;测试内容&#x27;) 这两种方式，在页面中呈现的内容是一样的 但是如果，这时我们在带入标签进行内容的设置，代码是： 123// 2. 设置标签$(&#x27;.box1&#x27;).html(&#x27; &lt;a href=&quot;#&quot;&gt;黑马程序员&lt;/a&gt;&#x27;)$(&#x27;.box2&#x27;).text(&#x27; &lt;a href=&quot;#&quot;&gt;黑马程序员&lt;/a&gt;&#x27;) 可以清楚的发现.text方法并没有将a标签解析，而.html方法解析了 接下来测试取值。 1234567// 3. 取值 let htmlContent = $(&#x27;.box1&#x27;).html(); //包含标签 console.log(htmlContent); let textContent = $(&#x27;.box1&#x27;).text(); //包含文本 console.log(textContent); 结果 可以看到，html方法的取值可以将标签取到并输出。而text方法只能取到文本，也就是标签的内容。 下面来说一点链式编程不适用的情况。链式编程是只要你返回的对象是jQ对象，就可以继续..来执行下面的方法，我们只需要比较在赋值时，将被赋值的内容获取，在与jQ选择器获取的对象进行比较即可 123let $box1 = $(&#x27;.box1&#x27;)let $res = $box1.html(&#x27;测试内容&#x27;)console.log($box1===$res) // true 说明$box1和$res是同一个jq对象,那么进行赋值操作的时候就可以调用其他的jq方法。 哪个方法设置的标签会被正常解析？ html方法 只获取元素的文本使用哪个方法? text方法 赋值还是取值支持链式编程? ​ 赋值 案例1:计数器1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;案例计数器&lt;/title&gt;&lt;/head&gt;&lt;!-- 引入jQ --&gt;&lt;script src=&quot;../jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt;&lt;body&gt; &lt;div class=&quot;input-num&quot;&gt; &lt;!-- 减号 --&gt; &lt;button id=&quot;btn1&quot;&gt; - &lt;/button&gt; &lt;!-- 内容 --&gt; &lt;span&gt;0&lt;/span&gt; &lt;!-- 加号 --&gt; &lt;button id=&quot;btn2&quot;&gt; + &lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; let i = $(&#x27;.input-num span&#x27;).text(); console.log(i); // 分情况讨论 $(&#x27;.input-num #btn1&#x27;).click(function()&#123; let btn1Obj = $(&#x27;.input-num #btn1&#x27;) if(i !== 0)&#123; i--; $(&#x27;.input-num span&#x27;).text(i) &#125;else&#123; window.alert(&#x27;i已经是0了,不能够继续递减了!&#x27;) &#125; &#125;) $(&#x27;.input-num #btn2&#x27;).click(function()&#123; let btn2Obj = $(&#x27;.input-num #btn2&#x27;) if(i == 10)&#123; window.alert(&quot;i已经到最大值10了,不能够增加了&quot;) &#125;else&#123; i++; $(&#x27;.input-num span&#x27;).text(i) &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 针对于两个按钮，除了可以按照上面的那种方法来给它们写一个不同的id以外，还可以用伪类选择器，指的是，在一个大元素中的第一个子元素和最后一个子元素，可以用到下面这样的 last-child和first-child叫做什么选择器? 伪类选择器 写法： span里面的文本设置和取值用的是什么方法 text方法 7.过滤方法使用jQuery的过滤方法对找到的元素再次筛选 jQuery中的过滤方法,作用是对jQuery对象中的dom元素再次进行筛选,让我们更精确的定位到希望操纵的元素。 方法一共有3个,分别是first,last,和eq,其中first和last不需要传递参数,作用分别是获取到第一个和最后一个元素,eq方法需要传递索引作为参数,索引从0开始.这三个方法返回的都是jQ对象,这就意味着我们可以直接用点语法调用我们目前学过的那些方法,比如绑定事件,修改内容等等 现在针对上面的内容，对案例：计数器中的进行改写如下 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;案例计数器&lt;/title&gt;&lt;/head&gt;&lt;!-- 引入jQ --&gt;&lt;script src=&quot;../jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt;&lt;body&gt; &lt;div class=&quot;input-num&quot;&gt; &lt;!-- 减号 --&gt; &lt;button &gt; - &lt;/button&gt; &lt;!-- 内容 --&gt; &lt;span&gt;0&lt;/span&gt; &lt;!-- 加号 --&gt; &lt;button &gt; + &lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; let i = $(&#x27;.input-num span&#x27;).text(); console.log(i); // 分情况讨论 $(&#x27;.input-num button &#x27;).first().click(function()&#123; if(i != 0)&#123; i--; $(&#x27;.input-num span&#x27;).text(i) &#125;else&#123; window.alert(&#x27;i已经是0了,不能够继续递减了!&#x27;) &#125; &#125;) $(&#x27;.input-num button&#x27;).last().click(function()&#123; if(i == 10)&#123; window.alert(&quot;i已经到最大值10了,不能够增加了&quot;) &#125;else&#123; i++; $(&#x27;.input-num span&#x27;).text(i) &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 8.样式操纵基础语法： 123.css(&#x27;样式名&#x27;,&#x27;值&#x27;)//注意，驼峰命名，否则不识别.css(&#x27;backgroundColor&#x27;,&#x27;pink&#x27;) 如果要设置多个样式，可以以对象的形式进行传递 语法： 1234567.css(对象).css(&#123; backgroundColor:&#x27;pink&#x27;, color:&#x27;red&#x27;, width:&#x27;200px&#x27;, height:200&#125;) 同样，也可以获取对应样式名字的值 语法： 12.css(&#x27;样式名&#x27;).css(&#x27;width&#x27;) css方法取值时是否需要传递参数? 需要，需要告诉css方法希望获取的是什么样式 设置时数值类的样式省略单位,默认值是什么？ px css方法设置的样式在元素什么位置? 行内 9.属性操纵使用jQuery提供的方法操纵元素的属性 示例代码： 12&lt;a href=&quot;https://www.baidu.com&quot;&gt;点击跳转百度&lt;/a&gt;&lt;img src=&quot;logo.png&quot; info=&quot;测试照片&quot; /&gt; 方法有2个，分别是attr和removeAttr，其中attr方法可以用来设置或者读取属性，removeAttr的作用是删除属性 我们先来看看attr方法的用法 设置属性是通过attr方法传入两个参数，分别是属性名和设置的值 取值需传入属性名就好，和css方法是一致的。 基础语法： // 赋值 .attr(&#39;属性名&#39;,&#39;值&#39;) // 取值 .attr(&#39;属性名&#39;) 12345678removeAttr方法基础语法：```js// 删除属性.removeAttr(&#x27;属性名&#x27;) 示例代码： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;12-属性操纵&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 测试用标签 --&gt; &lt;a href=&quot;#&quot;&gt;黑马程序员&lt;/a&gt; &lt;img src=&quot;&quot; /&gt; &lt;!-- 导入 jQuery --&gt; &lt;script src=&quot;./jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 1. 赋值 $(&#x27;a&#x27;).attr(&#x27;href&#x27;, &#x27;http://www.baidu.com/&#x27;) $(&#x27;img&#x27;).attr(&#x27;src&#x27;, &#x27;http://www.baidu.com/images/logo.png&#x27;) $(&#x27;img&#x27;).attr(&#x27;info&#x27;, &#x27;测试照片&#x27;) // 2. 取值 let href = $(&#x27;a&#x27;).attr(&#x27;href&#x27;) console.log(&#x27;href:&#x27;, href) let info = $(&#x27;img&#x27;).attr(&#x27;info&#x27;) console.log(&#x27;info:&#x27;, info) // 3. 删除 $(&#x27;a&#x27;).removeAttr(&#x27;href&#x27;) $(&#x27;img&#x27;).removeAttr(&#x27;src&#x27;) $(&#x27;img&#x27;).removeAttr(&#x27;info&#x27;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; attr方法赋值操作时需要传递几个参数？ 2个，参数1是属性名，参数2是属性值 attr方法传递一个参数的作用是什么？ 取值，要获取什么属性的值，传入对应的名字就ok啦！ 删除属性的方法名叫什么？ removeAttr 案例2:图片切换完成图片切换demo 案例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;13-图片切换&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/index.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;mask&quot;&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2 class=&quot;title&quot;&gt; &lt;img src=&quot;./images/logo.png&quot; alt=&quot;&quot; /&gt; &lt;/h2&gt; &lt;!-- 图片 --&gt; &lt;img class=&quot;cover&quot; src=&quot;./images/1.png&quot; alt=&quot;&quot; /&gt; &lt;!-- 左箭头 --&gt; &lt;a href=&quot;javascript:void(0)&quot; class=&quot;left&quot;&gt; &lt;img src=&quot;./images/prev.png&quot; alt=&quot;&quot; /&gt; &lt;/a&gt; &lt;!-- 右箭头 --&gt; &lt;a href=&quot;javascript:void(0)&quot; class=&quot;right&quot;&gt; &lt;img src=&quot;./images/next.png&quot; alt=&quot;&quot; /&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;!-- 导入jQuery --&gt; &lt;script src=&quot;./jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt;&lt;script&gt;// 箭头缩放//移入$(&#x27;.center a&#x27;).mouseenter(function()&#123; console.log(&#x27;鼠标移入&#x27;); $(this).css(&#x27;transform&#x27;,&#x27;scale(1.1)&#x27;)&#125;).mouseleave(function()&#123; console.log(&#x27;鼠标移出&#x27;); $(this).css(&#x27;transform&#x27;,&#x27;scale(1)&#x27;)&#125;)// 图片切换$(&#x27;.left&#x27;).css(&#x27;display&#x27;,&#x27;none&#x27;)let index = 1$(&#x27;.left&#x27;).click(function ()&#123;index--$(&#x27;.cover&#x27;).attr(&#x27;src&#x27;,`./images/$&#123;index&#125;.png`) if(index == 1)&#123; $(&#x27;.right&#x27;).css(&#x27;display&#x27;,&#x27;&#x27;) $(this).css(&#x27;display&#x27;,&#x27;none&#x27;)&#125;&#125;)$(&#x27;.right&#x27;).click(function ()&#123; index++ console.log(index); $(&#x27;.cover&#x27;).attr(&#x27;src&#x27;,`./images/$&#123;index&#125;.png`) if(index == 5)&#123; $(this).css(&#x27;display&#x27;,&#x27;none&#x27;) $(&#x27;.left&#x27;).css(&#x27;display&#x27;,&#x27;&#x27;) &#125;&#125;)&lt;/script&gt; 为transform设置什么可以调整元素缩放? scale 使用什么方法修改元素属性？ attr方法 使用什么方法修改元素样式 css方法 10.操纵value使用jQuery提供的方法操纵表单元素的value值 jQuery中如何去操纵表单元素的value值，在网页开发中获取用户的输入。语法很简单，就是一个方法.val。 1234// 取值$(&#x27;选择器&#x27;).val()// 赋值$(&#x27;选择器&#x27;).val(&#x27;值&#x27;) val也有两种用法，取值和赋值，我们在取值的时候，不需要传递参数。 示例代码： 12345678910111213141516&lt;body&gt; &lt;!-- 测试用输入框 --&gt; &lt;input class=&quot;text&quot; type=&quot;text&quot; /&gt; &lt;!-- 引入 jQuery --&gt; &lt;script src=&quot;./jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 1. 赋值 $(&#x27;.text&#x27;).val(&#x27;测试内容！&#x27;) // 2. 取值 $(&#x27;.text&#x27;).blur(function () &#123; let value = $(this).val() console.log(&#x27;value:&#x27;, value) &#125;) &lt;/script&gt;&lt;/body&gt; 测试结果： 赋值 取值 val方法是操纵元素的什么属性? value属性 获取value是否需要传递参数 11.查找方法使用jQuery提供的查找方法对元素再次检索 jQuery提供了一些查找元素的方法，通过这些方法就可以通过元素去查找他的父元素，兄弟元素，子元素和后代元素。 方法有4个，但是非常好理解：parent方法用来获取父元素，children方法用来获取子元素，siblings用来获取兄弟元素，find用来获取后代元素，考虑到后代元素种类比较多，所以find方法必须传入选择器 这4个方法返回的都是jQ对象，之前的方法也是适用的。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;查找方法&lt;/title&gt;&lt;/head&gt;&lt;script src=&quot;./jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;h4&gt;课程列表&lt;/h4&gt; &lt;ul class=&quot;course&quot;&gt; &lt;li&gt;html&lt;/li&gt; &lt;li&gt;css&lt;/li&gt; &lt;li&gt;javascript&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;校区列表&lt;/h4&gt; &lt;ul class=&quot;campus&quot;&gt; &lt;li class=&quot;bj&quot;&gt;北京校区&lt;/li&gt; &lt;li class=&quot;sh&quot;&gt;上海校区&lt;/li&gt; &lt;li class=&quot;gz&quot;&gt;广州校区&lt;/li&gt; &lt;li class=&quot;sz&quot;&gt;深圳校区&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 获取父元素,在这个例子中父元素就是div let parentElement = $(&#x27;.course&#x27;).parent().css(&#x27;backgroundColor&#x27;, &#x27;pink&#x27;); // 获取子元素上面的两个h4标签，ul标签都是子元素 let childrenElement = $(&#x27;.container&#x27;).children().css(&#x27;backgroundColor&#x27;, &#x27;yellow&#x27;); // 获取兄弟元素 let brotherElement = $(&#x27;.course&#x27;).siblings().css(&#x27;backgroundColor&#x27;, &#x27;blue&#x27;); console.log(&#x27;这是兄弟元素&#x27;+brotherElement); // 获取后代元素 指的是li标签 let afterElement = $(&#x27;.campus&#x27;).find($(&#x27;.bj&#x27;)).css(&#x27;backgroundColor&#x27;,&#x27;red&#x27;) &lt;/script&gt;&lt;/html&gt; 图片展示： parent方法是否需要传递参数？ 不需要，父元素只有一个 获取子元素的方法是什么？ children方法 siblings方法一定要传入选择器吗？ 不一定，不传入获取所有兄弟元素，传入的话就是进行筛选啦 find方法是否可以获取到子元素? 可以，子元素也是后代元素的一种 12.操纵类名使用jQuery提供的方法操纵元素的类名 通过操纵类名达到切换样式的目的。 适用场景：样式多且杂，这时候切换类名比一个个写入方便多 基础语法： 名字非常好记，方法都是通过class结尾的，结合不同的单词产生不同的效果 addClass就是添加类名 removeClass就是移除类名 hasClass是判断类名是否存在，返回的是布尔值 toggleClass可以对类名进行切换，有就移除，没有就添加。 参数就是需要操作的类名 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;操纵类名&lt;/title&gt; &lt;style&gt; body &#123; padding: 0 30px; &#125; p &#123; color: #333; &#125; .test &#123; width: 200px; height: 100px; background-color: green; &#125; .active &#123; background-color: red; border: 5px solid skyblue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 操纵的盒子 --&gt; &lt;div class=&quot;test&quot;&gt;&lt;/div&gt; &lt;hr /&gt; &lt;!-- 测试用按钮 --&gt; &lt;button class=&quot;add&quot;&gt;添加类名&lt;/button&gt; &lt;button class=&quot;remove&quot;&gt;移除类名&lt;/button&gt; &lt;button class=&quot;has&quot;&gt;判断类名&lt;/button&gt; &lt;button class=&quot;toggle&quot;&gt;切换类名&lt;/button&gt; &lt;!-- 导入jQuery --&gt; &lt;script src=&quot;./jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 1. 添加类名 $(&#x27;.add&#x27;).click(function () &#123; $(&#x27;.test&#x27;).addClass(&#x27;active&#x27;) &#125;) // 2. 移除类名 $(&#x27;.remove&#x27;).click(function () &#123; $(&#x27;.test&#x27;).removeClass(&#x27;active&#x27;) &#125;) // 3. 判断类名 $(&#x27;.has&#x27;).click(function () &#123; let res = $(&#x27;.test&#x27;).hasClass(&#x27;active&#x27;) console.log(&#x27;res:&#x27;, res) &#125;) // 4. 切换类名 $(&#x27;.toggle&#x27;).click(function () &#123; $(&#x27;.test&#x27;).toggleClass(&#x27;active&#x27;) &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 方法是否需要传递参数? 需要，这一节学习的4个方法都需要传递类名作为参数 hasClass方法的返回值是什么？ 布尔值，hasClass方法的作用是判断类名是否存在，true就是存在，false就是不存在 addClass是添加类名，removeClass是移除类名，切换类名的方法叫做? toggleClass，类名存在就移除，不存在就添加 13.事件进阶更为强大的事件绑定,还能解绑哦 学习事件进阶需要解决两个问题： 对于没有提供的方法的事件无法绑定，比如input。 对于绑定的事件如何移除呢？ 有些更高级的需求也不好实现，比如：绑定一次性事件，就是只能触发一次的事件！ 首先是注册事件，我们可以直接使用on方法，来注册所有的事件，他是要传递两个参数，第1个是事件名，比如点击事件写click就好，第2个是回调函数 ​ 如果要删除事件呢，可以使用off这个方法，想要删除什么事件，就传入什么事件名! ​ 如果不传入事件名，会删除所有哦，是不是特别暴力啊！ ​ 最后一个是注册一次性事件，用法和on类似，方法名换成了one 基础语法： 12345678// 1. 注册事件.on(&#x27;事件名&#x27;, function()&#123;&#125;)// 2. 移除指定事件.off(&#x27;事件名&#x27;)// 3. 移除所有事件.off()// 4. 注册一次性事件.one(&#x27;事件名&#x27;, function()&#123;&#125;) 在回调函数中，this还指的是jQ对象 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;事件进阶&lt;/title&gt; &lt;style&gt; body &#123; padding: 0 30px 40px; &#125; p &#123; color: #333; &#125; button &#123; margin-top: 10px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 测试标签 --&gt; &lt;input type=&quot;text&quot; class=&quot;onoff&quot; /&gt; &lt;br /&gt; &lt;button class=&quot;one&quot;&gt;支付&lt;/button&gt; &lt;!-- 导入jQuery --&gt; &lt;script src=&quot;./jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 1. 注册事件 on $(&#x27;.onoff&#x27;).on(&#x27;focus&#x27;, function () &#123; console.log(&#x27;获取焦点&#x27;) &#125;) $(&#x27;.onoff&#x27;).on(&#x27;blur&#x27;, function () &#123; console.log(&#x27;失去焦点&#x27;) &#125;) $(&#x27;.onoff&#x27;).on(&#x27;input&#x27;, function () &#123; // console.log(&#x27;input事件触发&#x27;) // console.log(this) let value = $(this).val() console.log(&#x27;value:&#x27;, value) &#125;) //下面这种写法会报错 // $(&#x27;.onoff&#x27;).input(function () &#123; // console.log(&#x27;input事件触发&#x27;) // &#125;) // 2. 移除指定事件 off $(&#x27;.onoff&#x27;).off(&#x27;focus&#x27;) // 3. 移除所有事件 off $(&#x27;.onoff&#x27;).off() // 4. 注册一次性事件 one $(&#x27;.one&#x27;).one(&#x27;click&#x27;, function () &#123; alert(&#x27;支付成功998元&#x27;) &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 使用on方法进行事件绑定时，第一个参数是什么? 事件名 使用off方法时可以不传递参数吗？ 可以，删除所有事件，比较暴力 一次性事件通过什么方法绑定？ one 14.触发事件用代码的方式触发注册的事件 学习在jQuery中如何通过代码的方式去触发绑定的事件。 基础语法： 直接调用对应的事件方法即可，不需要传入任何参数就是触发，比如点击事件，调用click方法即可 但并不是所有事件都有对应的方法，比如input事件，这个时候就可以通过trigger的方式来触发，直接传入希望触发的事件名就好啦 trigger方法可以触发任意的事件，包括自定义的事件，什么叫做自定义事件呢？顾名思义就是事件名是咱们自己想的，写什么都可以 自定义事件必须通过on的方式来注册，把第一个参数换成自定义的事件名就好啦，同时他也只能通过代码的方式来触发 自定义事件是一种更为高阶的用法，咱们只需要了解基本的用法即可。 12345678// 1. 直接触发.事件名()// 2. trigger触发.trigger(&#x27;事件名&#x27;)// 3. 触发自定义事件.trigger(&#x27;自定义事件&#x27;)// 4. 注册自定义事件.on(&#x27;自定义事件&#x27;,function()&#123;&#125;) 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;触发事件事件处理&lt;/title&gt; &lt;style&gt; body &#123; padding: 0 30px 40px; &#125; p &#123; color: #333; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 测试用标签 --&gt; &lt;button class=&quot;btn&quot;&gt;按钮&lt;/button&gt; &lt;br /&gt; &lt;input type=&quot;text&quot; class=&quot;text&quot; /&gt; &lt;!-- 导入jQuery --&gt; &lt;script src=&quot;./jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 1. 直接触发 $(&#x27;.btn&#x27;).click(function () &#123; $(this).css(&#x27;backgroundColor&#x27;, &#x27;skyblue&#x27;) &#125;) //下面这个代码模拟了一个点击 // $(&#x27;.btn&#x27;).click() $(&#x27;.text&#x27;).on(&#x27;input&#x27;, function () &#123; console.log(&#x27;input触发啦！&#x27;) &#125;) // // 2. trigger触发，也是相当于模拟了事件要执行的行为，比如点击，输入等等 $(&#x27;.text&#x27;).trigger(&#x27;input&#x27;) $(&#x27;.btn&#x27;).trigger(&#x27;click&#x27;) // 3. 注册自定义事件 $(&#x27;.text&#x27;).on(&#x27;itheima-input&#x27;, function () &#123; console.log(&#x27;自定义事件触发！&#x27;) &#125;) // 4. 触发自定义事件 $(&#x27;.text&#x27;).trigger(&#x27;itheima-input&#x27;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; ​ trigger方法可以触发所有的事件，但是他的强大之处可不仅于此。对于自定义的事件也是可以触发。 调用click方法是否可以触发点击事件？ 可以，只要有方法的事件，都可以用这样的方式来触发 trigger方法只能用来触发原生事件？ 不对，自定义事件也是可以触发的 自定义事件，可以通过鼠标点击来触发？ 不可以，自定义事件只能通过trigger来触发 15.window事件绑定如何为window对象绑定事件呢? 用原生的方式为他绑定事件是这样的：直接为window对象对应的事件赋值即可,比如滚动，比如点击 1234// 滚动window.onscroll = function () &#123;&#125;// 点击window.onclick = function () &#123;&#125; 适用jQ来获取windows对象基础语法 1234// 滚动$(window).scroll(function () &#123;&#125;)// 点击$(window).click(function () &#123;&#125;) $方法中传入什么可以为window绑定事件? window对象，不用加引号！！！ jQuery第二部分1.元素位置jQuery中如何获取元素位置呢? position和offset都可以获取位置 返回的是一个对象 两者获取位置的参照物不同: offset始终参照的是html position参照的有定位属性的最近祖先元素 对于margin两者的处理也不相同 offset忽略 position会累加margin 如果要设置位置的话只能通过offset方法、 总结： offset方法和position方法哪个参考的是html? offset方法,position方法参考的是最近并且有定位的祖先元素 offset方法和position方法哪个可以用来设置位置? offset方法可以设置位置,但是没有动画效果 如果元素有margin哪个方法会一起计算进去呢? offset会把margin也计算进去,而position不会 2.滚动距离 jQuery中如何获取滚动距离呢? 获取元素滚动距离 1234//垂直方向移动距离$(&#x27;选择器&#x27;).scrollTop()//水平方向移动距离$(&#x27;选择器&#x27;).scrollLeft() 获取网页的滚动距离 12$(&#x27;html&#x27;).scrollTop()$(&#x27;html&#x27;).scrollLeft() 设置滚动距离 12$(&#x27;html&#x27;).scrollTop(值)$(&#x27;html&#x27;).scrollLeft(值) 小结: 对于内容可以滚动的元素可以通过scrollTop或者scrollLeft获取滚动距离,如何获取网页的滚动距离呢? 把html作为选择器即可 调用scrollTop和scrollLeft方法可以让元素滚到指定位置。 3.jQuery动画显示&amp;隐藏动画如何使用jQuery的显示隐藏动画 如何使用show方法 12//显示，参数可以传递持续时间，单位ms$(&#x27;选择器&#x27;).show() 如何使用hide方法 12//隐藏，参数可以传递持续时间，单位ms$(&#x27;选择器&#x27;).hide() 如何使用toggle方法(可以自动控制显示和隐藏) 12//显示&amp;隐藏，参数可以传递持续时间，单位ms$(&#x27;选择器&#x27;).toggle() 方法中的this 动画的持续时间 就是你要传递的参数，单位ms 动画效果 调优demo 动画 - 淡入&amp;淡出基础语法： 123456//淡入$(&#x27;选择器&#x27;).fadeIn()//淡出$(&#x27;选择器&#x27;).fadeOut()//淡入&amp;淡出，相当于在淡入淡出效果之间切换$(&#x27;选择器&#x27;).fadeToggle() 控制淡入淡出的时长，依旧可以传递时间参数，单位ms 1.淡入淡出效果是通过修改元素的哪个样式实现?opactity2.元素的尺寸是否会在淡入淡出的动画过程中一起改变?不会 动画 - 展开&amp;收起 如何使用slideDown方法 12//展开$(&#x27;选择器&#x27;).slideDown() 如何使用slideUp方法 12//收起$(&#x27;选择器&#x27;).slideUp() 如何使用slideToggle方法，就是在展开和收起直接切换 12//展开&amp;收起$(&#x27;选择器&#x27;).slideToggle() 本质是修改了哪个样式 改变垂直方向上的尺寸 方法中的this 动画的持续时间 传递参数作为持续时间，单位ms 动画效果 demo中使用淡入淡出效果 1.slideDown和slideUp哪一个用来把元素显示出来?slideDown展开2.在垂直方向上调整的样式除了高度、margin、还有?padding 动画 - 队列及停止通过jQuery为元素设置的多个动画会依次添加到动画队列中,并根据添加的顺序依次播放 基础语法： 123456//停止当前动画，继续播放后续的动画效果$(&#x27;选择器&#x27;).stop()//清空队列 在动画当前状态停止，且不再继续播放后续动画$(&#x27;选择器&#x27;).stop(true)//清空队列 直接到当前动画的结束状态$(&#x27;选择器&#x27;).stop(true,true) 动画方法和stop方法返回的是同一个jQuery对象 1.队列中动画的播放顺序和添加顺序是否有关系?有2.stop方法要清空队列需要传递什么参数?true3.传递1个true和传递2个true的区别是?1个:动画停止在执行stop方法的瞬间2个:直接到当前播放动画的结束状态 动画-自定义动画jQuery提供了animate方法来实现更为复杂的动画效果 基本语法： 1$(&#x27;选择器&#x27;).animate(动画属性，持续时间) 数值类样式支持动画,支持多个 默认单位是px 支持非样式的特殊属性 scrollLeft：水平方向滚动 scrollTop：垂直方向滚动 持续时间单位是毫秒 4.事件参数如何使用事件参数呢? 学习jQuery中的事件对象,有时候也称之为事件参数日常开发中使用的频率还行,他在触发事件时为开发者额外提供了一些信息,和功能:比如事件的触发对象,用来阻止冒泡,阻止默认行为什么的. 用法和webapi阶段基本一致 123456// 语法$(&#x27;选择器&#x27;).事件(function(event)&#123;&#125;)// 比如 点击事件$(&#x27;选择器&#x27;).click(function(event)&#123;&#125;)// 比如 键盘抬起事件$(&#x27;选择器&#x27;).keyup(function(event)&#123;&#125;) 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;事件对象&lt;/title&gt; &lt;style&gt; body &#123; padding: 0 30px; &#125; p &#123; color: #333; &#125; .box &#123; width: 200px; height: 100px; background-color: pink; padding: 20px; text-align: center; border-radius: 10px; &#125; input &#123; margin: 10px; &#125; button &#123; width: 100%; height: 30px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;事件对象&lt;/h2&gt; &lt;p&gt;事件触发时额外提供给开发者的信息,可以用来干不少事情哦&lt;/p&gt; &lt;div class=&quot;box&quot;&gt; &lt;a href=&quot;http://www.baidu.com/&quot;&gt;跳转百度&lt;/a&gt; &lt;input type=&quot;text&quot; /&gt; &lt;br /&gt; &lt;button&gt;点我&lt;/button&gt; &lt;br /&gt; &lt;/div&gt; &lt;script src=&quot;./jquery/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1.最外层盒子绑定点击事件,查看事件触发源，也就是谁触发了事件 1234$(&#x27;.box&#x27;).click(function (event) &#123; console.log(&#x27;event.target:&#x27;,event.target) console.log(&#x27;box-click&#x27;)&#125;) 2.阻止a标签的默认行为，比如a标签是跳转了，阻止跳转 123$(&#x27;a&#x27;).click(function (event) &#123; event.preventDefault()&#125;) 3.判断键盘按键 123456$(&#x27;input&#x27;).keyup(function (event) &#123; console.log(&#x27;keyCode:&#x27;,event.keyCode) if (event.keyCode === 13) &#123; console.log(&#x27;按下回车&#x27;) &#125;&#125;) 4.阻止冒泡 1234$(&#x27;button&#x27;).click(function (event) &#123; event.stopPropagation() console.log(&#x27;button-click&#x27;)&#125;) 小结一下 事件对象: 也可以叫做事件参数用法和webapi阶段学习的基本一致 在事件触发时额外传递给开发者中的信息和功能 可以通过它获取触发源,实现阻止默认行为等功能 5.动态添加html节点 - 新增在jQuery中如何新增(插入)节点 用法01-基于创建的jQuery对象进行添加 1234567891011// 基于html创建jQuery对象let $a = $(&#x27;&lt;a href=&quot;#&quot;&gt;超链接&lt;/a&gt;&#x27;)// 添加jQuery对象// 在父元素末尾添加$(&#x27;选择器&#x27;).append($a)// 在父元素开头添加$(&#x27;选择器&#x27;).prepend($a)// 在兄弟元素之前添加$(&#x27;选择器&#x27;).before($a)// 在兄弟元素之后添加$(&#x27;选择器&#x27;).after($a) 用法02-直接添加html结构 123456789// 直接添加html结构// 在父元素末尾添加$(&#x27;选择器&#x27;).append(&#x27;html结构&#x27;)// 在父元素开头添加$(&#x27;选择器&#x27;).prepend(&#x27;html结构&#x27;)// 在兄弟元素之前添加$(&#x27;选择器&#x27;).before(&#x27;html结构&#x27;)// 在兄弟元素之后添加$(&#x27;选择器&#x27;).after(&#x27;html结构&#x27;) 小结一下: append、prepend 以父元素为参考分别在结尾处和开头处添加新的元素节点 after、before 以当前元素为参考在之前或之后插入新的元素节点 append、prepend、after、before 均支持直接将 html 字符串做为节点插入 节点 - 删除在jQuery中如何删除节点呢? 不同于webapi中需要通过父元素才可以删除自己,jQuery中直接就可以把自己给删掉。 基础语法： 12// 删除自己（删掉html结构）$(&#x27;选择器&#x27;).remove(); 总结： remove 方法删除的是当前调用方法的元素节点 节点 - 克隆jQuery中如何基于现有的节点进行克隆(复制)呢? jQuery 中封装了复制（克隆）元素节点的方法，其用法如下代码所示： 123456&lt;script&gt; // 通过复制获得新的节点 拷贝事件 $(&#x27;选择器&#x27;).clone(true); // 通过复制获得新的节点 不拷贝事件 $(&#x27;选择器&#x27;).clone(false);&lt;/script&gt; 使用方式 123456789// 假设我们有一个需要复制的元素2var originalElement = $(&#x27;#someElement&#x27;);34// 通过复制获得新的节点，并保留事件处理（根据需要选择true或false）5var clonedElement = originalElement.clone(true);67// 然后你可以将这个复制的元素插入到DOM中的其他位置8// 例如，将其添加到某个元素的末尾9$(&#x27;#targetElement&#x27;).append(clonedElement); 在这个例子中： originalElement是我们想要复制的元素，通过ID选择器#someElement选取。 clonedElement变量存储了复制得到的新节点。 使用.append(clonedElement)将复制的节点添加到ID为targetElement的元素内部末尾。 总结： clone 方法复制得到的元素节点仍是 jQuery 对象 待复制的节点中如果有事件监听，需要为 clone 方法传入参数 true 6.事件委托jQuery中如何使用事件委托呢? jQuery 中封装了事件委托的支持，其用法如下代码所示： 1234// on 方法内置支持事件委托$(&#x27;祖先元素&#x27;).on(&#x27;事件名&#x27;, &#x27;后代选择器&#x27;, function () &#123; &#125;) 举个例子： 12345&lt;ul id=&quot;myList&quot;&gt; &lt;!-- 初始时可能有一些列表项，也可能没有 --&gt; &lt;li&gt;列表项 1&lt;/li&gt; &lt;li&gt;列表项 2&lt;/li&gt;&lt;/ul&gt; 12345678910111213$(document).ready(function()&#123; // 使用事件委托，为 &#x27;#myList&#x27; 下现在及将来所有的 &#x27;li&#x27; 元素绑定点击事件 $(&#x27;#myList&#x27;).on(&#x27;click&#x27;, &#x27;li&#x27;, function()&#123; alert(&#x27;你点击了: &#x27; + $(this).text()); // 这里的 &#x27;this&#x27; 指向实际触发事件的 li 元素 &#125;); // 假设后面动态添加一些 li setTimeout(function()&#123; $(&#x27;#myList&#x27;).append(&#x27;&lt;li&gt;新增列表项 3&lt;/li&gt;&#x27;); $(&#x27;#myList&#x27;).append(&#x27;&lt;li&gt;新增列表项 4&lt;/li&gt;&#x27;); &#125;, 2000); // 2秒后添加新项&#125;); 在这个例子中： &#39;#myList&#39; 是祖先元素，我们在此元素上设置监听器。 &#39;li&#39; 是后代选择器，指定了实际应该响应事件的目标元素。 当用户点击任何现有的或将来动态添加到 #myList 中的 li 元素时，都会触发这个点击事件处理器。 即使是在 setTimeout 函数中动态添加的 li，也会自动拥有点击事件处理功能，因为事件委托是基于当前的及未来的匹配元素来工作的。 总结： 事件委托需要为某个在 DOM 中已经存在的祖先元素添加事件监听 delegate 方法是 jQuery 中专门的事件委托的方法 on 方法中也内置支持事件委托，推荐使用 on 方法 jQuery第三部分1.入口函数 在jQ中的入口函数咋写呢，类似于window.onload但是不一样。 jQ中的写法 对比window.onload jQuery 中提供了更为简便的入口函数写法 在我们原生js中： window.onload的执行时机是页面资源加载完毕，包括dom元素解析完毕，外部的css，图片什么的也需要加载完毕，所以写在他内部的逻辑肯定可以获取到页面上的dom元素。 在jQ中的写法是这样的，基础语法 1$(windows).on(&#x27;load&#x27;,function()&#123;&#125;) jQ还提供了一个ready方法，完整的写法略微有点复杂,调用$方法然后把document传进去接着调用ready方法并传入回调函数,但是这里介绍较为简单的写法，两种写法的功能是一样的。 同样的功能还有一种更为简单的写法，直接在调用$方法的时候传入回调函数即可 基础语法： 1234//完整写法$(document).ready(function()&#123;&#125;)//简单写法$(function()&#123;&#125;) 基于上面的这种写法，它能达到的功能是当dom载入完毕，即调用该函数 下面举一个例子，我们在head标签中写入一个盒子，写在这里如果修改盒子的样式，那么他是不会改变的，因为代码执行的时候dom元素还没加载呢！ 下面我们展示用window对象和jQ对象写法 12&lt;!-- 测试元素 --&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt; 12345678910111213141516171819//window对象window.onload = function () &#123; $(&#x27;.box&#x27;).css(&#x27;backgroundColor&#x27;, &#x27;orange&#x27;) &#125;//jQ的window对象写法 $(window).on(&#x27;load&#x27;, function () &#123; $(&#x27;.box&#x27;).css(&#x27;backgroundColor&#x27;, &#x27;skyblue&#x27;) &#125;)//jQ提供的ready方法 $(document).ready(function () &#123; $(&#x27;.box&#x27;).css(&#x27;backgroundColor&#x27;, &#x27;pink&#x27;) &#125;)//ready方法的简单写法 $(function () &#123; $(&#x27;.box&#x27;).css(&#x27;backgroundColor&#x27;, &#x27;deepskyblue&#x27;) &#125;) window.onload和ready哪个先执行 ready，因为ready只需要考虑dom元素加载完成，不需要考虑外部资源 window.onload和ready哪个可以获取图片尺寸 window.onload 开发中用哪个？ 看情况讨论 现在js都是在body底部载入，所以代码执行的时候dom元素都已经可以获取到了，这个时候用不用都是可以的。但是代码中如果要确保可以获取到图片的尺寸就需要用window.onload咯 2.轮播图插件–slick 轮播图作为一个非常常见的功能，有很多现成的插件，咱们来学习一下slick 轮播图插件 常用的功能封装成插件，直接使用即可 插件的含义用vscode插件讲解 jQuery插件的含义 插件使用套路 调整 配置调整 小圆点 箭头 样式调整 审查元素找到样式 直接覆盖 小结： slick是谁的插件？ jQuery，需要依赖于jQuery才可以执行 是否需要把用法和配置背下来？ 不需要，随用随查，结合翻译英文也不可怕 插件的样式可以调整吗？ 可以，直接用自己的样式覆盖默认的样式即可 那么轮播图具体要怎么写呢？ 下包：首先把需要使用的插件下载到本地 导包：jQuery的插件需要在jQ的后面导入，因为他依赖jQ，有的插件还需要用到css，根据需求导入就好！ 用包：根据文档提供的步骤使用它。 导包： 123 &lt;!-- 引入插件所需要的样式表 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/slick/slick.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/slick/slick-theme.css&quot;&gt; 建议使用插件的时候随查随用 3.懒加载插件 - lazyload这一节咱们来学习懒加载插件，名字叫做lazyload,作用是让图片的加载变的不那么迅速。从立刻加载变成看到了再去加载，这个功能在图片很多的网页用的较多，比如电商网站,像京东淘宝都有用呢。 既然是插件，那就是下包，导包，用包即可 这里示例导入包的代码 1234&lt;!-- 先导入jQueery --&gt;&lt;script src=&quot;./jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt;&lt;!-- 再导入lazyload插件 --&gt;&lt;script src=&quot;./assets/jquery.lazyload.min.js&quot;&gt;&lt;/script&gt; 用该插件的时候，有几个地方需要调整 将src换成data-original 然后通过选择器找到需要进行懒加载的图片，随后调用方法即可 12// 找到希望懒加载的图片并调用lazyload方法$(&#x27;.lazyload&#x27;).lazyload() 使用懒加载插件之后，看不到的图片会不会加载？ 不会，看到了才会加载 图片很多的网页用这个可以提升加载速度吗？ 可以，因为不会加载所有的图片，数据的传输量更小，在网速不变的情况下，加载的速度肯定会更快一些呢！ 4.fullpage插件fullpage，也是jQ的插件。他可以用来制作咱们平时在手机或者电脑上见过的那种全屏滚动的页面，这一类的页面主要的作用是营销或者推广。 同样三步走，下包，导包，用包 1234567&lt;!-- 导入 fullpage 配套样式 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;./fullpage/jquery.fullpage.css&quot; /&gt;&lt;!-- 导入 jQuery --&gt;&lt;script src=&quot;./jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt;&lt;!-- 在 jQuery 之后导入 fullpage 插件 --&gt;&lt;script src=&quot;./fullpage/jquery.fullpage.js&quot;&gt;&lt;/script&gt; 接下来是他的结构,外层的容器用个有意义的标记就好，比如id或者class都可以，内部就是每一屏的容器啦，每一屏要显示的内容放到对应的盒子里面就好，需要注意的是：每屏都必须有secion这个类名，如果有需求可以额外的添加其他的类名，但是这个必须存在哦 12345&lt;div id=&quot;fullpage&quot;&gt; &lt;div class=&quot;section&quot;&gt;第一屏&lt;/div&gt; &lt;div class=&quot;section&quot;&gt;第二屏&lt;/div&gt; &lt;div class=&quot;section&quot;&gt;第三屏&lt;/div&gt;&lt;/div&gt; 最后就是调用fullpage方法 12$(&#x27;#fullpage&#x27;).fullpage(&#123;&#125;) fullpage插件在使用的时候一定要传入配置吗？ 不一定，不传入任何的配置也有默认的功能 fullpage插件的区域容器一定要添加什么类名？ section，必须有这个类名，但是可以添加额外的类名 5.表单 - 提交事件示例表单： 12345678&lt;form&gt; &lt;input type=&quot;text&quot; placeholder=&quot;用户名&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;password&quot; placeholder=&quot;密码&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt; 绑定提交事件 12345$(&#x27;form&#x27;).submit(function (event) &#123; console.log(&#x27;submit&#x27;) event.preventDefault() return false&#125;) 使用场景：在输入完账号或者密码时进行账号密码的校验，已经提示错误等时候，需要弹出提示，这时就需要将表单提交行为的默认时间阻止了即可，然后再写需要的逻辑。 6.插件 - 日期选择器既然是插件，那就三步走，下包，导包，用包 这里示例： 123456789&lt;!-- 导入日期选择器的样式 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;./datepicker/datepicker.css&quot; /&gt;&lt;!-- 导入jQuery --&gt;&lt;script src=&quot;./jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt;&lt;!-- 导入日期选择器插件 --&gt;&lt;script src=&quot;./datepicker/datepicker.js&quot;&gt;&lt;/script&gt;&lt;!-- 导入语言包 --&gt;&lt;script src=&quot;./datepicker/i18n/datepicker.zh-CN.js&quot;&gt;&lt;/script&gt; 使用： 12345678&lt;!-- 准备html结构 --&gt;&lt;input type=&quot;text&quot; class=&quot;datapicker&quot; /&gt; // 调用插件方法 $(&#x27;.datapicker&#x27;).datepicker(&#123; //设置日期显示中文 language: &#x27;zh-CN&#x27;, &#125;) 设置选择完毕后自动关闭和自动设置 123456//传入配置项，这里传入了对象$(&#x27;.datapicker&#x27;).datepicker(&#123; language: &#x27;zh-CN&#x27;, autoPick: true, autoHide: true, &#125;) 插件默认显示的语言是中文还是英文? 英文 为了设置插件的语言为中文，需要导入什么? 中文语言包 7.插件 - 表单验证如何使用表单验证插件 业务场景：我们在注册的时候，如果用户名不填，或者密码强度不够，或者不勾选用户协议能不能注册呀？对啦，很明显是注册不了的，并且根据错误的不同会有与之对应的提示信息，这就是表单验证的功能。 既然是插件，那就三步走，下包，导包，用包 1234&lt;!-- 导入jQuery --&gt;&lt;script src=&quot;./jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt;&lt;!-- 导入validate插件 --&gt;&lt;script src=&quot;./jquery-validate/jquery-validate.js&quot;&gt;&lt;/script&gt; 123456&lt;input type=&quot;password&quot; name=&quot;password&quot; data-required data-pattern=&quot;.&#123;6,&#125;&quot;/&gt; 引入验证库：首先，确保您已经在项目中包含了所需的表单验证库或插件。这通常通过在HTML头部使用&lt;script&gt;标签或在项目依赖中导入来完成。 使用验证包：在您的JavaScript代码中，引入或创建一个实例来使用这个验证包。这是设置验证功能的基础。 选择表单元素：通过选择器（如jQuery的选择器、Vanilla JS的document.querySelector或类似的API）找到您想要进行验证的表单字段。 调用验证方法：选中表单元素后，调用验证库提供的validate方法。您可以传递多种配置选项，比如： 校验时机：指定何时触发验证（如提交时、失焦时等）。 表单提交控制：决定是否在验证失败时阻止表单提交。 回调函数：分别设置valid和invalid回调，用于处理验证成功或失败的情况。 显示错误信息：若需在页面上展示错误提示，可以通过设置表单元素的description属性或利用验证库提供的方法来实现。这部分内容会稍后详细说明。 定义验证规则： 直接在HTML的表单元素上使用自定义属性（如data-required、data-pattern）来指定验证规则。 data-required表示该字段为必填项。 data-pattern允许您通过正则表达式定义更复杂的格式要求。例如，data-pattern=&quot;.&#123;6,&#125;&quot;意味着该字段至少需要6个字符，且可包含任何字符。 表单结构：确保所有的表单元素都被正确地放置在&lt;form&gt;标签内，这是验证插件能够正常解析和工作的前提条件。 按照以上步骤操作，您就可以轻松地为网页表单添加数据验证逻辑了。记得，正则表达式的复杂度可能需要根据实际情况调整，不必一次性记住所有正则标记，可以逐步学习并应用 接下来介绍属性description data-describedby：设置的是信息显示的位置 data description：配置的是到底显示什么错误信息，需要和description中的属性对应。 除了这里需要对应，还有data-description也要对应上，比如下面 如果密码内容不填，会显示required的信息，如果填了但是不符合条件会线序pattern的信息 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;10-表单验证&lt;/title&gt; &lt;style&gt; body &#123; padding: 0 30px; &#125; p &#123; color: #333; &#125; ul &#123; padding: 0; list-style: none; &#125; li &#123; margin: 10px 0; &#125; span.error &#123; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 测试用标签 --&gt; &lt;form action=&quot;&quot;&gt; &lt;ul&gt; &lt;li&gt; 昵称: &lt;input data-required data-describedby=&quot;nickname-error&quot; data-description=&quot;nickname&quot; type=&quot;text&quot; name=&quot;nickname&quot; /&gt; &lt;span class=&quot;error&quot; id=&quot;nickname-error&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; 密码: &lt;input data-required data-pattern=&quot;.&#123;6,&#125;&quot; data-describedby=&quot;password-error&quot; data-description=&quot;password&quot; type=&quot;password&quot; name=&quot;password&quot; /&gt; &lt;span class=&quot;error&quot; id=&quot;password-error&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;label&gt; &lt;input data-required data-describedby=&quot;agree-error&quot; data-description=&quot;agree&quot; type=&quot;checkbox&quot; value=&quot;true&quot; name=&quot;agree&quot; /&gt; 同意注册协议 &lt;/label&gt; &lt;span class=&quot;error&quot; id=&quot;agree-error&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;button class=&quot;btn&quot;&gt;提交&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/form&gt; &lt;!-- 导入jQuery --&gt; &lt;script src=&quot;./jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt; &lt;!-- 导入 validate插件 --&gt; &lt;script src=&quot;./jquery-validate/jquery-validate.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&#x27;form&#x27;).validate(&#123; sendForm: false, description: &#123; password: &#123; required: &#x27;密码不能为空!&#x27;, pattern: &#x27;密码的长度必须大于等于6!&#x27; &#125;, nickname: &#123; required: &#x27;昵称不能为空!&#x27; &#125;, agree: &#123; required: &#x27;必须同意用户协议!&#x27; &#125; &#125;, valid () &#123; console.log(&#x27;验证成功&#x27;) &#125;, invalid () &#123; console.log(&#x27;验证失败&#x27;) &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 8.克隆学习jQuery中的克隆方法，他可以直接把一个jQuery对象拷贝一份，用法非常简单，直接调用clone方法即可，不需要传递任何参数就可以拷贝，如果希望连事件一起拷贝可以传入参数true. 返回的依旧是jQ对象 基本语法： 12//如果希望克隆时能够连带被克隆对象的事件。这里传入true参数，反正不需要克隆事件，则不传递参数即可$(&#x27;选择器(要克隆的对象)&#x27;).clone(); 克隆方法得到的是什么对象？ jQuery对象 希望事件一起克隆需要传递什么参数? true 9.获取dom对象jQ提供了很多便捷的方法，但是有些方法只有dom对象才有，如何将jQ对象转为dom对象呢？ 调用get方法传入索引。 二种是通过中括号的方式传入索引，索引是从0开始，获取到的都是dom对象，可以直接使用dom对象的那些方法 语法： 1234// get方法获取.get(索引)// 中括号获取[索引] 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;12-获取dom对象&lt;/title&gt; &lt;style&gt; p &#123; color: #333; &#125; video &#123; margin: 10px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 测试标签 播放器 --&gt; &lt;button class=&quot;play&quot;&gt;播放&lt;/button&gt; &lt;button class=&quot;pause&quot;&gt;暂停&lt;/button&gt; &lt;br /&gt; &lt;video src=&quot;./video/video.mp4&quot;&gt;&lt;/video&gt; &lt;!-- 测试标签 form --&gt; &lt;form action=&quot;&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;password&quot; placeholder=&quot;请输入密码&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;button&quot; class=&quot;reset&quot; value=&quot;重置&quot; /&gt; &lt;/form&gt; &lt;!-- 导入jQuery --&gt; &lt;script src=&quot;./jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 1.get方法获取dom对象 let $btn = $(&#x27;button&#x27;) console.log(&#x27;$btn:&#x27;, $btn) let pauseBtn = $btn.get(1) console.log(&#x27;pauseBtn:&#x27;, pauseBtn) // 2. 中括号获取dom对象 let playBtn = $btn[0] console.log(&#x27;playBtn:&#x27;, playBtn) // 3. 播放视频 $(&#x27;.play&#x27;).click(function () &#123; //方式1 $(&#x27;video&#x27;).trigger(&#x27;play&#x27;) //方式1 let video = $(&#x27;video&#x27;)[0] console.log(&#x27;video:&#x27;, video) video.play() &#125;) // 4. 暂停视频 $(&#x27;.pause&#x27;).click(function () &#123; //方式1 $(&#x27;video&#x27;).trigger(&#x27;pause&#x27;) //方式2 let video = $(&#x27;video&#x27;)[0] console.log(&#x27;video:&#x27;, video) video.pause() &#125;) // 5. 重置表单 $(&#x27;.reset&#x27;).click(function () &#123; //方式1 $(&#x27;form&#x27;).trigger(&#x27;reset&#x27;) //方式2 let form = $(&#x27;form&#x27;)[0] console.log(&#x27;form:&#x27;, form) form.reset() &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 可以使用 [] 还有一个什么方法来获取dom对象？ get方法 索引从几开始? 从0开始 10.表单 - 序列化(快速获取form表单元素的value值)方法的名字叫做serialize，首先获取到form标签，然后就可以调用啦，他是一个jQ的方法，为了能够正常获取数据需要为表单元素设置name属性，否则可是拿不到的哦。 ​ 获取到的是一个字符串，格式很有规律 name1&#x3D;value1&amp;name2&#x3D;value2 基础语法： 12345678&lt;script&gt; $(&#x27;form&#x27;).submit(function () &#123; //基础用法 let data = $(this).serialize() console.log(&#x27;data:&#x27;, data) return false &#125;)&lt;/script&gt; serialize方法要能够获取到value值，表单元素要有什么属性? name属性 获取到的数据是什么格式?(对象，字符串) 字符串，key&#x3D;value&amp;key2&#x3D;value的格式，目前掌握语法即可，在之后的课程中会用到这个方法呢 11.工具方法$.each遍历数组，第一个参数传入数组，然后传入回调函数，数组有几项回调函数就会执行几次，每次遍历的时候会把数组的内容传递给回调函数，回调函数的第一个参数是数组的每一项，第二个参数是下标，我们就可以在回调函数里面获取并使用这些数据啦。 ​ 还可以通过$.map来基于现有数组生成新的数组，用法和each类似，但是在回调函数里面可以返回一个值，每次执行返回的结果最终会被放到一个新增数组中。 123456// 遍历数组$.each(数组, function (item, index) &#123;&#125;)// 遍历并返回新数组$.map(数组,function(item,index)&#123; // 返回新的值&#125;) 了解即可。","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://example.com/tags/jQuery/"}]},{"title":"Vue.js","slug":"Vue-js","date":"2024-06-30T02:25:55.000Z","updated":"2024-07-08T11:40:26.167Z","comments":true,"path":"2024/06/30/Vue-js/","permalink":"http://example.com/2024/06/30/Vue-js/","excerpt":"","text":"模板语法Vue 使用一种基于 HTML 的模板语法，使我们能够声明式地将其组件实例的数据绑定到呈现的 DOM 上。所有的 Vue 模板都是语法层面合法的 HTML，可以被符合规范的浏览器和 HTML 解析器解析。 在底层机制中，Vue 会将模板编译成高度优化的 JavaScript 代码。结合响应式系统，当应用状态变更时，Vue 能够智能地推导出需要重新渲染的组件的最少数量，并应用最少的 DOM 操作。 如果你对虚拟 DOM 的概念比较熟悉，并且偏好直接使用 JavaScript，你也可以结合可选的 JSX 支持直接手写渲染函数而不采用模板。但请注意，这将不会享受到和模板同等级别的编译时优化。 文本插值最基本的数据绑定形式是文本插值，它使用的是“Mustache”语法 (即双大括号)： template 1&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; 双大括号标签会被替换为相应组件实例中 msg 属性的值。同时每次 msg 属性更改时它也会同步更新。 原始 HTML双大括号会将数据解释为纯文本，而不是 HTML。若想插入 HTML，你需要使用 v-html 指令： Using text interpolation: Using v-html directive: 12&lt;p&gt;Using text interpolation: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;&lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt; 1234//而使用vue中的&#123;&#123;&#125;&#125;不会渲染html，所以会显示纯文本Using text interpolation: &lt;span style=&quot;color: red&quot;&gt;This should be red.&lt;/span&gt;使用v-html会解析span标签，所以下面的会被渲染成红色Using v-html directive: This should be red. 这里我们遇到了一个新的概念。这里看到的 v-html attribute 被称为一个指令。指令由 v- 作为前缀，表明它们是一些由 Vue 提供的特殊 attribute，你可能已经猜到了，它们将为渲染的 DOM 应用特殊的响应式行为。这里我们做的事情简单来说就是：在当前组件实例上，将此元素的 innerHTML 与 rawHtml 属性保持同步。 span 的内容将会被替换为 rawHtml 属性的值，插值为纯 HTML——数据绑定将会被忽略。注意，你不能使用 v-html 来拼接组合模板，因为 Vue 不是一个基于字符串的模板引擎。在使用 Vue 时，应当使用组件作为 UI 重用和组合的基本单元。 Attribute 绑定双大括号不能在 HTML attributes 中使用。想要响应式地绑定一个 attribute，应该使用 v-bind 指令： 1&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt; v-bind 指令指示 Vue 将元素的 id attribute 与组件的 dynamicId 属性保持一致。如果绑定的值是 null 或者 undefined，那么该 attribute 将会从渲染的元素上移除。 简写因为 v-bind 非常常用，我们提供了特定的简写语法： 1&lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt; 开头为 : 的 attribute 可能和一般的 HTML attribute 看起来不太一样，但它的确是合法的 attribute 名称字符，并且所有支持 Vue 的浏览器都能正确解析它。此外，他们不会出现在最终渲染的 DOM 中。简写语法是可选的，但相信在你了解了它更多的用处后，你应该会更喜欢它。 同名简写 (要求vue版本为3.4+)如果 attribute 的名称与绑定的 JavaScript 值的名称相同，那么可以进一步简化语法，省略 attribute 值： 12345&lt;!-- 与 :id=&quot;id&quot; 相同 --&gt;&lt;div :id&gt;&lt;/div&gt;&lt;!-- 这也同样有效 --&gt;&lt;div v-bind:id&gt;&lt;/div&gt; 这与在 JavaScript 中声明对象时使用的属性简写语法类似。请注意，这是一个只在 Vue 3.4 及以上版本中可用的特性。 布尔型 Attribute布尔型 attribute 依据 true &#x2F; false 值来决定 attribute 是否应该存在于该元素上。disabled 就是最常见的例子之一。 v-bind 在这种场景下的行为略有不同： 1&lt;button :disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt; 当 isButtonDisabled 为真值或一个空字符串 (即 &lt;button disabled=&quot;&quot;&gt;) 时，元素会包含这个 disabled attribute。而当其为其他假值时 attribute 将被忽略。 动态绑定多个值如果你有像这样的一个包含多个 attribute 的 JavaScript 对象： 1const objectOfAttrs = &#123; id: &#x27;container&#x27;, class: &#x27;wrapper&#x27; &#125; 通过不带参数的 v-bind，你可以将它们绑定到单个元素上： 1&lt;div v-bind=&quot;objectOfAttrs&quot;&gt;&lt;/div&gt; 使用 JavaScript 表达式至此，我们仅在模板中绑定了一些简单的属性名。但是 Vue 实际上在所有的数据绑定中都支持完整的 JavaScript 表达式： 1234567&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;div :id=&quot;`list-$&#123;id&#125;`&quot;&gt;&lt;/div&gt; 这些表达式都会被作为 JavaScript ，以当前组件实例为作用域解析执行。 在 Vue 模板内，JavaScript 表达式可以被使用在如下场景上： 在文本插值中 (双大括号) 在任何 Vue 指令 (以 v- 开头的特殊 attribute) attribute 的值中 仅支持表达式每个绑定仅支持单一表达式，也就是一段能够被求值的 JavaScript 代码。一个简单的判断方法是是否可以合法地写在 return 后面。 12345&lt;!-- 这是一个语句，而非表达式 --&gt;&#123;&#123; var a = 1 &#125;&#125;&lt;!-- 条件控制也不支持，请使用三元表达式 --&gt;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125; 调用函数可以在绑定的表达式中使用一个组件暴露的方法： 123&lt;time :title=&quot;toTitleDate(date)&quot; :datetime=&quot;date&quot;&gt; &#123;&#123; formatDate(date) &#125;&#125;&lt;/time&gt; 指令 Directives指令是带有 v- 前缀的特殊 attribute。Vue 提供了许多内置指令，包括上面我们所介绍的 v-bind 和 v-html。 指令 attribute 的期望值为一个 JavaScript 表达式 (除了少数几个例外，即之后要讨论到的 v-for、v-on 和 v-slot)。一个指令的任务是在其表达式的值变化时响应式地更新 DOM。以 v-if 为例： 1&lt;p v-if=&quot;seen&quot;&gt;Now you see me&lt;/p&gt; 这里，v-if 指令会基于表达式 seen 的值的真假来移除&#x2F;插入该 &lt;p&gt; 元素。 参数 Arguments某些指令会需要一个“参数”，在指令名后通过一个冒号隔开做标识。例如用 v-bind 指令来响应式地更新一个 HTML attribute： 1234&lt;a v-bind:href=&quot;url&quot;&gt; ... &lt;/a&gt;&lt;!-- 简写 --&gt;&lt;a :href=&quot;url&quot;&gt; ... &lt;/a&gt; 这里 href 就是一个参数，它告诉 v-bind 指令将表达式 url 的值绑定到元素的 href attribute 上。在简写中，参数前的一切 (例如 v-bind:) 都会被缩略为一个 : 字符。 另一个例子是 v-on 指令，它将监听 DOM 事件： 1234&lt;a v-on:click=&quot;doSomething&quot;&gt; ... &lt;/a&gt;&lt;!-- 简写 --&gt;&lt;a @click=&quot;doSomething&quot;&gt; ... &lt;/a&gt; 这里的参数是要监听的事件名称：click。v-on 有一个相应的缩写，即 @ 字符。我们之后也会讨论关于事件处理的更多细节。 动态参数同样在指令参数上也可以使用一个 JavaScript 表达式，需要包含在一对方括号内： template 12345678&lt;!--注意，参数表达式有一些约束，参见下面“动态参数值的限制”与“动态参数语法的限制”章节的解释--&gt;&lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;&lt;!-- 简写 --&gt;&lt;a :[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt; 这里的 attributeName 会作为一个 JavaScript 表达式被动态执行，计算得到的值会被用作最终的参数。举例来说，如果你的组件实例有一个数据属性 attributeName，其值为 &quot;href&quot;，那么这个绑定就等价于 v-bind:href。 相似地，你还可以将一个函数绑定到动态的事件名称上： 1234&lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;&lt;!-- 简写 --&gt;&lt;a @[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt; 在此示例中，当 eventName 的值是 &quot;focus&quot; 时，v-on:[eventName] 就等价于 v-on:focus。 1234&lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;&lt;!-- 简写 --&gt;&lt;a @[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt; 在此示例中，当 eventName 的值是 &quot;focus&quot; 时，v-on:[eventName] 就等价于 v-on:focus。 动态参数值的限制动态参数中表达式的值应当是一个字符串，或者是 null。特殊值 null 意为显式移除该绑定。其他非字符串的值会触发警告。 动态参数语法的限制动态参数表达式因为某些字符的缘故有一些语法限制，比如空格和引号，在 HTML attribute 名称中都是不合法的。例如下面的示例： 12&lt;!-- 这会触发一个编译器警告 --&gt;&lt;a :[&#x27;foo&#x27; + bar]=&quot;value&quot;&gt; ... &lt;/a&gt; 如果你需要传入一个复杂的动态参数，我们推荐使用计算属性替换复杂的表达式，也是 Vue 最基础的概念之一，我们很快就会讲到。 当使用 DOM 内嵌模板 (直接写在 HTML 文件里的模板) 时，我们需要避免在名称中使用大写字母，因为浏览器会强制将其转换为小写： 1&lt;a :[someAttr]=&quot;value&quot;&gt; ... &lt;/a&gt; 上面的例子将会在 DOM 内嵌模板中被转换为 :[someattr]。如果你的组件拥有 “someAttr” 属性而非 “someattr”，这段代码将不会工作。单文件组件内的模板不受此限制。 修饰符 Modifiers修饰符是以点开头的特殊后缀，表明指令需要以一些特殊的方式被绑定。例如 .prevent 修饰符会告知 v-on 指令对触发的事件调用 event.preventDefault()： 1&lt;form @submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt; 之后在讲到 v-on 和 v-model 的功能时，你将会看到其他修饰符的例子。 最后，在这里你可以直观地看到完整的指令语法： 响应式基础声明响应式状态选用选项式 API 时，会用 data 选项来声明组件的响应式状态。此选项的值应为返回一个对象的函数。Vue 将在创建新组件实例的时候调用此函数，并将函数返回的对象用响应式系统进行包装。此对象的所有顶层属性都会被代理到组件实例 (即方法和生命周期钩子中的 this) 上。 12345678910111213141516171819202122&lt;script&gt;export default &#123; data() &#123; return &#123; count: 1 &#125; &#125;, // `mounted` is a lifecycle hook which we will explain later mounted() &#123; // `this` refers to the component instance. console.log(this.count) // =&gt; 1 &#125;&#125;&lt;/script&gt;&lt;template&gt; Count is: &#123;&#123; &#x27;这是容器中count的值：&#x27;+count &#125;&#125;&lt;/template&gt; 这些实例上的属性仅在实例首次创建时被添加，因此你需要确保它们都出现在 data 函数返回的对象上。若所需的值还未准备好，在必要时也可以使用 null、undefined 或者其他一些值占位。 虽然也可以不在 data 上定义，直接向组件实例添加新属性，但这个属性将无法触发响应式更新。 Vue 在组件实例上暴露的内置 API 使用 $ 作为前缀。它同时也为内部属性保留 _ 前缀。因此，你应该避免在顶层 data 上使用任何以这些字符作前缀的属性。 响应式代理 vs. 原始值在 Vue 3 中，数据是基于 JavaScript Proxy (代理) 实现响应式的。使用过 Vue 2 的用户可能需要注意下面这样的边界情况： 12345678910111213export default &#123; data() &#123; return &#123; someObject: &#123;&#125; &#125; &#125;, mounted() &#123; const newObject = &#123;&#125; this.someObject = newObject //如果写成this.newObject === this.someObject //那么这个结果就是true console.log(newObject === this.someObject) // false &#125;&#125; 当你在赋值后再访问 this.someObject，此值已经是原来的 newObject 的一个响应式代理。与 Vue 2 不同的是，这里原始的 newObject 不会变为响应式：请确保始终通过 this 来访问响应式状态。 声明方法要为组件添加方法，我们需要用到 methods 选项。它应该是一个包含所有方法的对象： 12345678910111213141516export default &#123; data() &#123; return &#123; count: 0 &#125; &#125;, methods: &#123; increment() &#123; this.count++ &#125; &#125;, mounted() &#123; // 在其他方法或是生命周期中也可以调用方法 this.increment() &#125;&#125; Vue 自动为 methods 中的方法绑定了永远指向组件实例的 this。这确保了方法在作为事件监听器或回调函数时始终保持正确的 this。你不应该在定义 methods 时使用箭头函数，因为箭头函数没有自己的 this 上下文。 1234567export default &#123; methods: &#123; increment: () =&gt; &#123; // 反例：无法访问此处的 `this`! &#125; &#125;&#125; 和组件实例上的其他属性一样，方法也可以在模板上被访问。在模板中它们常常被用作事件监听器： 1&lt;button @click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt; 在上面的例子中，increment 方法会在 &lt;button&gt; 被点击时调用。 深层响应性在 Vue 中，默认情况下，状态是深度响应的。这意味着当改变嵌套对象或数组时，这些变化也会被检测到： 1234567891011121314151617export default &#123; data() &#123; return &#123; obj: &#123; nested: &#123; count: 0 &#125;, arr: [&#x27;foo&#x27;, &#x27;bar&#x27;] &#125; &#125; &#125;, methods: &#123; mutateDeeply() &#123; // 以下都会按照期望工作 this.obj.nested.count++ this.obj.arr.push(&#x27;baz&#x27;) &#125; &#125;&#125; DOM 更新时机当你修改了响应式状态时，DOM 会被自动更新。但是需要注意的是，DOM 更新不是同步的。Vue 会在“next tick”更新周期中缓冲所有状态的修改，以确保不管你进行了多少次状态修改，每个组件都只会被更新一次。 要等待 DOM 更新完成后再执行额外的代码，可以使用 nextTick() 全局 API： 1234567891011import &#123; nextTick &#125; from &#x27;vue&#x27;export default &#123; methods: &#123; async increment() &#123; this.count++ await nextTick() // 现在 DOM 已经更新了 &#125; &#125;&#125; 有状态方法在某些情况下，我们可能需要动态地创建一个方法函数，比如创建一个预置防抖的事件处理器： 12345678910import &#123; debounce &#125; from &#x27;lodash-es&#x27;export default &#123; methods: &#123; // 使用 Lodash 的防抖函数 click: debounce(function () &#123; // ... 对点击的响应 ... &#125;, 500) &#125;&#125; 不过这种方法对于被重用的组件来说是有问题的，因为这个预置防抖的函数是有状态的：它在运行时维护着一个内部状态。如果多个组件实例都共享这同一个预置防抖的函数，那么它们之间将会互相影响。 要保持每个组件实例的防抖函数都彼此独立，我们可以改为在 created 生命周期钩子中创建这个预置防抖的函数： 12345678910111213141516export default &#123; created() &#123; // 每个实例都有了自己的预置防抖的处理函数 this.debouncedClick = _.debounce(this.click, 500) &#125;, unmounted() &#123; // 最好是在组件卸载时 // 清除掉防抖计时器 this.debouncedClick.cancel() &#125;, methods: &#123; click() &#123; // ... 对点击的响应 ... &#125; &#125;&#125; 计算属性基础示例模板中的表达式虽然方便，但也只能用来做简单的操作。如果在模板中写太多逻辑，会让模板变得臃肿，难以维护。比如说，我们有这样一个包含嵌套数组的对象： 1234567891011121314export default &#123; data() &#123; return &#123; author: &#123; name: &#x27;John Doe&#x27;, books: [ &#x27;Vue 2 - Advanced Guide&#x27;, &#x27;Vue 3 - Basic Guide&#x27;, &#x27;Vue 4 - The Mystery&#x27; ] &#125; &#125; &#125;&#125; 我们想根据 author 是否已有一些书籍来展示不同的信息： 12&lt;p&gt;Has published books:&lt;/p&gt;&lt;span&gt;&#123;&#123; author.books.length &gt; 0 ? &#x27;Yes&#x27; : &#x27;No&#x27; &#125;&#125;&lt;/span&gt; 这里的模板看起来有些复杂。我们必须认真看好一会儿才能明白它的计算依赖于 author.books。更重要的是，如果在模板中需要不止一次这样的计算，我们可不想将这样的代码在模板里重复好多遍。 因此我们推荐使用计算属性来描述依赖响应式状态的复杂逻辑。这是重构后的示例： 123456789101112131415161718192021export default &#123; data() &#123; return &#123; author: &#123; name: &#x27;John Doe&#x27;, books: [ &#x27;Vue 2 - Advanced Guide&#x27;, &#x27;Vue 3 - Basic Guide&#x27;, &#x27;Vue 4 - The Mystery&#x27; ] &#125; &#125; &#125;, computed: &#123; // 一个计算属性的 getter publishedBooksMessage() &#123; // `this` 指向当前组件实例 return this.author.books.length &gt; 0 ? &#x27;Yes&#x27; : &#x27;No&#x27; &#125; &#125;&#125; 123&lt;p&gt;Has published books:&lt;/p&gt;&lt;!--我们的计算属性publishedBooksMessage()返回了臃肿的表达式，而我们在使用时直接使用计算属性的名称即可--&gt;&lt;span&gt;&#123;&#123; publishedBooksMessage &#125;&#125;&lt;/span&gt; 我们在这里定义了一个计算属性 publishedBooksMessage。 更改此应用的 data 中 books 数组的值后，可以看到 publishedBooksMessage 也会随之改变。 在模板中使用计算属性的方式和一般的属性并无二致。Vue 会检测到 this.publishedBooksMessage 依赖于 this.author.books，所以当 this.author.books 改变时，任何依赖于 this.publishedBooksMessage 的绑定都将同时更新。 计算属性缓存 vs 方法你可能注意到我们在表达式中像这样调用一个函数也会获得和计算属性相同的结果： 1&lt;p&gt;&#123;&#123; calculateBooksMessage() &#125;&#125;&lt;/p&gt; 123456// 组件中methods: &#123; calculateBooksMessage() &#123; return this.author.books.length &gt; 0 ? &#x27;Yes&#x27; : &#x27;No&#x27; &#125;&#125; 若我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的，然而，不同之处在于计算属性值会基于其响应式依赖被缓存。一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要 author.books 不改变，无论多少次访问 publishedBooksMessage 都会立即返回先前的计算结果，而不用重复执行 getter 函数。 这也解释了为什么下面的计算属性永远不会更新，因为 Date.now() 并不是一个响应式依赖： js 12345computed: &#123; now() &#123; return Date.now() &#125;&#125; 相比之下，方法调用总是会在重渲染发生时再次执行函数。 为什么需要缓存呢？想象一下我们有一个非常耗性能的计算属性 list，需要循环一个巨大的数组并做许多计算逻辑，并且可能也有其他计算属性依赖于 list。没有缓存的话，我们会重复执行非常多次 list 的 getter，然而这实际上没有必要！如果你确定不需要缓存，那么也可以使用方法调用。 最佳实践Getter 不应有副作用计算属性的 getter 应只做计算而没有任何其他的副作用，这一点非常重要，请务必牢记。举例来说，不要改变其他状态、在 getter 中做异步请求或者更改 DOM！一个计算属性的声明中描述的是如何根据其他值派生一个值。因此 getter 的职责应该仅为计算和返回该值。在之后的指引中我们会讨论如何使用侦听器根据其他响应式状态的变更来创建副作用。 避免直接修改计算属性值从计算属性返回的值是派生状态。可以把它看作是一个“临时快照”，每当源状态发生变化时，就会创建一个新的快照。更改快照是没有意义的，因此计算属性的返回值应该被视为只读的，并且永远不应该被更改——应该更新它所依赖的源状态以触发新的计算。 Class 与 Style 绑定数据绑定的一个常见需求场景是操纵元素的 CSS class 列表和内联样式。因为 class 和 style 都是 attribute，我们可以和其他 attribute 一样使用 v-bind 将它们和动态的字符串绑定。但是，在处理比较复杂的绑定时，通过拼接生成字符串是麻烦且易出错的。因此，Vue 专门为 class 和 style 的 v-bind 用法提供了特殊的功能增强。除了字符串外，表达式的值也可以是对象或数组。 123456789101112131415161718192021&lt;script&gt;export default &#123; data() &#123; return &#123; isActive: true, hasError: false &#125; &#125;,&#125;&lt;/script&gt;&lt;template&gt; &lt;!-- 当容器中的isActive属性为true时，那么渲染时,就会是这样 &lt;div class=&quot;active&quot;&gt;data&lt;/div&gt; --&gt;&lt;div :class=&quot;&#123; active: isActive &#125;&quot;&gt;data&lt;/div&gt;&lt;!-- 当容器中的isActive属性为true,hasError属性为true时，那么渲染时,就会是这样 &lt;div class=&quot;static active text-danger&quot;&gt;data&lt;/div&gt; --&gt;&lt;div class=&quot;static&quot; :class=&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;&gt;&lt;/div&gt;&lt;/template&gt; 当 isActive 或者 hasError 改变时，class 列表会随之更新。举例来说，如果 hasError 变为 true，class 列表也会变成 &quot;static active text-danger&quot;。 绑定的对象并不一定需要写成内联字面量的形式，也可以直接绑定一个对象： 12345678data() &#123; return &#123; classObject: &#123; active: true, &#x27;text-danger&#x27;: false &#125; &#125;&#125; 1&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt; 这将渲染： 1&lt;div class=&quot;active&quot;&gt;&lt;/div&gt; 我们也可以绑定一个返回对象的计算属性。这是一个常见且很有用的技巧： js 1234567891011121314data() &#123; return &#123; isActive: true, error: null &#125;&#125;,computed: &#123; classObject() &#123; return &#123; active: this.isActive &amp;&amp; !this.error, &#x27;text-danger&#x27;: this.error &amp;&amp; this.error.type === &#x27;fatal&#x27; &#125; &#125;&#125; 1&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt; 绑定数组我们可以给 :class 绑定一个数组来渲染多个 CSS class： 123456data() &#123; return &#123; activeClass: &#x27;active&#x27;, errorClass: &#x27;text-danger&#x27; &#125;&#125; 1&lt;div :class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt; 渲染的结果是： 1&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt; 如果你也想在数组中有条件地渲染某个 class，你可以使用三元表达式： 1&lt;div :class=&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;&gt;&lt;/div&gt; errorClass 会一直存在，但 activeClass 只会在 isActive 为真时才存在。 然而，这可能在有多个依赖条件的 class 时会有些冗长。因此也可以在数组中嵌套对象： 1&lt;div :class=&quot;[&#123; activeClass: isActive &#125;, errorClass]&quot;&gt;&lt;/div&gt; 在组件上使用对于只有一个根元素的组件，当你使用了 class attribute 时，这些 class 会被添加到根元素上并与该元素上已有的 class 合并。 举例来说，如果你声明了一个组件名叫 MyComponent，模板如下： 12&lt;!-- 子组件模板 --&gt;&lt;p class=&quot;foo bar&quot;&gt;Hi!&lt;/p&gt;","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://example.com/tags/vue-js/"}]},{"title":"SpringMVC学习","slug":"SpringMVC学习","date":"2024-06-17T10:33:15.000Z","updated":"2024-06-17T13:51:11.051Z","comments":true,"path":"2024/06/17/SpringMVC学习/","permalink":"http://example.com/2024/06/17/SpringMVC%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"SSM：MyBaits+spring+SpringMVC 这是MVC的三层框架。 什么是MVC？ MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。 是将业务逻辑、数据、显示分离的方法来组织代码。 MVC主要作用是降低了视图与业务逻辑间的双向偶合。 MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。 **Model(模型):**数据模型，提供要展示的数，因此包含数据和行为，可以认为是领域模型或JavaBean组件(包含数据和行为)，不过现在一般都分离开来:Value Object(数据Dao)和 服务层(行为Service)。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务**View(视图):**负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。**Controler(控制器):**接收用户请求，委托给模型进行处理(状态改变)，处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。最典型的MVC就是JSP +servlet+javabean的模式: 回顾Servlet","categories":[],"tags":[]},{"title":"CI/CD技术","slug":"CI-CD技术","date":"2024-06-10T08:54:36.000Z","updated":"2024-06-10T08:54:36.400Z","comments":true,"path":"2024/06/10/CI-CD技术/","permalink":"http://example.com/2024/06/10/CI-CD%E6%8A%80%E6%9C%AF/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"K8S技术","slug":"K8S技术","date":"2024-06-10T08:54:27.000Z","updated":"2024-06-10T08:54:27.286Z","comments":true,"path":"2024/06/10/K8S技术/","permalink":"http://example.com/2024/06/10/K8S%E6%8A%80%E6%9C%AF/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Nginx网关","slug":"Nginx网关","date":"2024-06-10T08:54:18.000Z","updated":"2024-06-10T11:46:40.801Z","comments":true,"path":"2024/06/10/Nginx网关/","permalink":"http://example.com/2024/06/10/Nginx%E7%BD%91%E5%85%B3/","excerpt":"","text":"1. Nginx安装目录(对于源码安装): 当使用源代码编译安装 Nginx 时，整个 Nginx 的安装树可能位于此目录下。这包括可执行文件、配置文件、文档和模块文件等。 内部可能包含以下子目录： client_body_temp: 用于存储上传的大文件的临时目录。 conf: 包含所有的配置文件，如 nginx.conf，以及其他的配置片段或模块配置。 html: 这是 Nginx 的默认网站根目录，通常包含默认的 HTML 页面。 logs: 类似于 /var/log/nginx，用于存储日志文件。 mime.types: 包含 MIME 类型的定义，用于识别和处理不同的文件类型。 modules: 可能包含 Nginx 的模块文件，用于扩展 Nginx 的功能。 sbin: 包含 Nginx 的二进制可执行文件。 2. Nginx多线程请求模型和基本请求流程 Nginx 的设计并不基于传统的多线程模型来处理请求，而是采用了异步非阻塞的事件驱动模型。Nginx 使用了多进程（多worker进程）模型来提高并发性能和稳定性，每个worker进程内处理请求时则利用了高效的事件处理机制。 2.1 Nginx 的多进程模型Nginx 的工作模型包括一个master进程和多个worker进程。master进程主要负责读取和验证配置文件，生成worker进程，并监听和响应来自worker进程和外部的信号，如重启、停止等操作。worker进程则负责处理所有来自客户端的网络请求。 2.2 Nginx 的事件驱动模型每个worker进程都有自己的事件循环，可以同时处理多个连接。Nginx 使用了高效的事件处理模块，比如epoll（Linux）、kqueue（BSD系统）等，这些模块允许Nginx在一个进程内处理成千上万的并发连接，而无需为每一个连接创建一个新的线程。 2.3 Nginx 的基本请求处理流程当一个HTTP请求到达Nginx时，它遵循以下基本流程： 接受连接：Nginx监听在配置的端口上，当请求到达时，master进程通过套接字接受连接，然后将连接分配给一个空闲的worker进程。 读取请求：worker进程读取客户端的HTTP请求，包括请求行、请求头和可能的请求体。 解析请求：解析请求的URL、HTTP方法、协议版本等信息。 处理请求：根据配置文件中的规则和指令，Nginx决定如何处理请求，这可能包括： 路由到正确的站点或服务器块。 提供静态文件服务。 执行重定向。 执行反向代理，将请求转发到后端服务器。 执行负载均衡，选择后端服务器池中的一个服务器。 执行缓存策略，检查是否有缓存的数据可以提供。 生成响应：一旦请求被处理，Nginx会生成响应，这可能包括从文件系统读取数据、从后端服务器获取数据或从缓存中获取数据。 发送响应：将响应发送回客户端，包括HTTP状态行、响应头和响应体。 记录日志：Nginx会记录请求和响应的信息到日志文件，通常包括访问日志和错误日志。 关闭连接：根据HTTP协议版本和配置，Nginx可能会保持连接打开一段时间（持久连接）或立即关闭连接。 这种模型允许Nginx高效地处理大量的并发连接，同时也保持了较低的内存消耗和CPU占用率。由于每个worker进程独立处理请求，即使一个请求处理失败，也不会影响其他worker进程的正常工作。 3. Nginx配置文件nginx.conf详解Nginx的配置文件nginx.conf是其核心配置所在，用于定义Nginx的行为和服务设置。以下是您提到的一些关键配置项的详细解释： 3.1 worker_connections属性worker_connections是events块中的一个配置项，用来指定每个worker进程能够同时打开的最大连接数。这是Nginx并发能力的关键设置。例如： Nginx 1231events &#123;2 worker_connections 1024;3&#125; 默认情况下，这个值通常是系统限制的最大文件描述符数量。增加这个值可以提高Nginx处理并发连接的能力，但也要考虑到系统的实际硬件资源，如内存。 3.2 http属性http块包含了全局的HTTP设置和虚拟服务器定义。在这个块中，你可以定义各种与HTTP相关的设置，比如MIME类型、日志格式、gzip压缩、缓存、SSL证书等。例如： Nginx 123456789101http &#123;2 include mime.types;3 default_type application/octet-stream;45 sendfile on;6 tcp_nopush on;7 tcp_nodelay on;89 keepalive_timeout 65;10&#125; 3.3 sendfile属性sendfile是一个与文件传输相关的指令，控制Nginx是否使用高效的操作系统级别的文件传输方式。默认情况下，它是开启的(on)。使用sendfile可以避免用户空间和内核空间之间的数据复制，从而提高文件传输效率。例如： Nginx 11 sendfile on; 3.4keepalive_timeout属性keepalive_timeout用于设置HTTP持久连接（keep-alive）的超时时间。这是客户端和服务器之间保持连接打开的时间长度，直到超时或被关闭。例如： Nginx 11 keepalive_timeout 65; 这个设置对于减少网络延迟和提高性能非常重要，因为它允许客户端和服务器在多个请求间重用同一个TCP连接，而不需要每次请求都重新建立和关闭连接。 3.5 server属性server块用于定义一个虚拟服务器，可以绑定到特定的IP地址和端口，或者监听所有的可用接口。每个server块都可以有自己独立的设置，包括监听的端口、主机名、请求处理逻辑等。例如： Nginx 123456781server &#123; //监听端口号2 listen 80; //主机名称3 server_name localhost;45 # 配置请求路由、错误页面、日志等6&#125; 每个server块都可以包含多个location块，用于更细粒度的请求路由和处理。通过不同的server块，Nginx可以同时为多个不同的域名或服务提供服务。 正确配置这些选项对于优化Nginx的性能、安全性和功能性至关重要。 3.5.1 Server Blockserver 是 Nginx 中用于定义一个虚拟服务器的配置块，可以理解为一个独立的“网站”配置。每个 server 块可以绑定到一个或多个 IP 地址和端口，也可以监听特定的域名。server 块内的设置定义了该虚拟服务器的行为，包括但不限于： listen: 指定要监听的端口和地址，例如 listen 80; 表示监听 80 端口。 server_name: 设置虚拟服务器的域名，例如 server_name example.com;。 3.5.2 Location Blocklocation 块是 server 块内的子配置块，用于更精细地控制请求的处理方式。它基于 URL 的路径模式来匹配请求，并应用相应的配置。例如： 精确匹配: location = /index.html &#123; ... &#125; 前缀匹配: location /images/ &#123; ... &#125; 正则表达式匹配: location ~* \\.(jpg|jpeg|gif|png)$ &#123; ... &#125; location 块内的配置可以包括静态文件服务、反向代理设置、重写规则、错误页定制、访问控制等。 3.5.3 Error_page Directiveerror_page 指令用于定义特定错误代码的自定义错误页面。它可以将一组错误代码映射到一个特定的 URI，当发生这些错误时，Nginx 将重定向到该 URI。例如： Nginx 11error_page 404 /404.html; 这表示当 Nginx 遇到 404 错误时，会显示 /404.html 文件作为错误页面。error_page 可以在 http、server 或 location 块中定义。 4. Nginx 反向代理和负载均衡4.1 Nginx 反向代理Nginx作为反向代理服务器时，其主要工作原理是位于网络服务器群前端，接受来自客户端（如浏览器）的请求，但客户端并不直接知道实际提供服务的服务器位置。Nginx根据预设的规则将请求转发至后端服务器之一，并将该服务器的响应再转发回客户端。这一过程对客户端是透明的，即客户端只知道Nginx的地址，而不知道实际提供服务的服务器地址。 优点： 安全：隐藏后端服务器的真实IP，增强安全防护。 性能优化：可以通过缓存、压缩等技术减少后端服务器的负担。 负载均衡：通过分配请求到不同的后端服务器，实现资源的有效利用，提高系统整体性能。 4.2 负载均衡负载均衡是指将大量并发访问或数据流量合理地分配到多台服务器上，以达到最优资源利用，最大化处理能力，最小化响应时间，同时避免任何单一服务器过载。Nginx作为一个优秀的负载均衡器，它提供了多种算法来决定如何将请求分发到后端服务器，包括但不限于轮询（Round Robin）、最少连接数（Least Connections）、IP哈希（IP Hash）等。 轮询：按照顺序将请求分发给后端服务器。 最少连接数：将新请求分发给当前连接数最少的服务器。 IP哈希：根据客户端的IP地址进行哈希运算，将同一客户端的请求尽量分发到同一服务器上，以保持会话的一致性。 4.3 正向代理正向代理与反向代理的工作方式相反。正向代理位于客户端一侧，它的主要作用是代表客户端去获取互联网上的资源，而不是像反向代理那样代表服务器接收请求。当客户端配置了正向代理后，所有对外的请求都会先经过这个代理，由代理服务器代替客户端去访问目标服务器，获取资源后再返回给客户端。 用途： 匿名访问：通过代理服务器隐藏客户端的真实IP，保护隐私。 内容过滤：企业或学校网络中常见的场景，用于过滤不适宜的网站或内容。 缓存加速：对于重复的请求，代理服务器可以缓存资源，提高访问速度。 正向代理和反向代理虽然在工作方向上有本质的区别，但在实际应用中，它们都可以起到优化网络性能、提高安全性和控制网络流量的作用。Nginx本身既可以配置为反向代理，也可以配置为正向代理，不过在实践中更多被用作反向代理和负载均衡器。","categories":[],"tags":[{"name":"nginx学习","slug":"nginx学习","permalink":"http://example.com/tags/nginx%E5%AD%A6%E4%B9%A0/"}]},{"title":"RabbitMQ消息队列笔记","slug":"RabbitMQ消息队列笔记","date":"2024-06-10T08:54:08.000Z","updated":"2024-06-10T08:54:08.775Z","comments":true,"path":"2024/06/10/RabbitMQ消息队列笔记/","permalink":"http://example.com/2024/06/10/RabbitMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Redis缓存技术","slug":"Redis缓存技术","date":"2024-06-10T08:53:56.000Z","updated":"2024-06-10T08:53:56.895Z","comments":true,"path":"2024/06/10/Redis缓存技术/","permalink":"http://example.com/2024/06/10/Redis%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"SpringBoot缓存以及结合Redis","slug":"SpringBoot缓存以及结合Redis","date":"2024-06-08T03:22:44.000Z","updated":"2024-06-08T03:22:44.366Z","comments":true,"path":"2024/06/08/SpringBoot缓存以及结合Redis/","permalink":"http://example.com/2024/06/08/SpringBoot%E7%BC%93%E5%AD%98%E4%BB%A5%E5%8F%8A%E7%BB%93%E5%90%88Redis/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Docker学习笔记","slug":"Docker学习笔记","date":"2024-06-07T09:53:52.000Z","updated":"2024-06-07T10:05:19.020Z","comments":true,"path":"2024/06/07/Docker学习笔记/","permalink":"http://example.com/2024/06/07/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Docker 学习笔记1. Docker 简介Docker 是一个开源的应用容器引擎，基于 Go 语言并遵循 Apache2.0 协议开源。它允许开发者将应用程序及其依赖项封装到一个轻量级、可移植的容器中，以便在任何安装了 Docker 的 Linux 或 Windows 机器上运行。 2. Docker 架构Docker 架构主要由三部分组成： Docker Client: 用户与 Docker Daemon 通信的接口，可以发送命令给 Docker Daemon。 Docker Daemon: 运行在主机上的后台进程，负责接收 Docker Client 发来的请求，处理并管理 Docker 对象，如镜像、容器等。 Docker Registry: 用于存储和分发 Docker 镜像的仓库，分为公有仓库（如 Docker Hub）和私有仓库。 3. Docker 命令3.1 拉取镜像1docker pull [OPTIONS] NAME[:TAG|@DIGEST] 3.2 运行容器1docker run [OPTIONS] IMAGE [COMMAND] [ARG...] 3.3 列出容器1docker ps [OPTIONS] 3.4 停止容器1docker stop [OPTIONS] CONTAINER [CONTAINER...] 3.5 删除容器1docker rm [OPTIONS] CONTAINER [CONTAINER...] 3.6 删除镜像1docker rmi [OPTIONS] IMAGE [IMAGE...] 4. DockerfileDockerfile 是一个包含了一系列指令的文本文件，用于构建 Docker 镜像。例如： 12345FROM ubuntu:latestMAINTAINER user@example.comRUN apt-get update &amp;&amp; apt-get install -y nginxEXPOSE 80CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;] 4.1 常见指令 FROM: 指定基础镜像。 RUN: 执行命令，可以是 shell 命令或脚本。 COPY: 复制文件或目录至镜像中。 ADD: 类似于 COPY，但可以支持自动解压 tar 文件。 EXPOSE: 暴露端口。 CMD: 容器启动时默认执行的命令。 ENTRYPOINT: 类似于 CMD，但可以设置默认的可执行文件及参数。 5. Docker ComposeDocker Compose 是一个用于定义和运行多容器 Docker 应用程序的工具。它使用 YAML 文件来配置应用程序的服务，然后使用一个命令来创建和启动所有服务。 12345678version: &#x27;3&#x27;services: web: image: nginx:latest ports: - &quot;80:80&quot; db: image: postgres:latest 5.1 Compose 命令 docker-compose up: 启动服务。 docker-compose down: 停止并删除服务。 docker-compose restart: 重启服务。 docker-compose logs: 查看服务日志。 6. Docker SwarmDocker Swarm 是 Docker 的原生集群管理工具，允许用户将多个 Docker 主机组织成一个集群，并以集群为单位进行操作。 6.1 Swarm 命令 docker swarm init: 初始化 Swarm 集群。 docker swarm join: 加入 Swarm 集群。 docker service create: 创建服务。 docker service scale: 调整服务的副本数量。 6.2 初始化Swarm1234567# 在manager节点上初始化Swarmdocker swarm init# 获取worker节点加入Swarm的命令docker swarm join-token worker# 在worker节点上执行上面的命令，加入Swarm 6.3 网络模式 overlay: Swarm 模式下的默认网络，用于跨主机通信。 ingress: 用于负载均衡的网络模式。 7. Docker VolumesDocker Volumes 是用于在 Docker 容器之间共享数据的一种方式，它们独立于容器存在，即使容器被删除，数据也不会丢失。 7.1 常用命令 docker volume create: 创建卷。 docker volume ls: 列出所有卷。 docker volume inspect: 显示卷的详细信息。 docker volume rm: 删除卷。 7.2 创建 Docker Volume首先，你可以通过运行 docker volume create 命令来创建一个新的 Docker Volume。假设我们将其命名为 mydata: Bash 11$ docker volume create mydata 7.3 运行容器并挂载 Volume接下来，你可以运行一个新的容器，并将这个 Volume 挂载到容器内的某个目录。例如，我们可以运行一个带有 Nginx 的容器，并将 mydata Volume 挂载到 /var/www/html 目录下： Bash 11$ docker run -d --name mynginx -v mydata:/var/www/html nginx 这里 -v mydata:/var/www/html 参数指定了将名为 mydata 的 Volume 挂载到容器内 /var/www/html 目录上。 7.4 访问和修改 Volume 中的数据现在，你可以在宿主机上通过 docker exec 命令访问容器，并修改或查看 Volume 中的数据。例如，你可以向 /var/www/html 目录添加一个文件： Bash 121$ docker exec -it mynginx bash2# echo &#x27;Hello World!&#x27; &gt; /var/www/html/index.html 然后从容器内部退出。 7.5 查看 Volume你可以通过运行 docker volume ls 或者 docker volume inspect &lt;volume_name&gt; 来查看已存在的 Volumes 列表或特定 Volume 的详细信息。 Bash 1231$ docker volume ls2DRIVER VOLUME NAME3local mydata Bash 1234567891011121$ docker volume inspect mydata2[3 &#123;4 &quot;CreatedAt&quot;: &quot;2023-03-16T14:05:09Z&quot;,5 &quot;Driver&quot;: &quot;local&quot;,6 &quot;Labels&quot;: &#123;&#125;,7 &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/mydata/_data&quot;,8 &quot;Name&quot;: &quot;mydata&quot;,9 &quot;Options&quot;: &#123;&#125;,10 &quot;Scope&quot;: &quot;local&quot;11 &#125;12] 7.6 清理 Volume当你不再需要某个 Volume 时，可以使用 docker volume rm 命令来删除它。但请注意，在删除之前，确保该 Volume 不再被任何容器使用： Bash 11$ docker volume rm mydata 7.7 删除容器但保留 Volume即使你删除了容器，Volume 也会保持不变。如果要删除容器 mynginx 而保留其挂载的 Volume，只需运行： Bash 11$ docker rm mynginx 8. Docker NetworkDocker Network 提供了容器之间的网络通信能力，可以创建自定义网络，实现容器间的隔离和通信。 8.1 常用命令 docker network create: 创建网络。 docker network ls: 列出所有网络。 docker network connect: 连接容器到网络。 docker network disconnect: 断开容器与网络的连接。 8.2 创建和使用Network123456# 创建一个名为mynetwork的networkdocker network create mynetwork# 运行两个容器，并挂载到mynetworkdocker run -d --name container1 --network mynetwork alpine tail -f /dev/nulldocker run -d --name container2 --network mynetwork alpine tail -f /dev/null 9. Docker SecurityDocker 提供了多种安全机制，包括但不限于： 内容信任：确保拉取的镜像是可信的。 资源限制：限制容器的资源使用，如 CPU、内存等。 安全扫描：检测镜像中的漏洞。 运行时策略：控制容器的运行环境，如 SELinux、AppArmor 等。 10. Docker StackDocker Stack 是Docker的一种部署和管理多服务应用的方式，可以使用Docker Compose文件在Swarm模式下部署和管理多个服务。 10.1 部署Stack1234567891011121version: &#x27;3&#x27;2services:3 web:4 image: nginx:latest5 ports:6 - target: 807 published: 808 protocol: tcp9 db:10 image: postgres:latest11 environment:12 POSTGRES_PASSWORD: mysecretpassword 12341# 将上面的Compose文件保存为docker-compose.yml23# 在Swarm模式下部署Stack4docker stack deploy -c docker-compose.yml mystack","categories":[],"tags":[{"name":"Docker学习","slug":"Docker学习","permalink":"http://example.com/tags/Docker%E5%AD%A6%E4%B9%A0/"}]},{"title":"JavaWeb开发学习","slug":"JavaWeb开发学习","date":"2024-05-02T09:41:21.000Z","updated":"2024-07-08T15:27:50.779Z","comments":true,"path":"2024/05/02/JavaWeb开发学习/","permalink":"http://example.com/2024/05/02/JavaWeb%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"HTML笔记 HTML大致格式： 12345678&lt;HTML&gt; &lt;head&gt; &lt;title&gt;标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 内容 &lt;/body&gt;&lt;/HTML&gt; 1.超链接标签: 1&lt;a&gt;这是a标签&lt;/a&gt; 属性: href:指定资源访问的url target:指定在何处打开资源链接 self:默认值，在当前页面打开 blank:在空白页面打开 视频标签: 1&lt;audio&gt;&lt;/audio&gt; src:规定视频的ur1 controls:显示播放控件 width:播放器的宽度 height:播放器的高度 音频标签: 1&lt;audio src&quot;xxxxx&quot; controls = &quot;controls&quot;&gt; &lt;/audio&gt; src:规定音频的url controls:显示播放控件 段落标签: 1&lt;p&gt;这是段落标签&lt;/p&gt; 文本加粗标签： 1&lt;b&gt; / &lt;strong&gt; 盒子(div) 盒子:页面中所有的元素(标签)，都可以看做是一个 盒子，由盒子将页面中的元素包含在一个矩形区域内，通过盒子的视角更方便的进行页面布局 盒子模型组成:内容区域(content)边框区域(border)、外边距区域(margin)、内边距区域(padding) span标签:一行可以显示多个，宽度和高度默认由内容撑开，不可以设置宽高(width、height)。 表格： 标签： 1&lt;table&gt;&lt;/table&gt; ，属性border：规定表格边框的宽度，width：规定表格的宽度，cellspacing：规定单元之间的空间 &lt;tr&gt;：表格的行，可以包裹多个&lt;td&gt; 123* ```html &lt;td&gt;：表格的单元格(普通)，可以包裹内容，如果是表头单元格可以用标签&lt;th&gt; 表单标签： 1&lt;form&gt; 应用场景：数据的采集功能，如注册、登录等数据采集 表单项： input标签，定义表单项，通过type属性控制输入的形式 select：定义下拉列表， option定义列表选项 textarea：定义文本区域 表单属性 action：规定当提交表单时向何处发送表单数据，URL method：规定用于发送表单数据的方式。GET、POST ​ form表单属性: label标签有聚焦的作用 action：表单提交的ur1，往何处提交数据，如果不指定，默认提交到当前页面method：表单的提交方式get：在ur1后面拼接表单数据，比如:?username&#x3D;Tom&amp;age&#x3D;12，url长度有限制 。默认值post：在消息体(请求体)中传递的，参数大小无限制的 表单标签——表单项 JavaScript笔记1）JS引入方式JS的引入方式有两种： 内部脚本：将JS代码定义在HTML页面中 JavaScript代码必须位于script标签内 在HTML文档中，可以再任意地方 ，放置任意数量的script 一般会把脚本置于body元素的底部，可以改善显示速度 外部脚本：将JS代码定义在外部JS文件中，然后引入到HTML页面中 外部JS文件中，只包含JS代码，不包含script标签 script标签不能够自闭合，也就是不可以写成 2）JS基础语法1、书写语法 区分大小写：与java一样，变量名、函数名以及其他一切东西都是区分大小写的 每行结尾的分号可有可无 注释： 单行注释：&#x2F;&#x2F;注释内容 多行注释：&#x2F;注释内容 *&#x2F; 大括号代表代码块： 1234//判断if(count == 3)&#123;alert(count);&#125; 输出语句* 使用**window.alert()**写入警告框 * 使用**document.write()**写入HTML输出 * 使用**console.log()**写入浏览器控制台 2、变量 JavaScript 中用 var关键字(variable 的缩写)来声明变量。 var的特点： 作用域比较大，全局变量。 可以重复定义同一个变量。相当于一个覆盖 JavaScript 是一门弱类型语言，变量可以存放不同类型的值。 123var a = &quot;张三&quot;;//定义a的值是字符串张三a = 20//把值20赋值给aalert(a)//输出20 变量名需要遵循如下规则: 组成字符可以是任何字母、数字、下划线(_)或美元符号($) 数字不能开头 建议使用驼峰命名(如userName) let 关键字来定义变量。它的用法类似于 var，但是所声明的变量，只在let 关键字所在的代码块内有效，且不允许重复声明。 const 关键字，用来声明一个只读的常量。一旦声明，常量的值就不能改变。 3、数据类型 JS中分为：原始类型和引用类型。 原始类型 运算符 算术运算符:+，-，*，&#x2F;，%，++，– 赋值运算符:&#x3D;，+&#x3D;，-&#x3D;，，&#x2F;&#x3D;,%&#x3D; 比较运算符:&gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;，!&#x3D;，&#x3D;&#x3D;，**&#x3D;&#x3D;&#x3D;** &#x3D;&#x3D;与&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;会进行类型转换，&#x3D;&#x3D;&#x3D;不会进行类型转换。 逻辑运算符:&amp;&amp;，||，! 三元运算符:条件表达式?true_value:false value 类型转换： 字符串类型转为数字： paseInt方法：这个方法能够将字符串转为数字，原理是从字符串左边开始读取，读取到不是数字的地方(如12A45他会读取到A这个为止而停下来)停下来，取该位置前面的输出。 alert(parseInt(&quot;12&quot;));//转为12 alert(parseInt(&quot;12A45&quot;));//转为12 alert(parseInt(&quot;A45&quot;));//转为NaN(not a number) 其他类型转为boolean： Number类型：0和NaN转为false，其他均转为true。 String类型：空字符串转为false，其他 均转为true。 Null类型和undefined类型：均转为false。 隐式转换 检测数据类型 typeof + 检测的名字 流程控制 if…else if ….else…. switch for while do…while 值得注意的是，在JS中这些流程控制语句和我们的java是完全一致的。 break和continue 冒泡排序3）JS函数1、函数的定义123456789function functionName(参数1，参数2...)&#123;//要执行的代码&#125;//另一种方式调用let functionName = function(参数1，参数2...)&#123; //要执行的代码&#125; 注意 形式参数不需要类型。因为JS是弱类型语言。 返回值类型也不需要定义，可以再函数内部直接使用return返回即可。 调用：函数名称(实际参数列表) 2、匿名函数 函数分为 函数表达式 &lt;script&gt; // 1.函数表达式 let fn = function (x,y)&#123; console.log( x + y ); &#125; fn(1,2); // 函数表达式 和具名函数(有名函数) 有什么不同呢？ // 1.具名函数的调用可以写到任何位置 // 2.匿名函数的函数表达式形式写法必须先声明在使用，否则会报错未声明 &lt;/script&gt; 123456789101112131415161718192021* 立即执行函数 * ```js // 1、立即执行函数 (function(x,y)&#123; console.log(x+y); &#125;)(1,2); // 2、第二种 写法 (function(x,y)&#123; console.log(x+y); &#125;(1,3)); // 上面结构中，第二个小括号是实参，function()中的小括号传递的是形参&#123;&#125;中写入要执行的逻辑 * 注意：多个立即执行函数要在函数末尾用分号隔开。 4）JS对象定义：let 对象名 &#x3D; { } Array(数组对象) 定义：let 变量名 &#x3D; new Array(元素列表)；或者let 变量名&#x3D; [元素列表]; 1234567891011121314151617181920212223242526272829303132333435363738&lt;script&gt; //定义数组 var arr1 = new Array(1,2,3,4,5); //或者var arr1 = [1,2,3,4,5] //访问元素 console.log(arr1[0]); console.log(arr1[1]); //特点：长度可变，类型可变 var arr = new Array(1,2,3); arr[10] = 50; console.log(arr[10]); arr[9] = &quot;zhangsan&quot;; arr[8] = true; console.log(arr); //数组的遍历,遍历所有的元素 for (let i = 0; i &lt; arr.length; i++) &#123; const element = arr[i]; console.log(element); &#125; console.log(&quot;=========================&quot;); //数组的遍历(foreach):遍历数组中有值的元素 arr.forEach(element =&gt; &#123; console.log(element); //ES6 箭头函数：(形参列表...) =&gt;&#123;函数体的内容&#125; &#125;); //push方法：添加元素到数组末尾 arr.push(&quot;添加测试1&quot;,&quot;添加测试2&quot;) console.log(arr); //删除元素splice方法:(从某个索引位置开始删除,删除元素的个数) arr.splice(11,2)&lt;/script&gt; String对象1234567&lt;script&gt; //String对象 //方式一： var stringTest = new String(&quot;zhangsan&quot;); //方式二： var stringTest1 =&quot;lisi&quot;;&lt;/script&gt; String对象的属性和方法 1234567891011121314151617181920212223&lt;script&gt; //String对象 //方式一： // var stringTest = new String(&quot;zhangsan&quot;); //方式二： var stringTest1 =&quot; Hello World &quot;; //获取字符串长度 console.log(stringTest1.length); //chAt方法,返回指定位置的字符 console.log(stringTest1.charAt(2));//H //indexOf方法，查询对应字符的索引 console.log(stringTest1.indexOf(&quot;H&quot;)); //2 //trim方法(去除空格) var newString = stringTest1.trim(); console.log(newString); //substring方法，截取字符串，(前闭后开)输入两个值，开始索引和结束索引 //这里演示截取去除空格后的字符串，将Hello截取出来 console.log(newString.substring(0,5));//Hello&lt;/script&gt; json对象 概念: JavaScript Object Notation，JavaScript，对象标记法 JSON 是通过JavaScript 对象标记法书写的文本。 由于其语法简单，层次结构鲜明，现多用于作为数据载体，在网络中进行数据传输。 数据格式： 123456&#123;&quot;name&quot; : &quot;xiaoli&quot;,&quot;age&quot;:25,&quot;sex&quot;:&quot;男性&quot;, &quot;key1&quot;:&quot;value1&quot;&#125; 定义json案例 1234567891011&lt;script&gt; //定义json var jsonStr = &#x27;&#123;&quot;name&quot; = &quot;小李&quot;,&quot;age&quot; = 25, &quot;address&quot; = &quot;北京&quot; &#125;&#x27;; //JSON字符串转为JS对象——JSON.parse()方法 var jsonStrObject = JSON.parse(jsonStr); console.log(jsonStrObject); //JS对象转为JS字符串——JSON.stringify()方法 var jsObject = JSON.stringify(jsonStrObject); console.log(jsObject);&lt;/script&gt; BOM对象 概念:Browser Object Model 浏览器对象模型，允许lavaScript与浏览器对话，lavaScript 将浏览器的各个组成部分封装为对象。 Window对象 介绍:浏览器窗口对象。 获取:直接使用window，其中 window.可以省略window.alert()和alert()效果一样 属性 history:对 History 对象的只读引用。请参阅 History 对象 location:用于窗口或框架的 Location 对象。请参阅Location 对象。 navigator:对 Navigator 对象的只读引用。请参阅Navigator 对象 方法 alert():显示带有一段消息和一个确认按钮的警告框。 confirm():显示带有一段消息以及确认按钮和取消按钮的对话。 **setlnterval():**按照指定的周期(以毫秒计)来调用函数或计算表达式。 setTimeout():在指定的毫秒数后调用函数或计算表达式。 示例代码： 123456789101112131415161718192021&lt;script&gt; //获取 window.alert(&quot;Hello BOM&quot;); alert(&quot;Hello BoM window&quot;); // 方法 // confirm-对话框--确认:true ，取消:false var flag = confirm(&quot;您确认删除该记录吗?&quot;); alert(flag); // 定时器-setInterval -- 周期性的执行某一个函数 var i=0; setInterval(function()&#123; i++; console.log(&quot;定时器执行了&quot;+i+&quot;次&quot;); &#125;,2000); //定时器延迟指定时间执行一次:-setTimeout setTimeout(function()&#123; alert(&quot;Js&quot;); &#125;,3000); &lt;/script&gt; Location对象 介绍：地址栏对象。 获取：使用window.location获取，其中window.可以省略不写 属性： href：设置或返回完整的URL，如果设置URL那么他会自动跳转所设置的URL。 代码示例： 123456&lt;script&gt; //获取当前完整的URL console.log(location.href); //设置URL自动跳转 location.href=&quot;http://www.itcast.cn&quot;&lt;/script&gt; DOM对象 概念:Document Object Model，文档对象模型。 将标记语言的各个组成部分封装为对应的对象： Document：整个文档对象 Element：元素对象 Attribute：属性对象 Text：文本对象 Comment：注释对象 JavaScript 通过DOM，就能够对HTML进行如下操作： 改变 HTML元素的内容 改变 HTML元素的样式(CSS) 对 HTML DOM 事件作出反应 添加和删除 HTML元素 5）JS事件监听事件:HTML事件是发生在HTML元素上的“事情”。比如: 按钮被点击 鼠标移动到元素上 按下键盘按键 事件监听:JavaScript可以在事件被侦测到时 执行代码。 事件绑定 方式一：通过HTML标签中的时间属性进行绑定 1234567&lt;input type=&quot;button&quot; onclick=&quot;on()&quot; value=&quot;按钮1&quot;&gt;&lt;script&gt; function on() &#123; alert(&#x27;我被点击了!); &#125;&lt;/script&gt; 方式二：通过DOM元素属性绑定 1234567&lt;input type = &quot;button&quot; id =&quot;btn1&quot; value = &quot;按钮2&quot;&gt;&lt;script&gt;document.getElementById(&quot;btn1&quot;).onclick = function() &#123; alert(&quot;我被点击了！&quot;); &#125;&lt;/script&gt; 常见事件 6）变量语法：let 变量名 6.1、变量的赋值语法：变量 &#x3D; 要赋的值 1234567let ageage = 18//或者let age = 18；//弹出输入框prompt(&quot;请输入姓名&quot;)let name = prompt(&quot;请输入姓名&quot;) 6.2、var和let的区别在较旧的JavaScript，使用关键字 var 来声明变量 ，而不是 let。var现在开发中一般不再使用它，只是我们可能再老版程序中看到它。let 为了解决 var 的一些问题。 var 声明:可以先使用 在声明(不合理)var 声明过的变量可以重复声明(不合理)比如变量提升、全局变量、没有块级作用域等等 7）WebAPIS 变量声明 7.1、webAPI基本认识7.1.1、作用和分类 作用: 就是使用 JS 去操作 html和浏览器 分类:DOM(文档对象模型)、BOM(浏览器对象模型) 什么是webAPI？ API 指的是应用程序编程接口（Application Programming Interface）。 Web API 是 Web 的应用程序编程接口。 浏览器API 可以扩展 Web 浏览器的功能。 服务器 API 可以扩展 Web 服务器的功能 7.1.2、什么是DOM DOM(Document Object Model–文档对象模型)是用来呈现以及与任意 HTML 或 XML文档交互的API 白话文:DOM是浏览器提供的一套专门用来 操作网页内容 的功能 7.1.3、DOM树 DOM树是什么？ 将 HTML 文档以树状结构直观的表现出来，我们称之为文档树或 DOM 树 描述网页内容关系的名词 作用:文档树直观的体现了标签与标签之间的关系 7.1.4、DOM对象 DOM对象:浏览器根据html标签生成的JS对象 所有的标签属性都可以在这个对象上面找到 修改这个对象的属性会自动映射到标签身上 DOM核心思想 把网页内容当做对象来处理 doument对象 是 DOM 里提供的一个对象 所以它提供的属性和方法都是用来访问和操作网页内容的例:document.write() 网页所有内容都在document里面 7.2、获取DOM对象7.2.1、根据CSS选择器来获取DOM元素 选择匹配的第一个元素 语法 document.querySelector(&#39;css选择器&#39;) // 获取匹配的第一个元素(通过标签元素和类名来进行选择) const firstObj = document.querySelector(&#39;div&#39;) const firstObj2 = document.querySelector(&quot;.test&quot;) console.log(firstObj); console.log(firstObj2); const nav = document.querySelector(&quot;#nav&quot;) console.log(nav); const li = document.querySelector(&quot;ul li:first-child&quot;) console.log(li); 123456789101112 * 参数：包含一个或多个有效的CSS选择器字符串 * 返回值：CSS选择器匹配的**第一个元素**，一个HTMLElement对象* 选择多个元素* 语法： ```javascript const lis = document.querySelectorAll(&quot;ul li&quot;) console.log(lis); 返回值：返回一个数组 得到的是一个伪数组有长度有索引号的数组，但是没有 pop()push()等数组方法，想要得到里面的每一个对象，则需要遍历(for)的方式获得。 7.2.2、其他获取DOM元素的方法 7.3、操作元素内容7.3.1、对象.innerText属性7.3.2、对象.innerHtml属性获取元素内容最简单的方法是使用 innerHTML 属性。innerHTML 属性可用于获取或替换 HTML 元素的内容。innerHTML 属性可用于获取或改变任何 HTML 元素，包括 &lt;html&gt; 和 &lt;body&gt;。 下面的例子改变了 id&#x3D;”demo” 的 元素的内容： 1234567891011&lt;html&gt;&lt;body&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;document.getElementById(&quot;demo&quot;).innerHTML = &quot;Hello World!&quot;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在上面的例子中，getElementById 是方法，而 innerHTML 是属性。 7.3.3、getElementById 方法访问 HTML 元素最常用的方法是使用元素的 id。 在上面的例子中，getElementById 方法使用 id&#x3D;”demo” 来查找元素。 7.4、JavaScript 验证 API约束验证 DOM 方法 属性 描述 checkValidity() 如果 input 元素包含有效数据，则返回 true。 setCustomValidity() 设置 input 元素的 validationMessage 属性。 checkValidity() 方法 12345678910111213&lt;input id=&quot;id1&quot; type=&quot;number&quot; min=&quot;100&quot; max=&quot;300&quot; required&gt;&lt;button onclick=&quot;myFunction()&quot;&gt;OK&lt;/button&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;function myFunction() &#123; const inpObj = document.getElementById(&quot;id1&quot;); if (!inpObj.checkValidity()) &#123; document.getElementById(&quot;demo&quot;).innerHTML = inpObj.validationMessage; &#125; &#125;&lt;/script&gt; 约束验证 DOM 属性 属性 描述 validity 包含与输入元素有效性相关的布尔属性。 validationMessage 包含当有效性为 false 时浏览器将显示的消息。 willValidate 指示是否将验证 input 元素。 有效性属性input 元素的有效性属性包含许多与数据有效性相关的属性： 属性 描述 customError 如果设置了自定义有效性消息，则设置为 true。 patternMismatch 如果元素的值与其 pattern 属性不匹配，则设置为 true。 rangeOverflow 如果元素的值大于其 max 属性，则设置为 true。 rangeUnderflow 如果元素的值小于其 min 属性，则设置为 true。 stepMismatch 如果元素的值对其 step 属性无效，则设置为 true。 tooLong 如果元素的值超过其 maxLength 属性，则设置为 true。 typeMismatch 如果元素的值对其 type 属性无效，则设置为 true。 valueMissing 如果元素（具有 required 属性）没有值，则设置为 true。 valid 如果元素的值有效，则设置为 true。 rangeOverflow 属性 如果输入字段中的数字大于 100（input 元素的 max 属性），则显示一条消息： 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;JavaScript 验证&lt;/h1&gt;&lt;p&gt;请输入一个数字，然后单击“确定”：&lt;/p&gt;&lt;input id=&quot;id1&quot; type=&quot;number&quot; max=&quot;100&quot;&gt;&lt;button onclick=&quot;myFunction()&quot;&gt;确定&lt;/button&gt;&lt;p&gt;如果数字大于 100（输入的 max 属性），则会显示错误消息。&lt;/p&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;function myFunction() &#123; let text; if (document.getElementById(&quot;id1&quot;).validity.rangeOverflow) &#123; text = &quot;Value too large&quot;; &#125; else &#123; text = &quot;输入没问题&quot;; &#125; document.getElementById(&quot;demo&quot;).innerHTML = text;&#125;&lt;/script&gt;&lt;/body&gt; &lt;/html&gt; rangeUnderflow 属性 如果输入字段中的数字小于 100（input 元素的 min 属性），则显示一条消息： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;JavaScript 验证&lt;/h1&gt;&lt;p&gt;请输入一个数字，然后单击“确定”：&lt;/p&gt;&lt;input id=&quot;id1&quot; type=&quot;number&quot; min=&quot;100&quot;&gt;&lt;button onclick=&quot;myFunction()&quot;&gt;确定&lt;/button&gt;&lt;p&gt;如果数字小于 100（输入的 min 属性），则会显示错误消息。&lt;/p&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;function myFunction() &#123; let text; if (document.getElementById(&quot;id1&quot;).validity.rangeUnderflow) &#123; text = &quot;Value too small&quot;; &#125; else &#123; text = &quot;输入没问题&quot;; &#125; document.getElementById(&quot;demo&quot;).innerHTML = text;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 7.5、Web History APIWeb History API 提供了访问 windows.history 对象的简单方法。 window.history 对象包含用户访问过的 URL（网站）。 所有浏览器都支持 Web History API： History back() 方法back() 方法加载 windows.history 列表中的前一个 URL。 这与单击浏览器中的“后退箭头”相同。 1234567&lt;button onclick=&quot;myFunction()&quot;&gt;后退&lt;/button&gt;&lt;script&gt;function myFunction() &#123; window.history.back();&#125;&lt;/script&gt; History go() 方法go() 方法从历史列表中加载一个特定的 URL： 1234567&lt;button onclick=&quot;myFunction()&quot;&gt;后退两页&lt;/button&gt;&lt;script&gt;function myFunction() &#123; window.history.go(-2);&#125;&lt;/script&gt; History 对象属性 属性 描述 length 返回历史列表中的 URL 数量。 12345678910&lt;h1&gt;History对象&lt;/h1&gt;&lt;button onclick=&quot;getBack()&quot;&gt;获取浏览器历史列表长度&lt;/button&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;function getBack() &#123; let length = window.history.length; document.querySelector(&quot;#demo&quot;).innerHTML = `浏览器列表长度是：$&#123;length&#125;`&#125;&lt;/script&gt; History 对象方法 方法 描述 back() 加载历史列表中的上一个 URL。 forward() 加载历史列表中的下一个 URL。 go() 从历史列表中加载特定的 URL。 7.6、Web Storage APIWeb Storage API 是一种用于在浏览器中存储和检索数据的简单语法。他非常容易使用： 实例 12localStorage.setItem(&quot;name&quot;, &quot;Bill Gates&quot;);localStorage.getItem(&quot;name&quot;); localStorage 对象localStorage 对象提供对特定网站的本地存储的访问。它允许您存储、读取、添加、修改和删除该域的数据项。存储的数据没有到期日期，并且在浏览器关闭时不会被删除。 这些数据将在几天、几周和几年内均可用。 setItem() 方法 localStorage.setItem() 方法将数据项存储在 storage 中。 它接受一个名称和一个值作为参数： 实例 1localStorage.setItem(&quot;name&quot;, &quot;Bill Gates&quot;); sessionStorage 对象sessionStorage 对象与 localStorage 对象相同。 不同之处在于 sessionStorage 对象存储会话的数据。 当浏览器关闭时，数据会被删除。 实例 1sessionStorage.getItem(&quot;name&quot;); setItem() 方法 sessionStorage.setItem() 方法将数据项存储在存储（storage）中。 它接受一个名称和一个值作为参数： 实例 1sessionStorage.setItem(&quot;name&quot;, &quot;Bill Gates&quot;); getItem() 方法 sessionStorage.getItem() 方法从存储（storage）中检索数据项。 它接受一个名称作为参数： 实例 1sessionStorage.getItem(&quot;name&quot;); Storage 对象属性和方法 属性&#x2F;方法 描述 key(n) 返回存储中第 n 个键的名称。 length 返回存储在 Storage 对象中的数据项数。 getItem(keyname) 返回指定的键名的值。 setItem(keyname, value) 将键添加到存储中，或者如果键已经存在，则更新该键的值。 removeItem(keyname) 从存储中删除该键。 clear() 清空所有键。 Web Storage API 相关页面 属性 描述 window.localStorage 允许在 Web 浏览器中保存键&#x2F;值对。存储没有到期日期的数据。 window.sessionStorage 允许在 Web 浏览器中保存键&#x2F;值对。存储一个会话的数据。 7.7、Web Worker APIWeb Worker 是在后台运行的 JavaScript，不会影响页面的性能。 什么是 Web Worker？ 在 HTML 页面中执行脚本时，页面在脚本完成之前是无响应的。 Web Worker 是在后台运行的 JavaScript，独立于其他脚本，不会影响页面的性能。你可以继续做任何你想做的事情：点击、选取内容等，同时 web worker 在后台运行。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;JavaScript Web Workers API&lt;/h1&gt;&lt;p&gt;Count numbers: &lt;output id=&quot;result&quot;&gt;&lt;/output&gt;&lt;/p&gt;&lt;button onclick=&quot;startWorker()&quot;&gt;开始 Worker&lt;/button&gt; &lt;button onclick=&quot;stopWorker()&quot;&gt;停止 Worker&lt;/button&gt;&lt;script&gt;let w;function startWorker() &#123; if(typeof(w) == &quot;undefined&quot;) &#123; w = new Worker(&quot;demo_workers.js&quot;); &#125; w.onmessage = function(event) &#123; document.getElementById(&quot;result&quot;).innerHTML = event.data; &#125;;&#125;function stopWorker() &#123; w.terminate(); w = undefined;&#125;&lt;/script&gt; 创建 Web Worker 文件现在，让我们在外部 JavaScript 中创建我们的 Web Worker。 在这里，我们创建了一个重要的脚本。该脚本存储在 “demo_workers.js” 文件中： 123456789let i = 0;function timedCount() &#123; i ++; postMessage(i); setTimeout(&quot;timedCount()&quot;,500);&#125;timedCount(); 上面代码的重要部分是 postMessage() 方法 - 用于将消息发送回 HTML 页面。 注释：通常 web worker 不用于这种简单的脚本，而是用于 CPU 密集型任务。 创建 Web Worker 对象现在我们有了 web worker 文件，我们需要从 HTML 页面调用它。 以下代码行检查 worker 是否已存在，如果不存在，它会创建一个新的 web worker 对象并运行 “demo_workers.js” 中的代码： 1234if (typeof(w) == &quot;undefined&quot;) &#123; //引入你的workers.js的路径，若是放在同级目录下，直接使用文件名称即可。 w = new Worker(&quot;demo_workers.js&quot;);&#125; 然后我们可以发送和接收来自 web worker 的消息。 向 web worker 添加一个 “onmessage” 事件侦听器。 123w.onmessage = function(event)&#123; document.getElementById(&quot;result&quot;).innerHTML = event.data;&#125;; 当 Web Worker 发布消息时，将执行事件侦听器中的代码。来自 Web Worker 的数据存储在 event.data 中。 终止 Web Worker当 web worker 对象被创建时，它会继续监听消息（即使在外部脚本完成之后）直到它被终止。 如需终止 web worker，并释放浏览器&#x2F;计算机资源，请使用 terminate() 方法： 1w.terminate(); 重用 Web Worker如果将 worker 变量设置为 undefined，则在它终止后，您可以重用以下代码： 1w = undefined; Web Worker 和 DOM由于 Web Worker 位于外部文件中，因此他们无法访问以下 JavaScript 对象： window 对象 document 对象 parent 对象 7.8、JavaScript Fetch APIFetch API 接口允许 Web 浏览器向 Web 服务器发出 HTTP 请求。 *不再需要 XMLHttpRequest。 Fetch API 实例下面的例子获取文件并显示内 由于 Fetch 基于 async 和 await，因此上面的例子这么写可能更容易理解： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;p id=&quot;demo&quot;&gt;获取文件以更改此文本。&lt;/p&gt;&lt;script&gt;getText(&quot;/demo/js/fetch_info.txt&quot;);async function getText(file) &#123; let myObject = await fetch(file); let myText = await myObject.text(); document.getElementById(&quot;demo&quot;).innerHTML = myText;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 7.9、Web Geolocation APIHTML Geolocation API 用于获取用户的地理位置。 由于这可能会损害隐私，除非用户批准，否则位置不可用。 注释：地理定位对于带有 GPS 的设备（如智能手机）最为准确。 所有浏览器都支持 Geolocation API： Chrome IE Firefox Safari Opera 支持 支持 支持 支持 支持 注释：从 Chrome 50 开始，Geolocation API 将仅适用于安全上下文，例如 HTTPS。如果您的站点托管在非安全源（例如 HTTP）上，则获取用户位置的请求将不再起作用。 使用 Geolocation APIgetCurrentPosition() 方法用于返回用户的位置。 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;JavaScript Geolocation API&lt;/h1&gt;&lt;p&gt;请单击按钮以获取您的坐标。&lt;/p&gt;&lt;button onclick=&quot;getLocation()&quot;&gt;试一试&lt;/button&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;const x = document.getElementById(&quot;demo&quot;);function getLocation() &#123; if (navigator.geolocation) &#123; navigator.geolocation.getCurrentPosition(showPosition); &#125; else &#123; x.innerHTML = &quot;Geolocation is not supported by this browser.&quot;; &#125;&#125;function showPosition(position) &#123; x.innerHTML = &quot;Latitude: &quot; + position.coords.latitude + &quot;&lt;br&gt;Longitude: &quot; + position.coords.longitude;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 例子解释： 检查是否支持 Geolocation 如果支持，请运行 getCurrentPosition() 方法。如果没有，则向用户显示一条消息 如果 getCurrentPosition() 方法成功，则返回一个 coordinates 对象给参数 (showPosition) 中规定的函数 showPosition() 函数输出纬度和经度 上面的例子是一个非常基本的地理定位脚本，没有错误处理。 处理错误和拒绝getCurrentPosition() 方法的第二个参数用于处理错误。如果无法获取用户的位置，它规定要运行的函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;JavaScript Geolocation API&lt;/h1&gt;&lt;p&gt;单击按钮以获取您的坐标。&lt;/p&gt;&lt;button onclick=&quot;getLocation()&quot;&gt;试一试&lt;/button&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;const x = document.getElementById(&quot;demo&quot;);function getLocation() &#123; if (navigator.geolocation) &#123; navigator.geolocation.getCurrentPosition(showPosition, showError); &#125; else &#123; x.innerHTML = &quot;Geolocation is not supported by this browser.&quot;; &#125;&#125;function showPosition(position) &#123; x.innerHTML = &quot;Latitude: &quot; + position.coords.latitude + &quot;&lt;br&gt;Longitude: &quot; + position.coords.longitude;&#125;function showError(error) &#123; switch(error.code) &#123; case error.PERMISSION_DENIED: x.innerHTML = &quot;User denied the request for Geolocation.&quot; break; case error.POSITION_UNAVAILABLE: x.innerHTML = &quot;Location information is unavailable.&quot; break; case error.TIMEOUT: x.innerHTML = &quot;The request to get user location timed out.&quot; break; case error.UNKNOWN_ERROR: x.innerHTML = &quot;An unknown error occurred.&quot; break; &#125;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; getCurrentPosition() 方法 - 返回数据getCurrentPosition() 方法在成功时返回一个对象。会始终返回纬度、经度和精度属性。如果可用，则返回其他属性： 属性 返回 coords.latitude 以十进制数表示的纬度（始终返回）。 coords.longitude 以十进制数表示的经度（始终返回）。 coords.accuracy 位置精度（始终返回）。 coords.altitude 平均海平面以上的高度（以米计）（如果可用则返回）。 coords.altitudeAccuracy 位置的高度精度（如果可用则返回）。 coords.heading 从北顺时针方向的航向（如果可用则返回）。 coords.speed 以米&#x2F;秒计的速度（如果可用则返回）。 timestamp 响应的日期&#x2F;时间（如果可用则返回）。 JS ASYNCJavaScript 回调“I will call back later!” 回调 (callback) 是作为参数传递给另一个函数的函数 这种技术允许函数调用另一个函数 回调函数可以在另一个函数完成后运行 函数序列JavaScript 函数按照它们被调用的顺序执行。而不是以它们被定义的顺序。 此例最终将显示 “Goodbye”： 实例112345678910function myFirst() &#123; myDisplayer(&quot;Hello&quot;);&#125;function mySecond() &#123; myDisplayer(&quot;Goodbye&quot;);&#125;myFirst();mySecond(); 实例212345678910function myFirst() &#123; myDisplayer(&quot;Hello&quot;);&#125;function mySecond() &#123; myDisplayer(&quot;Goodbye&quot;);&#125;mySecond();myFirst(); 顺序控制有时您希望更好地控制何时执行函数。 假设您要进行计算，然后显示结果。 您可以调用计算器函数 (myCalculator)，保存结果，然后调用另一个函数 (myDisplayer) 来显示结果： 1234567891011function myDisplayer(some) &#123; document.getElementById(&quot;demo&quot;).innerHTML = some;&#125;function myCalculator(num1, num2) &#123; let sum = num1 + num2; return sum;&#125;let result = myCalculator(5, 5);myDisplayer(result); JavaScript 回调回调是作为参数传递给另一个函数的函数。 使用回调，您可以通过回调调用计算器函数（myCalculator），并在计算完成后让计算器函数运行回调： 实例12345678910function myDisplayer(some) &#123; document.getElementById(&quot;demo&quot;).innerHTML = some;&#125;function myCalculator(num1, num2, myCallback) &#123; let sum = num1 + num2; myCallback(sum);&#125;myCalculator(5, 5, myDisplayer); 在上面的例子中， myDisplayer 是函数的名称。 它作为参数传递给 myCalculator()。 当您将函数作为参数传递时，请记住不要使用括号。 正确：myCalculator(5, 5, myDisplayer); 错误：myCalculator(5, 5, myDisplayer()); 异步的 JavaScript在上面的例子中，myDisplayer 是函数的名称。 它作为参数传递给 myCalculator()。 在现实世界中，回调最常与异步函数一起使用。 一个典型的例子是 JavaScript setTimeout()。 等待超时在使用 JavaScript 函数 setTimeout() 时，可以指定超时时执行的回调函数： 实例112345setTimeout(myFunction, 3000);function myFunction() &#123; document.getElementById(&quot;demo&quot;).innerHTML = &quot;I love You !!&quot;;&#125; 在上面的示例中，myFunction 被用作回调。 函数（函数名）作为参数传递给 setTimeout()。 3000 是超时前的毫秒数，所以 3 秒后会调用 myFunction()。 当您将函数作为参数传递时，请记住不要使用括号。 正确：setTimeout(myFunction, 3000); 错误：setTimeout(myFunction(), 3000); 若不将函数的名称作为参数传递给另一个函数，您始终可以传递整个函数： 实例212345setTimeout(function() &#123; myFunction(&quot;I love You !!!&quot;); &#125;, 3000);function myFunction(value) &#123; document.getElementById(&quot;demo&quot;).innerHTML = value;&#125; 等待间隔在使用 JavaScript 函数 setInterval() 时，可以指定每个间隔执行的回调函数： 实例123456789setInterval(myFunction, 1000);function myFunction() &#123; let d = new Date(); document.getElementById(&quot;demo&quot;).innerHTML= d.getHours() + &quot;:&quot; + d.getMinutes() + &quot;:&quot; + d.getSeconds();&#125; 在上面的例子中，myFunction 用作回调。 函数（函数名）作为参数传递给 setInterval()。 1000 是间隔之间的毫秒数，因此 myFunction() 将每秒调用一次。 等待文件如果您创建函数来加载外部资源（如脚本或文件），则在内容完全加载之前无法使用这些内容。 这是使用回调的最佳时机。 此例加载一个 HTML 文件 (mycar.html)，并在文件完全加载后在网页中显示该 HTML 文件： 12345678910111213141516171819function myDisplayer(some) &#123; document.getElementById(&quot;demo&quot;).innerHTML = some;&#125;function getFile(myCallback) &#123; let req = new XMLHttpRequest(); req.open(&#x27;GET&#x27;, &quot;mycar.html&quot;); //req.onload指的是在加载完成时要执行的动作 req.onload = function() &#123; if (req.status == 200) &#123; myCallback(this.responseText); &#125; else &#123; myCallback(&quot;Error: &quot; + req.status); &#125; &#125; req.send();&#125;getFile(myDisplayer); 在上面的示例中，myDisplayer 用作回调。 函数（函数名）作为参数传递给 getFile()。 以下是 mycar.html 的副本： 123456&lt;img src=&quot;img_car.jpg&quot; alt=&quot;Nice car&quot; style=&quot;width:100%&quot;&gt;&lt;p&gt;A car is a wheeled, self-powered motor vehicle used for transportation.Most definitions of the term specify that cars are designed to run primarily on roads, to have seating for one to eight people, to typically have four wheels.&lt;/p&gt;&lt;p&gt;(Wikipedia)&lt;/p&gt; JavaScript Promise“I Promise a Result!” “Producing code（生产代码）” 是需要一些时间的代码 “Consuming code（消费代码）” 是必须等待结果的代码 Promise 是一个 JavaScript 对象，它链接生成代码和消费代码 JavaScript Promise 对象JavaScript Promise 对象包含生产代码和对消费代码的调用： Promise 语法123456789101112let myPromise = new Promise(function(myResolve, myReject) &#123;// &quot;Producing Code&quot;（可能需要一些时间） myResolve(); // 成功时 myReject(); // 出错时&#125;);// &quot;Consuming Code&quot; （必须等待一个兑现的承诺）myPromise.then( function(value) &#123; /* 成功时的代码 */ &#125;, function(error) &#123; /* 出错时的代码 */ &#125;); 当执行代码获得结果时，它应该调用两个回调之一： 结果 调用 成功 myResolve(result value) 出错 myReject(error object) Promise 对象属性Promise 对象支持两个属性：state(状态) 和 result。 当 Promise 对象 “pending”（工作）时，结果是 undefined。 当 Promise 对象 “fulfilled” 时，结果是一个值。 当一个 Promise 对象是 “rejected” 时，结果是一个错误对象。 myPromise.state myPromise.result “pending” undefined “fulfilled” 结果值 “rejected” error 对象 您无法访问 Promise 属性 state 和 result。 您必须使用 Promise 方法来处理 Promise。 如何使用 Promise以下是使用 Promise 的方法： 1234myPromise.then( function(value) &#123; /* 代码成功时 */ &#125;, function(error) &#123; /* 代码出错时 */ &#125;); Promise.then() 有两个参数，一个是成功时的回调，另一个是失败时的回调。 两者都是可选的，因此您可以为成功或失败添加回调。 实例1234567891011121314151617181920function myDisplayer(some) &#123; document.getElementById(&quot;demo&quot;).innerHTML = some;&#125;let myPromise = new Promise(function(myResolve, myReject) &#123; let x = 0;// 生成代码（这可能需要一些时间） if (x == 0) &#123; myResolve(&quot;OK&quot;); &#125; else &#123; myReject(&quot;Error&quot;); &#125;&#125;);myPromise.then( function(value) &#123;myDisplayer(value);&#125;, function(error) &#123;myDisplayer(error);&#125;); JavaScript Promise 实例为了演示 Promise 的使用，我们将使用上一章中的回调实例： 等待超时 使用回调的例子 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;JavaScript SetTimeout()&lt;/h1&gt; &lt;p&gt;等待 3 秒（3000 毫秒）让此页面发生变化。&lt;/p&gt; &lt;h1 id=&quot;demo&quot;&gt;&lt;/h1&gt; &lt;script&gt; //渲染页面3秒后将会调用myFunction函数 setTimeout(function() &#123; myFunction(&quot;I love You !!!&quot;); &#125;, 3000); //该函数负责将I love You !!!输出到id为demo的&lt;H1&gt;标签中 function myFunction(value) &#123; document.getElementById(&quot;demo&quot;).innerHTML = value; &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 12345678910111213141516171819202122232425262728* 使用Promise的例子 * ```html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;JavaScript Promise&lt;/h1&gt; &lt;p&gt;等待 3 秒（3000 毫秒）让此页面发生变化。&lt;/p&gt; &lt;h1 id=&quot;demo&quot;&gt;&lt;/h1&gt; &lt;script&gt; //在这里使用了我们的Promise const myPromise = new Promise(function(myResolve, myReject) &#123; setTimeout(function()&#123; myResolve(&quot;I love You !!&quot;); &#125;, 3000); &#125;); myPromise.then(function(value) &#123; document.getElementById(&quot;demo&quot;).innerHTML = value; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 等待文件 使用回调的例子 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;JavaScript 回调&lt;/h1&gt; &lt;p id=&quot;demo&quot;&gt;&lt;/p&gt; &lt;script&gt; function myDisplayer(some) &#123; document.getElementById(&quot;demo&quot;).innerHTML = some; &#125; function getFile(myCallback) &#123; let req = new XMLHttpRequest(); req.open(&#39;GET&#39;, &quot;/demo/js/mycar.html&quot;); req.onload = function() &#123; if (req.status == 200) &#123; myCallback(this.responseText); &#125; else &#123; myCallback(&quot;Error: &quot; + req.status); &#125; &#125; req.send(); &#125; getFile(myDisplayer); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839* 使用Promise的例子 * ```html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;JavaScript Promise&lt;/h1&gt; &lt;p id=&quot;demo&quot;&gt;&lt;/p&gt; &lt;script&gt; function myDisplayer(some) &#123; document.getElementById(&quot;demo&quot;).innerHTML = some; &#125; //在这里使用了promise let myPromise = new Promise(function(myResolve, myReject) &#123; let req = new XMLHttpRequest(); req.open(&#x27;GET&#x27;, &quot;/demo/js/mycar.html&quot;); req.onload = function() &#123; if (req.status == 200) &#123; myResolve(req.response); &#125; else &#123; myReject(&quot;File not Found&quot;); &#125; &#125;; req.send(); &#125;); myPromise.then( function(value) &#123;myDisplayer(value);&#125;, function(error) &#123;myDisplayer(error);&#125; ); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 浏览器支持ECMAScript 2015，也称为 ES6，引入了 JavaScript Promise 对象。 下表注明了首个完全支持 Promise 对象的浏览器版本： Chrome IE Firefox Safari Opera Chrome 33 Edge 12 Firefox 29 Safari 7.1 Opera 20 2014 年 2 月 2015 年 7 月 2014 年 4 月 2014 年 9 月 2014 年 3 月 JavaScript Async“async and await make promises easier to write” async 使函数返回 Promise await 使函数等待 Promise Async 语法函数前的关键字 async 使函数返回 promise： 实例1123async function myFunction() &#123; return &quot;Hello&quot;;&#125; 等同于： 123async function myFunction() &#123; return Promise.resolve(&quot;Hello&quot;);&#125; 以下是使用 Promise 的方法： 1234myFunction().then( function(value) &#123; /* 成功时的代码 */ &#125;, function(error) &#123; /* 出错时的代码 */ &#125;); 实例21234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;JavaScript async / await&lt;/h1&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;function myDisplayer(some) &#123; document.getElementById(&quot;demo&quot;).innerHTML = some;&#125;//async 使函数返回promiseasync function myFunction() &#123;return &quot;Hello&quot;;&#125;//在这里调用promise返回时的动作myFunction().then( function(value) &#123;myDisplayer(value);&#125;, //成功的回调 function(error) &#123;myDisplayer(error);&#125; //失败的回调);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Await 语法函数前的关键字 await 使函数等待 promise： 1let value = await promise; await 关键字只能在 async 函数中使用。 基础语法实例1让我们慢慢来学习如何使用它。 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h2&gt;JavaScript async / await&lt;/h2&gt;&lt;h1 id=&quot;demo&quot;&gt;&lt;/h1&gt;&lt;script&gt; //使函数myDisplay返回Promise对象async function myDisplay() &#123; let myPromise = new Promise(function(myResolve, myReject) &#123; myResolve(&quot;I love You !!&quot;); &#125;); //等待Promise对象 document.getElementById(&quot;demo&quot;).innerHTML = await myPromise;&#125;myDisplay();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 等待超时123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;JavaScript async / await&lt;/h1&gt;&lt;p&gt;请等待 3 秒（3000 毫秒）让此页面发生变化。&lt;/p&gt;&lt;h1 id=&quot;demo&quot;&gt;&lt;/h1&gt; &lt;!-- async function myDisplay()：定义了一个名为myDisplay的异步函数。关键字async表明该函数内部包含异步操作，并且该函数会返回一个Promise对象。在这个异步函数内部，首先创建了一个新的Promise对象myPromise。这个Promise对象接受一个函数作为参数，该函数有两个参数：myResolve和myReject，它们是用于解决（resolve）或拒绝（reject）Promise的回调函数。在Promise构造函数中，使用了setTimeout模拟了一个异步操作，即在3秒（3000毫秒）后执行myResolve(&quot;I love You !!&quot;)。这意味着在3秒后，Promise会被标记为已解决（fulfilled），并传递字符串&quot;I love You !!&quot;作为结果。接下来，document.getElementById(&quot;demo&quot;).innerHTML = await myPromise; 这一行代码是关键。这里使用了await关键字来等待myPromise的结果。await只能在async函数内部使用，它会使代码暂停执行，直到等待的Promise完成（resolve或reject）。在这个例子中，它会等待3秒，直到myPromise被解决，然后将解决的值（即&quot;I love You !!&quot;）赋给&lt;h1 id=&quot;demo&quot;&gt;元素的innerHTML，从而改变页面内容。--&gt;&lt;script&gt;async function myDisplay() &#123; let myPromise = new Promise(function(myResolve, myReject) &#123; setTimeout(function() &#123; myResolve(&quot;I love You !!&quot;); &#125;, 3000); &#125;); document.getElementById(&quot;demo&quot;).innerHTML = await myPromise;&#125;myDisplay();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 等待文件12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h2&gt;JavaScript async / await&lt;/h2&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;async function getFile() &#123; let myPromise = new Promise(function(myResolve, myReject) &#123; let req = new XMLHttpRequest(); req.open(&#x27;GET&#x27;, &quot;/demo/js/mycar.html&quot;); req.onload = function() &#123; if (req.status == 200) &#123; myResolve(req.response); &#125; else &#123; myResolve(&quot;File not Found&quot;); &#125; &#125;; req.send(); &#125;); document.getElementById(&quot;demo&quot;).innerHTML = await myPromise;&#125;getFile();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue常用指令 Ajax 概念:Asynchronous JavaScript And XML，异步的JavaScript和XML。 作用: AJAX 是开发者的梦想，因为您能够： 不刷新页面更新网页 在页面加载后从服务器请求数据 在页面加载后从服务器接收数据 在后台向服务器发送数据 数据交换:通过Ajax可以给服务器发送请求，并获取服务器响应的数据。 异步交互:可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如:搜索联想、用户名是否可用的校验等等。 Ajax实例12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;!-- 设置文档编码 --&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;!-- 适应移动设备 --&gt; &lt;title&gt;Ajax实例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;demo&quot;&gt; &lt;!-- 注意：应为id=&quot;demo&quot;而非class=&quot;demo&quot;以匹配JS中的getElementById --&gt; &lt;h2&gt;单击按钮，让Ajax改变这段文本&lt;/h2&gt; &lt;button onclick=&quot;changeEdit()&quot;&gt;更改文本&lt;/button&gt; &lt;/div&gt; &lt;script&gt; // 定义一个函数，用于通过Ajax请求更改文本内容 function changeEdit() &#123; // 创建一个新的XMLHttpRequest对象 let xhttp = new XMLHttpRequest(); // 设置请求完成后的回调函数 xhttp.onreadystatechange = function() &#123; // 当请求完成（readyState=4）且状态为成功（status=200）时，执行以下代码 if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; // 使用响应文本替换页面中id为&quot;demo&quot;的元素的内容,注：this.responseText是在使用XMLHttpRequest对象进行Ajax请求时的一个属性。这个属性包含了从服务器返回的响应文本内容。 document.getElementById(&quot;demo&quot;).innerHTML = this.responseText; &#125; &#125;; // 初始化请求，设置请求类型、URL及异步标志（true表示异步） xhttp.open(&#x27;GET&#x27;, &#x27;ajax_info.txt&#x27;, true); // 发送请求 xhttp.send(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 什么是 AJAX？AJAX &#x3D; Asynchronous JavaScript And XML. AJAX 并非编程语言。 AJAX 仅仅组合了： 浏览器内建的 XMLHttpRequest 对象（从 web 服务器请求数据） JavaScript 和 HTML DOM（显示或使用数据） Ajax 是一个令人误导的名称。Ajax 应用程序可能使用 XML 来传输数据，但将数据作为纯文本或 JSON 文本传输也同样常见。 Ajax 允许通过与场景后面的 Web 服务器交换数据来异步更新网页。这意味着可以更新网页的部分，而不需要重新加载整个页面。 AJAX 如何工作 网页中发生一个事件（页面加载、按钮点击） 由 JavaScript 创建 XMLHttpRequest 对象 XMLHttpRequest 对象向 web 服务器发送请求 服务器处理该请求 服务器将响应发送回网页 由 JavaScript 读取响应 由 JavaScript 执行正确的动作（比如更新页面） AJAX - XMLHttpRequest 对象XMLHttpRequest 对象是 AJAX 的基石。 创建 XMLHttpRequest 对象 定义回调函数 打开 XMLHttpRequest 对象 向服务器发送请求 XMLHttpRequest 对象所有现代浏览器都支持 XMLHttpRequest 对象。 XMLHttpRequest 对象可用于在后台与 Web 服务器交换数据。这意味着可以更新网页的部分内容，而无需重新加载整个页面。 创建 XMLHttpRequest 对象所有现代浏览器（Chrome、Firefox、IE、Edge、Safari、Opera）都有内置的 XMLHttpRequest 对象。 创建 XMLHttpRequest 对象的语法： 1variable = new XMLHttpRequest(); 定义回调函数回调函数是作为参数传递给另一个函数的函数。 在这种情况下，回调函数应包含响应准备就绪时要执行的代码。 123xhttp.onload = function() &#123; // 当响应准备就绪时要做什么&#125; 发送请求如需向服务器发送请求，您可以使用 XMLHttpRequest 对象的 open() 和 send() 方法： 12xhttp.open(&quot;GET&quot;, &quot;ajax_info.txt&quot;);xhttp.send(); 实例1234567891011// 创建 XMLHttpRequest 对象const xhttp = new XMLHttpRequest();// 定义回调函数xhttp.onload = function() &#123; // 您可以在这里使用数据&#125;// 发送请求xhttp.open(&quot;GET&quot;, &quot;ajax_info.txt&quot;);xhttp.send(); XMLHttpRequest 对象方法 方法 描述 new XMLHttpRequest() 创建新的 XMLHttpRequest 对象。 abort() 取消当前请求。 getAllResponseHeaders() 返回头部信息。 getResponseHeader() 返回特定的头部信息。 open(method, url, async, user, psw) 规定请求。method：请求类型 GET 或 POSTurl：文件位置async：true（异步）或 false（同步）user：可选的用户名psw：可选的密码 send() 向服务器发送请求，用于 GET 请求。 send(string) 向服务器发送请求，用于 POST 请求。 setRequestHeader() 将标签&#x2F;值对添加到要发送的标头。 XMLHttpRequest 对象属性 属性 描述 onload 定义接收到（加载）请求时要调用的函数。 onreadystatechange 定义当 readyState 属性发生变化时调用的函数。 readyState 保存 XMLHttpRequest 的状态。0：请求未初始化1：服务器连接已建立2：请求已收到3：正在处理请求4：请求已完成且响应已就绪 responseText 以字符串形式返回响应数据。 responseXML 以 XML 数据返回响应数据。 status 返回请求的状态号200: “OK”403: “Forbidden”404: “Not Found”如需完整列表请访问 Http 消息参考手册 statusText 返回状态文本（比如 “OK” 或 “Not Found”） onload 属性使用 XMLHttpRequest 对象时，您可以定义一个回调函数，以便在请求收到答复时执行。 请在 XMLHttpRequest 对象的 onload 属性中定义该函数： 实例12345xhttp.onload = function() &#123; document.getElementById(&quot;demo&quot;).innerHTML = this.responseText;&#125;xhttp.open(&quot;GET&quot;, &quot;ajax_info.txt&quot;);xhttp.send(); 多个回调函数如果网站中有多个 AJAX 任务，则应创建一个执行 XMLHttpRequest 对象的函数，并为每个 AJAX 任务创建一个回调函数。 函数调用应包含 URL 以及响应准备就绪时要调用的函数。 实例1234567891011121314151617loadDoc(&quot;url-1&quot;, myFunction1);loadDoc(&quot;url-2&quot;, myFunction2);function loadDoc(url, cFunction) &#123; const xhttp = new XMLHttpRequest(); xhttp.onload = function() &#123;cFunction(this);&#125; xhttp.open(&quot;GET&quot;, url); xhttp.send();&#125;function myFunction1(xhttp) &#123; // 这里是动作&#125;function myFunction2(xhttp) &#123; // 这里是动作&#125; 顺带一提，上面的this指的是什么呢？其实this就是如下图所示，是一个XMLHttpRequest对象 onreadystatechange 属性readyState 属性保存 XMLHttpRequest 的状态。 onreadystatechange 属性定义了一个回调函数，当 readyState 改变时执行该函数。 status 属性和 statusText 属性保存 XMLHttpRequest 对象的状态。 属性 描述 onreadystatechange 定义当 readyState 属性改变时调用的函数。 readyState 保存 XMLHttpRequest 的状态。0：请求未初始化1：服务器连接已建立2：请求已收到3：正在处理请求4：请求已完成且响应已就绪 status 返回请求的状态号200: “OK”403: “Forbidden”404: “Not Found”如需完整列表请访问 Http 消息参考手册 statusText 返回状态文本（比如 “OK” 或 “Not Found”）。 每次 readyState 改变时都会调用 onreadystatechange 函数。 当 readyState 为 4 且 status 为 200 时，响应就绪： 实例1234567891011function loadDoc() &#123; const xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; document.getElementById(&quot;demo&quot;).innerHTML = this.responseText; &#125; &#125;; xhttp.open(&quot;GET&quot;, &quot;ajax_info.txt&quot;); xhttp.send();&#125; onreadystatechange 事件被触发了四次（1-4），每次 readyState 变化一次。 XMLHttpRequest 对象用于同服务器交换数据。向服务器发送请求如需向服务器发送请求，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法： 12xhttp.open(&quot;GET&quot;, &quot;ajax_info.txt&quot;, true);xhttp.send(); 方法 描述 open(method, url, async) 规定请求的类型method：请求的类型：GET 还是 POSTurl：服务器（文件）位置async：true（异步）或 false（同步） send() 向服务器发送请求（用于 GET） send(string) 向服务器发送请求（用于 POST） GET 还是 POST？GET 比 POST 更简单更快，可用于大多数情况下。 不过，请在以下情况始终使用 POST： 缓存文件不是选项（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 无大小限制） 发送用户输入（可包含未知字符），POST 比 GET 更强大更安全 GET 请求一条简单的 GET 请求： 实例112xhttp.open(&quot;GET&quot;, &quot;demo_get.asp&quot;, true);xhttp.send(); 在上面的例子中，您可能会获得一个缓存的结果。为了避免此情况，请向 URL 添加一个唯一的 ID： 实例212xhttp.open(&quot;GET&quot;, &quot;demo_get.asp?t=&quot; + Math.random(), true);xhttp.send(); 如果您需要用 GET 方法来发送信息，请向 URL 添加这些信息： 实例3123//携带query形式的参数xhttp.open(&quot;GET&quot;, &quot;demo_get2.asp?fname=Bill&amp;lname=Gates&quot;, true);xhttp.send(); POST 请求一条简单的 POST 请求： 实例112xhttp.open(&quot;POST&quot;, &quot;demo_post.asp&quot;, true);xhttp.send(); 如需像 HTML 表单那样 POST 数据，请通过 setRequestHeader() 添加一个 HTTP 头部。请在 send() 方法中规定您需要发送的数据： 实例2123xhttp.open(&quot;POST&quot;, &quot;ajax_test.asp&quot;, true);xhttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);xhttp.send(&quot;fname=Bill&amp;lname=Gates&quot;); 方法 描述 setRequestHeader(header, value) 向请求添加 HTTP 头部header：规定头部名称value：规定头部值 url - 服务器上的文件open() 方法的 url 参数，是服务器上文件的地址： 1xhttp.open(&quot;GET&quot;, &quot;ajax_test.asp&quot;, true); 该文件可以是任何类型的文件，如 .txt 和 .xml，或服务器脚本文件，如 .asp 和 .php（它们可以在发送回响应之前在服务器执行操作）。 异步 - true 还是 false？如需异步发送请求，open() 方法的 async 参数必须设置为 true： 1xhttp.open(&quot;GET&quot;, &quot;ajax_test.asp&quot;, true); 发送异步请求对 web 开发人员来说是一个巨大的进步。服务器上执行的许多任务都非常耗时。在 AJAX 之前，此操作可能会导致应用程序挂起或停止。 通过异步发送，JavaScript 不必等待服务器响应，而是可以： 在等待服务器响应时执行其他脚本 当响应就绪时处理响应 onreadystatechange 属性通过 XMLHttpRequest 对象，您可以定义当请求接收到应答时所执行的函数。 这个函数是在 XMLHttpResponse 对象的 onreadystatechange 属性中定义的： 实例1234567xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; document.getElementById(&quot;demo&quot;).innerHTML = this.responseText; &#125;&#125;;xhttp.open(&quot;GET&quot;, &quot;ajax_info.txt&quot;, true);xhttp.send(); 同步请求如需执行同步的请求，请把 open() 方法中的第三个参数设置为 false： 1xhttp.open(&quot;GET&quot;, &quot;ajax_info.txt&quot;, false); 有时 async &#x3D; false 用于快速测试。你也会在更老的 JavaScript 代码中看到同步请求。 由于代码将等待服务器完成，所以不需要 onreadystatechange 函数： 实例123xhttp.open(&quot;GET&quot;, &quot;ajax_info.txt&quot;, false);xhttp.send();document.getElementById(&quot;demo&quot;).innerHTML = xhttp.responseText; 我们不推荐同步的 XMLHttpRequest (async &#x3D; false)，因为 JavaScript 将停止执行直到服务器响应就绪。如果服务器繁忙或缓慢，应用程序将挂起或停止。 同步 XMLHttpRequest 正在从 Web 标准中移除，但是这个过程可能需要很多年。 现代开发工具被鼓励对使用同步请求做出警告，并且当这种情况发生时，可能会抛出 InvalidAccessError 异常。 同步和异步： AJAX - 服务器响应onreadystatechange 属性readyState 属性存留 XMLHttpRequest 的状态。 onreadystatechange 属性定义当 readyState 发生变化时执行的函数。 status 属性和 statusText 属性存有 XMLHttpRequest 对象的状态。 属性 描述 onreadystatechange 定义了当 readyState 属性发生改变时所调用的函数。 readyState 保存了 XMLHttpRequest 的状态。0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 正在处理请求4: 请求已完成且响应已就绪 status 200: “OK”403: “Forbidden”404: “Page not found”如需完整列表，请访问 Http 消息参考手册 statusText 返回状态文本（例如 “OK” 或 “Not Found”） 每当 readyState 发生变化时就会调用 onreadystatechange 函数。当 readyState 为 4，status 为 200 时，响应就绪： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;div id=&quot;demo&quot;&gt;&lt;h1&gt;XMLHttpRequest 对象&lt;/h1&gt;&lt;button type=&quot;button&quot; onclick=&quot;loadDoc()&quot;&gt;更改内容&lt;/button&gt;&lt;/div&gt;&lt;script&gt;function loadDoc() &#123; var xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; document.getElementById(&quot;demo&quot;).innerHTML = this.responseText; &#125; &#125;; xhttp.open(&quot;GET&quot;, &quot;/demo/js/ajax_info.txt&quot;, true); xhttp.send();&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注释：onreadystatechange 被触发五次（0-4），每次 readyState 都发生变化。 回调函数是一种作为参数被传递到另一个函数的函数。 如果您的网站中有多个 AJAX 任务，那么您应该创建一个执行 XMLHttpRequest 对象的函数，以及一个供每个 AJAX 任务的回调函数。 该函数应当包含 URL 以及当响应就绪时调用的函数。 实例12345678910111213141516171819202122loadDoc(&quot;url-1&quot;, myFunction1);loadDoc(&quot;url-2&quot;, myFunction2);function loadDoc(url, cFunction) &#123; var xhttp; xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; cFunction(this); &#125; &#125;; xhttp.open(&quot;GET&quot;, url, true); xhttp.send();&#125;function myFunction1(xhttp) &#123; // 行动在这里 &#125; function myFunction2(xhttp) &#123; // 行动在这里 &#125; 服务器响应属性 属性 描述 responseText 获取字符串形式的响应数据 responseXML 获取 XML 数据形式的响应数据 responseText 属性responseText 属性以 JavaScript 字符串的形式返回服务器响应，因此您可以这样使用它： 实例1document.getElementById(&quot;demo&quot;).innerHTML = xhttp.responseText; responseXML 属性XML HttpRequest 对象有一个內建的 XML 解析器。 ResponseXML 属性以 XML DOM 对象返回服务器响应。 使用此属性，您可以把响应解析为 XML DOM 对象： 实例123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;XMLHttpRequest 对象&lt;/h1&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt; &lt;script&gt;var xhttp, xmlDoc, txt, x, i;xhttp = new XMLHttpRequest();xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; xmlDoc = this.responseXML; txt = &quot;&quot;; x = xmlDoc.getElementsByTagName(&quot;ARTIST&quot;); console.log(x); for (i = 0; i &lt; x.length; i++) &#123; txt = txt + x[i].childNodes[0].nodeValue + &quot;&lt;br&gt;&quot;; &#125; document.getElementById(&quot;demo&quot;).innerHTML = txt; &#125;&#125;;xhttp.open(&quot;GET&quot;, &quot;music_list.xml&quot;, true);xhttp.send();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 服务器响应方法 方法 描述 getResponseHeader() 从服务器返回特定的头部信息 getAllResponseHeaders() 从服务器返回所有头部信息 getAllResponseHeaders() 方法getAllResponseHeaders() 方法返回所有来自服务器响应的头部信息。 实例123456var xhttp = new XMLHttpRequest();xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; document.getElementById(&quot;demo&quot;).innerHTML = this.getAllResponseHeaders(); &#125;&#125;; getResponseHeader() 方法getResponseHeader() 方法返回来自服务器响应的特定头部信息。 实例12345678var xhttp = new XMLHttpRequest();xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; document.getElementById(&quot;demo&quot;).innerHTML = this.getResponseHeader(&quot;Last-Modified&quot;); &#125;&#125;;xhttp.open(&quot;GET&quot;, &quot;ajax_info.txt&quot;, true);xhttp.send(); AJAX 可用于同 XML 文件进行交互式通信。实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button onclick=&quot;loadDoc()&quot;&gt;获取CD&lt;/button&gt; &lt;table id=&quot;demo&quot;&gt;&lt;/table&gt;&lt;/body&gt;&lt;script&gt; let loadDoc = function()&#123; let xhttp = new XMLHttpRequest(); //调用响应准备就绪时的函数 xhttp.onreadystatechange = function()&#123; if(this.readyState == 4 &amp;&amp; this.status ==200)&#123; //调用回调函数 MyFunction(this); &#125; &#125; xhttp.open(&quot;GET&quot;,&#x27;music_list.xml&#x27;,true) xhttp.send() &#125; function MyFunction(xml)&#123; let i; console.log(xml); let xmlDoc = xml.responseXML console.log(xmlDoc); let table = &#x27;&lt;tr&gt;&lt;th&gt;艺术家&lt;/th&gt;&lt;th&gt;曲目&lt;/th&gt;&lt;/tr&gt;&#x27; let x = xmlDoc.getElementsByTagName(&#x27;TRACK&#x27;); console.log(x); for (let i = 0; i &lt; x.length; i++) &#123; //通过拼接字符串来完成表结构的构建 table += &#x27;&lt;tr&gt;&lt;td&gt;&#x27; + x[i].getElementsByTagName(&quot;ARTIST&quot;)[0].childNodes[0].nodeValue + &#x27;&lt;/td&gt;&lt;td&gt;&#x27; + x[i].getElementsByTagName(&#x27;TITLE&#x27;)[0].childNodes[0].nodeValue +&#x27;&lt;/td&gt;&lt;/tr&gt;&#x27; &#125; document.querySelector(&quot;#demo&quot;).innerHTML = table; &#125;&lt;/script&gt;&lt;/html&gt; XML 应用程序本章演示使用 XML、HTTP、DOM 以及 JavaScript 的 HTML 应用程序。 在 HTML div 元素中显示第一首曲子本例使用一个函数在 id&#x3D;”displayMUSIC” 的 HTML 元素中显示第一首歌曲： 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;displayMusic&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;demo&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; displayMusic(0); function displayMusic(i)&#123; let xhttp = new XMLHttpRequest() xhttp.onreadystatechange = function()&#123; if(this.readyState == 4 &amp;&amp; this.status == 200)&#123; MyFunction(this,i) &#125; &#125; xhttp.open(&#x27;Get&#x27;,&#x27;music_list.xml&#x27;,true) xhttp.send() &#125; function MyFunction(xml,i)&#123; let ul = &#x27;&lt;ul&gt;&lt;/ul&gt;&#x27; let responseObj = xml.responseXML; let x = responseObj.getElementsByTagName(&quot;TRACK&quot;) console.log(x); ul = ul+ &#x27;&lt;li&gt;&#x27; + x[i].getElementsByTagName(&#x27;TITLE&#x27;)[0].childNodes[0].nodeValue + &#x27;&lt;/li&gt;&#x27; + &#x27;&lt;li&gt;&#x27; + x[i].getElementsByTagName(&#x27;ARTIST&#x27;)[0].childNodes[0].nodeValue + &#x27;&lt;/li&gt;&#x27; document.getElementById(&quot;demo&quot;).innerHTML = ul; console.log(x[i].getElementsByTagName(&#x27;TITLE&#x27;)); &#125;&lt;/script&gt;&lt;/html&gt; 在曲目之间导航如需在上例中的曲目间导航，请添加 next() 和 previous() 函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;displayMusic&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;demo&quot;&gt; &lt;/div&gt; &lt;button onclick=&quot;next()&quot;&gt;下一首歌曲&lt;/button&gt; &lt;button onclick=&quot;previous()&quot;&gt;上一首歌曲&lt;/button&gt;&lt;/body&gt;&lt;script&gt; let i = 0, len; displayMusic(0); function displayMusic(i)&#123; let xhttp = new XMLHttpRequest() xhttp.onreadystatechange = function()&#123; if(this.readyState == 4 &amp;&amp; this.status == 200)&#123; MyFunction(this,i) &#125; &#125; xhttp.open(&#x27;Get&#x27;,&#x27;music_list.xml&#x27;,true) xhttp.send() &#125; function MyFunction(xml,i)&#123; let ul = &#x27;&lt;ul&gt;&lt;/ul&gt;&#x27; let responseObj = xml.responseXML; let x = responseObj.getElementsByTagName(&quot;TRACK&quot;) len = x.length; console.log(x); ul = ul+ &#x27;&lt;li&gt;&#x27; + x[i].getElementsByTagName(&#x27;TITLE&#x27;)[0].childNodes[0].nodeValue + &#x27;&lt;/li&gt;&#x27; + &#x27;&lt;li&gt;&#x27; + x[i].getElementsByTagName(&#x27;ARTIST&#x27;)[0].childNodes[0].nodeValue + &#x27;&lt;/li&gt;&#x27; document.getElementById(&quot;demo&quot;).innerHTML = ul; &#125; function next()&#123; //下一首，除非到达最后一首停下，由于len =x.length，当 i = len-1时，比如一共8首歌，当i=7时，即是最后一首，这时7 = 8-1故不再执行，并且到达了最后一首歌的位置 if(i &lt; len -1)&#123; i++; displayMusic(i) &#125; &#125; function previous()&#123; //当i=0时，也就是位于第一首歌的位置时，上一首是不管事的只能下一首 i--; if(i&gt;0)&#123; displayMusic(i) &#125; &#125;&lt;/script&gt;&lt;/html&gt; Axios基础语法： 123456789101112axios(&#123; //请求方式 method: //请求地址 url: //请求参数 data:&#123;/*post求情用data*/&#125; params:&#123;/*get请求用params*/&#125; //回调函数&#125;).then(function(res)&#123; console.loh(res.data)&#125;) Vue路由 介绍: Vue Router 是 Vue 的官方路由。 组成: VueRouter:路由器类，根据路由请求在路由视图中动态渲染选中的组件。 ：请求链接组件，浏览器会解析成。 ：动态视图组件，用来渲染展示与路由路径对应的组件。 图示： 部署——nginx服务器 部署： 将打包好的dist文件里面的内容放在nginx目录下的html文件夹下。 启动nginx即可 Maven Maven是apache旗下的一个开源项目，是一款用于管理和构建java项目的工具。 maven的作用： 仓库:用于存储资源，管理各种jar包。 本地仓库:自己计算机上的一个目录。 中央仓库:由Maven团队维护的全球唯一的。仓库地址:https://repo1.maven.qrg/maven2/ 远程仓库(私服):一般由公司团队搭建的私有仓库。 maven中的坐标： maven中的坐标是资源的唯一标识，通过该坐标可以唯一定位资源位置。 使用坐标来定义项目或引入项目中需要的依赖。 Maven 坐标主要组成： groupld:定义当前Maven项目隶属组织名称(通常是域名反写，例如:com.itheima)。 artifactld:定义当前Maven项目名称(通常是模块名称，例如 order-service、goods-service)。 version:定义当前项目版本号 依赖传递 依赖具有传递性 直接依赖:在当前项目中通过依赖配置建立的依赖关系。 间接依赖:被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源 排除依赖： 排除依赖指主动断开依赖的资源，被排除的资源无需指定版本。 上面通过标签来排除。 依赖范围：依赖的jar包在默认情况下可以再任何地方使用。但是我们通过标签可以指定它的作用范围。 主程序范围有效。(main文件夹范围内) 测试程序范围有效。(test文件夹范围内) 是否参与打包运行。(package指令范围内) maven的生命周期： clean：清理。 compile：编译 test：测试 package：打包 install：安装(将打好的jar包安装到本地仓库) 官网：https://spring.io Spring形成一种开发生态圈，Spring提供了若干个子项目，每个项目用于完成特定功能。 ServletServlet简介 Servlet就是sun公司开发动态web的一门技术 Sun在这些API中提供了一个接口叫做 ：Servlet，如果你想开发一个Servlet程序，只需要完成两个步骤： 编写一个类实现Servlet接口 把开发好的Java类部署到web服务器中 把实现了Servlet接口的java程序叫做Servlet HelloServletServlet接口有两个默认的实现类：HttpServlet，GenericServlet 1.构建一个Maven项目，删掉里面的src目录，以后就可以在这个项目里面建立多个Moduel(模块)，这个空的就是主工程 子工程的项目结构 2.关于Maven父子工程的理解 父项目中会有一个 123&lt;modules&gt; &lt;module&gt;Servlet-01&lt;/module&gt;&lt;/modules&gt; 子项目中会有 1234&lt;groupId&gt;org.example&lt;/groupId&gt;&lt;artifactId&gt;JavaWeb-02-Servlet&lt;/artifactId&gt;&lt;packaging&gt;pom&lt;/packaging&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; 4.编写一个Servlet程序 ​ 1.编写一个普通类 ​ 2.实现Servlet接口，这里我们直接继承HttpServlet 12345678910111213141516171819202122package com.li;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class HelloServlet extends HttpServlet &#123; //由于Get或者post只是请求实现方式不同，可以相互调用，业务逻辑一样 @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; PrintWriter writer = resp.getWriter(); //响应流 writer.print(&quot;Hello Servlet&quot;); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 5.编写Servlet的映射 ​ 为什么要映射：我们写Java程序，但是要通过浏览器访问，而浏览器需要连接Web服务器，所以我们需要在Web服务中注册我们写的Servlet。还需要给他浏览器能够访问的路径。 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt;&lt;!-- 注册Servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;com.li.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt;&lt;!-- Servlet请求路径--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 6.配置Tomcat ​ 注意 ：配置项目发布的路径 在第二步中，要注意下面问题 启动运行即可 Servlet原理 Mapping映射问题1、一个Servlet可以指定一个映射路径 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 2、一个Servlet可以指定多个映射路径 123456789101112131415161718192021222324&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello2&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello3&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello4&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello5&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 3、一个Servlet可以指定通用映射路径 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 4、默认请求路径 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 5、指定一些后缀或者前缀等等… 12345&lt;!-- 注意，*前面不能加项目映射的路径--&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;*.demo&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 6、优先级问题指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求； 12345678910&lt;!--404--&gt;&lt;servlet&gt; &lt;servlet-name&gt;error&lt;/servlet-name&gt; &lt;servlet-class&gt;com.kuang.servlet.ErrorServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;error&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; ServletContextweb容器在启动时候，它会为每个web程序都穿件一个对应的ServletContext对象，它代表了当前web应用； 1、共享数据 我们在一个servlet中放入数据，可以在另一个Servlet中拿到这个数据 public class HelloServlet extends HttpServlet &#123; //放入数据 @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;hello&quot;); ServletContext servletContext = this.getServletContext();// Servlet上下文 String name = &quot;小李&quot;; servletContext.setAttribute(&quot;username&quot;,name); //将一个数据保存在了Servlet中，名字为username，值是name &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125; &#125; 1234567891011121314151617181920* ```java public class GetServlet extends HttpServlet &#123; //拿到数据 @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //this.getServletContext();拿到的servletContext是和前一个类一样的容器 ServletContext servletContext = this.getServletContext(); String username =(String)servletContext.getAttribute(&quot;username&quot;); resp.setContentType(&quot;text/html&quot;); resp.setCharacterEncoding(&quot;UTF-8&quot;); resp.getWriter().print(&quot;名字是：&quot;+username); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125; &#125; 测试结果： 2、获取初始化参数12345&lt;!--配置一些web应用初始化参数--&gt;`&lt;context-param&gt;` &lt;param-name&gt;application-name&lt;/param-name&gt;` &lt;param-value&gt;学习Servlet&lt;/param-value&gt;`context-param&gt;` 1234567891011121314public class ServletDemo03 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletContext servletContext = this.getServletContext(); //调用方法，但是注意要在web.xml注册。 String url = servletContext.getInitParameter(&quot;url&quot;); resp.getWriter().print(url); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 3、进行请求转发123456789101112131415public class ServletDemo04 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletContext servletContext = this.getServletContext(); //参数是要转发的地址 RequestDispatcher requestDispatcher = servletContext.getRequestDispatcher(&quot;/hello&quot;); //转发的请求路径 requestDispatcher.forward(req,resp); //调用forward进行请求转发 &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 4、读取资源文件需要一个文件流 12345678910@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获得文件流的方法getResourceAsStream() InputStream is = this.getServletContext().getResourceAsStream(&quot;/WEB-INF/db.properties&quot;); Properties prop = new Properties(); prop.load(is); String user = prop.getProperty(&quot;username&quot;); String pwd = prop.getProperty(&quot;password&quot;); resp.getWriter().print(user+&quot;:&quot;+pwd);&#125; HttpServletRequest(6.21学到了狂神的servlet的这个地方)HttpServletResponseweb服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象，代表响应的一个HttpServletResponse； 获取客户端请求过来的参数：HttpServletRequest 响应客户端响应一些信息：HttpServletResponse SpringBoot入门 编写一个入门程序，浏览器访问url输出Hello，Spring！字样 项目结构： 第一步，在java包下的com下新建controller包下创建HelloTestController类中添加如下内容： 123456789101112131415package com.xiaoli.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController//该注解相当于@Controller + @ResponseBody@RequestMapping(&quot;/hello&quot;)public class HelloSpringController &#123; @GetMapping(&quot;/test&quot;) public void testSpring()&#123; System.out.println(&quot;Hello,Spring,你好，Spring&quot;); &#125;&#125; 启动类下启动SpringBoot项目，访问&#x2F;hello&#x2F;test查看页控制台输出 浏览器输出： 概念:Hyper Text Transfer Protocol，超文本传输协议，规定了浏览器和服务器之间数据传输的规则。 特点: 基于TCP协议:面向连接，安全 基于请求-响应模型的:一次请求对应一次响应 HTTP协议是无状态的协议:对于事务处理没有记忆能力。每次请求-响应都是独立的。 缺点:多次请求间不能共享数据。 优点:速度快 4.HTTP默认端口：80 5.HTTPS默认端口：443 HTTP 1.0: HTTP&#x2F;1.0:客户端可以与Web服务器连接，只能获得一个web资源，断开连接。 HTTP&#x2F;1.1：客户端可以与Web服务器连接，可以获得多个web资源 HTTP——请求数据格式客户端——发请求(Request)——服务器 请求行：请求数据的第一行(请求方式、资源路径、协议) 请求头：第二行开始，key：value格式 请求体：(post请求独有)，存放请求的参数 拿下面这一段代码举例： 我们来看下，他的各个部分代表着什么含义： HTTP——响应格式服务器——响应——客户端 响应行：响应数据的第一行(协议、状态码、描述) 状态码 ： 常见的响应状态码： 响应状态码 200:请求响应成功 200 3xx:请求重定向 重定向:你重新到我给你新位置去; 4xx:找不到资源 404资源不存在 5xx:服务器代码错误 500502:网关错误 常见面试题： ​ 当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么? 响应头：第二行开始，格式key：value 常见的响应头： 响应体：最后一部分，存放响应数据。 Web服务器——Tomcat 是一个开源免费的轻量级Web服务器，支持Servlet&#x2F;JSP少量JavaEE规范。 Tomcat也称为Web容器、Servlet容器。Servlet程序需要依赖于Tomcat才能运行。 Tomcat官网：https://tomcat.apache.org/ Tomcat目录说明 请求和响应概述（1）BS架构和CS架构 （2）接口测试的工具postman，apifox等等都可以 （3） 简单参数 原始方式 在原始Web程序中，获取求情参数，需要通过HttpServletRequest对象手动获取 实现代码： //请求地址 @RequestMapping(&quot;/simpleParam&quot;) public String simpleParam(HttpServletRequest request)&#123; //获取参数名称为name的值，赋值给变量name String name = request.getParameter(&quot;name&quot;); //获取参数名称为age的值，赋值给变量ageStr String ageStr = request.getParameter(&quot;age&quot;); //把ageStr转成int类型，赋值给age变量 int age = Integer.paseInt(ageStr); System.out.println(name+&quot;:&quot;+age); return &quot;ok;&quot; &#125; 123456789101112* SpringBoot方法： * 实现代码： ```java //请求地址 @RequestMapping(&quot;/simpleParam&quot;) public String simpleParam(String name,Integer age)&#123; System.out.println(name+&quot;:&quot;+age); return &quot;ok;&quot; &#125; 在SpringBoot方法中，如果你请求的参数名称和方法中定义的形参名称不一致，可以使用注解**@RequestParam完成映射。比如我形参为username，但是我请求的参数是name，那么这时候就需要这样改写(如下图形式)。如果说该参数不需要传，那么可以在@RequestParam注解中设置属性required &#x3D; false** 123456//请求地址@RequestMapping(&quot;/simpleParam&quot;)public String simpleParam(@RequestParam(name = &quot;name&quot;,required = false)String username,Integer age)&#123;System.out.println(username+&quot;:&quot;+age);return &quot;ok;&quot;&#125; （4）实体参数 简单实体对象：请求参数名与形参对象属性名相同，定义POJO接收即可。(query参数) 结果： 复杂实体对象：请求参数名与形参对象属性名相同，按照对象层次结构关系即可接受嵌套POJO属性参数。 （5）数组集合参数 数组参数：请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可接收参数。 结果： 集合参数 ：请求参数名称与形参集合名称相同且请求参数为多个时，@RequesParam绑定参数关系。 结果： （6）日期参数 日期参数：使用@DataTimeFormat注解完成日期参数格式转换。 结果： （7）Json参数 JSON参数：JSON数据键名与形参对象属性名相同，定义POJO类型形参即可接收参数，需要使用@RequestBody标识 （8）路径参数 通过URL直接传递参数，使用{….}来标识该路径参数，需要使用**@PathVariable**获取路径参数。 说明： 举例： 123456//接收来自前端的proId@RequestMapping(&quot;/pathParam/&#123;proId&#125;&quot;)public String pathParam(@PathVariable Long proId) &#123; //调用某个方法传入proId实现某种功能等等 return &quot;OK&quot;;&#125; 响应数据(介绍注解**@ResponseBody**)来看一图： 这里介绍注解**@ResponseBody** 类型：方法注解，类注解 位置：Controller方法上&#x2F;类上 作用：将方法返回值直接响应，如果返回值类型是实体对象&#x2F;集合，将会转换为JSON格式响应 说明：**@RestController &#x3D; @Controller + @ResponseBody** 为了统一并且方便管理，这里提供一个统一响应类Result类 三层架构 controller:控制层，接收前端发送的请求，对请求进行处理，并响应数据。 service:业务逻辑层，处理具体的业务逻辑。 dao:数据访问层(Data Access Object)(持久层)，负责数据访问操作，包括数据的增、删、改、查 （2）分层解耦 内聚:软件中各个功能模块内部的功能联系。 耦合:衡量软件中各个层&#x2F;模块之间的依赖、关联的程度。 如何解决耦合过高呢？下面提供解决方法 由图可以看出，我们需要提供一个容器，从而舍弃在controller层中去操作对象这一步。接下来，就介绍控制反转和依赖注入这两个概念。 控制反转: Inversion Of Control，简称IOC。对象的创建控制权由程序自身转移到外部(容器)，这种思想称为控制反转 依赖注入: Dependency Injection，简称DI。容器为应用程序提供运行时，所依赖的资源，称之为依赖注入。 Bean对象:IOC容器中创建、管理的对象，称之为bean。 （3）IOC&amp;DI入门步骤如下： 1.利用@Componet注解，将实现类交给IOC容器管理 注入依赖对象(注入Bean)，只需要在需要注入的对象上面添加注解@AutoWired注解即可完成 （4）IOC详解(控制反转) 对于Bean对象**(IOC容器中创建、管理的对象，称之为bean**)，如若要把某个对象交给IOC容器管理，需要在对应类上加上如下注解： Bean组件扫描 前面声明Bean的四大注解，想要生效，还需要被组件扫描注解**@ComponetScan**扫描。 @ComponetScan注解虽然没有显示配置，但是实际上已经包含在了启动类注解**@SpringBootApplication中，默认扫描范围是启动类所在的包及其子包。** （5）DI详解(依赖注入) Bean注入： 解决方法： 使用@Primary注解，想使用谁就在谁上添加该注解，在进行程序运行时就会使用带有@Primary注解的Bean对象 @AutoWried注解搭配@Qualifier注解： @Resource注解(由JDK提供)：注入哪一个Bean就使用@Resource(name &#x3D; “要注入Bean对象的名字”) 穿插一道面试题： @AutoWried与@Resource注解的区别 ： @Autowired 是spring框架提供的注解。而@Resource是JDK提供的注解。 @Autowired 默认是按照类型注入，而@Resource默认是按照名称注入。 Mysql——查询（1）Mysql——基本查询语法： 123456789# 查询多个字段Select 字段1,字段2,字段3 from 表名；# 查询所有字段(通配符)Selcet * from 表名;# 设置别名(as关键字可以省略)select 字段1 [as &#x27;别名1&#x27;],字段2 [as &#x27;别名2&#x27; ] from 表名;# 去除重复记录select DISTINCT 字段1,字段2 from 表名; （2）Mysql——条件查询 语法： 1select 要查询的字段 from 表名 where 条件 （3）Mysql——聚合函数 语法： 1234567891011121314select 字段列表from 表名列表where 条件列表group by 分组字段列表having 分组后条件列表order by 排序字段列表limit 分页参数 聚合函数： count：统计数量(*是通配符) max：取最大值 min：取最小值 avg：取平均值 sum：求和 语法： 1select 聚合函数(字段名) from 表名 （4）Mysql——分组查询 语法：group by 关键字 1select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后的过滤条件] （5）Mysql——排序查询 关键字：order by 语法： 1select 字段列表 from 表名 [where 条件] group by 分组字段名 order by 字段1 排序方式1,字段2,排序方式2,....; 排序方式： ASC：升序(默认值) DESC：降序 （6）Mysql——分页查询 关键字：limit 语法： select 字段列表 from 表名 limit 起始索引,查询记录数; 123456789101112131415161718192021222324252627282930313233343536373839* 起始索引从0开始。起始索引 = (页码－1) * 5* 注意事项： ![image-20240521202744500](./JavaWeb%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20240521202744500.png)## Mysql——多表设计#### （1）一对多* 实现：在数据库表中多的一方，添加字段，来关联一的一方的主键* 实现关联可以通过添加外键约束： * 外键语法： * ![image-20240521204007417](./JavaWeb%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20240521204007417.png)#### （2）一对一* 案例：用户与身份证的关系* 关系：一对一关系，用于单表拆分，将一张表的基础字段放在一张表中，其他字段放在另一张表中，以此来提升操作效率。* 图例：![image-20240525190504774](./JavaWeb%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20240525190504774.png)#### （3）多对多* 案例：学生和课程之间的关系* 关系：一门课程可以有多个学生选修，而一个学生也可以选修多门课程* 实现：建立一张第三表(中间表)，**中间表至少包含两个外键**，**分别关联两边的主键**。 * 示例：![image-20240525190728405](./JavaWeb%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20240525190728405.png)## Mysql——多表查询* 概念：从多张表中查询数据。* 笛卡尔积：笛卡尔积是指在数学中，两个集合(两张表)的所有组合情况，而多表查询的结果符合笛卡尔积。 * 语法： ```sql Select * from 表名1,表名2 where 表1.字段名 = 表2.字段名。 这里要注意的是：where后的条件是指表1表2中都有的字段。 分类： 连接查询 内连接：相当于查询A，B交集部分数据 外连接： 左外连接：查询左表所有数据(包括两张表交集部分数据) 右外连接 ：查询有表所有数据(包括两张表交集部分) 图示： 内连接： 隐式内连接：Select 字段列表 from 表1，表2 where 条件…； 显示内连接：Select 字段列表 from [inner] join 表2 on 连接条件.. 外连接 ： 左外连接(会把在左表中而不在右表中的数据查出)：Select 字段列表 from 表1 left [outer] join 表2 on 连接条件….； 右外连接(会把在右表中而不在左表中的数据查出)：select 字段列表 from 表1 left [outer] join 表2 on 连接条件… （1）子查询 介绍：sql语句中嵌套select查询，称为嵌套查询，又称子查询。 形式 ：select * from 表1 where 字段1 &#x3D;(select 字段1 from 表2)； 子查询外部的语句可以是insert &#x2F; update &#x2F; delete &#x2F; select 的任何一个。最常见的是select。 分类 ： 标量子查询:子查询返回的结果为单个值 列子查询:子查询返回的结果为一列 行子查询:子查询返回的结果为一行 表子查询:子查询返回的结果为多行多列 （1）标量子查询 子查询返回的结果是单个值(数字、字符串、日期等)，最简单 的形式。 常用的操作符: &#x3D; &lt;&gt; &gt; &gt;&#x3D; &lt; &lt;&#x3D; （2）列子查询 子查询返回的结果是一列(可以是多行)。 常用操作符：in、not in 等 （3）行子查询 子查询返回的结果是一行(可以是多列) 常用操作符：&#x3D; 、 &lt;&gt; 、 in 、 not in。 示例： 这里需要注意的是，当返回多个字段，(多列)时，可以使用括号，将要返回的字段括起来，并用逗号隔开，里面字段顺序和子查询中的字段顺序一致。 （4）表子查询 子查询返回的结果是多行多列，把它作为临时表来使用。 常用操作符：in Mysql——事务概念： 事务 是一组操作的集合，它是一个不可分割的工作单位。事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作 要么同时成功，要么同时失败。 事务控制： 开启事务：start transaction; &#x2F; begin ; 提交事务：commit; 回滚事务：rollback; 示例：依次运行。 事务的四大特性(ACID)： 原子性：事务是不可分割的最小单元，要么全部成功，要么全部失败 一致性：事务完成时，必须使所有的数据都保持一致状态 隔离性：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行 持久性：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的 （1）Mysql——索引(对数据库查询效率进行优化的手段 )索引的概念：是帮助数据库高效获取数据的数据结构(构建红黑二叉树)。 当一张表没有建立索引的时候，默认查找方法是进行全表扫描，数据量越大，性能越低。 索引的示例： 索引的优缺点： 优点： 缺点： 索引结构： MySQL数据库支持的索引结构有很多，如:Hash索引、B+Tree索引、Full-Text索引等。我们平常所说的索引，如果没有特别指明，都是指默认的 B+Tree 结构组织的索引。 拓展：请求方法以及含义1. GET 意义：GET方法用于从服务器请求信息。它是最常见的HTTP请求类型，主要用于获取资源。当使用GET方法时，请求的参数会被附加在URL后面，以问号分隔。 特点： 安全性：理论上不应该有副作用，不应修改数据或状态。 可缓存：结果可以被缓存。 可收藏：即请求可以被保存、书签化或分享给他人。 参数长度限制：由于参数是URL的一部分，因此可能受到URL长度的限制（尽管现代浏览器和服务器通常可以处理非常长的URL）。 2. POST 意义：POST方法用于向服务器发送数据，通常用于创建新的资源或者更新现有资源的部分内容。POST请求的数据体通常包含在HTTP请求的消息体中。 特点： 不安全：可能会改变服务器上的数据或状态。 不可缓存：结果不应被缓存。 不可收藏：请求不能被保存或分享。 数据大小无限制：理论上没有数据大小的限制。 3. PUT 意义：PUT方法用于替换指定的资源。与POST不同，PUT通常用于更新一个已存在的资源，而不是创建一个新的资源。PUT请求的数据体包含要更新的资源的新状态。 特点： 安全性：理论上不应有副作用，但会修改数据或状态。 可幂等：多次相同的请求应该产生相同的结果。 数据大小无限制：理论上没有数据大小的限制。 4.其他HTTP请求方法除了GET、POST和PUT，HTTP还定义了其他一些请求方法： HEAD：类似于GET，但服务器只会返回响应头部，而不返回响应体。这可以用来检查资源的状态和元数据，而不需要传输整个资源。 DELETE：用于删除指定的资源。 PATCH：用于对资源进行部分更新。与PUT不同，PATCH只更新指定的部分，而不是替换整个资源。 OPTIONS：用于查询服务器支持的通信选项，如HTTP方法和服务器支持的媒体类型。 CONNECT：用于建立与代理服务器的TCP连接，主要在HTTP代理隧道中使用。 每种请求方法都有其特定的用途和适用场景，在开发Web应用时，合理选择和使用这些方法对于构建高效、安全和符合标准的应用程序至关重要。 MyBatis——入门编写一个入门程序(基于注解的方式) 准备实体类User 12345678910111213141516171819202122232425262728293031323334353637383940package com.xiaoli.springbootmybatis.domain;public class User &#123; private int user_id; private String user_name; private int phone_number; public int getUser_id() &#123; return user_id; &#125; public void setUser_id(int user_id) &#123; this.user_id = user_id; &#125; public String getUser_name() &#123; return user_name; &#125; public void setUser_name(String user_name) &#123; this.user_name = user_name; &#125; public int getPhone_number() &#123; return phone_number; &#125; public void setPhone_number(int phone_number) &#123; this.phone_number = phone_number; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;user_id=&quot; + user_id + &quot;, user_name=&#x27;&quot; + user_name + &#x27;\\&#x27;&#x27; + &quot;, phone_number=&quot; + phone_number + &#x27;&#125;&#x27;; &#125;&#125; 引入MyBatis相关依赖。配置MyBatis（数据库连接信息） 123456789#配置数据库的连接信息 - 四要素#驱动类名称spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver#数据库连接的urlspring.datasource.url=jdbc://localhost:3306/springboot#连接数据库的用户名spring.datasource.username=root#连接数据库的密码spring.datasource.password=123456 mapper接口文件中的代码 12345678910111213141516package com.xiaoli.springbootmybatis.mapper;import com.xiaoli.springbootmybatis.domain.User;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;import java.util.List;@Mapper //在运行时 ，会自动生成该接口的实现类对象（代理对象），并将该对象交给IOC容器管理public interface UserMapper &#123; @Select(&quot;select * from user&quot;) public List&lt;User&gt; selectList();&#125; 在测试类中 有如下代码 1234567891011121314151617181920212223package com.xiaoli.springbootmybatis;import com.xiaoli.springbootmybatis.mapper.UserMapper;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTest //springboot整合单元测试的注解class SpringBootMyBatisApplicationTests &#123; //注入IOC容器中的bean @Autowired UserMapper userMapper; @Test public void allUsers()&#123; usersList.stream().forEach(item -&gt;&#123; System.out.println(item); &#125;); &#125;&#125; 输出如下 如果字段没有和数据对应，不会报错，但是数据会出现问题 ​ 1.JDBC介绍 JDBC:(Java DataBase Connectivity)，就是使用Java语言操作关系型数据库的一套API。 2.数据库连接池 数据库连接池是个容器，负责分配、管理数据库连接(Connection) 它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个 释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏 优点： 资源重用 提升系统响应速度 避免数据库连接遗漏 实现数据库连接池 标准接口：DataSource 官方(sun)提供的数据库连接池接口，由第三方组织实现此接口 功能:获取连接 代码：Connection getConnection() throws SOLException; 连接池常见产品： Druid(德鲁伊) Druid连接池是阿里巴巴开源的数据库连接池项目 功能强大，性能优秀，是ava语言最好的数据库连接池之一 切换数据库连接池：比如切换到德鲁伊连接池，在pom中引入启动依赖即可 3.LomBok Lombok是一个实用的]ava类库，能通过注解的形式自动生成构造器、getter&#x2F;setter、equals、hashcode、tostring等方法，并可以自动化生成日志变量，简化java开发、提高效率。如要使用LomBok需要引入依赖 MyBatis——基础操作准备项目，来看下项目结构 1.删除操作在Mapper包下创建对应的接口 @Mapper注解是在SpringBoot项目启动时候，动态的将bean注入容器中，注意，动态传参的参数名称应该和形参名称一致。#{}被称为参数占位符 注意事项如果mapper接口方法形参只有一个普通类型的参数，#{}里面的属性名可以随便写，如:#{id}、#{value}。 编写测试方法 如果想在控制台看到日志信息可以在application.properties中，打开mybatis的日志，并指定输出到控制台 12#指定mybatis输出日志的位置,输出控制台mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutlmpl 在输出的日志中，我们动态传入的参数会被?代替，这其实是Mysql的预编译SQL 对于预编译SQL他的： 优势：性能更高，更安全。（可以防止SQL注入） 使用Java在执行SQL语句的过程 参数占位符 2.新增员工 采用@Insert注解来进行插入操作，现在来看在mapper接口里面的方法。这里的对应指的是#{}中参数名称要和java实体类的属性名对应 新增(主键返回) 描述:在数据添加成功后，需要获取插入数据库数据的主键。如:添加套餐数据时，还需要维护套餐菜品关系表数据。 3.更新操作 在Mapper接口中写入更新的方法 采用@Update注解 执行更新操作，在测试类中操作bean对象调用上面定义的update方法。 4 .查询操作 由于在进行查询操作时候，通过某个条件查询出来我们想要的数据，那这时候就要选择封装该数据的方法，有很多，下面展示将返回来的某一个员工信息封装在对象中 方法： 在Test类中调用方法getByid，动态的传入值如下 下面来介绍一下再MyBatis中的数据封装 实体类属性名 和 数据库表查询返回(注意是返回来的数据)的字段名一致，mybatis会自动封装。 如果实体类属性名 和 数据库表查询返回的字段名不一致，不能自动封装 解决方法如下： 方案三：MyBatis的驼峰命名自动映射开关 比如数据库字段为a_Cloumn 会被解析为 aCloumn 开启方式：在配置文件中添加如下代码： mybatis.configuration.map-underscore-to-camel-case=true 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495### 5.查询操作(条件查询)即SQL语法中where关键字后面的内容，这里举例子如下* 当然，在进行查询的时候难免会遇到下面这种情况* ![image-20240612204731922](./JavaWeb%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20240612204731922.png)* concat方法：该方法会把里面包括的字符串拼接成一个字符串，那么就可解决上面的办法啦，如下，?即是我们的#&#123;name&#125;占位符、* ![image-20240612205413989](./JavaWeb%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20240612205413989.png)* 正确的代码是这样的：![image-20240612205517715](./JavaWeb%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20240612205517715.png)#### 参数名说明![image-20240612205655793](./JavaWeb%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20240612205655793.png)## MyBait——XML映射文件* 规范： * XML映射文件的名称与Mapper接口名称一致，并且将XML映射文件和Mapper接口放置在相同包下(**同包同名**) * XML映射文件的namespace属性为Mapper接口全限定名一致。 * XML映射文件中sql语句的id与Mapper接口中的方法名一致，并保持返回类型一致。 * ![image-20240612205928624](./JavaWeb%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/image-20240612205928624.png) * 返回类型我们用ResultType属性来指定，注意，resultType指的是单条记录所封装的类型## MyBatis——动态SQL***动态SQL标签以及关键属性的概述：**** 随着用户输入或外部条件的变化而变化的SQL语句，我们称为动态SQL。动态SQL在MyBatis中是一组非常强大的功能，允许你根据运行时的条件动态地构建SQL语句。以下是MyBatis中动态SQL标签及其关键属性的概述：1. **`&lt;if&gt;`** - **`test`**：表达式，用于测试条件。如果表达式计算为true，则执行if体内的SQL语句。2. **`&lt;choose&gt;`**, **`&lt;when&gt;`**, **`&lt;otherwise&gt;`** - **`choose`**：类似于Java中的switch语句，用于多个条件的选择。 - **`when`**：每个`&lt;when&gt;`元素都包含一个`test`属性，当测试条件满足时，执行其中的SQL语句。 - **`otherwise`**：当所有的`&lt;when&gt;`条件都不满足时，执行`&lt;otherwise&gt;`中的SQL语句。3. **`&lt;where&gt;`** - 自动在前面添加“WHERE”关键字，如果已经有“WHERE”关键字，则不会重复添加。还会移除前导的AND或OR关键字。4. **`&lt;set&gt;`** - 用于UPDATE语句中，只会在有至少一个字段需要更新的情况下添加“SET”关键字，并移除尾部的逗号。5. **`&lt;foreach&gt;`** - **`collection`**：指定要遍历的集合或数组的名称。 - **`item`**：当前元素的变量名。 - **`index`**：可选，表示当前元素的索引。 - **`open`**：开始符号，如左括号。 - **`close`**：结束符号，如右括号。 - **`separator`**：元素间的分隔符。6. **`&lt;trim&gt;`** - **`prefix`**：添加到内部SQL语句的开头的前缀。 - **`suffix`**：添加到内部SQL语句的结尾的后缀。 - **`prefixOverrides`**：从内部SQL语句开头移除的字符串。 - **`suffixOverrides`**：从内部SQL语句结尾移除的字符串。7. **`&lt;bind&gt;`** - **`name`**：定义的变量名。 - **`value`**：变量的值，可以是一个表达式。8. **`&lt;sql&gt;`** 和 **`&lt;include&gt;`** - **`&lt;sql&gt;`**：用于定义可重用的SQL片段。 - **`&lt;include&gt;`**：用于包含由`&lt;sql&gt;`定义的SQL片段。 - **`refid`**：在`&lt;include&gt;`标签中引用`&lt;sql&gt;`片段的ID。9. **`&lt;when&gt;`** 和 **`&lt;otherwise&gt;`** 在 **`&lt;choose&gt;`** 内部使用，已经提到过。每个标签都有自己的用途和特定的属性，这些属性帮助你控制SQL语句的动态生成过程。在实际应用中，这些标签通常会被组合使用，以生成复杂和灵活的SQL查询。例如，`&lt;if&gt;`标签可以嵌套在`&lt;foreach&gt;`标签中，或者`&lt;where&gt;`和`&lt;set&gt;`标签可以包含`&lt;if&gt;`或`&lt;choose&gt;`结构来进一步定制输出的SQL语句。### 1.`foreach` 标签的关键属性- **`collection`**：指定要迭代的集合或数组的名称。如果你传递的是一个单一的List或数组参数，`collection`属性可以省略，MyBatis会自动识别。对于Map类型的参数，需要明确指定Map中的键名作为`collection`属性的值。- **`item`**：表示每次迭代中当前元素的变量名。- **`index`**：表示当前元素在集合中的索引位置的变量名，这个属性是可选的。- **`open`** 和 **`close`**：分别指定开始和结束符号，常用于构建SQL语句的括号。- **`separator`**：指定迭代元素之间的分隔符，如逗号。#### 示例假设你有一个方法，接受一个整数列表，并且你想根据这些ID查询数据库中的记录：#### Java接口定义```javapublic interface UserMapper &#123; List&lt;User&gt; findUsersByIds(@Param(&quot;ids&quot;) List&lt;Integer&gt; ids);&#125; 映射文件中的SQL语句123456&lt;select id=&quot;findUsersByIds&quot; resultType=&quot;User&quot;&gt; SELECT * FROM user WHERE id IN &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt;&lt;/select&gt; 在这个例子中： collection=&quot;ids&quot; 表示传入的参数是名为ids的列表。 item=&quot;id&quot; 表示每次迭代的元素被称为id。 open=&quot;(&quot; 和 close=&quot;)&quot; 创建了一个包含所有ID的列表，它们被包裹在圆括号内。 separator=&quot;,&quot; 在每个ID之间插入一个逗号。 当调用findUsersByIds方法并传入一个ID列表时，MyBatis会生成一个SQL语句，其中包含一个适合的IN子句，以匹配提供的ID列表。 在MyBatis中，动态SQL主要通过使用&lt;if&gt;、&lt;choose&gt;、&lt;when&gt;、&lt;otherwise&gt;、&lt;where&gt;、&lt;set&gt;、&lt;foreach&gt;等标签来实现。下面分别介绍&lt;update&gt;和&lt;insert&gt;标签的动态写法： 2. &lt;update&gt;标签动态写法假设我们有一个用户表users，字段包括id、name、email和status。我们想要更新用户的name和email，但是只有当它们不为null时才进行更新。 123456789101112&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.example.User&quot;&gt; UPDATE users &lt;set&gt; &lt;if test=&quot;name != null&quot;&gt; name = #&#123;name&#125;, &lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt; email = #&#123;email&#125;, &lt;/if&gt; &lt;/set&gt; WHERE id = #&#123;id&#125;&lt;/update&gt; 这里使用了&lt;set&gt;标签来包含可能更新的字段，每个字段都用&lt;if&gt;标签包裹，通过test属性判断参数是否非空。 3. &lt;insert&gt;标签动态写法同样以users表为例，我们想要插入一条新记录，但是某些字段可能为空或未提供值，我们可以根据提供的值动态生成插入语句。 1234567891011121314151617181920212223242526&lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.example.User&quot;&gt; INSERT INTO users &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;name != null&quot;&gt; name, &lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt; email, &lt;/if&gt; &lt;if test=&quot;status != null&quot;&gt; status, &lt;/if&gt; &lt;/trim&gt; VALUES &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;name != null&quot;&gt; #&#123;name&#125;, &lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt; #&#123;email&#125;, &lt;/if&gt; &lt;if test=&quot;status != null&quot;&gt; #&#123;status&#125;, &lt;/if&gt; &lt;/trim&gt;&lt;/insert&gt; 这里使用了&lt;trim&gt;标签来帮助处理括号和逗号的添加和去除，使得SQL语句格式正确。每个字段同样使用&lt;if&gt;标签进行条件判断。 这些动态SQL技巧可以大大提高代码的灵活性和可维护性。 4.trim标签&lt;trim&gt;标签是MyBatis框架中一个非常有用的元素，主要用于处理动态SQL中常见的问题，如多余的前缀、后缀或分隔符（如逗号、AND等）。它允许你在生成SQL语句时自动添加或移除特定的字符串，从而确保SQL语句的正确性和效率。下面是&lt;trim&gt;标签的一些关键特性和属性： 基本属性 prefix：指定要添加到&lt;trim&gt;元素内部SQL语句开始处的前缀。 suffix：指定要添加到&lt;trim&gt;元素内部SQL语句结束处的后缀。 prefixOverrides：指定要从&lt;trim&gt;元素内部SQL语句开始处移除的字符串。这通常用于移除多余的逗号、AND或OR关键字。 suffixOverrides：指定要从&lt;trim&gt;元素内部SQL语句结束处移除的字符串。 使用场景 WHERE子句的动态构建：当你需要根据传入的参数动态构建WHERE子句时，&lt;trim&gt;标签可以自动添加”WHERE”关键字，并且确保不会出现多余的AND关键字。 1234&lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND&quot;&gt; &lt;if test=&quot;id != null&quot;&gt; AND id = #&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;name != null&quot;&gt; AND name = #&#123;name&#125; &lt;/if&gt;&lt;/trim&gt; SET子句的动态构建：在UPDATE语句中，&lt;trim&gt;标签可以用来构建动态的SET子句，确保不会有额外的逗号。 1234&lt;trim prefix=&quot;SET&quot;&gt; &lt;if test=&quot;name != null&quot;&gt; name = #&#123;name&#125;, &lt;/if&gt; &lt;if test=&quot;age != null&quot;&gt; age = #&#123;age&#125;, &lt;/if&gt;&lt;/trim&gt; VALUES子句的动态构建：在INSERT语句中，&lt;trim&gt;可以帮助构建动态的列名和值列表。 123456789&lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;name != null&quot;&gt; name, &lt;/if&gt; &lt;if test=&quot;age != null&quot;&gt; age, &lt;/if&gt;&lt;/trim&gt;VALUES&lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;name != null&quot;&gt; #&#123;name&#125;, &lt;/if&gt; &lt;if test=&quot;age != null&quot;&gt; #&#123;age&#125;, &lt;/if&gt;&lt;/trim&gt; 示例假设我们有以下需求：构建一个动态的SQL查询，如果userId和username都有值，则需要包含这两个字段的查询条件；如果没有值，则不包含。 1234567&lt;select id=&quot;selectUsersByCriteria&quot; resultType=&quot;User&quot;&gt; SELECT * FROM users &lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND&quot;&gt; &lt;if test=&quot;userId != null&quot;&gt; AND id = #&#123;userId&#125; &lt;/if&gt; &lt;if test=&quot;username != null&quot;&gt; AND username = #&#123;username&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; 这样，即使某些条件未被满足，SQL语句也不会出错，因为&lt;trim&gt;标签会确保正确的语法。 5.补充说明：MyBatis动态SQL——更多细节与高级用法1. &lt;choose&gt;, &lt;when&gt;, &lt;otherwise&gt;标签这些标签组合起来类似于Java中的switch-case结构，用于在多个条件中选择一个执行。这在构建复杂查询条件时特别有用，例如根据不同的业务逻辑分支生成不同的SQL片段。 1234567891011&lt;choose&gt; &lt;when test=&quot;type == &#x27;active&#x27;&quot;&gt; AND status = &#x27;active&#x27; &lt;/when&gt; &lt;when test=&quot;type == &#x27;inactive&#x27;&quot;&gt; AND status = &#x27;inactive&#x27; &lt;/when&gt; &lt;otherwise&gt; -- 如果没有匹配的条件，则不做任何操作 &lt;/otherwise&gt;&lt;/choose&gt; 2. &lt;bind&gt;标签&lt;bind&gt;标签用于定义局部变量，可以在后续的SQL片段中重用。这对于减少代码重复和提高代码可读性很有帮助。 1234&lt;select id=&quot;findUsersByName&quot;&gt; &lt;bind name=&quot;escapedName&quot; value=&quot;&#x27;%&#x27;+name+&#x27;%&#x27;&quot;/&gt; SELECT * FROM users WHERE name LIKE #&#123;escapedName&#125;&lt;/select&gt; 在这个例子中，&lt;bind&gt;标签创建了一个名为escapedName的变量，其值为%加上传入的名字再加上%，这样就可以在LIKE子句中使用这个变量，而无需直接在SQL语句中拼接字符串，提高了安全性。 3. &lt;foreach&gt;标签的高级用法除了基本的使用外，&lt;foreach&gt;标签还支持闭合表达式（closing expression），这允许在循环结束时添加额外的代码片段。 1234567&lt;select id=&quot;findUsersByIds&quot; resultType=&quot;User&quot;&gt; SELECT * FROM users WHERE id IN &lt;foreach collection=&quot;list&quot; item=&quot;item&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; #&#123;item&#125; &lt;/foreach&gt; ORDER BY id DESC&lt;/select&gt; 在这个例子中，ORDER BY id DESC是循环结束后添加的SQL片段，确保了查询结果按ID降序排列。 4. &lt;sql&gt;标签&lt;sql&gt;标签用于定义可复用的SQL片段。这有助于保持代码的DRY（Don’t Repeat Yourself）原则。 1234567&lt;sql id=&quot;commonFields&quot;&gt;id, name, email, status&lt;/sql&gt;&lt;select id=&quot;findUsers&quot; resultType=&quot;User&quot;&gt; SELECT &lt;include refid=&quot;commonFields&quot;/&gt; FROM users&lt;/select&gt; 这里，&lt;sql&gt;标签定义了一个包含常用字段的SQL片段，然后在&lt;select&gt;语句中通过&lt;include&gt;标签引用它。 5. &lt;isNotEmpty&gt;和&lt;isNotNUll&gt;标签虽然这些不是MyBatis的标准标签，但许多MyBatis插件提供了这样的功能，用于检查变量是否非空或非NULL。这在处理动态SQL时可以提供更简洁的语法。 123&lt;isNotEmpty property=&quot;name&quot;&gt; AND name = #&#123;name&#125;&lt;/isNotEmpty&gt; 这些标签可以简化条件判断，使SQL映射文件更加清晰和易于维护。 通过以上补充，我们看到了MyBatis动态SQL的更多细节和高级用法，这将帮助开发者更高效地处理复杂的数据库查询需求。 开发规范——Restful REST(REpresentational State Transfer)，表述性状态转换，它是一种软件架构风格 注意事项 REST是风格，是约定方式，约定不是规定，可以打破。 描述模块的功能通常使用复数，也就是加s的格式来描述，表示此类资源，而非单个资源。如:users、emps、books。 开发规范——统一响应结果 前后端交互统一响应结果Result类 开发流程","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"}]},{"title":"Java练习题","slug":"Java练习题","date":"2024-04-25T04:48:53.000Z","updated":"2024-04-25T04:51:07.319Z","comments":true,"path":"2024/04/25/Java练习题/","permalink":"http://example.com/2024/04/25/Java%E7%BB%83%E4%B9%A0%E9%A2%98/","excerpt":"","text":"题(1)：最简单的四舍五入1234567891011import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); double d= scanner.nextDouble(); //write your code here...... int i = (int)(d+0.5); System.out.println(i); &#125;&#125;","categories":[],"tags":[{"name":"练习题，面试题","slug":"练习题，面试题","permalink":"http://example.com/tags/%E7%BB%83%E4%B9%A0%E9%A2%98%EF%BC%8C%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"Java学习笔记","slug":"Java学习笔记","date":"2024-04-08T06:56:32.000Z","updated":"2024-06-22T14:46:25.037Z","comments":true,"path":"2024/04/08/Java学习笔记/","permalink":"http://example.com/2024/04/08/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1、如何拿到用户的输入有时候的一些业务是需要用户和系统互动的，这时，我们就需要来接收用户的互动，在java中，通常这么做 1234//新建一个扫描器对象scScanner sc = new Scanner(System.in);//定义一个变量来接收用户输入，类型要看你接受的是字符串还是数据而变动数据类型 变量 = sc.nextInt(); 举个例子，比如我下面这段代码 1234Scanner sc = new Scanner(System.in);System.out.println(&quot;请您输出查询的id&quot;);int id = sc.nextInt();operator.searchMovieById(id); 很好理解，接收用户输入的数字id然后把他传给operator.searchMovieById(id);方法完成代码逻辑。 2、this关键字在java中this关键字的作用是: this就是一个变量，可以用在方法中，用来拿到当前对象；哪个对象调用方法，this就指向那个对象，也就是拿到那个对象 用来解决对象的成员变量与方法内部变量的名称一样时，导致访问冲突问题的 123private Movie[] movies;public MovieOperator(Movie[] movies)&#123; this.movies = movies; 如果写成movies = movies 这时就会报错，让idea觉得你这是在该函数内部自己赋值给自己，显然不成立，如果加上this就会被识别为是Movie[ ] 的对象movies。 3、常用API(应用程序编程接口)(1)、String创建对象封装字符串数据的方式* 方式一: 123String name = &quot;小黑&quot;String schoolName = &quot;黑马程序员&quot; 方式二：调用String类的构造器初始化字符串对象 1234567public String() //创建一个空白字符串对象，不含有任何内容public String(String original) // 根据传入的字符串内容，来创建字符串对象public String(char[] chars)// 根据字符数组的内容，来创建字符串对象public String(byte[] bytes) //根据字节数组的内容，来创建字符串对象 (2)有关字符串的一些方法 1234567891011121314151617181920212223242526272829//查询字符串长度(字符个数)public int length()//获取某个索引位置处的字符返回public char charAt(int index) //将当前字符串转换成字符数组返回public char[] toCharArray()://判断当前字符串与另一个字符串的内容一样，一样返回truepublic boolean equals(object anobject) //判断当前字符串与另一个字符串的内容是否一样(忽略大小写)public boolean equalsIgnoreCase(String anotherString) //根据开始和结束索引进行截取，得到新的字符串(包前不包后)public String substring(int beginIndex, int endIndex) //从传入的索引处截取，截取到末尾，得到新的字符串返回public String substring(int beginIndex)//使用新值，将字符串中的旧值替换，得到新的字符串public String replace(CharSequence target,CharSequence replacement) ////判断字符串中是否包含了某个字符串public boolean contains(Charsequence s)//判断字符串是否以某个字符串内容开头，开头返回true，反之返回falsepublic boolean startsWith(String prefix)//判断字符串是否以某个字符串内容结尾，结尾返回true，反之返回falsepublic boolean endWith(String prefix)//把字符串按照某个字符串内容分割，并返回字符串数组回来public String[] split(String regex)//indexOf用于获取数据在字符串中第一次出现的位置String s = &quot;world hello hello world hello&quot;s.indexOf(&quot;world&quot;);//lastIndexOf用于获取数据在字符串中最后一次出现的位置s.lastIndexOf(&quot;hello&quot;); （3）字符串进行比较有哪些需要注意的？ 1、字符串的比较使用==比较好吗?为什么?什么时候使用==? 不好，对于字符串对象的比较，&#x3D;&#x3D;比较的是地址，容易出业务bug 基本数据类型的变量或者值应该使用&#x3D;&#x3D;比较。 2、开发中比较字符串推荐使用什么方式比较?使用String提供的equals方法，它只关心字符串内容一样就返回true， 123方法名public boolean equals(object anobject)public boolean equalsIgnoreCase(String anotherstring) (4)随机产生验证码(使用字符串方式) 12345678910111213141516171819202122232425package com.itheima.StringController;import java.util.Random;//随机产生验证码public class StringDemo2 &#123; public static void main(String[] args) &#123; System.out.println(randomCode(4)); System.out.println(randomCode(5)); System.out.println(randomCode(6)); &#125; public static String randomCode(int tempCode)&#123; Random r = new Random(); String code = &quot;&quot;; String data =&quot;abcdefghijklmnopqrstuVWXyZABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;; //我们需要5位验证码调用for循环 for (int i = 0; i &lt; tempCode; i++) &#123; int j = r.nextInt(data.length()); //将字符交给code code += data.charAt(j); &#125; return code; &#125;&#125; (5)两种方式的区别 双引号给出的字符串对象，存在于堆内存中的常量池中，相同内容只会存储一份。 new 字符串对象，每new一次都会在堆内存中产生一个字符串对象。 2）字符串大小写转换12345String s =&quot;Hello,World&quot;//字符串变小写s.toLowerCase()//字符串变大写s.toUpperCase() 3）StringBuilder方法java提供的一种对字符串进行拼接，反转的快捷类 使用实例： 1234567891011StringBuilder s = new StringBuilder();//拼接字符串for (int i = 0; i &lt; 10; i++) &#123; s.append(i); &#125;System.out.println(s);//反转字符串s.reverse();//在字符串指定位置插入s.insert(1,&quot;abc&quot;);System.out.println(s.toString()); 2、ArrayList集合概述1.怎么学？ arrayList会提供创建容器对象的方式 会提供相应方法对容器进行操作 增 删 改 查 创建对象 &#x3D;&#x3D;&#x3D;&#x3D;&gt; 添加增删改查方法 &#x3D;&#x3D;&#x3D;&#x3D;&gt; 了解集合特点 2.ArrayList常用方法 构造器 ArrayList是用的最多、最常见的一种集合。 1234567//创建一个空的集合对象public ArrayList() //存储任意数据类型 ArrayList list = new ArrayList(); /** 也可以这么写 */ Array&lt;Object&gt; list = new ArrayList(); 常用方法名 1234567891011121314//将指定的元素添加到此集合的末尾public boolean add(E e) //在此集合中的指定位置插入指定的元素public void add(int index,E element) //返回指定索引处的元素public E get(int index) //返回集合中的元素的个数public int size() //删除指定索引处的元素，返回被删除的元素public E remove(int index) //删除指定的元素，返回删除是否成功public boolean remove(Object o) //修改指定索引处的元素，返回被修改的元素public E set(int index,E element) 3.从集合中遍历元素，并筛选出元素删除它，应该如何操作才能不出bug?方式一:每次删除一个数据后，索引-1。 方式二:从集合后面遍历然后删除，可以避免漏掉元素。 (1) 集合中常用的接口1.Collection接口(面对单一的数据处理) 常用子接口：List，Set，Queue List：按照 插入顺序保存数据，数据可以重复 具体实现类：ArrayList，LinkedList Set：集，无序保存，数据不能重复 具体实现类：HashSet(面对K-V键值对的数据处理) Queue：队列 具体实现类：ArrayBlockingQueue 1.Map接口 具体实现类：hashMap，HashTable （2）ArrayList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.itheima.List;import java.util.ArrayList;public class TestList &#123; public static void main(String[] args) &#123; //ArrayList:Array + List // TODO List:列表，清单 // 按照数据插入顺序进行存储 ArrayList list = new ArrayList(); ArrayList list1 = new ArrayList(); list1.add(&quot;1&quot;); list1.add(&quot;2&quot;); list1.add(&quot;3&quot;); //创建集合对象 //1.不需要传入参数，底层数组为空数组 //2.构造参数需要传递一个int类型的值，设置底层数组的长度 //3.构造参数需要传递一个Collection集合类型的值，用于将其他集合中的数据放置在当前集合中 // TODO 增加数据 // add方法添加数据时，只要将数据作为参数传递到add方法即可 // 添加数据时，如果集合中没有任何的数据，那么底层就会创建长度为10的数组 // add方法也可以传入两个参数，第一个是索引,第二个是添加数据的值 list.add(&quot;zhangsan&quot;); list.add(&quot;wangwu&quot;); list.add(&quot;xiaoli&quot;); list.add(1,&quot;zhaoliu&quot;); //在该集合中传入其他集合 list.addAll(list1); // 获取集合中的数据条数 System.out.println(list.size());//3 //获取指定位置的数据，传入的是索引 System.out.println(list.get(1));//wangwu //遍历集合中的数据 for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; //如果循环数据不关心数据的位置，采用特殊的for循环 for (Object obj : list)&#123; System.out.println(&quot;集合中的数据：&quot;+obj); &#125; // todo 修改数据 //将指定位置的数据进行修改set()注意，传递两个参数，第一个参数表示数据的位置，第二个表示修改后的值 Object oldVal = list.set(1, &quot;lisi&quot;); System.out.println(&quot;修改前的值：&quot;+oldVal); // todo 删除数据 //将指定位置的数据进行修改remove()注意，传递1个参数，一个参数表示数据的位置。 Object remove = list.remove(1); System.out.println(&quot;删除的值&quot;+remove); //清空集合的数据// list.clear(); //删除指定集合中的数据(比如上面新添加的list1)// list.removeAll(list1); //判断集合中是否存在某条数据,包含返回true不包含返回false System.out.println(list.contains(&quot;lisi&quot;)); //获取数据在索引中第一个的位置，数据不存在返回-1，存在返回数据所在位置的索引值 System.out.println(list.indexOf(&quot;lisi&quot;)); //获取最后出现的位置的索引值(集合中有多个zhangsan，但是返回的是最后一个zhangsan的索引值) list.lastIndexOf(&quot;lisi&quot;); //复制一个集合 Object clone = list.clone(); ArrayList list2 = (ArrayList)clone; //该集合和被复制的list集合额内容一致 System.out.println(list2); // TODO 打印集合对象 System.out.println(list); &#125;&#125; （3）LinkedListLinkedList &#x3D; Linked(链接) + List 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.itheima.List;import java.util.LinkedList;public class LinkedListTest &#123; public static void main(String[] args) &#123; //todo 集合--- Collection // LinkedList //构建集合对象 LinkedList linkedList = new LinkedList(); LinkedList linkedList1=new LinkedList(); //增加第一个数据 linkedList.add(&quot;zhangsan&quot;); linkedList.add(&quot;lisi&quot;); linkedList.add(&quot;wangwu&quot;); linkedList1.add(&quot;1&quot;); linkedList1.add(&quot;2&quot;); linkedList1.add(&quot;3&quot;); //添加一个集合 linkedList.addAll(linkedList1); //链表前面增加// linkedList.addFirst(&quot;lisi&quot;); //链表后面增加// linkedList.add(1,&quot;wangwu&quot;); //获取数据 //拿到第一个数据(开头数据) System.out.println(linkedList.getFirst()); //拿到第二个数据(结尾数据) System.out.println(linkedList.getLast()); //根据索引拿数据 System.out.println(linkedList.get(1));//lisi // todo 遍历数据 for (int i = 0; i &lt; linkedList.size(); i++) &#123; System.out.println(linkedList.get(i)); &#125; //todo 遍历数据(第二种) for (Object obj:linkedList)&#123; System.out.println(obj); &#125; //删除数据 linkedList.remove(&quot;lisi&quot;); //表示删除第一个 linkedList.remove(1); linkedList.remove(); //删除链表第一个元素 linkedList.removeFirst(); //删除链表最后一个元素 linkedList.removeLast(); //push相当于addFirst方法 linkedList.push(&quot;123&quot;); //pop()弹出元素 System.out.println(linkedList.poll()); //todo 打印集合的数据 System.out.println(linkedList); &#125;&#125; （4）泛型12345678910111213141516171819202122232425package com.itheima.List;import java.util.ArrayList;public class ListQuestion &#123; //todo 集合 public static void main(String[] args) &#123; //todo 泛型语法&lt;&gt;中放你要在集合中存储的数据类型 User user = new User(); //如果没有尖括号里面的内容，表示我在这个容器中可以存储任何类型的数据 MyContainer&lt;User&gt; myContainer = new MyContainer(); //会报错，因为我已经用尖括号限定了容器类类型// MyContainer.data = new Object(); &#125;&#125;// todo 容器类class MyContainer&lt;C&gt;&#123; public C data;&#125;class User&#123;&#125; （5）比较器1234567891011121314151617181920212223242526272829303132package com.itheima.List;import java.util.ArrayList;import java.util.Comparator;public class ListSort &#123; public static void main(String[] args) &#123; ArrayList list = new ArrayList(); list.add(1); list.add(2); list.add(3); //new一个比较类的对象 NumberComparator comparator = new NumberComparator(); //todo 集合中的数据进行比较 list.sort(comparator); System.out.println(list); &#125;&#125;//创建一个比较类，实现Comparator接口class NumberComparator implements Comparator&lt;Integer&gt;&#123; @Override public int compare(Integer o1, Integer o2) &#123; //todo 如果第一个数大于第二个数，返回结果为正数，表示升序排序// return o1 - o2; //todo 如果第一个数小于第二个数，返回结果为负数，表示升序降序 return o2 - o1; //todo 如果第一个数等于第二个数，返回结果为0。// return 0; &#125;&#125; （6）HashSet12345678910111213141516171819202122232425262728package com.itheima.List;import java.util.HashSet;public class HashSetTest &#123; public static void main(String[] args) &#123; //HashSet:Hash + Set //Hash：哈希算法，散列(无序) //ArrayList：数组 //LinkedList： HashSet hashSet = new HashSet(); //todo 增加数据 hashSet.add(&quot;lisi&quot;); hashSet.add(&quot;zhangsan&quot;); hashSet.add(&quot;wangwu&quot;); // todo 修改数据(先删除，在增加) hashSet.remove(&quot;zhangsan&quot;); hashSet.add(&quot;xiaoli&quot;); //todo 遍历数据 for (Object obj : hashSet)&#123; System.out.println(obj); &#125; // todo 转换成数组 Object[] objects = hashSet.toArray(); System.out.println(hashSet); &#125;&#125; HashSet处理重复数据重写equals和hashcode方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.itheima.List;import java.util.HashSet;public class HashSetTestForNum &#123; public static void main(String[] args) &#123; //HashSet的底层是：数组 + 链表 结构 HashSet hashSet = new HashSet(); User1 user1 = new User1(); User1 user2 = new User1(); User1 user3 = new User1(); user1.id=1001; user1.name=&quot;zhangsan&quot;; user2.id=1001; user2.name=&quot;zhangsan&quot;; user3.id=1002; user3.name=&quot;lisi&quot;; hashSet.add(user1); hashSet.add(user2); hashSet.add(user3); System.out.println(hashSet); &#125;&#125;class User1&#123; public String name; public int id; //重写hashcode方法和equals //类似于内存地址 @Override public int hashCode() &#123; return id; &#125; @Override public boolean equals(Object obj) &#123; if(obj instanceof User1)&#123; User1 testObj = (User1) obj; if(testObj.id == this.id)&#123; if(testObj.name.equals(this.name))&#123; return true; &#125; &#125; return false; &#125;else&#123; return false; &#125; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&#x27;&quot; + id + &#x27;\\&#x27;&#x27; + &quot;, name=&quot; + name + &#x27;&#125;&#x27;; &#125;&#125; (7)Queue接口12345678910111213141516171819202122232425262728293031323334353637383940package com.itheima.Queue;import java.util.concurrent.ArrayBlockingQueue;public class TestQueue &#123; public static void main(String[] args) throws Exception&#123; //todo 了解我们的Queue // ArrayBlockingQueue = Array(数组) + Blocking(阻塞，等待) // 所以queue底层还是数组 ArrayBlockingQueue queue = new ArrayBlockingQueue(3); //添加数据 queue.add(&quot;zhangsan&quot;); queue.add(&quot;lisi&quot;); queue.add(&quot;wangwu&quot;); //由于我长度只给了3，所以只能存三个数据，下面这个数据无法存储,报错 Queue full，代表queue存满了// queue.add(&quot;xiaoli&quot;); //添加数据(put)方法，该方法能够体现出阻塞这一概念，当我添加的数据大于长度时，程序会继续运行，不会停止// queue.put(&quot;zhangsan&quot;);// queue.put(&quot;lisi&quot;);// queue.put(&quot;wangwu&quot;); //添加数据offer方法，该方法会返回一个布尔类型的值，添加成功返回true，添加失败(超出queue存储长度)返回false// boolean zhangsan = queue.offer(&quot;zhangsan&quot;);// boolean lisi = queue.offer(&quot;lisi&quot;);// boolean wangwu = queue.offer(&quot;wangwu&quot;);// System.out.println(zhangsan);// System.out.println(lisi);// System.out.println(wangwu); //拿取数据(poll方法)// System.out.println(queue.poll());// System.out.println(queue.poll());// System.out.println(queue.poll()); //拿取数据(take方法),当我去一个不存在的数据时，不会报错，程序不会结束，体现了一个等待，阻塞的过程 System.out.println(queue.take()); System.out.println(queue.take()); System.out.println(queue.take()); System.out.println(queue); &#125;&#125; (8)HashMap(处理键值对数据(K,V))数据存储无序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.itheima.HashMap;import java.util.*;public class TestHashMap &#123; public static void main(String[] args) &#123; //HashMap = Hash + Map //todo 处理键值对&#123;K=V&#125; //创建HashMap对象 HashMap&lt;String,String&gt; map = new HashMap(); //添加数据put方法,当put传入的键相同时，相当于修改操作，返回被修改的值 map.put(&quot;zhangsan&quot;,&quot;1&quot;); System.out.println(map.put(&quot;zhangsan&quot;, &quot;2&quot;));//返回1，并且zhangsan键对应的value值被改为了2 map.put(&quot;lisi&quot;,&quot;2&quot;); map.put(&quot;wangwu&quot;,&quot;3&quot;); System.out.println(map); //todo 查询数据(返回被删除的键对应的value值) System.out.println(map.get(&quot;zhangsan&quot;)); //todo 删除数据 map.remove(&quot;zhangsan&quot;); //todo 添加数据putIfAbsent方法，这个方法会检查该map里面有没有这个键值，如果有，则不做任何操作，如果没有则插入数据 map.putIfAbsent(&quot;Xiaoli&quot;,&quot;4&quot;); map.putIfAbsent(&quot;lisi&quot;,&quot;2&quot;); //todo 修改数据replace方法 map.replace(&quot;Xiaoli&quot;,&quot;8&quot;); //todo 清空// map.clear(); //todo 获取map集合中所有的key Set setKey = map.keySet();// for(Object i : setKey)&#123;// System.out.println(map.get(i));// &#125; //todo 获取所有的值 Collection value = map.values(); System.out.println(value); //判断集合中包含某个指定的value值 System.out.println(map.containsValue(&quot;1&quot;)); System.out.println(map); //todo 获取键值对对象 Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet(); for (Map.Entry&lt;String, String&gt; entry : entries) &#123; System.out.println(entry.getKey()+&quot;=&quot;+ entry.getValue()); &#125; &#125;&#125; (9)HashTable1234567891011package com.itheima.HashTable;public class TestHashTable &#123; public static void main(String[] args) &#123; //todo HashTable // HashTable底层容量默认11 // HashTable的K,V不可以为null值 // HashTable使用的是HashCode //基本操作和HashMap一致(第(8)小节内容) &#125;&#125; (10)迭代器12345678910111213141516171819202122232425262728293031package com.itheima.HashTable;import java.util.HashMap;import java.util.HashSet;import java.util.Iterator;import java.util.Set;public class DieDaiQi &#123; public static void main(String[] args) &#123; HashMap&lt;String, Integer&gt; map = new HashMap&lt;String,Integer&gt;(); map.put(&quot;a&quot;,1); map.put(&quot;b&quot;,2); map.put(&quot;c&quot;,3); //todo 获取map集合当中的key值，返回key值的集合 Set&lt;String&gt; setKeys = map.keySet(); //TODO 使用迭代器对集合map进行处理 //todo 创建迭代器对象(iterator) Iterator&lt;String&gt; iterator = setKeys.iterator(); //hasNext用于判断是否存在下一条数据 while (iterator.hasNext())&#123; //获取下一条数据 String key = iterator.next(); if(&quot;b&quot;.equals(key))&#123; iterator.remove(); &#125; System.out.println(map); &#125; System.out.println(map); &#125;&#125; (11)工具类第二章1、标识符的命名规则123456789101112131415161718192021222324252627282930313233/ /T0D0标识符得命名规则//1．英文拉丁字母/ / wx , qqString username = &quot;zhangsan&quot;;String xingming = &quot;lisi&quot;;// 2．符号//@，#，%，$//3.标识符只能采用下划线和美元$符号，其他符号不能使用，称之为特殊符号//4.空格属于特殊符号，所以也不能作为标识符使用String _name = &quot;wangwu&quot;;String $name = &quot;wangwu&quot; ;String $na_me = &quot;wangwu&quot;;system.out.println(_name);system.out.println($name);system.out.println($na_me);//5.阿拉伯数据0到9可以作为标识符使用，但是不能开头 //数字如果在标识符得开头位置，那么会被识别为数字，而不是标识符，所以会发生错误//String 1name = &quot;zhangsan&quot;;String name1 = &quot;zhangsan&quot;;//6.标识符区分大小写String Public = &quot;zhaoliu&quot;;//7.驼峰命名法String userName = &quot;小李&quot;; 2、数据存储单位1.比特(bit位)：数据运算的最小存储单位。 2.字节(byte)：数据的最小存储单位。 字节和比特之间可以互相转换的，关系如下 ​ 1byte = 8bit 3、基础数据类型1.整数数据类型:byte，short，int，long分别是8位，16位，32位，64位 2.浮点类型：含有小数点的数据类型；float（单精度浮点类型），double（双进度浮点类型）。 单精度浮点类型，我们需要用F(f)来结尾如 1float f = 2.0f; 3.字符类型:使用符号标识文字内容 1char c = &quot;@&quot; 4.布尔类型：判断条件是否成立，成立取值true，不成立取值false 1boolean bln = true; 4、数据类型转换在java中范围小的数据可以直接转换为范围大的数据，但是范围大的数据不能转换成范围小的数据，如果非要大类型转小类型，那么我们应该使用小括号进行强制类型转换 123byte b =10;int i = s;byte i1 =(byte)i; 5、引用数据类型类、String、接口、数组、枚举、特殊类型值:null 6、运算符、表达式、算数运算符1.运算符就是参与数据运算的符号，Java定义，无法自行定义2.表达式就是采用运算符和数据连接在一起形成符合Java语法规则的指令代码3.算数运算符 二元运算符：两个元素参与运算的运算符 1 + 2 算术表达式 &#x3D; 元素1 二元运算符 元素2 (表达式是有结果的，就需要有类型，这里的类型是元素种类类型最大的那一种，最小使用的类型为int类型) 123456System.out.println(1 + 2) //3System.out.println(2 - 2) //0System.out.println(1 * 2) //2System.out.println(4 / 2) //2 (int,int) ==&gt;int结果类型取决于类型大的那个System.out.println(1.0 / 2) //0.5 (double,int) ==&gt;double,结果类型取决于类型大的那个System.out.println(5 % 2) //1(取余数，模运算) 一元运算符：一个元素参与的运算符(++，--) ++:本质是加1操作的简化版本，也成为自增运算符,注意，++i，表示i先自加1随后在进入下面的运算，而i++表示i先参加运算后再加1 --:本质是减1操作的简化版本，也成为自减运算符,注意，–i，表示i先自减少1随后在进入下面的运算，而i–表示i先参加运算后再减1 4.赋值运算符123456789101112131415161718192021public class OperatorDemo3 &#123; public static void main(String[] args) &#123; // TODO 赋值运算符 //等号就是赋值运算符，将右边表达式的结果赋值给等号左边变量 //赋值运算符要考虑类型的关系 String name = &quot;zhangsan&quot;; //TODO 复合赋值运算符：+= // 如果元素进行运算后重新赋值给自己，那么可以将运算和赋值的符号进行简化 // 复合赋值运算符进行运算时，数据类型不会发生变化 int i =0; i+=1;//相当于i = i+1 System.out.println(i); byte num1 = 10; //下面这种写法由于二元运算符最小类型为int会导致报错 //num1 = num1 + 20; //使用复合运算符就不会报错了，因为复合赋值运算符进行运算时，数据类型不会发生变化 num1 +=20; System.out.println(num1); &#125;&#125; 5.逻辑运算符12345678910111213141516171819202122232425262728293031public class OperatorDemo1 &#123; public static void main(String[] args) &#123; //掌握逻辑运算符的使用 //需求:要求手机必须满足大于等于6.95英寸，切内存大于等于8 double size = 9.8; int storage = 16 boolean rs = size &gt;= 6.95 &amp; storage &gt;=8;//逻辑与:一假即假，两个都成立才为true System.out.println(rs); //需求:要求手机要么满足大于等于6.95英寸，要么内存大于等于8 boolean rs2 = size &gt;= 10 &amp; storage &gt;=8;//逻辑或:一真即真，两个都是假才为false System.out.println(rs2); System.out.println(&quot;---------------------&quot;); //逻辑非:取反的意思 System.out.println(2&gt;1); System.out.println(!(2&gt;1)); System.out.println(&quot;---------------------&quot;); //逻辑异或:前后结果条件相同返回false，不同返回true System.out.println(true ^ true); System.out.println(false ^ true); System.out.println(&quot;---------------------&quot;); //短路与: 写法:&amp;&amp;,规则:左边为false，右边不执行 //短路或: 写法:|| 规则:左边为true，右边不执行 int i = 10; int j =20; System.out.println(i&gt;100 &amp;&amp; ++j&gt;99); System.out.println(&quot;---------------------&quot;); int m =10; int n =30; System.out.println(m&gt;3 || ++n &gt;40); &#125;&#125; 6.三元运算符1234567891011public class OperatorDemo6 &#123; public static void main(String[] args) &#123; // TODO 运算符 - 三元运算符 // 指三个元素参与运算的运算符 //基本语法结构：变量 = （条件表达式）？（任意表达式1）：（任意表达式2） // 当条件表达式的结果为ture则执行表达式1，反之执行表达式2 int i = 10 ; int k =(i == 5)? (i+10):(i+1); System.out.println(k); &#125;&#125; 7、流程控制1.顺序执行 按照代码顺序从前往后执行 2.分支执行 if……else…… if……elif……….elif……..else…….. switch(变量){ case1: ……. ; case2: ……… ;default: ………..;},switch分支判断也叫等值分支判断。 其中在switch分支中如果想要跳出某个case并结束分支执行，就在那个case块的内容最后加上break用来跳出 3.重复执行（循环）在Java中用于循环的语法有3个： 1）while：有条件循环 while(条件表达式){需要循环的代码} 2）do….while(先执行一次，在进行条件判断) 3）for for(初始化表达式 ; 条件表达式 ; 更新表达式;){ 循环体内容 } ​ 初始化表达式实际上是对条件表达式中用到的变量进行初始化，循环体内容执行完毕后，会重新进行条件判断，如果判断为ture则会继续执行循环体内容。 小练习:九层妖塔 请在控制台输出打印如下 代码如下: 1234567891011for(int i = 0;i&lt;9;i++)&#123;//完成打印但是打印出来的是全部对齐的，并未达到要求 //下面打印空格因为最后一行不用输出空格所以我们只打印8层就可以，按照规律每层打印的空格数=8-层号for(int j=0;j&lt;8-i;j++)&#123;System.out.print(&quot; &quot;);&#125; for(int j=0;j&lt;i*2+1;j++)&#123; System.out.print(&quot;*&quot;); &#125; System.out.println(&quot; &quot;);&#125; 第三章 面向对象1）什么是面向对象？所谓面向对象，其实就是分析问题时，以问题所涉及的是或者物为中心的分析方式 2）类和对象1.类 and 对象(先有类，再有对象)类表示归纳和整理；对象表示具体的事务。 在Java中我们用class表示类，通常类名首写字母大写。 基本语法结构： 1234567class 类名&#123;特征(属性)功能(方法)&#125; 2.创建对象的语法结构对象：类的实例化(具象化) 12new 类名();//小括号不能丢//new是关键字，表示创建一个具体的对象，使用一次，创建一次，每次都是全新的对象。 对象是将内存地址赋值给了变量，所以变量其实引用了内存中的对象，所以称之为引用变量，而变量的类型称之为引用数据类型。 特殊的对象：空对象(null)，没有引用的对象，称之为空对象，关键字对象，所有引用对象的类型默认取值为null 3.属性所谓属性，就是类的对象的相同特征 声明：属性类型 属性名称 &#x3D; 属性值 如果在声明属性的同时进行了初始化赋值，那么所有对象的属性就完全相同。如果希望每个对象的属性不一致，那么我们可以只声明即可，那么属性会在构造对象的时候默认初始化，而默认初始化的值取决于属性的类型 byte，short，int，long &#x3D;&#x3D;&gt; 0 float,double &#x3D;&#x3D;&gt; 0.0 boolean flg &#x3D;&#x3D;&gt; false char &#x3D;&#x3D;&gt;空字符 引用数据类型 &#x3D;&#x3D;&gt; null 1234//初始化并赋值zhansanString name = &quot;zhansan&quot;;//只声明String name; 4.静态(static)针对于具体对象的属性称之为对象属性，成员属性，实例属性 针对于具体对象的方法称之为对象方法，成员方法，实例方法 把和对象无关，只和类相关的称之为静态， 和类相关的方法称为静态方法 和类相关的属性称为静态属性 静态语法：就是在属性和方法前面增加static关键字 在Java语法中： 成员方法可以访问静态属性和静态方法 静态方法不可以访问成员属性和静态方法 在访问静态类的属性时，可以用静态类名.属性名直接访问。 静态代码块当类的信息加载完成后，会自动调用静态代码块，可以完成静态属性的初始化功能 123static&#123; //代码块内容&#125; 在我们构建对象时，代码块会进行初始化，但不是静态的 1234&#123;//代码块内容&#125; 3）方法1.方法的声明：1【方法返回值类型】【void】 方法名(参数)&#123;功能代码&#125; 方法中void是空的意思，意味着没有结果。如果在方法中的结果需要返回，则确定返回值的类型利用return关键字来返回结果。没有返回值就用void 123456//返回的结果是布尔类型的所以用Booleanboolean register()&#123;System.out.println(&quot;注册成功&quot;) //返回结果return true;&#125; 2.方法传参(方法参数)1.语法:方法名(参数类型 参数名称) 方法名(参数类型1 参数名称1,参数类型2 参数名称2,参数类型3 参数名称3) { }进行多个参数的传递。 2.传参注意事项： 参数个数要匹配 参数类型要匹配 参数顺序要匹配 当参数个数不确定时，我们可以使用特殊语法来声明：可变参数 12参数类型... 参数名称方法名(String ... name)&#123; &#125; 当参数列表中还有别的参数时，我们需要将可变参数声明在参数列表最后。 基本数据类型:传数值 引用数据类型:传引用地址 1234567891011121314//main方法中User user = new User();String name =&quot;zhangsan&quot;； //传递参数user.sayHello(name);class User&#123;void sayHello(String name)&#123; //使用参数System.out.println(&quot;hello&quot;+ name); &#125;&#125; 小插曲Java中的三块内存区域 栈：存放的是(方法，变量) 堆：存放(对象) 元空间：存放类的信息，也称之为方法区 4）包-包中容纳类 语法：package 包完整路径; 包完整路径用·隔开 包名一般全是小写字母 包的导入:我们用import语法来导入包。 import使用在package后class前 12345package xxx.xxx.Xxxx;import xxxxxx;public class xxxx&#123;&#125; 5）面向对象——构建对象——构造方法12//创建了一个User类的对象userUser user = new User(); 上面这个过程实际上使用了构造方法来构建的对象下面来介绍一个构造方法 构造方法：专门用于构建对象 如果类中没有任何构造方法，那么**JVM(java虚拟机)**会自动添加一个公共的无参的构造方法。基本语法如下 123类名 ()&#123;&#125; 注意点: 构造方法也是方法，但是没有void关键字 方法名和类名完全相同 如果类中没有构造方法&#x3D;&#x3D;&#x3D;&gt;JVM会提供默认构造方法 如果类中有构造方法&#x3D;&#x3D;&#x3D;&gt;JVM不会提供默认构造方法 构造方法也是方法，可以传递参数，但是一般传递参数的目的是用于对象属性的赋值 6）面向对象——继承关键字：Extends 基本语法： 1class 子类 extends 父类 &#123; &#125; 类存在父子关系：子类可以直接获取到父类的成员属性和成员方法 类的继承只能是单继承，一个类只能有一个父类，不能存在多个父类 在继承中，如果父类和子类含有相同的属性，那么可以采用特殊的关键字进行区分:super &amp; this. super：表示上一级 this：表示当前 继承中的方法问题构造方法(完成内存控件属性的初始化操作): 父类对象是在子类对象前创建完成的，创建子类对象前，会先创建父类对象 如果父类提供了有参构造方法，那么JVM就不会提供默认的构造方法，那么子类应该调用super方法(带入参数)构建父类对象。 7）面向对象——多态所谓多态，其实就是一个对象在不同场景下表现出来的不同状态和形态。 多态语法其实就是对对象的使用场景进行了约束。 以父类声明的子类对象，只能使用父类中的方法，如果子类对象想使用子类方法，需要用子类来声明子类对象 8）面向对象——方法重载相同的方法：在一个类中，相同方法是指方法名，参数列表相同，和返回值类型无关的方法。 方法重载： 在Java中，如果方法名称相同，但是参数列表(个数，顺序，类型)不相同，会认为是不同的方法，只是名称一样，我们称之为方法的重载。 在构造方法中，想要调用其他构造方法，那么需要使用关键字:this 123456789101112131415161718192021222324package com.itheima.面相对象综合实例;public class ClassObject2 &#123; public static void main(String[] args) &#123; //我们只需要调用无参构造方法即可 //创建对象时会调用构造函数 User user = new User(); &#125;&#125;class User&#123; User()&#123; //使用this关键字传入参数调用下面构造方法 this(&quot;zhansan&quot;); &#125; User(String name)&#123; //接收name并用this关键字调用下面方法 this(&quot;zhangsan&quot;,&quot;男&quot;); &#125; User(String name, String sex)&#123; System.out.println(&quot;名字是:&quot;+name+&quot;,&quot;+sex); &#125;&#125; 打印如下: 1名字是:zhangsan,男 结论基本数据类型： 基本数据类型匹配方法时，可以在数值不变的情况下扩大数据的精度。 byte数据类型无法和char类型做转换，char没有负数，而byte存在着负数 引用数据类型： 引用数据类型无法扩大数据精度，但是引用数据类型匹配方法时，会往object类去找。 比如A类是B类的父类，那么当调用的方法在B类中不符合时，就去A类中寻找，如果A类中没有就去A类的父类object中寻找 9）面向对象——方法重写定义：在父类中的方法其实主要体现通用性(可以被多个子类继承，可以被多个子类使用自身方法)，无法在某一个特定情况去使用这个方法。如果子类对象需要再某个特定业务逻辑中使用该父类的方法，那么就需要对父类中的方法进行重写，这个操作成为重写。 请注意： 子类中的方法不会覆盖父类的方法，只是父类当前方法不适用这个场景 如果想在当前类调用父类方法可以使用super关键字进行调用 当子类的方法中的返回值类型，参数列表，方法名称都和父类相同时才可以进行重写 1234567891011121314151617181920212223package com.itheima.面相对象综合实例;public class RewriteMethods &#123; public static void main(String[] args) &#123; Child child = new Child(); Parent parent =new Parent(); System.out.println(child.sum());//40 System.out.println(parent.sum());//20 &#125;&#125; class Parent&#123; int i = 10; int sum()&#123; return i+10; &#125;&#125;class Child extends Parent&#123; int i =20; int sum()&#123; return i+20; &#125;&#125; 通过以上例子，总结四点： 一个对象能使用什么方法，取决于引用变量的类型 一个对象能使用什么属性，取决于引用变量的类型 一个对象的方法具体使用(这个方法怎么去执行，逻辑是什么，直接使用还是间接使用)，需要看具体对象 一个对象的属性具体的使用是不需要看具体的对象的，属性在哪里声明就在哪里使用 10）面向对象——递归定义：方法调用自身，成为递归方法 递归最经典的案例——求n以内的奇数和 123456789101112131415161718package com.itheima.面相对象综合实例;public class RewriteMethods &#123; public static void main(String[] args) &#123; int result = getSum(20); System.out.println(result); &#125; static int getSum(int n) &#123;//三元运算符，当n是偶数时会执行(n－1)，当n是奇数时直接用n n = n % 2 == 0 ? n - 1 : n; if (n == 1) &#123; return 1; &#125; else &#123; return n + getSum(n - 2); &#125; &#125;&#125; 递归——阶乘 一个大于1的数的阶乘就是这个数乘以这个数减一的阶乘 123456789101112131415package com.itheima.面相对象综合实例;public class RewriteMethods &#123; public static void main(String[] args) &#123; int result1 = jieCheng(5); System.out.println(result1); &#125; //求n以内的数的阶乘 public static int jieCheng(int n)&#123; if(n&lt;= 1)&#123; return 1; &#125;else &#123; return n * jieCheng(n-1); &#125; &#125;&#125; 注意： 递归应该有跳出的逻辑 调用自身时，传入的参数应该是有规律的 11）面向对象——访问权限 public：公共的，访问权限修饰符 ​ 在Java中，公共类只有一个，且名称和源码文件相同 ​ main方法：main方法是有JVM调用的，JVM可以任意调用，可以忽略权限问题 Java中的访问权限有四种： private：私有的，同一个类中可以使用，别的类，其他地方无法使用 (default)：默认权限，当不设定任何权限时，JVM会默认提供权限，包(路径)权限 protected：受保护的权限，子类可以访问 public：公共的，任意使用。 12）面向对象——内部类——外部类外部类：在源码中直接声明的类 内部类：类中声明的类 内部类在进行定义的时候，可以当成外部类的属性使用即可，但是在使用的时候，因为内部类被看做了外部类的属性，所以需要定义外部类对象进行使用。 1234//内部类定义class InnerClass&#123;&#125; 举个例子： 1234567891011121314151617181920212223242526package com.itheima.面相对象综合实例;public class InerClass &#123; public static void main(String[] args) &#123; //创建外部类对象 OuterClass outerClass = new OuterClass(); //通过外部类对象来创建内部类对象 OuterClass.InnerClass1 innerClass1 = outerClass.new InnerClass1(); //调用各自的方法 outerClass.printSome(); innerClass1.printSome(); &#125;&#125;class OuterClass&#123; public void printSome()&#123; System.out.println(&quot;我是外部类方法&quot;); &#125; class InnerClass1 &#123; public void printSome()&#123; System.out.println(&quot;我是内部类方法&quot;); &#125; &#125;&#125; 13）面向对象——final关键字 final可以修饰变量：变量的值一旦初始化不允许被修改 final可以修饰属性：但是JVM不会对自动对属性进行初始化，需要手动初始化，并且属性值不可以修改 final可以修饰方法：final修饰的方法不可以被子类重写 final可以修饰类：当final修饰一个类时，被修饰的类不可以有子类 final不可以修饰构造方法。 final可以修饰方法参数：一旦修饰，该参数无法修改。 一般将final修饰的变量称之为常量，或者叫不可变量。 14）面向对象——抽象—Abstract 抽象类：不完整的类就是抽象类，抽象类不能够构造对象 1234//语法abstract class 类名&#123;&#125; 抽象方法：只有声明方法，而不去写方法里面的逻辑。 12//语法abstract 返回值类型 方法名(参数); 在一个类中，有抽象方法就是抽象类，反之，如果有抽象类，他的方法不一定是抽象方法。 抽象类无法直接构造对象，但是可以通过子类间接构造对象。 如果抽象类中含有抽象方法，那么子类继承抽象类，需要重写抽象方法，将方法补充完整。 abstract关键字不能和final关键字一起使用 15）面向对象——接口(interface)接口：可以简单理解为规则。 基本语法： 12//接口语法interface 接口名称&#123; 接口属性，接口规则&#125; 接口其实是抽象的 规则的属性必须为固定值，而且不能修改。 属性和行为的访问权限是公共的。 属性是静态的。 行为是抽象的。 接口可以继承其他接口 类的对象需要遵循接口，在Java中其实就是实现(implements)接口。而且类可以实现多个接口 接口的一段演示代码 12345678910111213141516171819202122232425262728293031323334353637383940public class InterfaceTest &#123; public static void main(String[] args) &#123; Computer c = new Computer(); Light light = new Light(); //相当于把电灯插到usb1口上 c.usb1 = light; //把电灯插到usb2口上 c.usb2 = light; //电脑给上面两个供电(调用givePower方法) c.givePower(); &#125;&#125;interface rule &#123; &#125;interface PowerOut extends rule&#123; public void givePower();&#125;interface PowerIn extends rule&#123; public void receivePower();&#125;class Computer implements PowerOut&#123; public PowerIn usb1; public PowerIn usb2; public void givePower()&#123; System.out.println(&quot;电脑提供电源&quot;); usb1.receivePower(); usb2.receivePower(); &#125;&#125;class Light implements PowerIn&#123; public void receivePower()&#123; System.out.println(&quot;电灯接受电源&quot;); &#125;&#125; 16）面向对象——枚举(Enum)定义：枚举是一个特殊的类，其中包含了一组特定的对象，一般使用大写的的字母，这些对象不会发生改变。 123enum City&#123; BEIJING,SHANGHAI&#125; 枚举使用enum关键字使用。 枚举类的对象一般放在前面，如果还要写入别的语法那么应该用分号与后面的语法隔开。 枚举类不能创建对象，只能在内部使用 举个例子 1234567891011121314151617181920public class EnumTest &#123; public static void main(String[] args) &#123; System.out.print(City.SHANGHAI.name); System.out.println(City.SHANGHAI.code); System.out.print(City.BEIJING.name); System.out.println(City.BEIJING.code); &#125;&#125;enum City&#123; //相当于new一个对象,JVM完成 BEIJING(&quot;北京&quot;,1001),SHANGHAI(&quot;上海&quot;,1002); City(String name, int code)&#123; this.name = name; this.code = code; &#125; public String name; public int code;&#125; 17）面向对象——匿名类在某些场合下，类的名字不重要了，我们只是想使用类中的方法或功能，那么这个时候就需要用到特殊的语法：匿名类。 定义：没有名字的类，被称为匿名类 举个例子 1234567891011121314151617181920212223242526272829public class NoNameClass &#123; public static void main(String[] args) &#123; //创建了一个SayHello的对象me SayHello me = new SayHello(); //下面这种写法不需要再额外创建张三和李四的类，也就是我们创建了一个没有名字的类new person()&#123;&#125; me.sayHelloToPeople(new Person() &#123; //重写抽象方法具体化 public String name()&#123; return &quot;张三&quot;; &#125; &#125;); me.sayHelloToPeople(new Person() &#123; public String name()&#123; return &quot;李四&quot;; &#125; &#125;); &#125;&#125;abstract class Person&#123; //有抽象方法所以是抽象类 public abstract String name();&#125;class SayHello &#123; public void sayHelloToPeople(Person person) &#123; System.out.println(&quot;hello&quot; + person.name()); &#125;&#125; 接口也可以 12345678910111213//只关心你是怎么飞的，并没有考虑你是什么类，所以这里用匿名类。 new Fly() &#123; public void fly() &#123; System.out.println(&quot;使用飞行器飞行&quot;); &#125; &#125;.fly(); &#125;&#125;//接口是抽象的interface Fly&#123; public void fly();&#125; 18）面向对象——Bean规范 类要求必须含有无参的，公共的构造方法 属性必须私有化，然后提供公共的get，set方法 例子 1234567891011121314151617181920212223242526272829public class Movie &#123; private int id; private String name; private double price; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; &#125; 19）面向对象——作用域例子 12345678910111213141516171819202122package com.itheima.面相对象综合实例;public class ZuoYongYu &#123; public static void main(String[] args) &#123; User2 user2 = new User2(); user2.test(); &#125;&#125;class Person2&#123; &#125;class User2 extends Person2&#123; String name = &quot;lisi&quot;; public void test()&#123; //如果属性和(局部)变量名称相同，访问时不加修饰符，那么优先访问变量 String name = &quot;wangwu&quot;;//启动打印的是wangwu，如果注释掉这一行，那么打印的将会是lisi System.out.println(name); &#125;&#125; 第四章 常见类和对象1）常见类和对象——ObjectObject类的包路径：java.lang.Object Object对象的常用方法： 1234567891011121314151617181920212223242526272829303132333435package com.itheima.常见类和对象;public class ObjectClass &#123; public static void main(String[] args) &#123; Object obj = new Person(); //object对象的常用方法 // TODO toString()，将对象转换成字符串 String s = obj.toString(); System.out.println(s); // TODO 获取对象的内存地址 int i = obj.hashCode(); System.out.println(i); // TODO 判断两个对象是否相等，如果相等返回true，不相等返回flase // equals方法比较对象时，默认比较的是内存地址 Person person = new Person(); boolean equals1 = obj.equals(person); boolean equals2 = obj.equals(obj); System.out.println(equals1);//false System.out.println(equals2);//true //TODO getClass获取对象的类型信息 Class&lt;?&gt; currentClassName = obj.getClass(); System.out.println(currentClassName.getSimpleName()); &#125;&#125;class Person&#123;&#125;class user extends Person&#123;&#125; 2）常见类和对象——数组在Java中数组的声明方式：类型[] 变量名； 数组的创建：new 类型[容量]; 123456789101112131415//数组的声明String[] names;//数组的创建(创建了一个存储3个数据的names数组)String[] names = new String[3]//给数组赋值names[0] = &quot;lisi&quot;;names[1] = &quot;wangwu&quot;;//数组的访问System.out.println(names[0]);//打印lisiSystem.out.println(names[0]);//打印wangwu//也可以用循环访问数组for(int i;i&lt;names.length;i++)&#123; String j = names[i]; System.out.println(j);&#125;//循环执行完打印的是lisi，wangwu 如果需要一次创建多个对象可以用数组来完成 1234567//创建一个对象数组userUsers[] users = new Users[4];//利用for循环来生成该数组的对象for(int i ; i&lt;users.length;i++)&#123; //创建对象 users[i] = new Users();&#125; 3）常见类和对象——二维数组二维数组的定义 123456789//二维数组(可以简单理解为3X3的表格)String[][] names = new String[3][3];//二维数组的遍历for(int row= 0 ;row&lt;3;i++)&#123; for(int col =0; col &lt; 3; j++)&#123; System.out.print(names[row][col]); &#125; System.out.println(&quot; &quot;);&#125; 数组——应用冒泡排序1234567891011121314151617181920212223package com.itheima.常见类和对象;public class MaoPaoPaiXu &#123; // TODO 将一个数组的最大的数放在数组最后面 public static void main(String[] args) &#123; int[] nums = &#123;1,4,3,5，2&#125;; //注意不能索引到最后一个数，因为最后一个数的下一位没有数据 //左边和右边比较，我们先找出最大的数，让他放在数组最后一个元素位置 for(int i = 0;i&lt; nums.length-1;i++)&#123; int num1 =nums[i]; int num2 =nums[i+1]; if(num1&gt;num2)&#123; nums[i] = num2; nums[i+1] = num1; &#125; &#125; for (int num : nums) &#123; //打印结果为1,3,2,4,5 System.out.println(num); &#125; &#125; &#125; 上面这个只是找出了我们的最大的数放到了数组最后面，那么我们的冒泡排序的结果应该1,2,3,4,5所以稍加改动如下: 解析：那么在上面的基础上，我们每次把最大数放在后面不就可以了吗？也就是说第一次比较5个数，那么5最大放在后面，第二次比较4个数一定是4最大，我们把四放在四个数的最后面。依次类推，不就完成了吗？ 123456789101112131415161718192021222324252627//代码逻辑(冒泡排序)package com.itheima.常见类和对象;public class ErWeiShuZu &#123; // TODO 将一个数组的最大的数放在数组最后面 public static void main(String[] args) &#123; int[] nums = &#123;1,4,3,5，2&#125;; //注意不能索引到最后一个数，因为最后一个数的下一位没有数据 //左边和右边比较，我们先找出最大的数，让他放在数组最后一个元素位置 for (int i = 0; i &lt; nums.length; i++) &#123; //当i=0时，我们下面的循环就找5个数的大小，等于1就找4个数的大小..... for (int j = 0; j &lt; nums.length - i - 1; j++) &#123; int num1 = nums[j]; int num2 = nums[j + 1]; if (num1 &gt; num2) &#123; nums[j] = num2; nums[j + 1] = num1; &#125; &#125; &#125; for (int num : nums) &#123; System.out.println(num); &#125; &#125;&#125; 思路图解冒泡排序 选择排序12345678910111213141516171819202122232425 //选择排序int[] nums = &#123;1,4,3,5，2&#125;;//第一步：找到最大值的索引 for (int j = 0; j &lt; nums.length; j++) &#123; //将最大值索引定为0，因为0已经被用了所以下面的循环从1开始 int maxIndex = 0; for (int i = 1; i &lt; nums.length-j; i++) &#123; int num1 = nums[i];//4 3 2 5 int num2 =nums[maxIndex];//1 4 4 4 if (num1&gt;num2)&#123; //循环完成后我们的最大值索引就被找到了 maxIndex = i; &#125; &#125; //把最后一个数和我们的最大值索引对应的数进行交换就完成了将最大的数放在数组最后面 int num3 = nums[nums.length-j-1]; int num4 = nums[maxIndex]; nums[nums.length-j-1] = num4; nums[maxIndex] = num3; &#125;for (int num : nums) &#123; //打印的结果为1，2，3，4，5 System.out.println(num); &#125; 二分查找法* 前提：数据有序。 解释：二分查找法，又称折半查找（Binary Search），是一种在有序数组中高效查找特定元素的算法。其核心思想是通过将待查找区间反复减半来逼近目标值，直至找到目标或者确定目标不存在于数组中。以下是二分查找的基本步骤： 初始化: 确定查找区间的初始边界，通常是整个数组的开始索引（设为left）和结束索引（设为right），或者说是数组的第一个元素和最后一个元素的索引。 计算中间索引: 在每一轮查找中，计算当前查找区间中间元素的索引 mid = (left + right) / 2（实际应用中为防止整数溢出，通常写作 mid = left + (right - left) / 2）。 比较与分支: 如果数组中间元素array[mid]正好等于目标值，查找成功，返回中间元素的索引mid。 如果array[mid]小于目标值，则说明目标值位于中间元素右侧的子区间，因此更新查找区间为left = mid + 1。 如果array[mid]大于目标值，则目标值位于中间元素左侧的子区间，更新查找区间为right = mid - 1。 重复步骤2和3，直到left &gt; right，此时说明目标值不在数组中，查找失败。 二分查找的时间复杂度为O(log n)，其中n是数组中的元素数量。这是因为每次操作都将查找范围减半，因此大大减少了需要检查的元素数量，尤其是在处理大数据集时，这种算法的效率优势更为明显。但需要注意的是，二分查找的前提是数组必须是有序的，且通常适用于静态数据结构，因为对数组的插入和删除操作可能会破坏其有序性，从而增加维护成本。 1234567891011121314151617181920212223242526272829package com.itheima.常见类和对象;//演示的是二分法查找，前提是必须数组有序public class SelectPaiXu &#123; public static void main(String[] args) &#123; int nums[]=&#123;1,2,3,4,5,6,7&#125;; //定义查找的目标数 int targetNumber = 5; //定义开始的索引 int startIndex = 0; //定义中间值索引 int middle = 0; //定义结束索引 int endIndex = nums.length - 1; //查找中间值索引 while (startIndex &lt;=endIndex )&#123; middle= (startIndex+endIndex) / 2; if(nums[middle] &gt; targetNumber)&#123; endIndex = middle -1; &#125;else if(nums[middle]&lt;targetNumber)&#123; startIndex= middle+1; &#125;else &#123; break; &#125; &#125; //打印中间值索引 System.out.println(&quot;数据的位置是：&quot;+middle); &#125;&#125; 4）常见类和对象——包装类12345678Byte b = null;Short s = null;Integer i = null;Long lon = null;Float f = null;Double d = null;Character c = null;Boolean bln = null; 将基本数据类型转换为包装类12345678910111213141516package com.itheima.常见类和对象;public class BaoZhuangLei &#123; public static void main(String[] args) &#123; int i =1; //将基本数据类型转换为包装类型 Integer i1 = Integer.valueOf(i); //也可以写成,这个过程称为自动装箱 Integer i2 =i; //自动拆箱 int j = i1.intValue(); //也可以写成 int j1 = i1; &#125;&#125; 5）常见类和对象——日期和日历日期类: 1234567891011121314151617181920212223242526272829package com.itheima.常见类和对象;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class DateTest &#123; public static void main(String[] args) throws ParseException &#123; //Date :日期类 //Calendar :日历类 Date d = new Date(); System.out.println(d);// Java格式化日期格式: //y(Y)-&gt;年-&gt; yyyy //m(M)-&gt;MM:月份，mm:分钟 //d(D)-&gt;dd :一个月中的日期，D:一年中的日期 //h(H)-&gt;h:12进制，HH:24进制 //s(S)-&gt;s :秒,S:亳秘 //Date -&gt;String SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); String dateFormatString =sdf.format(d); System.out.println(dateFormatString); //string -&gt;Date String dateString=&quot;2022-06-01&quot;; Date parseDate = sdf.parse(dateString); System.out.println(parseDate); &#125;&#125; 日历类： 123456789//拿到日历的对象Calendar instance =Calendar.getInstance();//打印日历中的各种属性System.out.println(instance.get(Calendar.YEAR)); System.out.println(instance.get(Calendar.MONTH));System.out.println(instance.get(Calendar.DATE));//在日历中找到当前时间instance.setTime(new Date());instance.add(Calendar.YEAR,1); 6）常见类和对象——工具类 工具类不应该创建对象才能使用，也就意味着，可以直接使用类中的属性和方法，一般都声明为静态的。 工具类对外提供的属性和方法都应该是公共的。 为了使开发者方便，应该尽量提供丰富的方法和属性。 第五章 异常Java中的异常分为两大类： 可以通过代码恢复正常逻辑执行的异常，称之为运行期异常：RuntimeException 不可以通过代码恢复正常执行逻辑的异常，称之为编译异常： Exception 异常处理的语法： try：尝试(放的是可能会出现问题的代码) catch：捕捉，捕捉多个异常时，优先选择小的异常，然后将其抛出 finally：最终 12345678910try&#123; //可能会出现异常的代码 //如果出现异常那么JVM会将异常进行封装，形成一个具体的异常类然后将这个异常抛出&#125;catch(抛出的异常对象 对象引用)&#123; //异常的解决方案&#125;catch()&#123;&#125;finally()&#123; //最 终要执行的逻辑(不论异常处没处理)&#125; 异常的常见类型： 1234567891011121314151617// TODO 异常//1.除数为0的算术异常:java.lang.ArithmeticException//运行期异常int i = 0;if(i!=0)&#123; int j= 10 /i;&#125;//2:空指针异常:java.lang.NullPointerException，调用了一个成员对象或成员方法为空(null)对象的属性或方法时，就会发生异常User3 user = null;System.out.println(user.tostring());//3:索引越界，针对数组，字符串索引越界，针对字符串class User3 &#123; &#125; 如果方法中可能会出现问题，那么需要提前声明，告诉其他人，我的方法可能会出现问题。这时，我们需要使用throws关键字 12345678910111213public static void main(String args[]) throws ArithmeticException&#123; User user = new User(); int i =10; int j =0; user.test(i,j);&#125;class User8public void test(int i,int j) throws ArithmeticException &#123;System.out.println(i/j); &#125; 那么在运行期的异常，他不会抱任何问题，因为只要你的逻辑对了，代码就能继续运行，那么我们该如何让他出现提示，需要解决异常呢？下面这种方法，我们手动抛出异常对象，但是使用的是throw关键字，然后new出异常对象 12345678910111213141516public static void main(String args[]) throws Exception&#123; User user = new User(); int i =10; int j =0; user.test(i,j);&#125;class User8&#123; public void test(int i,int j) throws Exception &#123; try&#123; System.out.println(i/j); &#125;catch(ArithmeticException e) //这里演示手动抛出异常 throw new Exception(); &#125;&#125; （1）自定义异常看代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.itheima.Exception;public class ZiDingYiException &#123; public static void main(String[] args) throws Exception &#123; String username = &quot;admin&quot;; String password =&quot;admin&quot;; //对异常进行处理 try &#123; //可能出现异常的代码 loginSystem(username,password); &#125;catch (AccountException e)&#123; System.out.println(&quot;账号输入有误，请重新输入&quot;); &#125;catch (PasswordException e)&#123; System.out.println(&quot;密码输入有误，请重新输入&quot;); &#125; &#125; //如果下面是运行期异常(RuntimeException)这里可以不用抛出异常 //如果下面是编译期异常(Exception)，则需抛出异常 public static void loginSystem(String username,String password) throws AccountException,PasswordException&#123; if(!&quot;admin&quot;.equals(username))&#123; //创建异常对象 throw new AccountException(&quot;用户名不正确&quot;); &#125; if(!&quot;admin&quot;.equals(password))&#123; throw new PasswordException(&quot;密码不正确&quot;); &#125; System.out.println(&quot;登录成功&quot;); &#125;&#125;//账户异常class AccountException extends loginException&#123; public AccountException(String message) &#123; // 调用父类里面的方法，传入message参数，详细可以在代码中ctrl+左键点击查看 super(message); &#125;&#125;//密码异常class PasswordException extends loginException&#123; public PasswordException(String message)&#123; super(message); &#125;&#125;//自定义异常，如果这里继承运行期异常(RuntimeException)，那么上面就不需要抛出，如果是编译期异常(Exception),责需要抛出异常class loginException extends RuntimeException&#123; public loginException(String message)&#123; super(message); &#125;&#125; 第六章 Java中遇到的各种问题(1)Mybatis与java​ 在Mybatis和java联合编写xml文件时，有关Mapper.xml（编写SQL的）文件中，增删改查标签中，使用parameterType属性指定传递参数类，resultType属性指定返回结果类型，resultMap标签完成当数据库表字段和Java实体类属性名或类型不一致时的手动映射，另外，SQL文中，where条件中只有一个参数时，推荐使用基本类型（int，short，char，byte，float，double，long，boolean）+String，当有多个参数时，使用Java实体类，接下来，我们来讲讲具体的用法。来看示例： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--上面是文件头，下面是这个xml文件对应的mapper文件的路径--&gt;&lt;mapper namespace=&quot;com.ruoyi.publicController.mapper.proDetailMapper&quot;&gt; &lt;resultMap id=&quot;proDetailsResult&quot; type=&quot;proSelectDetails&quot;&gt; &lt;result property=&quot;proName&quot; column=&quot;pro_name&quot;/&gt; &lt;result property=&quot;profounder&quot; column=&quot;user_name&quot;/&gt; &lt;result property=&quot;proTrack&quot; column=&quot;pro_track&quot;/&gt; &lt;result property=&quot;proScore&quot; column=&quot;pro_score&quot;/&gt; &lt;/resultMap&gt; &lt;resultMap id=&quot;countResult&quot; type=&quot;proSelectDetails&quot;&gt; &lt;result property=&quot;countOne&quot; column=&quot;countOne&quot;/&gt; &lt;result property=&quot;countTwo&quot; column=&quot;countTwo&quot;/&gt; &lt;/resultMap&gt; &lt;!--查询总表所有项目信息--&gt; &lt;select id=&quot;selectAllInfo&quot; resultMap=&quot;proDetailsResult&quot; resultType=&quot;proSelectDetails&quot;&gt; &lt;include refid=&quot;selectProDetailsVo&quot;/&gt; &lt;/select&gt; &lt;sql id=&quot;selectProDetailsVo&quot;&gt; SELECT DISTINCT pro_details3.pro_id, pro_name, pro_details3.pro_score, user_name, pro_track FROM pro_details3 INNER JOIN judges_score ON judges_score.pro_id = pro_details3.pro_id INNER JOIN pro_coreteam ON pro_details3.pro_id = pro_coreteam.pro_id INNER JOIN sys_user ON sys_user.user_id = pro_coreteam.student_id &lt;/sql&gt;&lt;!--根据项目赛道查询项目信息--&gt;&lt;select id=&quot;selectProDetailsByProTrack&quot; resultMap=&quot;proDetailsResult&quot; resultType=&quot;proSelectDetails&quot;&gt; &lt;include refid=&quot;selectProDetailsVo&quot;/&gt; where pro_track = #&#123;proTrack&#125;&lt;/select&gt; 1.parameterType定义在增删改查标签中的属性，指定SQL文中where条件的参数类型，可以是基本数据类型（8个）或String或者对象类型例如，根据id查询name，如果数据库中定义的字段id是int类型，就可以指定parameterType的属性值是int，可以参看下边的代码。 1&lt; select id=&quot;queryPersonNameById&quot; parameterType=&quot;int&quot; resultType=&quot;String&quot;&gt;&lt;/select&gt; 2.resultType也是定义在增删改查标签中的属性，用于指定查询结果或增删改执行结果的类型，同样可以是基本数据类型+String+对象类型，这里需要注意的是，当查询结果是多条时，无需写List，MyBatis底层会自动为我们生成List&lt;数据类型&gt;，我们只需指定类型即可。同样是上边的例子，根据id查询name，name在数据库中是varchar类型，resultType就指定成String类型，类型不区分大小写，尽量保持和Java一致，使用大写。 1&lt; select id=&quot;queryPersonNameById&quot; parameterType=&quot;int&quot; resultType=&quot;String&quot;&gt;&lt;/select&gt; 3.resultMap当实体类的属性名和数据库表字段名或类型不一致时使用例如，Person表中，定义的字段是id和nameJava实体类中，定义的是pid和pname，这种情况下，使用resultMap手动完成数据库和Java实体类属性的映射。它是单独的&lt; resultMap&gt;标签，定义id(该属性是下面要用到的resultMap标签对应的值)，type（该属性指定了结果应该映射到的Java类的完全限定名或别名。）通常使用在查询标签中例如下边的代码id标签完成数据库主键的映射result标签完成数据库非主键字段的映射property属性指定java实体类中的属性名，column是数据库字段名 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;xxx.xxx.mapper.PersonMapper&quot;&gt; &lt;resultMap type=&quot;person&quot; id=&quot;personMapping&quot;&gt; &lt;id property=&quot;pid&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;pname&quot; column=&quot;name&quot;/&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;queryAllPersonUseResultMap&quot; resultMap=&quot;personMapping&quot;&gt; select * from person &lt;/select&gt;&lt;/mapper&gt; (2)增强for循环123for (元素类型 参数 : 集合名称) &#123; // 使用element(参数)&#125; 通常适配类型：它通常用于遍历数组或实现了Iterable接口的集合类（如ArrayList、HashSet等）。 增强for循环的优点： 使用增强型for循环的优点 简洁易读: 代码更简洁，不需要显式地处理索引。 减少错误: 避免了手动操作索引可能带来的错误，例如越界访问。 使用增强型for循环的限制 只读访问: 增强型for循环适用于只读访问集合中的元素，如果需要修改元素或需要索引值，则需要使用传统的for循环。 无法跳跃访问: 不能实现按特定步长跳跃访问元素，只能顺序遍历。","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://example.com/tags/Java%E5%AD%A6%E4%B9%A0/"}]},{"title":"记录Hadoop中HDFS命令统计词频错误","slug":"记录Hadoop中HDFS命令统计词频错误","date":"2024-03-30T10:07:41.000Z","updated":"2024-03-30T10:14:54.518Z","comments":true,"path":"2024/03/30/记录Hadoop中HDFS命令统计词频错误/","permalink":"http://example.com/2024/03/30/%E8%AE%B0%E5%BD%95Hadoop%E4%B8%ADHDFS%E5%91%BD%E4%BB%A4%E7%BB%9F%E8%AE%A1%E8%AF%8D%E9%A2%91%E9%94%99%E8%AF%AF/","excerpt":"","text":"关于这次错误我个人搭建了Hadoop集群，当词频统计这个案例的时候，我上传没问题但就是查看有问题，我点击查看文件时，报出了个这么一个错误 Couldn&#39;t preview the file. NetworkError: Failed to execute &#39;send&#39; on &#39;XMLHttpRequest&#39;:xxx 大概翻译就是:无法预览文件。NetworkError：无法在“XMLHttpRequest”上执行“send”： 百度了很多，很多人都在说是配置文件hdfs-site.xml文件中有个叫做 1234&lt;property&gt; &lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt; &lt;value&gt;true&lt;/value&gt;&lt;/property&gt; 这个的value值是false或者根本没有设置这一条属性，当然了，我属于后者，我的配置文件中并没有这项配置，但是我也照做了，然而在次启动后，依旧报同样的错误。 实际上解决方法就是在windows上修改文件: C:\\Windows\\System32\\drivers\\etc\\hosts增加内容（Hadoop集群中各节点及主机名的映射 以我为例: 192.168.121.160 主机名1 192.168.121.161 主机名2 192.168.121.161 主机名3 重启，完美解决成功出现统计的词和文件内容。","categories":[],"tags":[{"name":"Linux Error","slug":"Linux-Error","permalink":"http://example.com/tags/Linux-Error/"}]},{"title":"开发(基于ruoyiui)笔记","slug":"开发-基于ruoyiui-笔记","date":"2024-03-21T07:30:34.000Z","updated":"2024-06-10T06:28:54.242Z","comments":true,"path":"2024/03/21/开发-基于ruoyiui-笔记/","permalink":"http://example.com/2024/03/21/%E5%BC%80%E5%8F%91-%E5%9F%BA%E4%BA%8Eruoyiui-%E7%AC%94%E8%AE%B0/","excerpt":"","text":"问题（一）在查询时参数没有带入1234567891011121314151617181920212223242526272829*&lt;el-form-item label=&quot;项目赛道&quot; prop=&quot;proTrack&quot;&gt;*​ *&lt;el-select*​ *v-model=&quot;queryParams.proTrack&quot;*​ *placeholder=&quot;请选择项目赛道&quot;*​ *clearable*​ *@keyup.enter.native=&quot;handleQuery&quot;*​ *\\&gt;*​ *&lt;el-option v-for=&quot;item in proTrackList&quot;*​ *:key=&quot;item.key&quot;*​ *:label=&quot;item.proTrack&quot;*​ *:value=&quot;item.proTrack&quot;*​ *\\&gt;*​ *&lt;/el-option&gt;*​ *&lt;/el-select&gt;* *&lt;/el-form-item&gt;* 这是一段vue代码,我出现的问题是再前端页面查询的时候无法带入proTrack这个参数。 解决方法:因为我们proTrackList中没有value这个字段，导致我再绑定的时候:value&#x3D;”item.value”绑定出错，将value更换为proTrack成功在查询时候带入了参数proTrack 还有一种没有带入参数的情况就是，有些需要参数的函数，你可能没有传入函数或者定义接受函数的变量。那这时候我们就需要去定义这个函数对于变量的传与接。下面来举一个我的错误例子 先来看我原本的写法 123456789101112131415161718192021222324252627 //查询小组列表 selectGroup()&#123; this.loading=true; selectGroupList(this.queryParams).then(response =&gt;&#123;​ this.tableList = response.rows;​ this.total = response.total;​ this.loading=false; &#125;) &#125;, //赛道改变清空组列表 selectOnChangeTrack()&#123; this.tableList = []; this.selectGroup(this.Track); &#125;, 可以看selectOnChangeTrack这个函数里，我在调用 this.selectGroup(this.Track);时，我传入了参数this.Track，this.Track是选择框的数据，proTrack是查询参数。而我在上面的函数时，却没有接收传过来的参数this.Track ,在vue中，通常定义一个形参，在作为传来参数的载体，然后再将这个形参的值赋值给查询变量，这样就能完成参数的传递，改动如下 12345678910111213141516171819//查询小组列表selectGroup(tempdata)&#123; //将形参tempdata赋值给查询参数proTrack，这样在查询时就会携带proTrack这个参数. this.queryParams.proTrack = tempdata this.loading=true; selectGroupList(this.queryParams).then(response =&gt;&#123; this.tableList = response.rows; this.total = response.total; this.loading=false; &#125;)&#125;, 以上即是改正后的。改正后可以带入要传的参数了。 问题（二）数据库字段名称与后端java应该对应这是一段ruoyi对应的后端代码 123456789101112&lt;select id=&quot;selectRecommendationList&quot; parameterType=&quot;Recommendation&quot; resultMap=&quot;RecommendationResult&quot;&gt; &lt;include refid=&quot;selectRecommendationVo&quot;/&gt; &lt;where&gt; &lt;if test=&quot;time != null &quot;&gt; and pro_details3.time = #&#123;time&#125;&lt;/if&gt; &lt;if test=&quot;proName != null and proName != &#x27;&#x27;&quot;&gt; and pro_name like concat(&#x27;%&#x27;, #&#123;proName&#125;, &#x27;%&#x27;)&lt;/if&gt; &lt;if test=&quot;proScore != null &quot;&gt; and pro_score = #&#123;proScore&#125;&lt;/if&gt; &lt;if test=&quot;proGroup != null and proGroup != &#x27;&#x27;&quot;&gt; and pro_group = #&#123;proGroup&#125;&lt;/if&gt; &lt;if test=&quot;userName != null and userName != &#x27;&#x27;&quot;&gt; and user_name = #&#123;userName&#125;&lt;/if&gt; &lt;if test=&quot;deptName != null and deptName != &#x27;&#x27;&quot;&gt; and dept_name = #&#123;deptName&#125;&lt;/if&gt; &lt;if test=&quot;proTrack !=null and proTrack != &#x27;&#x27;&quot;&gt; and pro_track=#&#123;proTrack&#125;&lt;/if&gt; &lt;/where&gt;&lt;/select&gt; mybaits中数据查询mapper文件中，值得注意的是在and后的字段名称**(比如uesr_name,dept_name,pro_track,pro_group等等)**要和数据库中的字段对应而前面的proGroup是实体类中我们自己定义的属性。 不对应，就会报错 以下这段代码是同样的道理，请注意数据字段是column后面的而实体类是property后面的，数据库字段要和自己的数据库中的字段一致(完全一致) 123456789101112&lt;resultMap type=&quot;Recommendation&quot; id=&quot;RecommendationResult&quot;&gt; &lt;result property=&quot;proId&quot; column=&quot;pro_id&quot; /&gt; &lt;result property=&quot;proName&quot; column=&quot;pro_name&quot; /&gt; &lt;result property=&quot;proScore&quot; column=&quot;pro_score&quot; /&gt; &lt;result property=&quot;proGroup&quot; column=&quot;pro_group&quot; /&gt; &lt;result property=&quot;userName&quot; column=&quot;user_name&quot; /&gt; &lt;result property=&quot;deptName&quot; column=&quot;dept_name&quot; /&gt; &lt;result property=&quot;proTrack&quot; column=&quot;pro_track&quot;/&gt; &lt;result property=&quot;proGroupId&quot; column=&quot;pro_group_Id&quot;/&gt; &lt;result property=&quot;proGroupName&quot; column=&quot;pro_group_name&quot;/&gt; &lt;result property=&quot;time&quot; column=&quot;time&quot;/&gt;&lt;/resultMap&gt; 问题(三)对vue中v-for的理解在Vue的v-for循环中，:key、:label和:value是用于绑定循环中每个元素的属性的特殊语法。 :key用于指定循环中每个元素的唯一标识符。它是必需的，用于帮助Vue跟踪每个元素的身份，以便在更新DOM时进行高效的重用和重新排序。通常，你可以使用一个唯一的属性或索引作为key，确保在循环中的元素之间具有唯一性。 :label用于指定循环中每个选项的显示文本。它绑定了每个选项的显示值，这将在选择框中显示给用户。 :value&#96;用于指定循环中每个选项的实际值。它绑定了每个选项的实际值，当用户选择某个选项时，该值将被传递给绑定的数据模型。 这些特殊语法（:key、:label和:value）是Vue中用于在循环中绑定属性的常见约定，但你也可以根据需要选择其他属性名称。重要的是确保在循环中的每个元素都有唯一的标识符作为key，以及适当的属性用于label和value。这样可以确保循环中的每个元素都能正确地显示和处理。 问题（四）理解一段代码的含义(以获取学院名称列表为例)12345678910111213141516171819/**获取学院名称函数 */ getDeptNameList()&#123; this.loading = true; listRecommendation(this.queryParams).then(response =&gt; &#123;​ this.deptNameList = response.rows;​ console.log(this.deptNameList)​ this.total = response.total;​ this.loading = false;​ &#125;) &#125;, 下面对这段代码剖析： 1234567891011121314getDeptNameList() &#123; this.loading = true; *// 设置 loading 状态为 true，表示正在加载数据* *// 调用 listRecommendation 函数，并传递 this.queryParams 参数* listRecommendation(this.queryParams).then(response =&gt; &#123; this.deptNameList = response.rows; *// 将返回的学院名称列表赋值给 this.deptNameList* console.log(this.deptNameList); *// 打印学院名称列表到控制台* this.total = response.total; *// 设置总数为返回结果的总数* this.loading = false; *// 设置 loading 状态为 false，表示加载数据完成* &#125;); &#125;, 帮助理解 思路（一）选择框一限定选择框二的内容如果想实现两个选择框第一个选择框里面的所选择的内容可以改变第二个选择框里面的数据（比如选择了第一个框里面的2021年，那第二个选择框就会显示在2021里面有什么内容) 可以考虑使用@change&#x3D;””来绑定一个变化，只要第一个选择框里面的内容变了，那么就会执行@change绑定的事件比如 12345678910111213141516171819202122232425262728 //选择框一&lt;el-form-item label=&quot;选择赛事:&quot; prop=&quot;time&quot;&gt;​ &lt;el-select​ v-model=&quot;queryParams.time&quot;​ placeholder=&quot;请选择参赛时间&quot;​ clearable //表示是否可以清除选择框内容​ @change=&quot;handleSelectionChange1&quot;​ \\&gt;​ &lt;el-option v-for=&quot;dict in dict.type.events_year&quot; ​ :key=&quot;dict.key&quot; ​ :label=&quot;dict.value&quot; ​ :value=&quot;dict.value&quot;&gt;​ &lt;/el-option&gt;​ &lt;/el-select&gt; &lt;/el-form-item&gt; 123456789101112131415161718192021222324252627282930//选择框二el-form-item label=&quot;&quot; prop=&quot;selectCompetition&quot;&gt;​ &lt;el-select​ class=&quot;custom-select&quot;​ v-model=&quot;queryParams.selectCompetition&quot;​ placeholder=&quot;请选择赛事&quot;​ clearable​ @keyup.enter.native=&quot;handleQuery&quot; //回车​ \\&gt;​ &lt;el-option v-for=&quot; item in competitionList&quot; ​ :key=&quot;item.key&quot;​ :label=&quot;item.eventName&quot;​ :value=&quot;item.value&quot;&gt;​ &lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; 123456789101112//@change的所绑定事件的功能 handleSelectionChange1() &#123; this.queryParams.startTime = this.queryParams.time; // Update the query parameter this.queryParams.selectCompetition = null; // Clear the competition dropdown this.competitionList = []; // Clear the competition list this.getEventsList(); // Call the function to fetch the updated competition list&#125;, 问题（五）:在今天编写代码时候遇到了这么一个问题，就是关于添加数据前端页面他不给我显示。 查看发现是getfilename函数作怪，因为我的这个函数是要获取路径去分割，然而我并没有在数据库给出路径，所以这两个数据显示不出来，更改函数后成功显示，函数更改如下 12345678910111213 getfileName(path)&#123; if(path)&#123;​ return path.split(&#x27;/&#x27;).pop(); &#125;else&#123;​ return &quot;暂无资料&quot;; &#125; &#125;, 方法1:在数据库中呢，我删除一个数据，由于这个数据关联很多表，那就需要一同删除，这可以利用触发器，以下是我在该项目中写道的触发器123BEGIN DELETE FROM pro_coreteam WHERE pro_id = OLD.pro_id;END 该触发器是当我们根据项目id（pro_id）删除数据时，他会带着通过项目id关联的id里面的内容一同删除,删除的表名称、是pro_coreteam 4.2新添加了一个触发器代码如下 1234567891011DELIMITER //CREATE TRIGGER update_group_idAFTER INSERT ON pro_mapping_groupFOR EACH ROWBEGIN UPDATE pro_details3 SET pro_group_id = NEW.group_id WHERE pro_id = NEW.pro_id;END;//DELIMITER ; 解释 在这个触发器中，当在 pro_mapping_group 表中插入新的记录时，将会更新 pro_details3 表中对应 pro_id 的 pro_group_id 字段。这里假设 pro_mapping_group 表和 pro_details3 表通过 pro_id 字段关联。如果你的实际情况不同，请根据实际情况修改 WHERE 子句。 请注意，这个触发器只在插入新的记录时触发，如果你更新 pro_mapping_group 表中的 group_id 字段，这个触发器不会触发。如果你希望在更新 group_id 时也触发，你需要创建一个额外的 AFTER UPDATE 触发器 方法2:如何写一个对话框即点击按钮弹出对话框？1234567891011121314151617181920212223242526&lt;template&gt; &lt;!-- ... --&gt; &lt;el-button type=&quot;success&quot; @click=&quot;showDialog&quot;&gt;导入互联网+大赛官网（大创网）项目资料&lt;/el-button&gt; &lt;el-dialog title=&quot;导入互联网+大赛官网（大创网）项目资料&quot; :visible.sync=&quot;dialogVisible&quot; width=&quot;800px&quot; top=&quot;5vh&quot; append-to-body&gt; &lt;!-- 对话框内容 --&gt; &lt;!-- ... --&gt; &lt;/el-dialog&gt;&lt;/template&gt;&lt;script&gt;export default &#123; // ... data() &#123; return &#123; dialogVisible: false, // 对话框可见性 &#125;; &#125;, methods: &#123; showDialog() &#123; this.dialogVisible = true; // 点击按钮时显示对话框 &#125;, // 其他方法 // ... &#125;,&#125;;&lt;/script&gt; 方法3:如何在插入数据时携带其他参数新建你要插入的属性比如我下面的 12345@Excel(name = &quot;学生账号&quot;)private Long StuNumber;/** 学生id*/private Long userId; 在服务层写好定义的方法 1public int insertCore(ProCoreteam proCoreteam); 实现类中实现方法 12345@Overridepublic int insertCore(ProCoreteam proCoreteam)&#123; return proManagerMapper.insertCore(proCoreteam);&#125; 在mapper中定义方法 1public int insertCore(ProCoreteam proCoreteam); 在xml文件中使用方法 1234&lt;insert id=&quot;insertCore&quot; parameterType=&quot;ProCoreteam&quot; &gt; insert into pro_coreteam (pro_id,student_id) value (#&#123;proId&#125;,#&#123;studentId&#125;)&lt;/insert&gt; 同理按照以上步骤创建stuNumber的方法 123&lt;select id=&quot;selectstuIdBystuNumber&quot; parameterType=&quot;long&quot; resultMap=&quot;ProManagerResult&quot;&gt; select user_id from sys_user where phonenumber = #&#123;stuNumber&#125;&lt;/select&gt; 关键点在下面，我们要先获取插入完成以后的proid 1234567-- &lt;insert&gt;//获取插入完以后的proid &lt;selectKey resultType=&quot;Long&quot; keyProperty=&quot;proId&quot; order=&quot;AFTER&quot;&gt; select LAST_INSERT_ID() &lt;/selectKey&gt; &lt;/insert&gt; 1.最外层的&lt;insert&gt;&lt;/insert&gt;没有返回属性（resultType），但是里面的&lt;selectKey&gt;&lt;/selectKey&gt;是有返回值类型的。 2.order=&quot;AFTER&quot;表示先执行插入，之后才执行selectkey语句的。 3.select @@identity和select LAST_INSERT_ID()都表示选出刚刚插入的最后一条数据的id。 4.实体类中id属性字段一定需要set以及get方法 5.此时，接口中仍不需要有返回值，框架会自动将值注入到我们insert的那个对象中，我们可以直接使用就可以了。 其实，我们的接口中可以有返回值，但是这个返回值不是id,而是表示插入后影响的行数，此时sql中仍和上面一样，不需要写返回值。 1234567&lt;insert id=&quot;insertStudentCacheId&quot; parameterType=&quot;Student&quot;&gt; insert into student(name,age,score) values(#&#123;name&#125;,#&#123;age&#125;,#&#123;score&#125;) &lt;!-- 指定结果类型resultType，keyProperty是属性，自动返回到属性id中，order是次序，after是指获取id是在于插入后 --&gt; &lt;selectKey resultType=&quot;int&quot; keyProperty=&quot;id&quot; order=&quot;AFTER&quot;&gt; select @@identity &lt;/selectKey&gt;&lt;/insert&gt; 最最最核心的一步 12345678//执行完以后主键自增，获取到自增的proId所以要先执行proManagerMapper.insertProManager(proManager);//创建实体类ProManager的对象S存储通过学生账号获得stuidProManager S = proManagerMapper.selectstuIdBystuNumber(proManager.getStuNumber());//带参数的构建对象方法,上面已经获取到了proId和studentId所以下面创建ProCoreteam的对象p_core存储这两个idProCoreteam p_core=new ProCoreteam(proManager.getProId(),S.getUserId());//调用插入方法插入id，由于是个导入过程所以会在导入过程中执行以上内容自动插入，这样就携带了其他参数proManagerMapper.insertCore(p_core); 问题（六）基于ruoyiUI新建对话框的一些属性问题我们首先新建一个对话框，代码如下(我这个时ruoyiUI的对话框建法) 1&lt;el-dialog :title=&quot;title&quot; :visible.sync=&quot;open&quot; width=&quot;1500px&quot; append-to-body&gt; &lt;/el-dialog&gt; :title=&quot;title&quot;：此属性设置对话框的标题。title 应该是你的 Vue 实例的 data 属性之一，用来存放对话框的标题。: 前缀表示这是一个动态属性，它的值会被解析为 JavaScript 表达式。 :visible.sync=&quot;open&quot;：此属性控制对话框的可见性。如果 open 是 true，对话框就会显示；如果 open 是 false，对话框就会隐藏。.sync 修饰符表示这个属性是双向绑定的：当对话框的可见性改变时，open 的值也会相应地改变（对话框自带的×）。 width=&quot;1500px&quot;：此属性设置对话框的宽度。在这个例子中，对话框的宽度被设置为 1500 像素。 append-to-body：此属性表示对话框将被附加到 body 元素。这可以防止对话框被其他 CSS 影响，确保它能正确地显示在其他元素之上。这是一个布尔属性，如果存在，其值就是 true。 方法4: 如何获取当前行id？面对这个问题我只想说，这可真是让我想的酣畅淋漓的一次啊，为什么这么说？先来看看我犯了什么错误把首先，我当时一心只想着获取当前行id，但是却忽视了原表格是一个静态表格这个前提。所以我花了快一个小时，唉还好脑子转得快(快什么，要是快的话早想到了)突然意识到了，这是一个静态表格，我去哪里动态获取当前行？ 其次，因为脑子当时很热，一点思路也没有，所以就乱撞，白白荒废了时间。 接下来，让我来整理获取当前行id的一个思路 首先想，你要在哪一行操作，好的定位到这一行，要用&lt;template&gt;&lt;/template&gt;标签，具体写法如下: 1234567891011121314151617&lt;el-table-column prop=&quot;selectPro&quot; label=&quot;查看项目&quot; width=&quot;208&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button class=&quot;ebtn1&quot; style=&quot;color: white;&quot; @click=&quot;getAllocationList(scope.row.groupId)&quot; \\&gt;查看&lt;/el-button&gt; &lt;/template&gt;&lt;/el-table-column&gt; 比如我就是这一行要注意了，绑定点击事件的时候，必须加scope.row.xxxx其中的xxxx是你要获取的什么什么id，那么这样你就可以获取到当前行的id了 12345678910111213141516getAllocationList(groupId)&#123; console.log(groupId) this.loading = true; alreadyAllocation(groupId).then(response =&gt;&#123; this.alAllocationList = response.rows; this.total = response.total; this.loading=false; &#125;) &#125; 可以在你所用的时间console.log(groupId)你获取的id然后查看控制台有没有对应的id输出，然后传递参数就可以了。 你甚至还可以这么写 1234567891011121314151617getAllocationList(groupId)&#123; // 输出传入的 groupId console.log(groupId) // 创建一个新对象，包含 groupId const params = &#123;groupId&#125; this.loading = true; //传递参数 alreadyAllocation(params).then(response =&gt;&#123; this.alAllocationList = response.rows; this.total = response.total; this.loading=false; &#125;) &#125; 也是可以的，ok今天就写这么多0.0 问题7:在传入参数时的错误报错是这样对的 Error: nested exception is org.apache.ibatis.binding.BindingException: Parameter &#39;groupId&#39; not found. Available parameters are [arg1, arg0, param1, param2] 翻译一下就是 错误：嵌套异常是 org.apache.ibatis.binding.BindingException：找不到参数“groupId”。可用参数为 [arg1， arg0， param1， param2] 这是我传入参数的函数 12345678910111213141516171819202122232425262728getAllocationList(row)&#123; const proTrack = this.Track; const groupId=row.groupId; const groupName=row.groupName; this.loading = true; alreadyAllocation(groupId,proTrack).then(response =&gt;&#123;​ this.alAllocationList = response.data;​ // console.log(this.alAllocationList)​ this.sendArrayToParent(this.alAllocationList);​ this.sendArrayToParent2(groupName);​ // console.log(tableList);​ this.total = response.total;​ this.loading=false; &#125;) &#125; 这是js里面对应的接口 1234567891011export function alreadyAllocation(groupId,proTrack)&#123; return request(&#123;​ url: &#x27;/project/csxmfp/group/&#x27; + groupId +&#x27;/&#x27;+ proTrack,​ method: &#x27;get&#x27; &#125;)&#125; 报错问题是gruopId找不到，可用参数给出了[arg1, arg0, param1, param2] 这四个参数，这时我就在想，那是不是传入的参数得用这四个中的几个呢？于是我检查了后端，在处理器(proAllocationController)中打印了我从前端带过来的两个参数 123456789101112 /** * 通过赛道名称和小组获取参赛项目分配详细信息 */ @PreAuthorize(&quot;@ss.hasPermi(&#x27;project:csxmfp:querybygroupId&#x27;)&quot;) @GetMapping(value = &quot;group/&#123;groupId&#125;/&#123;trackName&#125;&quot;) public AjaxResult getInfoByGroupId(@PathVariable(&quot;groupId&quot;) Long groupId,@PathVariable(&quot;trackName&quot;) String trackName) &#123; System.out.println(groupId); System.out.println(&quot;aaaa&quot;+trackName); return success(proAllocationService.selectGroupProjectByGroupId(groupId,trackName)); &#125;&#125; 控制台输出 可以看到控制台是有groupId的输出1这就是说拿到了前端数据那为什么后端确说我没有定义呢？检查xml文件 12345678910111213141516171819&lt;select id=&quot;selectGroupProjectByGroupId&quot; parameterType=&quot;GroupProject&quot; resultMap=&quot;GroupProjectresultMap&quot;&gt; SELECT pro_details3.pro_id, pro_details3.pro_name, pro_details3.pro_logo, pro_details3.pro_track, pro_details3.pro_group_id FROM pro_details3 INNER JOIN pro_mapping_group ON pro_details3.pro_id = pro_mapping_group.pro_id &lt;where&gt; pro_mapping_group.group_id = #&#123;group_id&#125; &lt;if test=&quot;proTrack != &#x27;null&#x27; and proTrack != &#x27;&#x27; and arg1!= null&quot;&gt; and pro_details3.pro_track = #&#123;proTrack&#125;&lt;/if&gt; &lt;/where&gt; ORDER BY pro_details3.pro_id;&lt;/select&gt; 于是就想到会不会是参数的传递问题呢？于是我就尝试用arg0代替groupId，用age1代替了proTrack,下面是更新完xml文件 12345678910111213141516171819&lt;select id=&quot;selectGroupProjectByGroupId&quot; parameterType=&quot;GroupProject&quot; resultMap=&quot;GroupProjectresultMap&quot;&gt; SELECT pro_details3.pro_id, pro_details3.pro_name, pro_details3.pro_logo, pro_details3.pro_track, pro_details3.pro_group_id FROM pro_details3 INNER JOIN pro_mapping_group ON pro_details3.pro_id = pro_mapping_group.pro_id &lt;where&gt; pro_mapping_group.group_id = #&#123;arg0&#125; &lt;if test=&quot;arg1 != &#x27;null&#x27; and arg1 != &#x27;&#x27; and arg1!= null&quot;&gt; and pro_details3.pro_track = #&#123;arg1&#125;&lt;/if&gt; &lt;/where&gt; ORDER BY pro_details3.pro_id;&lt;/select&gt; 运行代码，成功传递了数据，问题解决了。你要是问我为什么这样做，其实我也不清楚，但是通过报错信息给出了可用的四个参数，所以说有错误还是要从报错信息入手啊 问题8：vue+ruoyi前端内网在线预览ppt在内网在线预览ppt时，我踩了很多坑，这里记录一下我都翻过什么错误。 错误一：在给数据模型里面的数据赋值时，没有搞清楚层级，来看代码这里，我定义了一个prevForm对象，里面有prev和url两个数据。然而在我进行赋值操作时错写成了this.prev &#x3D; xxxx，this.url&#x3D;xxxx，看似没错，但是实际上已经少写了一层了那就是丢了一个最大的对象prevForm正确写法是这样的 错误二：没有搞清楚&#x3D;，&#x3D;&#x3D;，&#x3D;&#x3D;&#x3D;这三个符号的意思，&#x3D;：意味着赋值操作，左边的值赋值给右边的，&#x3D;&#x3D;是比较运算符，当左右两边相等时返回true，不相等时返回false，而&#x3D;&#x3D;&#x3D;在前端中表示全等，意味着完全相等，意思就是在做运算判断时，等式两边的数值以及数据类型都必须相同。 在线预览ppt： 我完成这次任务主要使用了vue-office，官网：vue-office: 支持word(.docx)、excel(.xlsx)、pdf等各类型office文件预览的vue组件集合，提供一站式office文件预览方案，支持vue2和3 (gitee.com) 思路是，我在a标签中写了一个函数whatType用来判断这是一个以什么结尾的文件，这里用到了方法pop()取最后一个元素 来说一下在线预览ppt的模板： 第一步，确定你要在线预览文件的类型： 12345678//docx文档预览组件npm install @vue-office/docx vue-demi//excel文档预览组件npm install @vue-office/excel vue-demi//pdf文档预览组件npm install @vue-office/pdf vue-demi vue模板 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;vue-office-docx :src=&quot;docx&quot; @rendered=&quot;rendered&quot;/&gt; &lt;vue-office-excel :src=&quot;excel&quot; @rendered=&quot;rendered&quot;/&gt; &lt;vue-office-pdf :src=&quot;pdf&quot; @rendered=&quot;rendered&quot;/&gt;&lt;/template&gt;&lt;script&gt;//引入VueOfficeDocx组件import VueOfficeDocx from &#x27;@vue-office/docx&#x27;//引入VueOfficeExcel组件import VueOfficeExcel from &#x27;@vue-office/excel&#x27;//引入VueOfficePdf组件import VueOfficePdf from &#x27;@vue-office/pdf&#x27;//引入相关样式import &#x27;@vue-office/docx/lib/index.css&#x27;export default &#123; components:&#123; VueOfficeDocx &#125;, data()&#123; return &#123; docx: &#x27;http://static.shanhuxueyuan.com/test6.docx&#x27; //设置文档网络地址，可以是相对地址 excel： pdf: &#125; &#125;, methods:&#123; rendered()&#123; console.log(&quot;渲染完成&quot;) &#125; &#125;&#125;&lt;/script&gt; 一次性引入了三个，这样会渲染三个 最后，展示一下我写的点击弹出弹窗，来展示对应的内容，代码如下(只展示核心部分，多余代码省略)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;template&gt;......... &lt;el-table-column label=&quot;项目计划书&quot; align=&quot;center&quot; prop=&quot;proPlan&quot; &gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;a @click=&quot;whatType(scope.row.proPlan)&quot; v-if=&quot;getfileName(scope.row.proPt) !== &#x27;暂无资料&#x27;&quot;&gt; &#123;&#123; getfileName(scope.row.proPlan) &#125;&#125; &lt;/a&gt; &lt;a v-else&gt; &#123;&#123; getfileName(scope.row.proPlan) &#125;&#125; &lt;/a&gt; &lt;/template&gt;.......&lt;!--弹出各种文件预览弹窗--&gt;&lt;el-dialog :visible.sync=&quot;dialogPrevVisible&quot; title=&quot;文件预览&quot; width=&quot;90%&quot; &gt; &lt;el-form style=&quot;margin-top: 10px;&quot; :model=&quot;prevForm&quot;&gt; &lt;template v-if=&quot;prevForm.prev == &#x27;docx&#x27;&quot;&gt; &lt;vue-office-docx style=&quot;height: 90%&quot; :src=&quot;prevForm.url&quot; @rendered=&quot;rendered&quot;/&gt; &lt;/template&gt; &lt;template v-if=&quot;prevForm.prev == &#x27;xlsx&#x27;&quot;&gt; &lt;vue-office-excel style=&quot;height: 90%&quot; :src=&quot;prevForm.url&quot; @rendered=&quot;rendered&quot; /&gt; &lt;/template&gt; &lt;template v-if=&quot;prevForm.prev == &#x27;pdf&#x27;&quot;&gt; &lt;vue-office-pdf style=&quot;height: 90%&quot; :src=&quot;prevForm.url&quot; @rendered=&quot;rendered&quot;/&gt; &lt;/template&gt; &lt;/el-form&gt; &lt;/el-dialog&gt;......&lt;/template&gt;&lt;script&gt;//引入VueOfficeDocx组件import VueOfficeDocx from &#x27;@vue-office/docx&#x27;;import VueOfficeExcel from &#x27;@vue-office/excel&#x27;;import VueOfficePdf from &#x27;@vue-office/pdf&#x27;;//引入相关样式import &#x27;@vue-office/docx/lib/index.css&#x27;;data() &#123; return &#123; //设置弹窗初始状态 dialogPrevVisible:false, prevForm:&#123; prev:&#x27;&#x27;, url:&#x27;&#x27; &#125;,.....&#125;methods: &#123; //判断路径的类型 whatType(path)&#123; //获取文件拓展名并改为小写 var tempPath = path; console.log(tempPath); //pop函数取最后一个元素，然后在转成小写。 var fileType = path.split(&#x27;.&#x27;).pop().toLowerCase(); console.log(fileType); if(fileType == &#x27;docx&#x27;)&#123; this.prevForm.prev = &#x27;docx&#x27;, this.prevForm.url=&#x27;http://192.168.1.104/dev-api&#x27;+ tempPath this.dialogPrevVisible = true; &#125;else if(fileType == &#x27;excel&#x27;)&#123; this.prevForm.prev = &#x27;excel&#x27;, this.prevForm.url=&#x27;http://192.168.1.104/dev-api&#x27;+ tempPath this.dialogPrevVisible = true; &#125;else if(fileType ==&#x27;pdf&#x27;)&#123; this.prevForm.prev = &#x27;pdf&#x27;, this.prevForm.url=&#x27;http://192.168.1.104/dev-api&#x27;+ tempPath this.dialogPrevVisible = true; &#125;else&#123; window.alert(&quot;不支持查看该文件格式&quot;) &#125; &#125;, rendered()&#123; console.log(&quot;渲染完成&quot;) &#125;, &#125;&lt;/script&gt; Vue中v-model数据绑定问题(绑定对象) 在vue中，选择框中如果需要传递多个值到后端进行带参数的查询，这时，我们就应该将这两个值，绑定在一个对象上，那么关于如何绑定到对象以及进行参数的传递，下面是我的理解： 示例代码： &lt;el-form :model=&quot;queryParams&quot;&gt; &lt;el-form-item label=&quot;请选择赛事：&quot; prop=&quot;proGameId&quot;&gt; &lt;el-select v-model=&quot;this.selectedOption&quot; placeholder=&quot;请选择下拉选择&quot; clearable :style=&quot;&#123;width: &#39;100%&#39;&#125;&quot; @change=&quot;getList2&quot;&gt; &lt;el-option v-for=&quot;(item, index) in EventList&quot; :key=&quot;index&quot; :label=&quot;`$&#123;item.proGame&#125;——$&#123;item.groupName&#125;`&quot; :value=&quot;&#123; proGameId: item.proGameId, groupId: item.groupId &#125;&quot; :disabled=&quot;item.disabled&quot;&gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; 解释：**:label&#x3D;”$&#123;item.proGame&#125;——$&#123;item.groupName&#125;“**绑定成这样的label，在我们的选择框中就会是下面的样式 **:value&#x3D;”{ proGameId: item.proGameId, groupId: item.groupId }”**通过这样的绑定，想要将proGameId和groupId同时绑定到该选择框中，那么首先v-model的绑定应该是一个对象 并且在对象中，还必须包含你所绑定的这两个属性值，初始化为null。(初始化为空的原因是对象初始化就是空对象)，如下图 这样，就完成了数据在选择框层面的绑定。那么如何传递这两个数据呢？比如我今天就遇到这样的问题，从后端查询到这两个的值，同时也需要把查询到的值 ，再绑定到选择框中，当选择框的内的选项一改变就会传递这两个对象的值到后端再进行一次查询。 首先要做的就是绑定@change事件，比如我上面代码中的 然后 这样就成功把值带到查询参数里面，就可以在次传递给后端进行查询啦。 最后，如果在调用函数getList2的时候我并没有指定参数，那么在方法中的getList2(value)中，这个value就指的是:value所绑定的内容。也就是用户选择的值","categories":[],"tags":[{"name":"java和vue开发中遇到的错误以及如何改正和对他们的理解整理(参加的项目)","slug":"java和vue开发中遇到的错误以及如何改正和对他们的理解整理-参加的项目","permalink":"http://example.com/tags/java%E5%92%8Cvue%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E6%94%B9%E6%AD%A3%E5%92%8C%E5%AF%B9%E4%BB%96%E4%BB%AC%E7%9A%84%E7%90%86%E8%A7%A3%E6%95%B4%E7%90%86-%E5%8F%82%E5%8A%A0%E7%9A%84%E9%A1%B9%E7%9B%AE/"}]},{"title":"SpingCloud学习","slug":"SpingCloud学习","date":"2023-12-10T02:04:18.000Z","updated":"2024-03-06T12:42:59.377Z","comments":true,"path":"2023/12/10/SpingCloud学习/","permalink":"http://example.com/2023/12/10/SpingCloud%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"1. 系统架构演变概述目标：了解项目架构的演变历程 小结： 12345graph LR;1[集中式架构] --&gt; 2[垂直拆分]2 --&gt; 3[分布式服务]3 --&gt; 4[SOA面向服务架构]4 --&gt; 5[微服务架构] 2. 微服务架构说明目标：了解SOA与微服务架构的区别以及说出微服务架构的特点 分析： SOA使用了ESB组件的面向服务架构：ESB自身实现复杂；应用服务粒度较大，所有服务之间的通信都经过ESB会降低通信速度；部署、测试ESB比较麻烦。 小结： 微服务架构：是一套使用小服务或者单一业务来开发单个应用的方式或途径。 微服务架构特点： 单一职责 服务粒度小 面向服务（对外暴露REST api） 服务之间相互独立 与使用ESB的SOA架构的区别：微服务架构没有使用ESB，有服务治理注册中心；业务粒度小。 3. 服务调用方式说明目标：能够说出服务调用方式种类 小结： RPC：基于socket，速度快，效率高；webservice、dubbo HTTP：基于TCP，封装比较臃肿；对服务和调用方没有任何技术、语言的限定，自由灵活；RESTful，Spring Cloud 4. Spring RestTemplate示例工程导入目标：了解Spring RestTemplate的应用 分析： 一般情况下有如下三种http客户端工具类包都可以方便的进行http服务调用： httpClient okHttp JDK原生URLConnection spring 提供了RestTemplate的工具类对上述的3种http客户端工具类进行了封装，可在spring项目中使用RestTemplate进行服务调用。 小结： 12345678910111213141516@RunWith(SpringRunner.class)@SpringBootTestpublic class RestTemplateTest &#123; @Autowired private RestTemplate restTemplate; @Test public void test()&#123; String url = &quot;http://localhost/user/8&quot;; //restTemplate可以对json格式字符串进行反序列化 User user = restTemplate.getForObject(url, User.class); System.out.println(user); &#125;&#125; 5. Spring Cloud概述目标：Spring Cloud整合的组件和版本特征 小结： 整合的组件可以有很多组件；常见的组件有：eureka注册中心，Gateway网关，Ribbon负载均衡，Feign服务调用，Hystrix熔断器。在有需要的时候项目添加对于的启动器依赖即可。 版本特征：以英文单词命名（伦敦地铁站名） 6. 创建微服务工程目标：创建微服务父工程heima-springcloud、用户服务工程user-service、服务消费工程consumer-demo 分析： 需求：查询数据库中的用户数据并输出到浏览器 父工程heima-springcloud：添加spring boot父坐标和管理其它组件的依赖 用户服务工程user-service：整合mybatis查询数据库中用户数据；提供查询用户服务 服务消费工程consumer-demo：利用查询用户服务获取用户数据并输出到浏览器 小结： 123456789&lt;!-- springCloud --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt; 通过 scope 的import可以继承 spring-cloud-dependencies 工程中的依赖 7. 搭建配置user-service工程目标：配置user-service工程并能够根据用户id查询数据库中用户 分析： 需求：可以访问http://localhost:9091/user/8输出用户数据 实现步骤： 添加启动器依赖（web、通用Mapper）； 创建启动引导类和配置文件； 修改配置文件中的参数； 编写测试代码（UserMapper，UserService，UserController）； 测试 小结： 添加启动器依赖 123456789101112131415161718&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 通用Mapper启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写配置文件 123456789101112server: port: 9091spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/springcloud username: root password: rootmybatis: type-aliases-package: com.itheima.user.pojo 8. 搭建配置consumer-demo工程目标：编写测试类使用restTemplate访问user-service的路径根据id查询用户 分析： 需求：访问http://localhost:8080/consumer/8 使用RestTemplate获取http://localhost:9091/user/8的数据 实现步骤： 添加启动器依赖； 创建启动引导类（注册RestTemplate）和配置文件； 编写测试代码（ConsumerController中使用restTemplate访问服务获取数据） 测试 小结： 服务管理如何自动注册和发现如何实现状态监管如何实现动态路由 服务如何实现负载均衡 服务如何解决容灾问题 服务如何实现统一配置 上述的问题都可以通过Spring Cloud的各种组件解决。 9. Eureka注册中心说明目标：说出Eureka的主要功能 小结： Eureka的主要功能是进行服务管理，定期检查服务状态，返回服务地址列表。 10. 搭建eureka-server工程目标：添加eureka对应依赖和编写引导类搭建eureka服务并可访问eureka服务界面 分析： Eureka是服务注册中心，只做服务注册；自身并不提供服务也不消费服务。可以搭建web工程使用Eureka，可以使用Spring Boot方式搭建。 搭建步骤： 创建工程； 添加启动器依赖； 编写启动引导类（添加Eureka的服务注解）和配置文件； 修改配置文件（端口，应用名称…）； 启动测试 小结： 启动器依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件 1234567891011121314server: port: 10086spring: application: name: eureka-servereureka: client: service-url: # eureka 服务地址，如果是集群的话；需要指定其它集群eureka地址 defaultZone: http://127.0.0.1:10086/eureka # 不注册自己 register-with-eureka: false # 不拉取服务 fetch-registry: false 11. 服务注册与发现目标：将user-service的服务注册到eureka并在consumer-demo中可以根据服务名称调用 分析： 服务注册：在服务提供工程user-service上添加Eureka客户端依赖；自动将服务注册到EurekaServer服务地址列表。 添加依赖； 改造启动引导类；添加开启Eureka客户端发现的注解； 修改配置文件；设置Eureka 服务地址 服务发现：在服务消费工程consumer-demo上添加Eureka客户端依赖；可以使用工具类根据服务名称获取对应的服务地址列表。 添加依赖； 改造启动引导类；添加开启Eureka客户端发现的注解； 修改配置文件；设置Eureka 服务地址； 改造处理器类ConsumerController，可以使用工具类DiscoveryClient根据服务名称获取对应服务地址列表。 小结： 添加Eureka客户端依赖； 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 添加启动引导类注解； 修改配置 1234567spring: application: name: consumer-demoeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka 12. Eureka Server高可用配置目标：可以启动两台eureka-server实例；在eureka管理界面看到两个实例 分析： Eureka Server是一个web应用，可以启动多个实例（配置不同端口）保证Eureka Server的高可用。 小结： 高可用配置：将Eureka Server作为一个服务注册到其它Eureka Server，这样多个Eureka Server之间就能够互相发现对方，同步服务，实现Eureka Server集群。 13. Eureka客户端与服务端配置目标：配置eureka客户端user-service的注册、续约等配置项，配置eureka客户端consumer-demo的获取服务间隔时间；了解失效剔除和自我保护 分析： Eureka客户端工程 user-service 服务提供 服务地址使用ip方式 续约 consumer-demo 服务消费 获取服务地址的频率 Eureka服务端工程 eureka-server 失效剔除 自我保护 小结： user-service 12345678910111213eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: # 更倾向使用ip地址，而不是host名 prefer-ip-address: true # ip地址 ip-address: 127.0.0.1 # 续约间隔，默认30秒 lease-renewal-interval-in-seconds: 5 # 服务失效时间，默认90秒 lease-expiration-duration-in-seconds: 5 consumer-demo 123456eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka # 获取服务地址列表间隔时间，默认30秒 registry-fetch-interval-seconds: 10 eureka-server 123456eureka: server: # 服务失效剔除时间间隔，默认60秒 eviction-interval-timer-in-ms: 60000 # 关闭自我保护模式（默认是打开的） enable-self-preservation: false 14. 负载均衡Ribbon简介目标：描述负载均衡和ribbon的作用 分析： 负载均衡是一个算法，可以通过该算法实现从地址列表中获取一个地址进行服务调用。 在Spring Cloud中提供了负载均衡器：Ribbon 小结： Ribbon提供了轮询、随机两种负载均衡算法（默认是轮询）可以实现从地址列表中使用负载均衡算法获取地址进行服务调用。 15. Ribbon负载均衡应用目标：配置启动两个用户服务，在consumer-demo中使用服务名实现根据用户id获取用户 分析： 需求：可以使用RestTemplate访问http://user-service/user/8获取服务数据。 可以使用Ribbon负载均衡：在执行RestTemplate发送服务地址请求的时候，使用负载均衡拦截器拦截，根据服务名获取服务地址列表，使用Ribbon负载均衡算法从服务地址列表中选择一个服务地址，访问该地址获取服务数据。 实现步骤： 启动多个user-service实例（9091,9092）； 修改RestTemplate实例化方法，添加负载均衡注解； 修改ConsumerController； 测试 小结： 在实例化RestTemplate的时候使用@LoadBalanced，服务地址直接可以使用服务名。 16. 熔断器Hystrix简介目标：了解熔断器Hystrix的作用 小结： Hystrix是一个延迟和容错库，用于隔离访问远程服务，防止出现级联失败。 17. 线程隔离&amp;服务降级目标：了解什么是线程隔离和服务降级 分析： Hystrix解决雪崩效应： 线程隔离：用户请求不直接访问服务，而是使用线程池中空闲的线程访问服务，加速失败判断时间。 服务降级：及时返回服务调用失败的结果，让线程不因为等待服务而阻塞。 小结： 添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 开启熔断 降级逻辑 12345678910111213141516171819202122232425262728293031323334353637@RestController@RequestMapping(&quot;/consumer&quot;)@Slf4j@DefaultProperties(defaultFallback = &quot;defaultFallback&quot;)public class ConsumerController &#123; @Autowired private RestTemplate restTemplate; @Autowired private DiscoveryClient discoveryClient; @GetMapping(&quot;/&#123;id&#125;&quot;) //@HystrixCommand(fallbackMethod = &quot;queryByIdFallback&quot;) @HystrixCommand public String queryById(@PathVariable Long id)&#123; /*String url = &quot;http://localhost:9091/user/&quot;+id; //获取eureka中注册的user-service的实例 List&lt;ServiceInstance&gt; serviceInstances = discoveryClient.getInstances(&quot;user-service&quot;); ServiceInstance serviceInstance = serviceInstances.get(0); url = &quot;http://&quot; + serviceInstance.getHost() + &quot;:&quot; + serviceInstance.getPort() + &quot;/user/&quot; + id;*/ String url = &quot;http://user-service/user/&quot; + id; return restTemplate.getForObject(url, String.class); &#125; public String queryByIdFallback(Long id)&#123; log.error(&quot;查询用户信息失败。id：&#123;&#125;&quot;, id); return &quot;对不起，网络太拥挤了！&quot;; &#125; public String defaultFallback()&#123; return &quot;默认提示：对不起，网络太拥挤了！&quot;; &#125;&#125; 修改超时配置 1234567hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 2000 18. 服务熔断演示目标：了解熔断器工作原理 小结： 可以通过配置服务熔断参数修改默认： 1234567891011hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 2000 circuitBreaker: errorThresholdPercentage: 50 # 触发熔断错误比例阈值，默认值50% sleepWindowInMilliseconds: 10000 # 熔断后休眠时长，默认值5秒 requestVolumeThreshold: 10 # 熔断触发最小请求次数，默认值是20 SpringCloud第二天1. Feign应用目标：Feign的作用；使用Feign实现consumer-demo代码中调用服务 分析： 导入启动器依赖； 开启Feign功能； 编写Feign客户端； 编写一个处理器ConsumerFeignController，注入Feign客户端并使用； 测试 小结： Feign主要作用：自动根据参数拼接http请求地址。 启动器依赖； 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; Feign客户端： 123456789//声明当前类是一个Feign客户端，指定服务名为user-service@FeignClient(&quot;user-service&quot;)public interface UserClient &#123; //http://user-service/user/123 @GetMapping(&quot;/user/&#123;id&#125;&quot;) User queryById(@PathVariable Long id);&#125; 2. Feign负载均衡及熔断目标：可以配置Feign内置ribbon配置项和Hystrix熔断的Fallback配置 分析： 负载均衡 服务熔断 请求压缩 日志级别 都可以通过配置项在Feign中开启使用。 小结： 在服务消费工程consumer-demo中的配置文件： 12345678910111213141516171819ribbon: ConnectTimeout: 1000 # 连接超时时长 ReadTimeout: 2000 # 数据通信超时时长 MaxAutoRetries: 0 # 当前服务器的重试次数 MaxAutoRetriesNextServer: 0 # 重试多少次服务 OkToRetryOnAllOperations: false # 是否对所有的请求方式都重试feign: hystrix: enabled: true # 开启Feign的熔断功能 compression: request: enabled: true # 开启请求压缩 mime-types: text/html,application/xml,application/json # 设置压缩的数据类型 min-request-size: 2048 # 设置触发压缩的大小下限 response: enabled: truelogging: level: com.itheima: debug 3. Spring Cloud Gateway网关简介目标：Spring Cloud Gateway网关的作用 小结： Spring Cloud Gateway的核心就是一系列的过滤器，可以将客户端的请求转发到不同的微服务。主要作用：过滤和路由。 4. Spring Cloud Gateway入门目标：搭建网关服务工程测试网关服务作用 分析： 需求：通过网关系统heima-gateway将包含有 &#x2F;user 的请求 路由到 http://127.0.0.1:9091/user/用户id 实现步骤： 创建工程； 添加启动器依赖； 编写启动引导类和配置文件； 修改配置文件，设置路由信息； 启动测试 http://127.0.0.1:10010/user/8 –&gt; http://127.0.0.1:9091/user/8 小结： 启动器依赖 1234567891011&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置文件 12345678910111213141516171819202122server: port: 10010spring: application: name: api-gateway cloud: gateway: routes: # 路由id，可以任意 - id: user-service-route # 代理的服务地址 uri: http://127.0.0.1:9091 # 路由断言： 可以匹配映射路径 predicates: - Path=/user/**eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true 5. 面向服务的路由目标：使用在eureka注册的服务作为路由地址 分析： 如果将路由服务地址写死明显是不合理的；在Spring Cloud Gateway中可以通过配置动态路由解决。 小结： 面向服务的路由；只需要在配置文件中指定路由路径类似： lb://user-service lb 之后编写的服务名必须要在eureka中注册才能使用 6. 路由前缀处理目标：可以对请求到网关服务的地址添加或去除前缀 分析： 提供服务的地址：http://127.0.0.1:9091/user/8 添加前缀：对请求地址添加前缀路径之后再作为代理的服务地址； http://127.0.0.1:10010/8 –&gt; http://127.0.0.1:9091/user/8 添加前缀路径&#x2F;user 去除前缀：将请求地址中路径去除一些前缀路径之后再作为代理的服务地址； http://127.0.0.1:10010/api/user/8 –&gt; http://127.0.0.1:9091/user/8 去除前缀路径&#x2F;api 小结： 客户端的请求地址与微服务的服务地址如果不一致的时候，可以通过配置路径过滤器实现路径前缀的添加和去除。 7. 过滤器简介目标：Gateway默认过滤器的用法和过滤器类型 小结： 用法：在配置文件中指定要使用的过滤器名称； 类型：局部、全局； 使用场景：请求鉴权、异常处理、记录调用时长等。 8. 自定义局部过滤器目标：按照默认过滤器编写并配置一个自定义局部过滤器，该过滤器可以通过配置文件中的参数名称获取请求的参数值 分析： 需求：在过滤器（MyParamGatewayFilterFactory）中将http://localhost:10010/api/user/8?name=itcast中的参数name的值获取到并输出到控制台；并且参数名是可变的，也就是不一定每次都是name；需要可以通过配置过滤器的时候做到配置参数名。 实现步骤： 配置过滤器； 编写过滤器； 测试 小结： 配置；与其他过滤器的配置一致。 实现过滤器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.itheima.gateway.filter;import org.springframework.cloud.gateway.filter.GatewayFilter;import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;import org.springframework.http.server.reactive.ServerHttpRequest;import org.springframework.stereotype.Component;import java.util.Arrays;import java.util.List;@Componentpublic class MyParamGatewayFilterFactory extends AbstractGatewayFilterFactory&lt;MyParamGatewayFilterFactory.Config&gt; &#123; static final String PARAM_NAME = &quot;param&quot;; public MyParamGatewayFilterFactory() &#123; super(Config.class); &#125; public List&lt;String&gt; shortcutFieldOrder() &#123; return Arrays.asList(PARAM_NAME); &#125; @Override public GatewayFilter apply(Config config) &#123; return (exchange, chain) -&gt; &#123; // http://localhost:10010/api/user/8?name=itcast config.param ==&gt; name //获取请求参数中param对应的参数名 的参数值 ServerHttpRequest request = exchange.getRequest(); if(request.getQueryParams().containsKey(config.param))&#123; request.getQueryParams().get(config.param). forEach(value -&gt; System.out.printf(&quot;------------局部过滤器--------%s = %s------&quot;, config.param, value)); &#125; return chain.filter(exchange); &#125;; &#125; public static class Config&#123; //对应在配置过滤器的时候指定的参数名 private String param; public String getParam() &#123; return param; &#125; public void setParam(String param) &#123; this.param = param; &#125; &#125;&#125; 9. 自定义全局过滤器目标：定义一个全局过滤器检查请求中是否携带有token参数 分析： 需求：编写全局过滤器，在过滤器中检查请求地址是否携带token参数。如果token参数的值存在则放行；如果token的参数值为空或者不存在则设置返回的状态码为：未授权也不再执行下去。 实现步骤： 编写全局过滤器； 测试 小结： 123456789101112131415161718192021@Componentpublic class MyGlobalFilter implements GlobalFilter, Ordered &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; System.out.println(&quot;--------------全局过滤器MyGlobalFilter------------------&quot;); String token = exchange.getRequest().getQueryParams().getFirst(&quot;token&quot;); if(StringUtils.isBlank(token))&#123; //设置响应状态码为未授权 exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED); return exchange.getResponse().setComplete(); &#125; return chain.filter(exchange); &#125; @Override public int getOrder() &#123; //值越小越先执行 return 1; &#125;&#125; 10. Gateway其它配置说明目标：Gateway网关的负载均衡和熔断参数配置 小结： 网关服务配置文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455server: port: 10010spring: application: name: api-gateway cloud: gateway: routes: # 路由id，可以任意 - id: user-service-route # 代理的服务地址 #uri: http://127.0.0.1:9091 # lb表示从eureka中获取具体服务 uri: lb://user-service # 路由断言： 可以匹配映射路径 predicates: #- Path=/user/** #- Path=/** - Path=/api/user/** filters: # 添加请求路径的前缀 #- PrefixPath=/user #1表示过滤1个路径，2表示两个路径，以此类推 - StripPrefix=1 - MyParam=name # 默认过滤器，对所有路由都生效 default-filters: - AddResponseHeader=X-Response-Foo, Bar - AddResponseHeader=abc-myname,heima globalcors: corsConfigurations: &#x27;[/**]&#x27;: #allowedOrigins: * # 这种写法或者下面的都可以，*表示全部 allowedOrigins: - &quot;http://docs.spring.io&quot; allowedMethods: - GETeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: truehystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 6000ribbon: ConnectTimeout: 1000 ReadTimeout: 2000 MaxAutoRetries: 0 MaxAutoRetriesNextServer: 0 Gateway网关一般直接给终端请求使用；Feign一般用在微服务之间调用。 11. Spring Cloud Config分布式配置中心简介目标：分布式配置中心的作用 小结： spring cloud config作用：可以通过修改在git仓库中的配置文件实现其它所有微服务的配置文件的修改。 12. 搭建配置中心微服务目标：创建码云的远程公开git仓库，搭建配置中心微服务config-server 分析： 创建git仓库：在码云上创建仓库 搭建配置中心config-server：使用spring boot方式搭建和配置 小结： 配置中心依赖 1234567891011&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置中心的配置文件 1234567891011121314server: port: 12000spring: application: name: config-server cloud: config: server: git: uri: https://gitee.com/goheima/heima-config.giteureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka 在gitee中修改了配置文件会在配置中心服务及时更新。 13. 获取配置中心配置目标：改造用户微服务user-service，配置文件信息不再由微服务项目提供，而是从配置中心获取 分析： 需求：将服务提供工程user-service的application.yml配置文件删除，修改为从配置中心config-server中获取。 实现步骤： 添加启动器依赖； 修改配置文件； 启动测试 小结： 将原来的application.yml删除；然后添加bootstrap.yml配置文件，该文件也是spring boot的默认配置文件，其内容经常配置一些项目中固定的配置项。如果是项目经常变动的应该配置到application.yml中，现在使用了配置中心则应该配置到git仓库中对于的配置文件。 依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置文件bootstrap.yml 12345678910111213141516171819spring: cloud: config: # 要与仓库中的配置文件的application保持一致 name: user # 要与仓库中的配置文件的profile保持一致 profile: dev # 要与仓库中的配置文件所属的版本（分支）一样 label: master discovery: # 使用配置中心 enabled: true # 配置中心服务名 service-id: config-servereureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka 14. Spring Cloud Bus简介目标：了解Spring Cloud Bus作用 小结： Spring Cloud Bus作用：将git仓库的配置文件更新，在不重启系统的情况下实现及时同步到各个微服务。 15. Spring Cloud Bus应用目标：启动RabbitMQ通过修改码云中的配置文件后发送Post请求实现及时更新用户微服务中的配置项 分析： 需求：在码云的git仓库中修改user-dev.yml配置文件，实现不重启user-service的情况下可以及时更新配置文件。 实现步骤： 启动RabbitMQ； 修改配置中心config-server； 修改服务提供工程user-service； 测试 小结： config-server的依赖添加内容 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-bus&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;&lt;/dependency&gt; config-server的配置文件添加内容 1234567891011121314151617181920212223242526server: port: 12000spring: application: name: config-server cloud: config: server: git: uri: https://gitee.com/goheima/heima-config.git # 配置rabbitmq信息；如果是都与默认值一致则不需要配置 rabbitmq: host: localhost port: 5672 username: guest password: guesteureka: client: service-url: defaultZone: http://127.0.0.1:10086/eurekamanagement: endpoints: web: exposure: # 暴露触发消息总线的地址 include: bus-refresh user-service的依赖添加内容 12345678910111213&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-bus&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; user-service的配置文件添加内容 1234567# 配置rabbitmq信息；如果是都与默认值一致则不需要配置rabbitmq: host: localhost port: 5672 username: guest password: guest UserController的修改 16. Spring Cloud 体系技术综合应用说明目标：了解Spring Cloud中的Eureka、GateWay、Config、Bus、Feign等技术的综合应用 小结：","categories":[],"tags":[]},{"title":"后端获取图片数据的开发文档","slug":"基于ruoyi框架的开发笔记","date":"2023-12-06T13:42:11.048Z","updated":"2024-02-29T03:51:16.751Z","comments":true,"path":"2023/12/06/基于ruoyi框架的开发笔记/","permalink":"http://example.com/2023/12/06/%E5%9F%BA%E4%BA%8Eruoyi%E6%A1%86%E6%9E%B6%E7%9A%84%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/","excerpt":"","text":"后端获取图片数据的开发文档1.后端获取图片数据的基本需求（文件）在com&#x2F;ruoyi&#x2F;system&#x2F;domain&#x2F;目录下创建SysPicture.java 在该类中编写你在图片数据库中定义的属性:以下拿我的举例子 1234567891011121314151617181920212223242526272829/** * 图片表 data_entires * * */public class SysPicture extends BaseEntity&#123; private static final long serialVersionUID = 1L; /** 图片序号 */ @Excel(name = &quot;图片序号&quot;, cellType = Excel.ColumnType.NUMERIC) private Long pictureId; /** 图片编码 */ @Excel(name = &quot;图片编码&quot;) private String pictureCode; /** 图片名称 */ @Excel(name = &quot;图片名称&quot;) private String pictureName; /** 图片排序 */ @Excel(name = &quot;图片排序&quot;) private Integer pictureSort; /** 状态（0正常 1停用） */ @Excel(name = &quot;状态&quot;, readConverterExp = &quot;0=正常,1=停用&quot;) private String status; 添加Set,Get方法 123456789101112131415161718192021222324252627282930313233343536373839public Long getPictureId() &#123; return pictureId;&#125;public void setPictureId(Long pictureId) &#123; this.pictureId = pictureId;&#125;public String getPictureCode() &#123; return pictureCode;&#125;public void setPictureCode(String pictureCode) &#123; this.pictureCode = pictureCode;&#125;public String getPictureName() &#123; return pictureName;&#125;public void setPictureName(String pictureName) &#123; this.pictureName = pictureName;&#125;public Integer getPictureSort() &#123; return pictureSort;&#125;public void setPictureSort(Integer pictureSort) &#123; this.pictureSort = pictureSort;&#125;public String getStatus() &#123; return status;&#125;public void setStatus(String status) &#123; this.status = status;&#125; 添加toString()方法 1234567891011121314@Overridepublic String toString() &#123; return new ToStringBuilder(this, ToStringStyle.MULTI_LINE_STYLE) .append(&quot;pictureId&quot;, getPictureId()) .append(&quot;postCode&quot;, getPictureCode()) .append(&quot;postName&quot;, getPictureName()) .append(&quot;postSort&quot;, getPictureSort()) .append(&quot;status&quot;, getStatus()) .append(&quot;createBy&quot;, getCreateBy()) .append(&quot;createTime&quot;, getCreateTime()) .append(&quot;updateBy&quot;, getUpdateBy()) .append(&quot;updateTime&quot;, getUpdateTime()) .append(&quot;remark&quot;, getRemark()) .toString(); 可以参考其他的domian类文件。 在com&#x2F;ruoyi&#x2F;web&#x2F;controller&#x2F;system&#x2F;目录下创建SysPictureController.java 控制层中我们主要添加 1234567891011121314151617181920@RestController@RequestMapping(&quot;/system/picture&quot;)public class SysPictureController extends BaseController&#123; //创建并注入服务处的对象 @Autowired private ISysPictureService pictureService; /** * 获取图片 */ @PreAuthorize(&quot;@ss.hasPermi(&#x27;system:picture:list&#x27;)&quot;) @GetMapping(&quot;/list&quot;) public TableDataInfo list(SysPicture picture) &#123; startPage(); List&lt;SysPicture&gt; list = pictureService.selectPictureList(picture); return getDataTable(list); &#125;&#125; 在com&#x2F;ruoyi&#x2F;system&#x2F;service&#x2F;目录下创建服务层的类ISysPictureService.java 在该类中添加如下代码 123456789public interface ISysPictureService &#123; /** * 查询图片信息集合 * * @param picture 图片信息 * @return 图片列表 */ public List&lt;SysPicture&gt; selectPictureList(SysPicture picture);&#125; 在com&#x2F;ruoyi&#x2F;system&#x2F;service&#x2F;impl&#x2F;目录下编写SysPictureServiceImpl.java类并添加如下代码: 1234567891011@Servicepublic class SysPictureServiceImpl implements ISysPictureService &#123; @Autowired private SysPictureMapper pictureMapper; @Override public List&lt;SysPicture&gt; selectPictureList(SysPicture picture) &#123; return pictureMapper.selectPictureList(picture); &#125;&#125; 在com&#x2F;ruoyi&#x2F;system&#x2F;mapper&#x2F;目录下编写SysPictureMapper.java类 在该类中添加 123456789101112131415/** *图片信息 数据层 */@Repositorypublic interface SysPictureMapper &#123; /** * 查询图片数据集合 * * @param picture 图片信息 * @return 图片数据集合 */ public List&lt;SysPicture&gt; selectPictureList(SysPicture picture);&#125; 在mapper&#x2F;system&#x2F;目录下添加SysPictureMapper.xml文件 内容如下 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; 以上部分为文件头，可复制直接使用 &lt;mapper namespace=&quot;com.ruoyi.system.mapper.SysPictureMapper&quot;&gt;//该位置必须要找到Mapper文件所在位置 &lt;resultMap type=&quot;SysPicture&quot; id=&quot;SysPictureResult&quot;&gt; &lt;id property=&quot;pictureId&quot; column=&quot;picture_id&quot; /&gt; &lt;result property=&quot;pictureCode&quot; column=&quot;picture_code&quot; /&gt; &lt;result property=&quot;pictureName&quot; column=&quot;picture_name&quot; /&gt; &lt;result property=&quot;pictureSort&quot; column=&quot;picture_sort&quot; /&gt; &lt;result property=&quot;status&quot; column=&quot;status&quot; /&gt; &lt;result property=&quot;createBy&quot; column=&quot;create_By&quot; /&gt; &lt;result property=&quot;createTime&quot; column=&quot;create_time&quot; /&gt; &lt;result property=&quot;updateBy&quot; column=&quot;update_by&quot; /&gt; &lt;result property=&quot;updateTime&quot; column=&quot;update_time&quot; /&gt; &lt;result property=&quot;remark&quot; column=&quot;remark&quot; /&gt; &lt;/resultMap&gt; &lt;sql id=&quot;selectPictureVo&quot;&gt; select picture_id, picture_code, picture_name, picture_sort, status, create_by, create_time, remark from data_entires &lt;/sql&gt; &lt;select id=&quot;selectPictureList&quot; parameterType=&quot;SysPost&quot; resultMap=&quot;SysPictureResult&quot;&gt; &lt;include refid=&quot;selectPictureVo&quot;/&gt; &lt;where&gt; &lt;if test=&quot;pictureCode != null and pictureCode != &#x27;&#x27;&quot;&gt; AND picture_code like concat(&#x27;%&#x27;, #&#123;pictureCode&#125;, &#x27;%&#x27;) &lt;/if&gt; &lt;if test=&quot;status != null and status != &#x27;&#x27;&quot;&gt; AND status = #&#123;status&#125; &lt;/if&gt; &lt;if test=&quot;pictureName != null and pictureName != &#x27;&#x27;&quot;&gt; AND picture_name like concat(&#x27;%&#x27;, #&#123;pictureName&#125;, &#x27;%&#x27;) &lt;/if&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; 以上的大部分代码，均参考ruoyi官方编写的其他内容改编 由于ruoyi设置了查询权限，我们在运行项目进行数据查询时会提示权限不足,这时候我们需要带着两个请求头去查询 Cookie Authorization","categories":[],"tags":[]},{"title":"SpringBoot学习","slug":"SpringBoot学习","date":"2023-12-04T10:27:49.000Z","updated":"2024-06-09T09:09:08.889Z","comments":true,"path":"2023/12/04/SpringBoot学习/","permalink":"http://example.com/2023/12/04/SpringBoot%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"1.SpringBoot基础1.1 SpringBoot的目标既是提供了一种快速使用Spring的方式，提高开发效率。那么Spring有什么缺点呢？ 1.配置繁琐 2.依赖繁琐 这样就引出了SpringBoot技术，下面介绍一下SpringBoot功能 （1）自动配置 （2）起步依赖 （3）辅助功能 SpringBoot并不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式 1.2 SpringBoot快速入门利用一个简单的小项目来入门一下 SpringBoot在创建项目时，使用jar的打包方式。 SpringBoot的引导类，是项目入口，运行main方法就可以启动项目。 使用SpringBoot和Spring构建的项目，业务代码编写方式完全一样。 同时利用idea工具可实现快速构建 在new–&gt;Module下的Spring Initializr选项卡中实现快速构建项目 1.3 Spring Boot 起步依赖原理（1）spring-boot-starter-parent （2）spring-boot-starter-web 1.4 Spring Boot配置原理配置文件分类: 在application.properties下编写如下代码: server.port &#x3D;8080 或者yml方式(在idea中的resources下创建application.yml或application.yaml文件里面编写如下配置): server: ​ port: 8080 以上三个配置文件的优先级(按照后缀来排序): .properties&gt;.yml&gt;.yaml yaml yaml:基本语法:joy: yaml:数据格式: 对象(map):键值对的集合。 数组:一组按次序排列的值。 纯量:单个的、不可再分的值。 以上注意 属性名称:(空格)+属性值 yaml:参数引用 YAML:小结 读取配置文件内容 (1)@Value @Value(“${name}”) ​ private String name ​ 采用这样的方式来获取application.yaml里对应的name的值 ​ 如果获取数组的值我们在@Value中取得是数组的下标 (2)Environment 使用Environment获取值时的步骤如下: 1)使用**@Autowired注解让Springboot启动时注入一个对象env** 2)直接在输出这一行利用env.getProperty(“”)输入你要获取的值的属性名字即可 (3)@ConfigurationProperties 创建一个你需要用到的对象类(如我图中的person类): 两个注解: ​ @Component:让Spring识别 ​ @ConfigurationProperties 注意了!!!! 如果此时你的@ConfigurationProperties并没有写前缀，那么它会读取配置文件中你所配置的属性名的属性值 如下 但是如果你加了前缀@ConfigurationProperties(prefix &#x3D; “person”)那么它读取的是你在.yaml文件里前缀为person：下的属性名的属性值 profile 1)profile配置方式 多profile文件方式 一般来讲结构是这样的 我们分别在dev、pro、test里面配置需要的属性 然后再主要文件application.properties里面加上 12spring.profiles.active=dev/pro/test这就是启动dev/pro/test配置文件 yml多文档方式 在yml中用—分割即可 2)profile激活方式 在运行位置编辑运行设置找到这两个; 虚拟机参数:-Dspring.profiles.active&#x3D;pro 命令行参数:–spring.profiles.active&#x3D;pro 内部配置加载顺序 外部配置加载顺序 2.SpringBoot整合其他框架2.1 SpringBoot整合Junit。 1.在搭建的com&#x2F;itheima&#x2F;Springboottest&#x2F;下创建类UserService 并编写以下内容 这里我们编写了一个名为add()的方法，作用是打印add…… 在test包下的com&#x2F;itheima&#x2F;目录下创建test目录，在test下创建UserServiceTest类作为测试类 利用@Autowired注入一个类的对象userService @Test下创建一个test()函数，通过对象去访问UserService下的add方法即 userService.add() 以上注意点有: 当你的测试路径和的包名和上面主目录的包名一致时,@SpringBootTest(classes &#x3D; SpringbootTestApplication.class)中的classes &#x3D; SpringbootTestApplication.class可以省略不写 2.2 SpringBoot整合Redis 在pom.xml文件中添加Redis依赖 编写实体类，这里演示Spring Boot 与Redis数据库的整合使用，分别在domain包下编写实体类如下 persoon类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.itcast.springbootandredis.domain;import org.springframework.data.annotation.Id;import org.springframework.data.redis.core.RedisHash;import org.springframework.data.redis.core.index.Indexed;import java.util.List;//指定操作实体类对象在Redis数据库中的存储空间@RedisHash(&quot;person&quot;)public class Person &#123; @Id //表示实体类主键 private int Id; @Indexed //标识对应属性在Redis数据库中生成的二级索引 private String firstName; @Indexed private String lastName; private Address address; private List&lt;Family&gt; familyList; //无参构造器 public Person() &#123; &#125; //有参构造器 public Person(String firstName, String lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125; public int getId() &#123; return Id; &#125; public void setId(int id) &#123; Id = id; &#125; public String getFirstName() &#123; return firstName; &#125; public void setFirstName(String firstName) &#123; this.firstName = firstName; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public Address getAddress() &#123; return address; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; public List&lt;Family&gt; getFamilyList() &#123; return familyList; &#125; public void setFamilyList(List&lt;Family&gt; familyList) &#123; this.familyList = familyList; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;Id=&quot; + Id + &quot;, firstName=&#x27;&quot; + firstName + &#x27;\\&#x27;&#x27; + &quot;, lastName=&#x27;&quot; + lastName + &#x27;\\&#x27;&#x27; + &quot;, address=&quot; + address + &quot;, familyList=&quot; + familyList + &#x27;&#125;&#x27;; &#125;&#125; Address类 1234567891011121314151617package com.itcast.springbootandredis.domain;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import org.springframework.data.redis.core.index.Indexed;@Data //该注解会帮你自动生成get，set方法和tostring方法@AllArgsConstructor // 生成有参构造器@NoArgsConstructor //生产无参构造器public class Address &#123; @Indexed private String city; @Indexed private String country;&#125; Family类 1234567891011121314151617package com.itcast.springbootandredis.domain;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import org.springframework.data.redis.core.index.Indexed;@Data@NoArgsConstructor@AllArgsConstructorpublic class Family &#123; @Indexed private String type; @Indexed private String userName;&#125; 针对springboot整合Redis数据库操作有以下几个注解需要解释一下： @RedisHash(“person”)：用于操作指定实体类对象在Redis数据库中存储空间，此处表示针对Person实体类的数据操作都存储在Redis数据库中名为person的存储空间下。 @Id：用于标识实体类主键，在Redis数据库中会默认生成字符串形式的HashKey表示唯一实体类对象id，当然也可以在数据存储时手动指定id。 @Indexed：用于标识对应属性在Redis数据库中生成二级索引。使用该注解后会在Redis数据库中生成属性对应的二级索引 ，索引名称就是属性名。 （3）编写Repository接口SrpingBoot针对包括Redis在内的一些常用数据库提供了简化配置，可以通过实现Respository接口简化对数据库中的数据进行增删改查操作，这些操作同Spring DATA JPA 操作数据的使用方法基本相同，可以使用方法名的关键字进行对数据的操作。 1234567891011121314151617package com.itcast.springbootandredis.Repository;import com.itcast.springbootandredis.domain.Family;import com.itcast.springbootandredis.domain.Person;import org.springframework.data.repository.CrudRepository;import java.awt.print.Pageable;import java.util.List;public interface PersonRepository extends CrudRepository&lt;Person,String&gt; &#123; public List&lt;Person&gt; findByLastName(String lastName); public List&lt;Person&gt; findPersonByLastName(String lastName, Pageable pageable); public List&lt;Person&gt; findFirstByFirstNameAndLastName(String firstName,String lastName); public List&lt;Person&gt; findByAddress_City(String city); public List&lt;Person&gt; findByFamilyList_userName(String userName);&#125; Redis配置连接 123456#Redis服务器地址spring.redis.host=127.0.0.1#Redis服务器连接端口spring.redis.port=6379#Redis服务器连接密码(默认为空)spring.redis.password = 编写模板进行测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.itcast.springbootandredis;import com.itcast.springbootandredis.Repository.PersonRepository;import com.itcast.springbootandredis.domain.Address;import com.itcast.springbootandredis.domain.Family;import com.itcast.springbootandredis.domain.Person;import jdk.jfr.internal.Repository;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.test.context.junit4.SpringRunner;import java.util.ArrayList;import java.util.List;@RunWith(SpringRunner.class)@SpringBootApplicationpublic class RedisTest &#123; @Autowired private PersonRepository repository; @Test public void savePerson()&#123; Person person = new Person(&quot;张&quot;,&quot;有才&quot;); Person person2 = new Person(&quot;James&quot;,&quot;Harden&quot;); //创建并添加住址信息 Address address = new Address(&quot;北京&quot;,&quot;中国&quot;); person.setAddress(address); //创建并添加家庭成员 List&lt;Family&gt; list = new ArrayList&lt;&gt;(); Family dad = new Family(&quot;父亲&quot;,&quot;李先生&quot;); Family mon = new Family(&quot;母亲&quot;,&quot;陈女士&quot;); list.add(dad); list.add(mon); //向Redis数据库添加数据 Person save = repository.save(person); Person save2 = repository.save(person2); System.out.println(save); System.out.println(save2); &#125; @Test public void selectPerson()&#123; List&lt;Person&gt; personList = repository.findByAddress_City(&quot;北京&quot;); System.out.println(personList); &#125; @Test public void updatePerson()&#123; Person person = repository.findFirstByFirstNameAndLastName(&quot;张&quot;, &quot;有才&quot;).get(0); person.setLastName(&quot;小明&quot;); Person update = repository.save(person); System.out.println(update); &#125; @Test public void deletePerson()&#123; Person delete = repository.findFirstByFirstNameAndLastName(&quot;张&quot;,&quot;小明&quot;).get(0); repository.delete(delete); &#125;&#125; 以上只是Redis和SpringBoot项目合起来，Redis作为数据库的使用方法，下面介绍Redis的别的用法。 2.3 SpringBoot整合mybaits 按步骤如下排列: 在主目录domain下创建类User 并且写好get，set方法最后写上toString() 在com&#x2F;itheima&#x2F;springbiittestmybaits&#x2F;下创建UserMapper文件 内容如下 注意写好@Mpper注解,@Repository注解，@Select(“”)里面写好查询语句(select * from t_user) 来到test目录下操作 在测试类中编写如下代码，其中@Autowired注解注入了UserMapper的对象userMapper @Test注解中编写了testFindAll()方法来调用对象userMapper中的findAll()方法并打印输出列表list 我们的application.yaml文件的内容如下 方法2在主目录下创建mapper目录，目录下创建UserXmlMapper接口并编写里面的内容 在resources目录下创建mapper文件，在里面创建UserMapper.xml文件并且编写如下 这一步注意:一定要指定namespace的路径(其实是UserMapper的路径) 在applications.yaml里面编写 在主要测试类中添加@Autowired注解注入UserXmlMapper的对象userXmlMapper，并且添加对象对应的findAll()方法 运行测试的结果 2.4 Spring Data JPA基本使用2.4.1 Spring Data JPA简介 Spring Data JPA是Spring基于ORM框架、JPA规范的基础上封装的一套JPA应用框架，它提供了增删改查等常用功能，使开发者可以用较少的代码实现数据操作，同时还易于扩展。 ORM框架： 对象关系映射（Object Relational Mapping，简称ORM）是一种编程技术，用于在面向对象编程语言中表示和操作关系型数据库中的数据。ORM框架充当了一座桥梁，使得开发者可以使用面向对象的方式去处理数据库中的数据，而无需直接编写SQL语句。 ORM的核心概念 对象：在面向对象的语言中，数据以对象的形式存在，每个对象通常对应于数据库中的一行记录。 关系型数据库：数据存储在表中，表之间通过外键等关系相互联系。 映射：ORM框架提供了一种机制，用于描述对象和数据库表之间的映射关系，包括对象的属性到数据库列的映射，以及对象实例到数据库行的映射。 ORM的工作原理 元数据定义：ORM框架允许你定义对象和数据库表之间的映射规则，这通常是通过注解、XML配置或者代码生成完成的。 对象持久化：ORM框架会将对象的状态变化持久化到数据库中，当对象被修改后，框架会自动更新对应的数据库记录。 查询：ORM框架提供了一种方式让你用面向对象的方式来查询数据库，而不是直接写SQL语句。 ORM的优点 简化数据库交互：开发者可以直接操作对象，而无需关心底层的SQL语句和数据库交互细节。 提高开发效率：减少了手动编写SQL语句的工作量，也降低了出错的机会。 可移植性：更换数据库时，只需要更改配置，而不需要修改大量的SQL代码。 ORM的常见框架 Hibernate：一个全表映射的ORM框架，非常流行，适用于大型项目。 MyBatis：一个半自动映射的框架，允许更细粒度的控制，比如支持存储过程和动态SQL。 EclipseLink：另一个成熟的ORM框架，原名为TopLink，由Oracle公司贡献给Eclipse基金会。 **JPA (Java Persistence API)**：一个标准的Java持久化规范，多个ORM框架（如Hibernate和EclipseLink）实现了这一规范。 ORM的局限性 性能问题：过度的封装可能会导致性能下降，特别是在大量数据读取和复杂查询的情况下。 灵活性受限：对于一些复杂的SQL查询，使用ORM可能不如直接写SQL灵活。 2.4.2 Spring DATA JPA基本使用 1.编写ORM实体类:实体类与数据表进行映射，并且配置好映射关系。 2.编写Repository接口:针对不同的表数据操作编写各自对应的Repositor接口，并根据需要编写对应的数据操作方法， 编写ORM实体类 1234567891011121314151617package com.itheima.domain;import javax.persistence.*;//标主要与数据库做映射的实体类，默认数据表名称是首字母小写的类名@Entity(name = &quot;t_comment&quot;)@DATA//使用javalombok插件里面DATA注解快速生成get，set方法以及tostring方法public class Discuss &#123; //标注在类属性或者getter方法上，表示某一个属性对应表中的主键 @Id //与@Id注解标注在同一位置，用于表示属性对应主键的生成策略，可省略 @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Column(name = &quot;a_id&quot;) private Integer aId;&#125; &#x3D;","categories":[],"tags":[{"name":"SpringBoot学习","slug":"SpringBoot学习","permalink":"http://example.com/tags/SpringBoot%E5%AD%A6%E4%B9%A0/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-12-04T09:46:55.840Z","updated":"2023-12-04T09:46:55.840Z","comments":true,"path":"2023/12/04/hello-world/","permalink":"http://example.com/2023/12/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"","slug":"Springboot模块学习2","date":"2023-12-04T08:59:28.628Z","updated":"2023-12-09T11:06:31.174Z","comments":true,"path":"2023/12/04/Springboot模块学习2/","permalink":"http://example.com/2023/12/04/Springboot%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A02/","excerpt":"","text":"SpringBoot模块学习(二)—-SpringBoot高级1.SpringBoot自动配置1)Condition 以上是Condition的作用 2)切换内置web服务器SpringBoot的web环境中默认使用tomcat作为内置服务器，其实SpringBoot提供了4种内置服务器供我们选择，我们可以很方便进行切换 那么我们如何在这四种服务器之间切换呢？ 只需要在pom.xml文件中引入对应的服务器坐标就可以了 &lt;dependency&gt; &lt;artifactID&gt;spring-boot-starter-tomcat&lt;/artifactID&gt; &lt;groupID&gt;org.springframework.boot&lt;/groupID&gt; &lt;/dependency&gt; 以上是我们的tomcat的坐标 只需要将tomcat位置替换成jetty就可以了 3)@Enable注解 下面我们利用项目来加深一下理解 创建一个叫springboot-enable的模块和为名springboot-enable-other的模块，第二个模块的作用是提供一些Bean来查询。 以上是第一个项目需要的代码 第二个项目我们在包下创建 在UserConfig下编写如下代码即可 随后我们在springbootenable模块的pom文件中引入springbootenableother的依赖即可 运行第一个项目报错为正常情况，然后我们来说@Enable注解的作用。 我们自己写一个EnableUser注解 接下来我们在启动类里面运用上自己写的@EnableUser注解启动 成功访问到其他类的Bean！ 4)@Import注解Import注解有4种用法: 1234* 1.直接导入Bean:@Import(User.class)Bean名字* 2.导入配置类:@Import(UserConfig.class)配置类名字* 3.导入ImportSelector的实现类* 4.导入ImportBeanDefinitionRegistrar实现类 5)@EnableAutoConfiguration注解 6)自定义stater案例 7)SpringBoot监听器 这些监听器，是一些列的接口，我们要使用就要创建实现这些接口的类并实现里面的方法。 2.SpringBoot监控 上面的信息当中三个是health信息,一个是info 这里推荐使用json,cn网站来进行解析: 得到如下结果 我们访问info信息发现是空的，如果想要在info里面添加内容，需要在配置文件中写上以info.开头的属性名称和其对应的属性值,我下面只举一个例子: 在配置文件中添加如下内容后重新启动再次进入 关于health信息，初次访问只会显示一个内容 如果你想开启有关健康方面的所有内容，需要在配置文件中配置上如下内容 1management.endpoint.health.show-details=always 即可！ 如果你想开启所有监控信息全部暴露出来你需要在配置文件中添加: 2)SpringBoot 监控 Spring Boot Admin 使用步骤: 3.SpringBoot项目部署利用idea中的maven打包默认打jar包 可以在目录下用Powershell终端 java -jar+ jar包名 也可以打war包 在pom中将打包方式改为war 然后再启动类中继承一个名为SoringBootServletInitializer的类 随后在加一个@Override注解 将war包放在Tomcat的wabapp下启动Tomcat访问但注意: 1.目录发生了变化 2.端口号内置的不在起作用，需要从外置tomcat配置文件中更改","categories":[],"tags":[]}],"categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"git学习","slug":"git学习","permalink":"http://example.com/tags/git%E5%AD%A6%E4%B9%A0/"},{"name":"jQuery","slug":"jQuery","permalink":"http://example.com/tags/jQuery/"},{"name":"vue.js","slug":"vue-js","permalink":"http://example.com/tags/vue-js/"},{"name":"nginx学习","slug":"nginx学习","permalink":"http://example.com/tags/nginx%E5%AD%A6%E4%B9%A0/"},{"name":"Docker学习","slug":"Docker学习","permalink":"http://example.com/tags/Docker%E5%AD%A6%E4%B9%A0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"},{"name":"练习题，面试题","slug":"练习题，面试题","permalink":"http://example.com/tags/%E7%BB%83%E4%B9%A0%E9%A2%98%EF%BC%8C%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"Java学习","slug":"Java学习","permalink":"http://example.com/tags/Java%E5%AD%A6%E4%B9%A0/"},{"name":"Linux Error","slug":"Linux-Error","permalink":"http://example.com/tags/Linux-Error/"},{"name":"java和vue开发中遇到的错误以及如何改正和对他们的理解整理(参加的项目)","slug":"java和vue开发中遇到的错误以及如何改正和对他们的理解整理-参加的项目","permalink":"http://example.com/tags/java%E5%92%8Cvue%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E6%94%B9%E6%AD%A3%E5%92%8C%E5%AF%B9%E4%BB%96%E4%BB%AC%E7%9A%84%E7%90%86%E8%A7%A3%E6%95%B4%E7%90%86-%E5%8F%82%E5%8A%A0%E7%9A%84%E9%A1%B9%E7%9B%AE/"},{"name":"SpringBoot学习","slug":"SpringBoot学习","permalink":"http://example.com/tags/SpringBoot%E5%AD%A6%E4%B9%A0/"}]}
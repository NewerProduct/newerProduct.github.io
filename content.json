{"meta":{"title":"LiSir","subtitle":"心怀远方","description":"","author":"LiSir","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2024-07-08T10:04:11.000Z","updated":"2024-07-08T11:39:20.851Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"categories","date":"2024-07-08T11:34:48.000Z","updated":"2024-07-08T11:39:30.431Z","comments":true,"path":"categories/index-1.html","permalink":"http://example.com/categories/index-1.html","excerpt":"","text":""},{"title":"","date":"2024-07-08T11:01:05.658Z","updated":"2024-07-08T11:01:05.658Z","comments":true,"path":"json/music.json","permalink":"http://example.com/json/music.json","excerpt":"","text":"[{\"name\":\"青花瓷\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.4/青花瓷/青花瓷.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000002eFUFm2XYZ7z_2.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.4/青花瓷/青花瓷.lrc\"},{\"name\":\"稻香\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/稻香/稻香.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/稻香/稻香.lrc\"},{\"name\":\"晴天\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/晴天/晴天.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000000MkMni19ClKG_3.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/晴天/晴天.lrc\"},{\"name\":\"七里香\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/七里香/七里香.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000003DFRzD192KKD_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/七里香/七里香.lrc\"},{\"name\":\"花海\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/花海/花海.flac\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/花海/花海.lrc\"},{\"name\":\"反方向的钟\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/反方向的钟/反方向的钟.flac\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000000f01724fd7TH_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/反方向的钟/反方向的钟.lrc\"},{\"name\":\"兰亭序\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/兰亭序/兰亭序.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/兰亭序/兰亭序.lrc\"},{\"name\":\"说好的辛福呢\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/说好的辛福呢/说好的辛福呢.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/说好的辛福呢/说好的幸福呢.lrc\"},{\"name\":\"等你下课 (with 杨瑞代)\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/等你下课/等你下课.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000003bSL0v4bpKAx_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/等你下课/等你下课.lrc\"},{\"name\":\"我落泪情绪零碎\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/我落泪情绪零碎/我落泪情绪零碎.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000000bviBl4FjTpO_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/我落泪情绪零碎/我落泪情绪零碎.lrc\"},{\"name\":\"听妈妈的话\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/听妈妈的话/听妈妈的话.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000002jLGWe16Tf1H_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/听妈妈的话/听妈妈的话.lrc\"},{\"name\":\"明明就\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/明明就/明明就.flac\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000003Ow85E3pnoqi_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/明明就/明明就.lrc\"},{\"name\":\"我是如此相信\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/我是如此相信/我是如此相信.flac\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000001hGx1Z0so1YX_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/我是如此相信/我是如此相信.lrc\"},{\"name\":\"发如雪\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.3/发如雪/发如雪.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M0000024bjiL2aocxT_3.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.3/发如雪/发如雪.lrc\"},{\"name\":\"以父之名\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.3/以父之名/以父之名.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000000MkMni19ClKG_3.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.3/以父之名/以父之名.lrc\"},{\"name\":\"园游会\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.3/园游会/园游会.flac\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000003DFRzD192KKD_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.3/园游会/园游会.lrc\"},{\"name\":\"本草纲目\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.4/本草纲目/本草纲目.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000002jLGWe16Tf1H_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.4/本草纲目/本草纲目.lrc\"},{\"name\":\"龙卷风\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.4/龙卷风/龙卷风.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000000f01724fd7TH_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.4/龙卷风/龙卷风.lrc\"}]"},{"title":"tags","date":"2024-05-20T09:20:46.000Z","updated":"2024-05-20T09:21:28.598Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"music","date":"2024-07-08T10:59:36.000Z","updated":"2024-07-08T11:00:14.773Z","comments":false,"path":"music/index.html","permalink":"http://example.com/music/index.html","excerpt":"","text":""}],"posts":[{"title":"数据结构","slug":"数据结构","date":"2024-09-15T03:57:19.000Z","updated":"2024-09-15T13:06:37.250Z","comments":true,"path":"2024/09/15/数据结构/","permalink":"http://example.com/2024/09/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"第一章绪论数据相关概念数据：所有能输入到计算机中并能被程序识别和处理的符号集合 数据分类： 数值数据：整数、实数等。 非数值数据：图形、图像、声音、文字等 数据对象：是性质相同的数据元素的集合，是数据的一个子集。比如字符集合C&#x3D;{‘A’,’B’,’C’} 数据元素：数据的基本单位，在程序中作为一个整体进行考虑和处理。 数据项：构成数据元素的最小单位。又被称为属性。 ！！！一个数据元素由若干个数据项组成，数据项是数据不可分割的最小单位。 数据结构即数据的组织形式，它是数据元素之间存在的一种或多种特定关系的数据元素集合 数据结构的三要素： 数据元素间的逻辑关系 —-&gt;数据的逻辑结构 数据元素及其关系在计算机存储器中存储的方式 —–&gt;数据的存储结构(或物理结构) 施加在该数据上的操作 ——-&gt;数据运算。 数据结构三要素逻辑结构数据元素之间的关系可以是元素间代表某种含义的自然关系，也可以是为处理问题方便而人为定义的关系，这种人为定义的关系称为数据元素间的逻辑关系，相应的结构称为逻辑结构&#x2F;概念结构。 数据结构从逻辑上分为四类： 集合、线性结构、树结构、图结构 集合元素之间的关系：无。 特点：数据元素之间除了”属于同一个集合”的关系外，别无其他逻辑关系。是最松散的，不受任何制约的关系。 线性结构比如：线性表、栈、队列、串、数组、广义表 元素之间的关系：一对一。 特点：开始元素和终端元素都是唯一的，除此之外，其余元素都有且仅有一个前驱元素和一个后记元素 树结构比如：树、二叉树 元素之间的关系：一对多。 特点：开始元素唯一，终端元素不为一。除了终端元素外，每个元素有一个或多个后继元素；除开始元素外，每个元素有且仅有一个前驱元素 图结构比如：有向图和无向图、带权图和无权图 元素之间的关系：多对多。 特点：所有元素都可能有多个前驱元素和多个后继元素 总结逻辑结构（有时直接称为数据结构） 线性结构：线性表、栈、队列、串、广义表 非线性结构：集合、树、图。 说明： 逻辑结构与数据元素本身的形式、内容无关 逻辑结构与数据元素的相对位置无关 逻辑结构与所含结点个数无关 逻辑结构与计算机无关 数据的存储结构顺序存储(物理上连续) 定义：顺序存储是最直观的一种存储方式，它将数据元素按照一定的顺序存放在一段连续的内存空间中。 特点： 访问速度快，因为可以直接通过索引进行访问。 插入和删除操作较慢，因为需要移动大量元素来保持顺序或腾出空间。 存储密度高（存储利用率高），因为不需要额外的空间来存储元素之间的关系。 适用场景：适用于频繁访问但很少修改的数据集合。 链式存储 定义：链式存储使用指针来链接数据元素，每个元素（节点）包含指向下一个节点的链接。 特点： 插入和删除操作快，只需改变相邻节点之间的指针即可。 访问速度相对较慢，因为需要遍历链表直到找到目标元素。 存储密度较低，因为每个节点除了存储自身数据外还需要存储指向其他节点的指针。 适用场景：适合频繁修改的数据集合，特别是当数据量不确定或经常变化时 索引存储 定义：索引存储是为了解决顺序存储中插入删除效率低下的问题而提出的，它为每个数据元素创建一个索引项，索引项通常包含元素的位置信息。 特点： 通过索引可以快速定位到具体的数据元素。 需要维护额外的索引表，这会增加存储开销。 支持高效的随机访问。 适用场景：适合大数据量且需要快速定位的情况。 散列存储 定义：散列存储使用哈希函数将关键字映射到数组的一个位置上进行存储。 特点： 基于哈希函数的查找非常快速，理想情况下可以达到O(1)的时间复杂度。 可能会出现哈希冲突，需要合适的解决冲突策略。 散列表的空间利用效率取决于哈希函数的选择以及处理冲突的方式。 适用场景：适合需要快速查找、插入和删除操作的应用场景。 数据的运算定义：施加在数据上的运算包括运算的定义和实现。 运算的定义是针对逻辑结构的，指出运算的功能。 运算的实现是针对存储结构的，指出运算的具体操作步骤。 数据类型、抽象数据类型数据类型是一个值的集合和定义在此集合上的一组操作的总称。 举例： int：值的范围：-2147483648 ~ 2147483647 ，可进⾏操作：加、减、乘、除、模运算… bool：值的范围：true、false，可进⾏操作：与、或、⾮… 1）原子类型。其值不可再分的数据类型。 2）结构类型。其值可以再分解为若干成分（分量）的数据类型。 抽象数据类型（Abstract Data Type，ADT）是抽象数据组织及与之相关的操作。 ADT 用数学化的语言定义数据的逻辑结构、定义运算。与具体的实现无关。(与存储的结构无关) 算法算法的概念程序 &#x3D; 数据结构 + 算法 算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令 表示一个或多个操作 算法的特性 有穷性。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。 确定性。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。 可行性。算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。 输入。一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。 输出。一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。 “好”算法的特点 正确性。算法应能够正确地解决求解问题。 可读性。算法应具有良好的可读性，以帮助人们理解。 健壮性。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。 高效率与低存储量需求 时间复杂度时间复杂度：衡量时间开销和问题规模n的关系。 口诀：常对幂指阶 图示： 上图表示为：**$O(1) &lt; O(\\log_2{n}) &lt; O(n) &lt; O(n\\log_2{n}) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)$** 在计算时间复杂度时，我们可以只考虑阶数高的部分。用大O表示法表示 在利用大O表示法表示时间复杂度时： 顺序执行的代码只会影响常数项，可以忽略， 只需要挑选循环中的一个基本操作分析它执行的次数x与n的关系即可。 多层嵌套循环，只关注最深层次循环执行的次数。 x的数量级O(x)就是时间复杂度T(n) 比如： T1(n)&#x3D;3n+3 —-&gt;时间复杂度是O(n) T2(n)&#x3D;n^2+3n+1000 ——&gt;时间复杂度是O(n^2) T3(n)&#x3D;n^3 + n^2 +9999999 ——–&gt;时间复杂度是：O(n^3) 在比如： 我们在考虑时间复杂度时多考虑： 最坏时间复杂度 平均时间复杂度 一般不考虑最好时间复杂度。 空间复杂度空间复杂度：衡量空间大小与问题规模的关系。 程序代码所占用的空间是不变的，变得是程序中那些需要额外定义的变量所占用的空间。 遇到普通程序时： ①找到所占空间大小与问题规模相关的变量。 ②分析所占空间x与问题规模n的关系 x &#x3D; f(n) ③x的数量级O(x)就是算法的空间复杂度S(n) —-&gt;S指的是space空间的意思 当遇到递归函数时： ①找到递归函数调用的次数x与问题规模n的关系x &#x3D; f(n) ②x的数量级O(x)就是算法的空间复杂度S(n)","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"算法跟学","slug":"算法跟学","date":"2024-09-12T13:58:11.000Z","updated":"2024-09-13T13:49:07.230Z","comments":true,"path":"2024/09/12/算法跟学/","permalink":"http://example.com/2024/09/12/%E7%AE%97%E6%B3%95%E8%B7%9F%E5%AD%A6/","excerpt":"","text":"数组数组理论基础 数组是存放在连续内存空间上的相同类型数据的集合。 数组下标都是从0开始的。 数组内存空间的地址是连续的 正是因为数组在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。 数组的元素是不能删的，只能覆盖。 针对二维数组： 结论： C++中二维数组在地址空间上是连续的。 衡量算法好坏事前分析法 从最差的执行情况进行一个预估计 - 事前分析法 时间复杂度 利用时间复杂度衡量：一个算法的执行，随数据规模的增大，而增长的时间成本 不依赖环境因素 大O表示法渐进上界：从某个常数n0开始，c * g(n) 总是位于f(n)的上方，那么记作O(g(n)) 图示： 表示算法执行的最差情况。 已知f(n)去求g(n) 表达式中相乘的常量，可以省略：100 * n^2 中的100。 多项式中数量规模更小(低次项)的表达式可以省略：f(n) &#x3D; n^3 + n 中的 n 不同底数的对数，渐进上界可以用一个对数函数log_n 来表示。 对数的常数次幂可以省略。 常见的大O表示法按照时间复杂度从低到高排序： **常数时间复杂度 O(1)**： 不依赖于输入数据规模的固定时间操作。 例子：访问数组中的某个元素。 **对数时间复杂度 O(log n)**： 当数据规模增加时，执行时间以对数方式增加。 例子：二分查找算法。 **线性时间复杂度 O(n)**： 执行时间随着输入数据规模线性增长。 例子：遍历一个数组或列表。 **线性对数时间复杂度 O(n log n)**： 经常出现在高效的排序算法中。 例子：归并排序或快速排序。 **平方时间复杂度 O(n^2)**： 包含两个嵌套循环的情况。 例子：冒泡排序、选择排序或插入排序。 **立方时间复杂度 O(n^3)**： 三个嵌套循环的情况。 例子：一些矩阵乘法算法。 **指数时间复杂度 O(2^n)**： 对于每项都有两种选择的情况。 例子：解决旅行商问题（TSP）的简单递归算法。 **阶乘时间复杂度 O(n!))**： 需要枚举所有可能的情况。 例子：列出所有可能的排列组合。 下面是这些复杂度的一个简单图示表示，展示了随着n的增长，不同复杂度函数的增长速度： 1234567891011121314Y Axis (Time) | | O(n!) | / | / | / | / | / | / | / |/ +----------------------------------------------------&gt; X Axis (Input Size n) O(1) O(log n) O(n) O(n log n) O(n^2) O(n^3) O(2^n) 在这个图示中，可以看到随着输入规模n的增加，时间复杂度从O(1)到O(n!)逐渐增加。最理想的情况是时间复杂度为O(1)，即无论输入规模如何，算法的执行时间都是固定的；而最糟糕的情况是时间复杂度为O(n!)，这种情况下算法的执行时间会随着输入规模的增加呈阶乘增长。 大Ω表示法渐进下界：从某个常数n0开始，c * g(n) 总是位于f(n)的下方，那么记作Ω(g(n)) 大Ω符号描述了算法在最好情况下的增长行为，给出了算法运行时间的一个下界估计。 例如，如果一个算法的时间复杂度为Ω(n)，这意味着在最好的情况下，该算法至少需要执行一个常数倍的n次操作。 图示： Θ表示法渐进紧界：从某个常数n0开始，f(n)总是位于c1 * g(n) 和c2 * g(n)之间，那么记作Θ(g(n)) Θ符号同时考虑了上界和下界，表示算法的渐近紧致界。它描述了算法在平均情况下的增长行为。 例如，如果一个算法的时间复杂度为Θ(n log n)，这意味着在大多数情况下，算法的运行时间将接近于n log n。 图： 空间复杂度与时间复杂度类似，一般也使用大O表示法来衡量：一个算法执行随数据规模增大，而增长的额外空间成本。 基础数据结构篇二分查找算法描述二分法也被称为折半查找。 题目中如果出现：1.数组为有序数组(升序排列或降序)，2.数组中无重复元素。就可以考虑是不是可以使用二分法了。 因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。 实现代码： 1234567891011121314151617181920//算法 - 二分查找public static int binarySearch(int a[],int target)&#123; //确定查找的范围 - 左闭右闭版。 int i = 0,j = a.length-1; //进入循环，进行查找 while(i &lt;= j)&#123; //寻找中间值索引 int mid = (i + j ) / 2; //判断中间值与目标值的大小 if(a[mid] &lt; target )&#123; //中间值小于目标值 - 说明应该在中间值的右边边去查找。 i = mid + 1; &#125; else if ( target &lt; a[mid] ) &#123; j = mid -1; &#125;else&#123; return mid; &#125; &#125; //如果没找到返回 -1 return -1;&#125; 算法细节 为什么是 i &lt;&#x3D; j 而不是 i&lt;j？ 这样写会疏漏掉让i &#x3D; j 时 的比较，导致循环退出返回 -1 int mid &#x3D; (i + j ) &#x2F; 2 有没有问题？ 有问题，当数据特别多，进而导致最大索引特别大时，在进行取中间值索引操作时，会出现溢出问题，当出现溢出后java会将最高位看做符号位。导致可能会出现负数引发错误，解决方式就是利用右移运算符右移1位代替 除2操作 可以写成 int mid = (i + j ) &gt;&gt;&gt; 1 改进算法二分查找 - 左闭右开版在这版二分查找中 j不参与查找。 1234567891011121314151617181920//算法 - 二分查找public static int binarySearch(int a[],int target)&#123; //确定查找的范围 int i = 0,j = a.length; //进入循环，进行查找 while(i &lt; j)&#123; // - 如果 = 会造成死循环。 //寻找中间值索引 int mid = ( i + j ) &gt;&gt;&gt; 1; //判断中间值与目标值的大小 if(a[mid] &lt; target )&#123; //中间值小于目标值 - 说明应该在中间值的右边边去查找。 i = mid + 1; &#125; else if ( target &lt; a[mid] ) &#123; j = mid -1; &#125;else&#123; return mid; &#125; &#125; //如果没找到返回 -1 return -1;&#125; 二分查找 - 平衡版算法性能时间复杂度 最坏情况：O(log_n) 该算法的函数: 最好情况：如果目标元素位于数组中央，只需循环1次就能找到O(1) 空间复杂度 需要常数个指针i，j，m，因此额外占用空间是O(1)","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"项目AI绘画开发总结","slug":"项目AI绘画开发总结","date":"2024-09-04T00:25:48.000Z","updated":"2024-09-11T12:07:35.424Z","comments":true,"path":"2024/09/04/项目AI绘画开发总结/","permalink":"http://example.com/2024/09/04/%E9%A1%B9%E7%9B%AEAI%E7%BB%98%E7%94%BB%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/","excerpt":"","text":"数组去重操 数组去重我们使用：set对象，这是ES6中提出的新语法。 基本语法： const obj = new Set([1, 2, 3, 3, 4]) Set 对象： 定义：Set 是一种存储唯一值的集合数据结构。 创建：new Set([iterable]) 主要方法： add(value)：添加值 delete(value)：删除值 has(value)：检查值是否存在 clear()：清空 Set size：获取 Set 大小 特点： 值唯一性 可存储任何类型的值 不使用索引，而是使用键来引用值 遍历： forEach() for…of 循环 常见用途： 数组去重 检查元素是否存在 实现集合运算（交集、并集、差集） 示例： 1234const mySet = new Set([1, 2, 3, 3, 4]);console.log(mySet); // Set(4) &#123;1, 2, 3, 4&#125;mySet.add(5);console.log(mySet.has(3)); // true 与数组转换： Set 转数组：[…mySet] 或 Array.from(mySet) 数组转 Set：new Set(myArray) 项目体现： 12345678910111213141516//监听键盘抬起事件function enterUp()&#123; // 首先检查 tipWord 是否为空或者已经存在于数组中 if (form.tipWord &amp;&amp; !form.tipWords.includes(form.tipWord)) &#123; // 如果不存在，则添加到数组中 form.tipWords.push(form.tipWord); &#125; // 对数组进行去重操作 - 这里使用展开运算符对去重后的数组进行展开，并赋值 form.tipWords = [...new Set(form.tipWords)]; console.log(form.tipWords); // 清空 tipWord form.tipWord = &#x27;&#x27;; &#125; 查找DOM节点 这里介绍一个新函数：closest()函数。 closest 函数： 定义：closest() 是一个 DOM 方法，用于获取最近的匹配特定选择器的祖先元素。 用法：element.closest(selector) 特点： 从当前元素开始向上遍历 DOM 树 返回第一个匹配选择器的祖先元素 如果没有匹配的祖先元素，返回 null 示例： 12const button = document.querySelector(&#x27;button&#x27;);const closestDiv = button.closest(&#x27;div&#x27;); 用途： 事件委托 查找特定的父元素 在复杂的 DOM 结构中导航 浏览器支持：现代浏览器都支持，但在旧版本可能需要 polyfill 处理特殊数据场景：这是在进行该项目前端开发时遇到的：在进行对表单需要数据校验时，发现了一个格式比较特殊的表单项，由于直接在代码中更改我发现很不好下手。所以这里将修改数据这一步封装为一个函数 如果需要对数据进行更改显示格式，调用函数即可。 12345678910111213141516&#123; &quot;init_images&quot;: [ ], &quot;sampler_index&quot;: &quot;DPM++ 2M&quot;, &quot;denoising_strength&quot;: 0.4, &quot;prompt&quot;: &quot;(1girl,1.5),(solo,1.3)&quot;, &quot;seed&quot;: -1, &quot;steps&quot;: 20, &quot;cfg_scale&quot;: 11, &quot;width&quot;: 948, &quot;height&quot;: 533, &quot;negative_prompt&quot;: &quot;(EasyNegative,1.3),(nsfw,1.2)&quot;, &quot;mask&quot;: null, &quot;mask_blur&quot;: null, &quot;inpainting_mask_invert&quot;: null&#125; 看prompt和negative_prompt字段，查了下文档，左边叫做提示词，右边叫权重。发现显示是(提示词:权值)这样的格式，于是我们就可以封装一个数据处理函数，来获得我们需要的这样格式的数据。就比如： 123456//格式化数据函数，用来生成格式为(提示词:权值) 数据function formatPrompt(promptObj: &#123; [key: string]: number &#125;): string &#123; return Object.entries(promptObj) .map(([key, value]) =&gt; `($&#123;key&#125;:$&#123;value.toFixed(1)&#125;)`) .join(&#x27;,&#x27;);&#125; 最后也是成功获得同样格式的数据，所以记录一下这种思路。因为直接去操作原本的数据我发现十分困难。 接入翻译API场景：由于在输入提示词的时候，需要把中文提示词转化为英文的，不然后台ai无法进行识别。所以这里就用到了翻译的API。首选推荐的API是百度的API，这是一款免费的API。下面我就以百度翻译API为例，来写一个翻译函数。 百度翻译API官方文档：https://fanyi-api.baidu.com/product/113，需要可以查看。 签名生成方法为什么需要签名：签名是为了保证调用安全，使用 MD5 算法生成的一段字符串，生成的签名长度为 32 位，签名中的英文字符均为小写格式。 Step1. 将请求参数中的 APPID(appid)， 翻译 query(q，注意为UTF-8编码)，随机数(salt)，以及平台分配的密钥(可在管理控制台查看) 按照 appid+q+salt+密钥的顺序拼接得到字符串 1。Step2. 对字符串 1 做 MD5 ，得到 32 位小写的 sign。 —— const md5Sign &#x3D; CryptoJS.MD5(signStr).toString();注： 待翻译文本（q）参数需为 UTF-8 编码； 在生成签名拼接 appid+q+salt+密钥 字符串时，q 不需要做 URL encode，在生成签名之后，发送 HTTP 请求之前才需要对要发送的待翻译文本字段 q 做 URL encode； 3.如遇到报 54001 签名错误，请检查您的签名生成方法是否正确，在对 sign 进行拼接和加密时，q 不需要做 URL encode，很多开发者遇到签名报错均是由于拼接 sign 前就做了 URL encode；4.在生成签名后，发送 HTTP 请求时，如果将 query 拼接在URL上，需要对 query 做 URL encode。 输入参数请求方式： 可使用 GET 或 POST 方式，如使用 POST 方式，Content-Type 请指定为：application&#x2F;x-www-form-urlencoded字符编码：统一采用 UTF-8 编码格式query 长度：为保证翻译质量，请将单次请求长度控制在 6000 bytes以内（汉字约为输入参数 2000 个） 字段名 类型 是否必填 描述 备注 q string 是 请求翻译query UTF-8编码 from string 是 翻译源语言 可设置为auto to string 是 翻译目标语言 不可设置为auto appid string 是 APPID 可在管理控制台查看 salt string 是 随机数 可为字母或数字的字符串 sign string 是 签名 appid+q+salt+密钥的MD5值 以下字段仅开通了”我的术语库“用户需要填写 needIntervene integer 否 判断是否需要使用自定义术语干预API 1-是，0-否 123456789101112131415161718192021222324252627282930313233343536//接入百度翻译apiasync function baiduTranslate(word: string) &#123; //定义翻译后的结果 let t_Result = ref(&#x27;&#x27;); //生成salt const salt = new Date().getTime(); //生成签名 const sign = appid + word + salt + sKey; const signStr = sign.replace(/-/g, &#x27;&#x27;); // 移除签名中的&#x27;-&#x27; const md5Sign = CryptoJS.MD5(signStr).toString(); // MD5加密签名 try &#123; //利用axios向翻译发送请求 const result = await axios(&#123; url: &quot;/fanyi&quot;, method: &#x27;POST&#x27;, headers: &#123; &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot; &#125;, data: &#123; q: word, from: &#x27;zh&#x27;, to: &#x27;en&#x27;, appid: appid, salt: salt, sign: md5Sign &#125; &#125;) //成功后打印输出结果 console.log(result); const &#123;data&#125; = result const &#123;trans_result&#125; = data; //返回翻译的结果 return t_Result = trans_result[0].dst &#125; catch (error:any) &#123; //抛出一个错误提示 throw new Error(error.message) &#125;&#125; 在想要翻译的地方调用该函数即可完成对汉字的翻译。详细更多语种请查看百度翻译API官网。 拉取设备摄像头场景：因为需要把照片作为输入，传给AI进行识别，所以这里就需要采集照片，该项目使用的是利用相机来采集拍摄的照片。 调取摄像头12345678910111213141516// 调起摄像头const handleOpen = async () =&gt; &#123; dialogVisible.value = true try &#123; // 调起摄像头 - 重要的一步 const stream = await navigator.mediaDevices.getUserMedia(&#123; video: true &#125;) // 也可以调摄像头的比例 // const stream = await navigator.mediaDevices.getUserMedia(&#123; video: &#123; width: 300,height: 400 &#125;&#125;) const videoElement = video.value // 将摄像头画面绑定到 video 元素上 videoElement.srcObject = stream videoElement.play() &#125; catch (error) &#123; console.error(&#x27;无法访问摄像头:&#x27;, error) &#125;&#125; 点击拍摄12345678910111213141516171819202122232425// 点击确认let photo = ref() // 获取img的DOMconst submitImg = () =&gt; &#123; dialogVisible.value = false // 创建一个canvas - 这里是一个画布。 const canvas = document.createElement(&#x27;canvas&#x27;) canvas.width = video.value.videoWidth canvas.height = video.value.videoHeight // 将摄像头捕捉到的图像绘制到canvas上 canvas.getContext(&#x27;2d&#x27;)!.drawImage(video.value, 0, 0, canvas.width, canvas.height) // 将canvas转换为图片，这时候的图片格式是base64，如果需要什么格式，需要另外进行转换 - canvas.toDataURL(&#x27;image/png&#x27;) //同时也赋值给表单的init_images属性 form.init_images.push(canvas.toDataURL(&#x27;image/png&#x27;)) //从表单当中拿去照片的base64值 photo.value.src = form.init_images[0]; console.log(&quot;1111&quot;, form); // 如果使用formData的话 // let formData = new FormData() // formData.append(&#x27;picture&#x27;, photo.value.src) // 如果使用formdata，那么接口需要添加 headers: &#123;&#x27;Content-Type&#x27;: &#x27;multipart/form-data&#x27;&#125; // 显示图片 photo.value.style.display = &#x27;block&#x27; clearVideo()&#125; 关闭摄像头123456789const clearVideo = () =&gt; &#123; // 关闭摄像头 const stream = video.value.srcObject const tracks = stream.getTracks() tracks.forEach((track: any) =&gt; &#123; track.stop() &#125;) video.value.srcObject = null&#125; 页面中文但表单中的数据是英文今天遇到了这么一个业务需求：前端页面展示用户的输入是中文，但携带到后端提交的数据的时候必须是英文。经过思考后，决定使用Map来以K,V键值对的形式存储内容 逻辑：因为要做到一一对应，所以想法就是一个英文单词作为key，英文单词对应的翻译作为value，这样的话就可以做到前端我们通过key去获取中文，而表单数据我们继续用英文。 创建Map 12//为了实现前端显示中文，表单数据携带应为提示词，这里需要做一个翻译映射const translationMap = new Map&lt;string,string&gt;(); 向Map中存入数据 - 对象.set(key,value) 123456//将翻译的结果添加进映射里面 const englishWord = t_Result.value console.log(&quot;2222&quot;,englishWord); console.log(word); translationMap.set(englishWord,word); 从Map拿数据 - 对象.get(key) 12345678910//添加一个新的函数，来map映射中获取中文部分function getChineseWord(englishWord:string):string &#123; //利用get方法，传入键来获取对应的值 const result = translationMap.get(englishWord) if(result) &#123; return result; &#125;else &#123; return englishWord; &#125;&#125;","categories":[{"name":"开发总结","slug":"开发总结","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"开发总结","slug":"开发总结","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"}]},{"title":"TypeScript","slug":"TypeScript","date":"2024-09-02T01:29:05.000Z","updated":"2024-09-15T03:54:54.820Z","comments":true,"path":"2024/09/02/TypeScript/","permalink":"http://example.com/2024/09/02/TypeScript/","excerpt":"","text":"认识TypeScript了解TSTypeScript是Microsoft公司注册商标。 TypeScript具有类型系统，且是JavaScript的超集。 它可以编译成普通的JavaScript代码。 TypeScript支持任意浏览器，任意环境，任意系统并且是开源的。 TypeScript目前还在积极的开发完善之中，不断地会有新的特性加入进来。 因此本手册也会紧随官方的每个commit，不断地更新新的章节以及修改措词不妥之处。 安装TS有两种主要的方式来获取TypeScript工具： 通过npm（Node.js包管理器） 安装Visual Studio的TypeScript插件 针对使用npm的用户： 1npm install -g typescript 简单运行TS文件新建一个index.ts文件 1234567function greeter(person) &#123; return &quot;Hello, &quot; + person;&#125;let user = &quot;Jane User&quot;;document.body.innerHTML = greeter(user); 在命令行中，使用tsc index.ts 来编译ts文件 —-&gt;生成同名的js文件 自动化编译TypeScript因为ts不能够直接运行，需要我们手动转为js才能运行，为了方便开发者，我们需要将自动转为js这一操作开启。 命令行输入tsc --init我们会得到一个名为tsconfig.json文件。该文件配置了ts转为js时的一些规则，比如转换成那个规范(es5，es6，es7)等。 使用命令tsc --watch，表示监视某个ts文件，当文件内容发生变化时，就转为js，如果不指定文件那该命令就是监视所有的ts文件，一旦发生变化就自动进行转换。 还有一点，当我开启全局监视时，确实完成了自动ts转js的功能，但是当我们ts文件中写的内容发生错误时，它依旧会直接进行转换，这个是我们不希望的。解决如下： 打开tsconfig.json文件查找noEmitOnError，将其注释去掉即可。该配置项意味着出现错误就不要再提交进行转换了。 类型声明基础语法：let 变量:变量类型 123let a: string;let b: number;let c: boolean; 除了能定义变量，还能定义函数参数的类型和函数的返回值的类型，比如 123function add(x: number, y: number): number &#123; return x + y;&#125; 这表示你要接受两个类型是数字型的参数。，并且返回值的类型也是数字型。 类型推断TypeScript类型推断简介类型推断是指TypeScript编译器自动地根据赋值来确定一个值的类型。这意味着在某些情况下，你不需要显式地指定类型，TypeScript可以根据上下文来推断出正确的类型。 1. 变量声明当你声明一个变量并立即赋予一个值时，TypeScript会根据这个值的类型来推断该变量的类型。 1let myVariable = &quot;Hello World&quot;; // myVariable被推断为string类型 2. 函数参数在函数参数中，如果没有显式地指定类型，TypeScript也会尝试根据函数体内的操作进行类型推断。 123function logMessage(message) &#123; console.log(message.length); // message被推断为string类型&#125; 3. 函数返回值当函数的返回值没有明确指定类型时，TypeScript会根据return语句的结果来推断返回值类型。 123function getFirstElement(arr) &#123; return arr[0]; // 如果arr是一个数组，TypeScript将根据arr[0]的类型来推断getFirstElement的返回类型&#125; 4. 数组对于数组，类型推断会根据初始化时的元素来确定数组元素的类型。 1let numbers = [1, 2, 3]; // numbers被推断为number[] 5. 对象字面量当定义一个对象字面量时，TypeScript会根据提供的键值对来推断对象的类型。 1let person = &#123; name: &quot;Alice&quot;, age: 25 &#125;; // person被推断为&#123; name: string; age: number &#125; 注意事项虽然类型推断可以使代码更加简洁，但在某些情况下，显式地指定类型可能会更加清晰并且有助于避免潜在的错误。因此，在使用类型推断时，应权衡其带来的便利性和可能的混淆性。 显式类型声明 vs 类型推断 显式类型声明：在声明时就清楚地定义了类型，适用于复杂的逻辑和需要明确类型的情况。 类型推断：减少了代码量，适用于简单和直白的情况。 类型总览JavaScropt数据类型 string number boolean null undefined bigint symbol object 其中object包含：Array，Function，Date，Error等…… TypeScript数据类型 上述js中的所有类型 六个新类型 any unknow never void tuple enum 新增了两个用于自定义类型的方式 type interface 注意点官方推荐在指定类型时，使用小写，比如 12let a: string;let b: number; 原始类型 VS 包装对象 自动装箱JavaScript在必要时会将自动原始类型包装成对象，以便调用方法或访问属性。 类型断言什么是类型断言？类型断言（Type Assertion）是一种告诉编译器“你应该将此值视为这种类型”的方式。通常，当你从一个上下文获取一个值时，这个值可能是多种类型之一，这时你就需要使用类型断言来明确地指定这个值应该被视为哪种类型。 使用场景类型断言常用于以下几种情况： 当你知道一个值的真实类型，但是TypeScript无法推断出来时。 在使用JavaScript的库时，这些库可能没有类型信息，或者类型信息不准确。 需要在联合类型或任何类型（any）之间进行转换。 断言语法TypeScript提供了两种形式的类型断言： 尖括号语法： 12let someValue: any = &quot;this is a string&quot;;let strLength: number = &lt;string&gt;someValue.length; as 关键字语法： 12let someValue: any = &quot;this is a string&quot;;let strLength: number = (someValue as string).length; 示例假设你有一个函数，它可能返回多种类型的值，你想要使用其中一个类型的功能。 12345678910111213function getFirstElement(array: any[]): any &#123; return array[0];&#125;let myArray = [1, &quot;hello&quot;, true];let element = getFirstElement(myArray);// 这里element的类型是any，因为我们不知道myArray的第一个元素是什么类型// 如果我们知道第一个元素总是number类型，我们可以使用类型断言let firstElement: number = element as number;console.log(firstElement.toFixed()); // 这样就可以调用number的方法 注意事项 类型兼容性：断言只能在兼容的类型之间进行。例如，你不能将一个string断言为boolean。 滥用any类型：尽量避免使用any类型，因为这会绕过TypeScript的所有类型检查。如果必须使用any，在可能的情况下尽快将其断言回一个具体的类型。 类型安全：类型断言不会改变运行时的实际值，只影响TypeScript编译时的类型检查。如果断言错误，可能会导致运行时错误。 常用类型anyany：含义是任意类型，一旦将变量类型限制为any，那就意味着放弃了对该变量的类型检查 any类型的变量可以赋值给任意类型的变量。！！！ unknownunknown：含义是未知类型。 unknow可以理解为一个类型安全的any，适用于：不确定数据的具体类型。 当我们给某个变量类型定义为known时，会出现一些问题(比如:”str的类型为未知”)，这时候解决问题有三种方法：1.使用条件判断。2.使用类型断言，明确数据类型。 nevernever：含义是任何值都不是，简单说就是不能有值，undefined、null、&#39; &#39;、0都不行！ 实际开发中，几乎不使用never去限制变量类型 never一般是TS主动推断出来的。 never可以用来限制函数的返回值 voidvoid：通常用于函数返回值的声明。含义：函数返回值为空，调用者也不应该依赖于函数的返回值去做任何操作。 undefined是void可接受的一种空。 若函数的返回值是void，则：1.从语法上讲：函数可以返回undefined，至于显式返回还是隐式返回，无所谓。2.函数调用者不应该关心函数的返回值，也不应该依赖于函数的返回值去做任何操作。即使明白该函数返回了undefined object和Objectobject：（该类型开发不常用，因为限制的范围太大了）该类型的含义是：能够存储非原始类型数据。 Object：该类型的含义是：除了null类型和undefined类型，其他类型的数据都可以存储。 拓展1：声明对象类型1234567891011//声明对象类型的数据 - 用逗号 ?表示age是可选属性let person1: &#123; name: string, age?: number &#125;//还可以这样写 - 使用 ;let person2: &#123; name: string; age?: number; &#125;//也可以这样写 - 使用换行let person3: &#123; name: string age?: number&#125;//如果想要追加属性可以使用索引签名 - [key:string]:anylet person1: &#123; name: string, age?: number,[key:string]:any &#125; 拓展2：声明函数类型12//let 函数名 = (函数参数) =&gt; 返回值类型let count = (a:number,b:number) =&gt; number 通过上面那样定义，表示：该变量count，接受一个返回值是number类型，且携带了a，b两个数字类型的参数的函数。 拓展3：声明数组类型12let arr = string[] // - 表示声明了一个存储字符串类型的数组。let arr1 = Array&lt;number&gt; // - 表示声明了一个存储数字型数据的数组。 基础语法：数据类型[] / Array&lt;数据类型&gt; tuple元组(tuple)是一种特殊的数组类型，可以存储固定数量的元素，并且每个元素的类型都是已知的且可以不同。元组用于精确描述一组值的类型，?表示可选元素。 基本语法： 1let arr = [string,number]; 这表示该元祖存储的数据类型必须是string和number且string在前，number在后。 enum枚举类型。枚举可以定义一组命名常量，它能增强代码的可读性，也让代码更好维护。枚举是一个对象。 常量：无法更改其值。 基本语法：enum + 枚举名(一般开头大写) &#123; &#125; 数字枚举数字枚举存在反向映射。也就是0 - up，1-down，2-left，3-right 123456enum Direction &#123; Up, Down, Left, Right&#125; 查看控制台： 字符串枚举字符串枚举不存在反向映射 1234enum StrEnum &#123; name=&#x27;xiaoli&#x27;, age=&#x27;22&#x27;&#125; 查看控制台：发现并不存在有值 - 键的关系。 常量枚举常量枚举是一种特殊的枚举类型，它使用const关键字定义，在编译时会被内联，避免生成一些额外代码。 如果我像下面这样写 1234567//数字枚举enum Direction &#123; up, down, left, right&#125; 那么生成的js文件是下面这样的：多且杂 123456789&quot;use strict&quot;;//数字枚举var Direction;(function (Direction) &#123; Direction[Direction[&quot;up&quot;] = 0] = &quot;up&quot;; Direction[Direction[&quot;down&quot;] = 1] = &quot;down&quot;; Direction[Direction[&quot;left&quot;] = 2] = &quot;left&quot;; Direction[Direction[&quot;right&quot;] = 3] = &quot;right&quot;;&#125;)(Direction || (Direction = &#123;&#125;)); 如果我像下面这样写 - 这种写法就被称为常量枚举。 1234567//数字枚举const enum Direction &#123; up, down, left, right&#125; 生成的js文件就是这样的 1console.log(0 /* Direction.up */); //其实是个对象 type在TypeScript中，type关键字用于创建类型别名（Type Aliases），这可以帮助简化复杂的类型名称，使得代码更加清晰易读。下面是一些关于TypeScript中的type类型的简要学习笔记： 1. 基础类型定义TypeScript 中的基础类型包括 string, number, boolean, null, undefined, void, any, unknown 等。你可以为这些基础类型创建一个别名： 12type Name = string;let userName: Name = &quot;Tom&quot;; 2. 联合类型联合类型允许将几种类型合并为一种类型： 123type ID = number | string;let myId: ID = 42;myId = &quot;str42&quot;; // 合法的，因为ID可以是string或number 3. 交叉类型交叉类型允许组合多种类型来形成一个新的类型： 1234567891011type Person = &#123; name: string;&#125;;type Employee = &#123; employeeId: number;&#125;;type EmployeePerson = Person &amp; Employee;let employee: EmployeePerson = &#123; name: &#x27;John Doe&#x27;, employeeId: 12345&#125;; 4. 类型别名与接口类型别名和接口都可以用来描述对象的形状，但是它们有一些不同之处。类型别名可以合并类型，而接口则可以扩展： 12345678type Animal = &#123; name: string; &#125;;interface Animal &#123; age?: number;&#125;// 或者使用extendsinterface Animal extends &#123; name: string &#125; &#123; age?: number;&#125; 一个特殊况情况case1：声明函数的同时限制返回值类型为void看下面这段代码 123456789101112//定义函数的同时也限制返回值类型 - void 并声明函数。function Hello():void&#123; //如果我们这样子写了，那么该函数只能返回undefined ，不能返回其他类型的值 /* return 11; return false; return null; return &quot;hello&quot; 上述写法全部报错类型分配错误 */&#125; case2：先定义函数的类型和声明返回值为void，然后再利用变量去声明函数。123456789101112//如果我们先定义函数和声明返回值类型，在进行函数的声明，就比如type testFn = () =&gt; void; //定义一个类型是testFn 且返回值类型是void的函数//利用变量去声明该函数const f1:testFn = function() &#123; /* 如果向这样子写了，那么该函数返回任何类型的值都可以，就好像失去了void返回值类型的限制 return 11; return true; 均不会报错。 */&#125; 上述看着好像没多大问题，但是实际上，问题就在于如果我们拿到了这个返回值，并使用返回值进行一些逻辑编写，还是会报错。比如 123if(f1())&#123; //这就会发生报错 - 无法测试&quot;void&quot;类型的表达式的真实性&#125; 这点要注意了。 类相关知识最基本类的定义12345678910111213141516class Person &#123; name:string, age:number //使用构造器来 constructor(name:string,age:number)&#123; this.name = name; this.age = age; &#125; //类方法 speak()&#123; console.log(`我叫$&#123;this.name&#125;,今年$&#123;this.age&#125;岁`); &#125;&#125;//使用类const p1 = new Person(&#x27;张三&#x27;,18); 类的继承使用extends来继承父类。 注意点： 如果想要在子类中添加新的属性，需要利用constructor构造器来添加，并且构造器中必须包含父类中已有的属性，随后在添加子类独有的属性。 在子类中能够重写父类的方法。注意要同名，如不同名则会被TS认为是子类独有方法。并利用override修饰重写的方法。 12345678910111213141516//该类继承上面的Person类class Student extends Peoson&#123; //类独有属性 grade:string, //通过构造器注入 - 不要丢掉父类中的属性 constructor(name:string,age:number,grade:string)&#123; //先调用父类 super(name,age); //在子类 this.grade = grade; &#125; //重写父类方法直接同名即可覆盖 注意加上override来修饰方法 override speack()&#123; console.log(`我是子类中重写的方法，我叫$&#123;this.name&#125;,今年$&#123;this.age&#125;岁，来自于班级$&#123;this.grade&#125;`) &#125;&#125; 属性修饰符 关键字 描述 示例 public 默认的可见性级别，表示该成员可以在任何地方被访问。 class MyClass &#123; public myProperty = 'Hello World';&#125; private 表示只有在声明它的类内部可以访问该成员。 class MyClass &#123; private myProperty = 'Secret';&#125; protected 表示该成员可以在声明它的类和其子类中访问。 class BaseClass &#123; protected myProperty = 'Shared';&#125;class DerivedClass extends BaseClass &#123;&#125; readonly 表示该成员一旦初始化后就不能被重新赋值。 class MyClass &#123; readonly myProperty: string; constructor() &#123; this.myProperty = 'Immutable'; &#125;&#125; static 表示该成员属于类本身，而不是类的实例。 class MyClass &#123; static myStaticMethod() &#123; console.log('Called static method'); &#125;&#125; 引入修饰符后我们可以引出新概念：属性的简写形式 属性的简写形式简写前： 123456789class Person &#123; name:string, age:number //使用构造器来注入 constructor(name:string,age:number)&#123; this.name = name; this.age = age; &#125;&#125; 简写后： 123class Person &#123; constructor(public name:string,public age:string)&#123;&#125;&#125; 可以发现，通过修饰符修饰属性，就省略了属性的声明和赋值操作，直接大大减少代码量。以后要多用。 抽象类抽象类是通过关键字abstract来声明的，抽象类是一类无法被实例化的类，专门用来定义类的结构和行为，类中可以写抽象方法，也可以写具体实现。抽象类主要用来为其派生类提供一个基础结构，要求其派生类必须实现其中的抽象方法。 抽象类概念简单理解：抽象类不能被实例化，可以继承，抽象类里面可以有普通方法，也可以有抽象方法 抽象方法要用abstract来修饰，并且抽象函数不需要函数体，比如,抽象方法更像是一种形式，我并没有具体要怎么做，我只是声明了一个方法。 12345678910abstract class Package &#123;//构造方法注入属性。 constract(public weight:number)&#123;&#125; //抽象方法 abstract calculate():number //抽象类中也可以存在具体方法。 printPackage()&#123; console.log(`包裹重$&#123;this.weight&#125;KG,花费$&#123;this.calculate()&#125;元`) &#125;&#125; 抽象类的使用想要使用抽象类，就必须通过继承来实现。继承的关键字是extends，来看下面这个例子。 1234567891011class StandardPackahge extends Package &#123; //继承就要注意父类中的属性不能丢掉，同时子类也可以有自己的属性 constructor(weight:number,public initPrice:number)&#123; //特别注意这里要使用super方法来给父类传入weight super(weight); &#125; //定义方法 - 实现抽象类中的方法 calculate():number &#123; return this.weight * this.initPrice &#125;&#125; 何时使用抽象类？ 定义通用接口：为一组相关的类定义通用的行为(方法或属性)时。 提供基础实现：在抽象类中提供某些方法或为其提供基础实现，这样派生类就可以继承这些实现了。 确保关键实现：强制派生类实现一些关键行为。 共享代码和逻辑：当多个类需要共享部分代码时，抽象类可以避免代码重复。 interface接口interface是一种定义结构的方式，主要作用是为：类，对象，函数等规定一种契约，这样可以确保代码的一致性和类型安全，但要注意interface只能定义格式，不能包含任何实现！ 就拿在AI图生图项目中，定义的一组表单接口如下 1234567891011121314151617181920interface formType &#123; init_images: string[]; sd_model_checkpoint: string; refBd: boolean; refHair: boolean; //使用索引签名 来限制 所有键必须是字符串类型，这样可以动态的向该对象添加属性名和属性值。 prompt: &#123; [index: string]: number &#125;; steps: number; cfg_scale: number; sampler_index: string; seed: number; negative_prompt: &#123; [key: string]: number &#125;; pictureNum: number; denoising_strength: number; width: number; height: number; mask: null, mask_blur: null, inpainting_mask_invert: null&#125; 接口定义类利用implements关键字来实现这个类 123456interface PersonInterface &#123; name:string, age:number, //定义了一个speack函数，返回值类型是void speack(n:number) =&gt; void,&#125; 上面定义了类接口，下面就实现这个类接口 - 通过implements关键字 123456789class Person implements PersonInterface &#123; name:string, age:number, speack(n:number)&#123; for(i = 0; i&lt;n; i++)&#123; console.log(&#x27;1&#x27;); &#125; &#125;&#125; 接口定义对象在利用接口定义一个对象类型是，接口更像是一种类型。使用方式也和类型一样 123456interface PeosonInterface&#123; name:string, age?:number, //可选属性 gender:number, run(n:number) =&gt; void&#125; 上面定义了一个人的接口，使用如下 12345678const user:PeosonInterface = &#123; name:&#x27;张三&#x27;， gender:&#x27;男&#x27;, age:20, run(n:number) &#123; console.log(`跑了$&#123;n&#125;米`) &#125;&#125; 接口定义函数当你需要定义一个函数的类型时，可以使用接口来描述这个函数应该接受什么样的参数以及返回什么样的值。 1234567interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;//下面就来实现该接口let mySearch: SearchFunc = function (src: string, sub: string):boolean &#123; return src.search(sub) !== -1;&#125;; 接口可以继承接口比如说 1234interface Student &#123; name:string, age:18,&#125; 我还有一个接口 1234//让班级接口继承学生接口interface Grade extends Student &#123; grade:string&#125; 可以看到，也就是s1这个对象中，必须有Student接口的属性和Grade接口的属性，缺一不可。 接口自动合并接口可以进行重复定义： 12345678interface PersonInterface &#123; name:string, age:number&#125;//还可以再次定义一个同名接口interface PersonInterface &#123; gender:string&#125; 最终使用该接口时，就要求包含这三个属性，也就是说底层认为，你定义了一个接口 12345interface PersonInterface &#123; name:string, age:number, gender:string&#125; 何时使用接口？ 定义对象的格式：描述数据、API响应格式、配置对象等等…..开发常用 类的契约：规定一个类中需要哪些属性和方法，以及他们的类型 自动合并：拓展第三方库的类型。 区分一些相似概念interface和type的区别 相同点：interface和type都可以用于定义对象结构，在许多场景中可以互换 不同： interface：更专注于对象和类的结构，能够继承和自动合并 type：可以定义类型别名、联合类型、交叉类型，不支持继承和自动合并 interface和抽象类的区别 都用于定义一个类的格式(应该遵守的规则) 不同点： 接口：只能描述类的接口，不能有任何实现代码，一个类可以实现(implements)多个接口 抽象类：既可以包含抽象方法，也可以包含具体方法，一个类只能继承(extends)一个抽象类 泛型泛型允许我们在定义函数、类、接口时，使用类型参数来表示未指定的类型，这些参数在具体使用时，才被指定为具体的类型，泛型能让同一段代码适用多种类型，同时任然保持类型的安全性。我们用&lt;&gt;来表示泛型。 泛型函数举例：比如在一个函数中： 12345678//泛型举例function printData&lt;T&gt;(params:T)&#123; console.log(params);&#125;//调用时在具体指定具体类型printData&lt;number&gt;(10);printData&lt;string&gt;(&#x27;father&#x27;) 泛型函数可以有多个 123456function logData&lt;T,U&gt;(params1:T,params2:U)&#123; console.log(params1); console.log(params2);&#125;//多个logData&lt;string,number&gt;(&#x27;hello&#x27;,10); 泛型接口泛型接口也很好理解：关键在于使用时在具体指定类型 12345678910111213141516171819202122232425262728//泛型接口interface IPerson&lt;T&gt; &#123; name: string, age: number, extraInfo: T&#125;//在具体使用时传入具体类型const p1: IPerson&lt;number&gt; = &#123; name: &#x27;小李&#x27;, age: 20, extraInfo: 10,&#125;type jobInfo = &#123; title:string, company:string,&#125;//在具体使用时传入具体类型const p2:IPerson&lt;jobInfo&gt; = &#123; name:&#x27;小三&#x27;, age:21, extraInfo:&#123; title:&#x27;高级工程师&#x27;, company:&#x27;小米&#x27; &#125;&#125; 泛型类泛型类：任旧是在具体使用时传入具体类型 1234567891011121314151617181920type jobInfo = &#123; title:string, company:string,&#125;//泛型类class Person&lt;T&gt; &#123; constructor( public name:string, public age:number, public extraInfo:T )&#123;&#125; //类方法 speak()&#123; console.log(`我叫$&#123;this.name&#125;,今年$&#123;this.age&#125;岁`); console.log(this.extraInfo); &#125;&#125;//具体实现const p3 = new Person&lt;jobInfo&gt;(&#x27;小五&#x27;,30,&#123;title:&#x27;高级软件开发工程师&#x27;,company:&#x27;小米公司&#x27;&#125;) 类型声明文件在TypeScript中，类型声明文件是用来定义类型信息的特殊文件。这些文件通常用于描述非TypeScript代码（如JavaScript库）的类型结构，或者为项目中的其他部分提供类型信息而不包含任何实现逻辑。类型声明文件通常以.d.ts扩展名结尾，表示“declaration”文件。 类型声明文件的作用 提高开发体验：通过提供类型信息，可以增强IDE的功能，如智能提示、自动补全等。 确保类型安全：当项目使用了类型声明文件后，TypeScript编译器可以在编译阶段检查类型兼容性，提前发现潜在错误。 简化API使用：良好的类型定义可以帮助开发者更快地理解第三方库或模块的API，从而更方便地使用它们。 基本语法类型声明文件可以包含以下元素： 接口（Interfaces）：定义对象的形状。 类型别名（Type Aliases）：定义复杂类型的别名。 类类型（Class Types）：描述类的静态成员和实例成员。 函数类型（Function Types）：定义函数参数和返回值的类型。 变量声明（Variable Declarations）：声明全局变量或模块作用域内的变量。 模块声明（Module Declarations）：描述全局模块或命名空间。 命名空间（Namespaces）：组织相关类型。 枚举（Enums）：定义一组命名常量。 导入&#x2F;导出（Imports&#x2F;Exports）：从其他模块导入类型或向其他模块导出类型。 TypeScript装饰器 装饰器的本质是一种特殊的函数，它可以对：类、属性、方法、参数进行拓展，同时让代码更简洁。 装饰器自2015年在ES6中被提出到现在，已经10年。 截止目前，装饰器依然是实验性特性，需开发者手动调整配置，来开启装饰器。 装饰器有5种： 类装饰器 属性装饰器 方法装饰器 访问器装饰器 参数装饰器 类装饰器类装饰器是一个应用在类声明上的函数，可以为类添加额外功能，或添加额外逻辑。 基本语法 123456789101112131415//类装饰器 - 本质是一个函数//Demo函数会在Person类定义时执行，参数target就是被装饰的类 - Personfunction Demo(target: Function) &#123; console.log(target);&#125;@Democlass Student &#123; name:string age:number constructor(name:string,age:number) &#123; this.name = name; this.age = age &#125;&#125; 类装饰器应用举例1234567891011121314151617181920212223//类装饰器 - 本质是一个函数//Demo函数会在Person类定义时执行，参数target就是被装饰的类 - Personfunction Demo(target: Function) &#123; target.prototype.toString = function() &#123; //注意这里传递的是实例对象 return JSON.stringify(this) &#125;&#125;@Democlass Student &#123; name:string age:number constructor(name:string,age:number) &#123; this.name = name; this.age = age &#125;&#125;const p4 = new Student(&#x27;张三&#x27;,20);console.log(p4.toString()); //&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:20&#125; 关于装饰器的返回值 如果装饰器有返回值，且返回值是一个类，那么返回值的类会代替被装饰器装饰的类。 如果装饰器没有返回值或返回undefined，那装饰器的类不会被替换。 未启用装饰器 12345678910111213141516171819202122function test()&#123; return class &#123; test2()&#123; console.log(200); console.log(300); console.log(400); &#125; &#125;&#125;//@testclass Demo &#123; test() &#123; console.log(100); &#125;&#125;console.log(Demo); 控制台： 启动装饰器 1234567891011121314151617181920212223function test(target:Function)&#123; return class &#123; test2()&#123; console.log(200); console.log(300); console.log(400); &#125; &#125;&#125;// @ts-ignore@testclass Demo &#123; test() &#123; console.log(100); &#125;&#125;console.log(Demo); 控制台： 关于构造类型 声明构造类型 new: 表示该类型可以使用new操作符调用。 …args：表示该类型可以接受任何数量的参数 any[]：表示该类型可以接受任意类型的参数。 {} ：表示返回的是一对象类型（非null，非undefined） 12345678910111213141516171819//声明构造类型/* new: 表示该类型可以使用new操作符调用。 ...args：表示该类型可以接受任何数量的参数。 any[]：表示该类型可以接受任意类型的参数。 &#123;&#125; ：表示返回的是一对象类型（非null，非undefined）*/type Constructor = new (...args:any[]) =&gt; &#123;&#125;//使用构造类型function test(fn:Constructor)&#123; console.log(fn); &#125;class PersonTest&#123; //必须要有静态属性wife static wife:string&#125;//可以传递因为类符合上述类型条件test(PersonTest) 声明构造类型的同时还能规定静态属性 12345678910111213type Constructor = &#123; new (...args:any[]):&#123;&#125;, wife:string&#125;//使用构造类型function test(fn:Constructor)&#123; console.log(fn); &#125;class PersonTest&#123; //必须要有静态属性wife static wife:string&#125; 这段代码的意思是 定义了一个类型别名 Constructor，它实际上是一个接口，描述了一个构造函数的要求。这个构造函数应该能够接受任意数量的参数（由 ...args:any[] 表示的 rest 参数），并且能够返回一个对象 &#123;&#125;。此外，还要求这个构造函数本身具有一个名为 wife 的字符串属性。 替换被装饰的类可以看到，不仅获得原来类的属性，同时也新添加了一些新的属性和方法。 123456789101112131415161718192021222324252627282930313233@logTimeclass User&#123; constructor(public name:string,public age:number)&#123;&#125; speak()&#123; console.log(&#x27;随便打印点什么&#x27;); &#125;&#125;interface User &#123; //声明一个函数，它的返回值是void getCreateTime:()=&gt; void getCreateTime():void&#125;//使用类装饰器来替换这个类，要求保留该类所有内容，并新添加一些内容//构造类型type Constructor = new (...args: any[]) =&gt; &#123;&#125;function logTime&lt;T extends Constructor&gt;(target:T)&#123; //这里返回User类 return class extends target &#123; //这里定义返回的新的类中独有的属性 createTime:Date //使用构造器，来接住原本类中的属性 constructor(...args: any[])&#123; super(...args) this.createTime = new Date(); &#125; getCreateTime()&#123; return `当前的时间是$&#123;this.createTime&#125;` &#125; &#125;&#125;const p5 = new User(&#x27;张三&#x27;,20);console.log(p5.getCreateTime()); 装饰器工厂所谓的装饰器工厂：声明一个函数，该函数的返回值是一个装饰器，即装饰器工厂。该写法可以给装饰传递参数。 12345678910111213141516171819202122232425262728293031//装饰器工厂：声明一个函数，该函数的返回值是一个装饰器，即装饰器工厂。@createDec(3)class User &#123; name:string age:number constructor(name:string,age:number)&#123; this.name = name, this.age = age &#125; speak()&#123; console.log(&#x27;会说话&#x27;); &#125;&#125;//装饰器工厂 - 返回一个装饰器function createDec(n:number)&#123; return function (target:Function) &#123; //在类的原型对象上添加一个方法 target.prototype.introduce = function() &#123; for (let i = 0; i &lt; n; i++) &#123; console.log(`你好，我叫$&#123;this.name&#125;,今年$&#123;this.age&#125;岁`); &#125; &#125; &#125;&#125;interface User &#123; introduce(): void&#125;const p5 = new User(&#x27;张三&#x27;,20);p5.introduce() //3次输出： 你好，我叫张三,今年20岁 装饰器组合装饰器组合使用，执行顺序是：先 [由上到下] 执行装饰器工厂，获取到装饰器后，再[由下到上]执行所有装饰器 1234567891011121314151617181920212223242526272829//装饰器function test1(target:Function) &#123; console.log(&#x27;test1&#x27;)&#125;//装饰器工厂function test2() &#123; console.log( &#x27;test2工厂&#x27;) return function (target:Function) &#123; console.log(&#x27;test2&#x27;) &#125;&#125;//装饰器工厂function test3() &#123; console.log( &#x27;test3工厂&#x27;) return function (target:Function) &#123; console.log(&#x27;test3&#x27;) &#125;&#125;//装饰器function test4(target:Function) &#123; console.log(&#x27;test4&#x27;)&#125;@test1@test2()@test3()@test4class Person5 &#123;&#125; 测试结果如下： 属性装饰器属性装饰器也是一个函数，他会收到两个参数，第一个参数会因为修饰的属性而改变，第二个参数是修饰的属性 12345678910111213141516function logProperty(target: object, propertyName: string) &#123; console.log(target); console.log(propertyName);&#125;class User &#123; @logProperty name: string; @logProperty static age:number constructor(name: string) &#123; this.name = name; &#125;&#125;const user = new User(&#x27;Alice&#x27;); 说明： 如果属性装饰器修饰的是实例属性，那么target这个参数指的是该类的原型对象。 如果属性装饰器修饰的是静态属性，那么target这个参数指的是这个类本身 图示： 关于属性遮蔽问题 简单说明一下这个问题：问题就是：代码执行顺序 如果我们先进行实例化const p5 = new User(&#39;张三&#39;,20);那么在类的实例属性上就会存在age属性，那么这时去修改age属性是不会触发原型对象上的get和set函数的。 123456789101112131415161718192021222324class User &#123; name: string; age:number constructor(name: string,age:number) &#123; this.name = name; this.age = age &#125;&#125;const p5 = new User(&#x27;张三&#x27;,20);//要在原型对象上追加一个属性 agelet value:any;Object.defineProperty(User.prototype,&#x27;age&#x27;,&#123; get() &#123; return value &#125;, set(val) &#123; console.log(`新值是$&#123;val&#125;`); value = val &#125;,&#125;) 如果我们先在类的原型对象上添加一个实例属性age的话，然后再实例化类，这时就会去调用构造器，执行this.age = age，但是实例上还没有age这个属性，接下来就沿着原型链去原型对象上查找，此时发现原型对象中存在age属性，且值为30，于是就把原型对象上的age属性交给了实例对象的age属性。那么实际上就相当于，当我们修改实例对象的age属性时，其实是修改的原型对象上的age属性。 123456789101112131415161718192021222324class User &#123; name: string; age:number constructor(name: string,age:number) &#123; this.name = name; this.age = age &#125;&#125;//要在原型对象上追加一个属性 agelet value = 30;Object.defineProperty(User.prototype,&#x27;age&#x27;,&#123; get() &#123; return value &#125;, set(val) &#123; console.log(`新值是$&#123;val&#125;`); value = val &#125;,&#125;)const p5 = new User(&#x27;张三&#x27;,20); 属性装饰器的应用举例场景：封装一个监视性的装饰器State来监视某个属性，当其发生变化时，打印变化的值。 123456789101112131415161718192021222324252627282930function State(target: object, propertyName: string) &#123; //我们就在其原型对象上追加一个age属性 let key = `_$&#123;propertyName&#125;`; Object.defineProperty(target,propertyName,&#123; get() &#123; return this[key]; //也是添加属性，只不过是通过键的方式来访问某个属性 &#125;, set(newValue) &#123; console.log(`age属性被修改了，修改后的值是$&#123;newValue&#125;`); this[key] = newValue; &#125;, enumerable:true, //是否可枚举 configurable:true, //是否可配置 &#125;)&#125;class User &#123; name: string; @State age:number constructor(name: string,age:number) &#123; this.name = name; this.age = age &#125;&#125;const p5 = new User(&#x27;张三&#x27;,20);const p6 = new User(&#x27;李三&#x27;,20); 方法装饰器方法装饰器依旧是一个函数，具体如下： 当我们装饰一个类的实例方法时： target：是被装饰方法所在类的原型对象 propertyKey：被装饰的方法的方法名 descriptor：被装饰方法的描述 图示： 1234567891011121314151617181920function Demo(target:object,propertyKey:string,descriptor:PropertyDescriptor)&#123; console.log(target); console.log(propertyKey); console.log(descriptor); &#125;//方法修饰器class User &#123; constructor(public name:string,public age:number)&#123;&#125; @Demo speak()&#123; console.log(&#x27;说点什么&#x27;); &#125; static run()&#123; console.log(`我学会跑路了`); &#125;&#125; 当我们装饰一个类的静态方法时： target：是被装饰方法所在的类。 propertyKey：被装饰的方法的方法名 descriptor：被装饰方法的描述 图示： 12345678910111213141516171819202122function Demo(target:object,propertyKey:string,descriptor:PropertyDescriptor)&#123; console.log(target); console.log(propertyKey); console.log(descriptor); &#125;//方法修饰器class User &#123; constructor(public name:string,public age:number)&#123;&#125; speak()&#123; console.log(&#x27;说点什么&#x27;); &#125; @Demo static run()&#123; console.log(`我学会跑路了`); &#125;&#125; 方法装饰器的应用能够实现：在方法调用前执行一些逻辑，在方法调用后执行一些逻辑。 12345678910111213141516171819202122232425262728293031function Demo(target:object,propertyKey:string,descriptor:PropertyDescriptor)&#123; //1.保存原始方法 const originnal = descriptor.value; //2.替换原始方法 descriptor.value = function(...args:any[])&#123; //函数执行前执行的逻辑 console.log(`$&#123;propertyKey&#125;方法开始执行..........`); //调用原始函数，注意千万不能丢了this的指向，这里推荐使用call或者apply来调用函数 originnal.call(this,...args) //函数执行后执行的逻辑 console.log(`$&#123;propertyKey&#125;方法结束执行..........`); &#125; &#125;//方法修饰器class User &#123; constructor(public name:string,public age:number)&#123;&#125; @Demo speak()&#123; console.log(&#x27;说点什么&#x27;); &#125; static run()&#123; console.log(`我学会跑路了`); &#125;&#125;const p5 = new User(&#x27;张三&#x27;,20)p5.speak() 控制台输出 访问器装饰器访问器装饰器是装饰类中的get和set方法的一种装饰器。 参数说明： target： 对于实例中的访问器来说，target指的是该访问器所属的原型对象。 对于静态访问器来说，target指的是该访问器所属的类 propertyKey：属性访问器的名称 descriptor：属性访问器的描述。 基本语法： 1234567891011121314151617181920212223242526function Demo(target:object,propertyKey:string,descriptor:PropertyDescriptor)&#123; console.log(target); console.log(propertyKey); console.log(descriptor); &#125;class User &#123; constructor(public name:string,public _age:number)&#123;&#125; speak()&#123; console.log(&#x27;说点什么&#x27;); &#125; static run()&#123; console.log(`我学会跑路了`); &#125; @Demo get age()&#123; return this._age &#125; set age(val)&#123; this.age = val &#125;&#125; 访问器装饰器举例给set加一个限制，表示我们不能随意设置任意值。 123456789101112131415161718192021222324252627282930313233//为了能传递参数，这里我们使用装饰器工厂function Demo(min:number,max:number)&#123; return function(target:object,propertyKey:string,descriptor:PropertyDescriptor)&#123; //保存原来类中的set const originnal = descriptor.set; //给现在的set换新逻辑 descriptor.set = function(value:number)&#123; if(value &gt; max || value &lt; min)&#123; console.log(`您设置的值应该在$&#123;min&#125; 和 $&#123;max&#125;`); throw new Error(&#x27;您设置的数值不在范围内&#x27;) &#125; //如果有set，那么我们调用set。 if(originnal) originnal.call(this,value) &#125; &#125; &#125;//方法修饰器class User &#123; constructor(public name:string,public _temp:number)&#123;&#125; get temp()&#123; return this._temp &#125; @Demo(-50,50) set temp(val)&#123; this._temp = val &#125;&#125;const p5 = new User(&#x27;小李&#x27;,90)p5.temp = -100;console.log(p5._temp); //您设置的数值不在范围内 参数装饰器在 TypeScript 中，参数装饰器是一种特殊类型的装饰器，它们应用于类的方法或构造函数的参数声明。当在方法或构造函数的参数前使用装饰器时，这些装饰器即为参数装饰器。参数装饰器接收三个参数： 对于类的方法来说，第一个参数是 target（原型对象）。 第二个参数是方法的 propertyKey（即方法名）。 第三个参数是索引签名，表示被装饰的参数的位置（从0开始计数）。 下面是一个简单的例子，展示了如何使用参数装饰器： 12345678910111213// 参数装饰器function required(target: any, propertyKey: string | symbol, parameterIndex: number) &#123; console.log(`Called with target: $&#123;target&#125;, propertyKey: $&#123;propertyKey&#125;, parameterIndex: $&#123;parameterIndex&#125;`);&#125;class Greeter &#123; greet(@required name: string) &#123; console.log(&quot;Hello, &quot; + name + &quot;!&quot;); &#125;&#125;let greeter = new Greeter();greeter.greet(&quot;World&quot;); 在这个例子中，@required 被用作 greet 方法中 name 参数的装饰器。每次创建 Greeter 实例并调用其 greet 方法时，required 装饰器就会被调用，并打印出装饰器接收到的信息。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"}]},{"title":"移动端开发+less+BSP","slug":"移动端开发","date":"2024-08-09T10:44:43.000Z","updated":"2024-08-17T08:01:01.523Z","comments":true,"path":"2024/08/09/移动端开发/","permalink":"http://example.com/2024/08/09/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/","excerpt":"","text":"1.移动端基础1.移动端调试方法 通过谷歌浏览器来模拟手机调试 搭建本地Web服务器。手机和服务器一个局域网内，通过手机访问浏览器 使用外网服务器，直接IP或域名访问 2.视口视口（Viewport）是移动设备上一个非常重要的概念，特别是在响应式设计和移动端开发中。视口是指用户通过浏览器查看网页时所看到的那一部分屏幕区域。理解视口对于确保网页在不同尺寸和分辨率的设备上正确显示至关重要。下面是关于视口的一些关键点： 视口的基本概念 视口的定义： 视口是指移动设备上浏览器显示网页内容的可视区域。 它并不是实际的物理屏幕大小，而是浏览器用来渲染网页内容的虚拟窗口。 视口的重要性： 不同设备有不同的屏幕尺寸和分辨率，视口帮助浏览器确定如何缩放内容以适应设备屏幕。 通过设置视口元标签，开发者可以控制页面在不同设备上的显示效果。 视口的类型： 视觉视口（Visual Viewport）：用户实际看到的内容区域。 理想视口（Ideal Viewport）：浏览器根据设备的物理尺寸和像素密度计算出的最佳视口尺寸。 布局视口（Layout Viewport）：浏览器用来布局页面内容的参考视口，默认情况下通常是设备的物理宽度。 视口元标签(meta标签)为了确保网页在不同设备上能够正确显示，通常会在HTML文档的&lt;head&gt;部分添加视口元标签： 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; **width=device-width**：设置视口的宽度等于设备的宽度（以CSS像素为单位），这样可以使页面宽度与设备宽度一致。 **initial-scale=1**：设置初始缩放比例为1，即不缩放，以1:1的比例显示页面。 maximum-scale：最大缩放比，大于0的数字 minimum-scale：最小缩放比，大于0的数字 user-scalable：用户是否可以进行缩放操作，yes or no (1或0) 视口单位 vw&#x2F;vh：视口宽度&#x2F;高度的百分比单位。 1vw 相当于视口宽度的1%。 1vh 相当于视口高度的1%。 vmin&#x2F;vmax：较小&#x2F;较大的视口尺寸的百分比单位。 1vmin 是视口宽度和高度中较小者的1%。 1vmax 是视口宽度和高度中较大者的1%。 3.二倍图1.物理像素和物理像素比物理像素（Physical Pixels） 定义：物理像素是屏幕显示的最小颗粒，是硬件层面真实存在的像素点。 物理像素比（Device Pixel Ratio, DPR）物理像素比指的是一个逻辑像素（logical pixel）所对应的物理像素点的数量。它反映了设备的实际分辨率与其逻辑分辨率之间的关系。 定义：物理像素比是指在同一排上一个逻辑像素能放置的物理像素的数量。例如，如果物理像素比为2，则意味着一个逻辑像素对应着两个物理像素点。 示例：在iPhone X上，屏幕的实际分辨率为1125x2436物理像素，而逻辑分辨率（通常用于编程）为375x812逻辑像素。因此，物理像素比为1125&#x2F;375&#x3D;3.0，这意味着每个逻辑像素对应3个物理像素点。 在移动端开发中，“二倍图”（也称为@2x图像）是一种为了适应高分辨率屏幕而使用的图像资源。随着移动设备屏幕像素密度的提高，如iPhone的Retina显示屏等高清屏幕能够显示更多的细节，使得图像看起来更加清晰和细腻。为了确保在这些高分辨率屏幕上图像不失真且保持清晰，开发者需要使用更高分辨率的图像。 2.什么是二倍图 分辨率提升：通常情况下，二倍图的分辨率是标准分辨率的两倍，即每个方向上的像素数都是普通图片的两倍。例如，如果一个标准图片的尺寸是50x50像素，那么它的二倍图版本就是100x100像素。 文件命名：在命名二倍图时，通常会在文件名后加上“@2x”来表示这是为高分辨率屏幕准备的图像资源。例如，一张名为icon.png的标准图片，其对应的二倍图会命名为icon@2x.png。 二倍图使用方式比如我们需要一个50x50的图片，我们可以使用它的二倍图也就是100x100px的图片，随后在手动利用CSS样式调整到50x50px 4.移动端技术选择1.移动端主流方案1.单独制作移动端页面通常情况下，通过判断设备来决定，如果是移动端就打开移动端页面 2.响应式兼容PC移动端通过判断屏幕宽度来改变样式，以适应不同终端 比如：https://xiaomi.com 2.移动端的盒模型建议使用C3中的盒子模型。即怪异盒模型 box-sizing:border-box 5.移动端常见布局1.流式布局 (Fluid Layout)流式布局是一种使用户界面能够根据容器宽度（通常是视口或屏幕宽度）自动调整其尺寸的设计方法。它使用相对单位（如百分比 % 或者可伸缩单位如 em, rem）而不是固定单位（如 px），以确保布局在不同尺寸的屏幕上保持一致的比例。 实现方法： 使用百分比宽度：在CSS中定义元素宽度时使用百分比，使其能够根据父元素的宽度自动调整。 Flexbox 和 Grid：现代Web开发中，可以利用CSS Flexbox和Grid布局来创建更加灵活且复杂的流式布局。 媒体查询：虽然主要用于响应式设计，但也可以用于流式布局，以便在特定条件下应用不同的样式规则。 2.flex弹性布局(强烈推荐)Flex弹性布局（Flexible Box Layout）是CSS3中的一项重要特性，它为Web开发者提供了一种更为灵活的方式来布局和对齐UI组件。Flex布局特别适用于响应式设计和移动应用开发，因为它能够轻松处理不同屏幕尺寸和方向的变化。 以下是Flex布局的一些关键概念和属性： 容器属性 display: flex; 或 display: inline-flex; 将一个元素定义为Flex容器。 display: flex; 创建一个块级Flex容器。 display: inline-flex; 创建一个内联Flex容器。 flex-direction 定义主轴的方向。 可选值包括： row：从左到右（默认值） row-reverse：从右到左 column：从上到下 column-reverse：从下到上 flex-wrap 控制项目是否换行。 可选值包括： nowrap：不换行（默认值） wrap：允许换行，第一行在上方 wrap-reverse：允许换行，第一行在下方 justify-content 控制主轴上项目的对齐方式。 可选值包括： flex-start：开始位置对齐（默认值） flex-end：结束位置对齐 center：居中对齐 space-between：两端对齐，项目间的间隔平均分布 space-around：每个项目两侧的间隔相等 align-items 控制交叉轴上项目的对齐方式。（一行） 可选值包括： stretch：拉伸（默认值） flex-start：开始位置对齐 flex-end：结束位置对齐 center：居中对齐 baseline：基线对齐 align-content 当有多行时，控制多行之间的对齐方式。 可选值与align-items相同。 项目属性 order 定义项目的排列顺序。 默认值为0。 flex-grow 定义项目的扩展比率。 默认值为0。 flex-shrink 定义项目的收缩比率。 默认值为1。 flex-basis 定义项目的初始主轴大小。 默认值为auto，意味着项目的大小由内容决定。 flex 是flex-grow、flex-shrink和flex-basis的简写形式。 默认值为0 1 auto。 align-self 允许单个项目覆盖容器的align-items属性。 可选值与align-items相同。 3.less+rem+媒体查询布局利用下面的步骤来定html元素需要的font-size的大小，因为单位rem是以HTML标签的font-size大小来决定的 1rem&#x3D;HTML标签元素font-size大小 首先我们选一套标准尺寸 750为准 我们用屏幕尺寸 除以 我们划分的份数 得到了 html 里面的文字大小 但是我们知道不同屏幕下得到的文字大小是不一样的 页面元素的rem值 &#x3D;页面元素在 750像素的下px值 &#x2F; html 里面的文字大小 4.响应式布局1.响应式原理原理：使用媒体查询针对不同宽度的设备进行布局和样式的设置，从而设置不同设备的目的 2.响应式布局容器响应式需要一个父级作为布局容器，来配合子级元素实现变换效果。 原理：在不同屏幕下，通过媒体查询来改变这个布局容器的大小，在改变里面子元素的排列方式和大小，从而实现不同屏幕下，看到不同的页面布局和样式变化 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;响应式布局.html&lt;/title&gt; &lt;style&gt; .container &#123; height: 150px; background-color: skyblue; /* 水平居中 */ margin: 0 auto; &#125; /* 1.超小屏幕下， 小于768px 布局容器宽度为100% */ @media screen and (max-width:767px) &#123; .container &#123; width: 100%; &#125; &#125; /* 2.小屏幕下， 大于等于768px 布局容器宽度为750px */ @media screen and (min-width:768px) &#123; .container &#123; width: 750px; &#125; &#125; /* 3.中等屏幕下， 大于等于992px 布局容器宽度为970px */ @media screen and (min-width:992px) &#123; .container &#123; width: 970px; &#125; &#125; /* 4.大屏幕下， 大于等于1200px 布局容器宽度为1170px */ @media screen and (min-width:1200px) &#123; .container &#123; width: 1170px; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6.移动端事件移动端事件是指在移动设备（如智能手机和平板电脑）上触发的用户交互事件。与传统的桌面端事件相比，移动端事件通常涉及到触摸屏幕的操作。下面是一些关键的移动端事件及其描述： 触摸事件（Touch Events）触摸事件是移动设备中最常见的事件类型，它们允许开发者检测用户的触摸操作。主要包括以下几种： **touchstart**：当用户触摸屏幕时触发。 **touchmove**：当用户的手指在屏幕上移动时触发。 **touchend**：当用户的手指离开屏幕时触发。 **touchcancel**：当触摸序列因某种原因被中断时触发。 事件特性 触摸点：每个触摸事件都包含一个或多个触摸点的信息，可以通过 event.touches、event.changedTouches 等属性获取。 多点触控：支持同时识别多个触摸点，这对于实现缩放和旋转等手势非常有用。 特殊注意事项 延迟问题：在某些情况下，例如点击事件 (click) 在移动端可能会有大约 300ms 的延迟，这是因为浏览器需要等待用户可能的长按操作。为了克服这个问题，可以使用第三方库如 FastClick 或者使用 touchstart 事件来代替。 双击与长按：在某些场景下，双击和长按操作可能会干扰正常的点击事件。可以使用 touchstart 和 touchend 事件来避免这些问题。 例子下面是一个简单的示例，演示如何监听触摸事件并显示触摸点的位置： 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;title&gt;触摸事件示例&lt;/title&gt;&lt;style&gt; #touchArea &#123; width: 200px; height: 200px; background-color: lightblue; margin: 0 auto; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;touchArea&quot;&gt;&lt;/div&gt;&lt;script&gt; const touchArea = document.getElementById(&#x27;touchArea&#x27;); touchArea.addEventListener(&#x27;touchstart&#x27;, (event) =&gt; &#123; event.preventDefault(); // 防止默认行为（如滚动页面） const touches = event.changedTouches; for (let i = 0; i &lt; touches.length; i++) &#123; const touch = touches[i]; console.log(`Touch at ($&#123;touch.clientX&#125;, $&#123;touch.clientY&#125;)`); &#125; &#125;); touchArea.addEventListener(&#x27;touchend&#x27;, (event) =&gt; &#123; console.log(&#x27;Touch ended&#x27;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 其他相关事件除了触摸事件之外，还有一些其他的移动端事件，例如： **orientationchange**：当设备的方向改变时触发。 **deviceorientation**：当设备的方向改变时持续触发。 **gesturestart, gesturechange, gestureend**：与手势相关的事件，如缩放和旋转。 **contextmenu**：长按时触发，可以用来创建上下文菜单。 less基础LESS 是一种动态样式语言，设计用于简化 CSS 的编写过程，并且使 CSS 更易于维护和管理。LESS 提供了变量、嵌套规则、混合（mixins）、函数等特性，这些功能使得 CSS 的编写更加灵活和强大。LESS 的源代码会被编译成标准的 CSS 文件，然后这些 CSS 文件可以被任何现代浏览器解析和显示。 1. 变量LESS允许你在样式表中定义变量，这样就可以在多处重用相同的值，提高代码的可维护性。 语法：@变量名:值 变量名规范 必须以@开头 不能包含特殊字符 不能以数字开头 大小写敏感，区分大小写 123456789// 定义变量@color-primary: #3f51b5;@color-secondary: #ffeb3b;// 使用变量.button &#123; background-color: @color-primary; color: @color-secondary;&#125; 2. 嵌套规则LESS中的选择器可以被嵌套，这样可以让你的代码更加清晰和组织良好。 HTML中的代码如下 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Less嵌套.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--div和a是嵌套关系--&gt; &lt;div class=&quot;header&quot;&gt; &lt;a href=&quot;#&quot;&gt;文字&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在less中,应用嵌套规则如下 12345678910.header &#123; width: 200px; height: 200px; background-color: skyblue; //在less中,不需要再重新进行选择a,而是将嵌套的a标签直接写在header里面即可 a &#123; color: red; &#125;&#125; 经过插件编译后的css文件内容如下 123456789.header &#123; width: 200px; height: 200px; background-color: skyblue;&#125;.header a &#123; color: red;&#125; 特殊性如果有伪类&#x2F;伪元素&#x2F;交集选择器，我们内层选择器要在前面加上符号&amp; 3. 混合（Mixins）混入（Mixins）是一种将一组属性定义在一起的方式，可以在多个地方重用这些属性。它们可以带有参数，类似于函数。 1234567891011// 定义混入.border-radius(@radius: 5px) &#123; border-radius: @radius; -webkit-border-radius: @radius; -moz-border-radius: @radius;&#125;// 使用混入.button &#123; .border-radius(10px);&#125; 4. 函数LESS支持定义函数来执行计算或者处理值，例如颜色操作。 12345678910// 定义函数.mix-colors(@color1, @color2) &#123; @result: mix(@color1, @color2, 50%); return @result;&#125;// 使用函数.button &#123; background-color: @mix-colors(#ff0000, #00ff00);&#125; 5. 运算LESS支持基本的数学运算，如加、减、乘、除。 下面这种写法是一种混合的写法。混合的语法详见第三小结 123456789// 运算示例.width(@base: 100px) &#123; width: @base / 2;&#125;// 使用运算.box &#123; .width(200px); // 结果为 100px&#125; 注意点 运算符： LESS 支持基本的数学运算符：加号 (+), 减号 (-), 乘号 (*), 除号 (/)。 运算符两边需要有空格，例如 10px + 5px 而不是 10px+5px。 单位： 当对具有单位的数值进行运算时，确保单位相同。 如果没有单位，LESS 将假设是像素 (px)，例如 10 + 5 等同于 10px + 5px。 对于两个不同的单位值之间的运算，运算结果的值取第一个值的单位 如果两个值中只有一个值有单位，则运算结果就去该单位 6. 条件语句LESS支持简单的条件语句来控制输出。 123456789101112131415// 条件语句.theme(@theme: light) &#123; @if (@theme == light) &#123; background-color: #fff; color: #000; &#125; @else if (@theme == dark) &#123; background-color: #000; color: #fff; &#125;&#125;// 使用条件语句.box &#123; .theme(dark);&#125; 7. 循环LESS支持简单的循环来重复执行一系列指令。 1234567891011121314151617// 循环示例.gradient(@colors: (red, yellow, blue)) &#123; @each $color in @colors &#123; .gradient-stop(@color); &#125;&#125;.gradient-stop(@color) &#123; .stop &#123; stop-color: @color; &#125;&#125;// 使用循环.box &#123; .gradient(red, yellow, blue);&#125; 实际应用示例下面是一个综合示例，展示如何使用LESS的各种特性来构建一个简单的响应式按钮： 123456789101112131415161718192021222324// 定义变量@base-color: #3f51b5;@text-color: #ffffff;@button-padding: 10px;// 混入定义.border-radius(@radius: 5px) &#123; border-radius: @radius; -webkit-border-radius: @radius; -moz-border-radius: @radius;&#125;// 混入使用.button &#123; background-color: @base-color; color: @text-color; padding: @button-padding; .border-radius(); // 使用默认半径 // 媒体查询 @media (max-width: 480px) &#123; padding: @button-padding / 2; &#125;&#125; 编译LESS到CSS要将LESS文件转换为浏览器可识别的CSS文件，你需要使用LESS编译器。有许多工具可以帮助你完成这个任务，包括： 命令行工具（如lessc） 浏览器插件 IDE插件 自动构建工具（如Gulp、Grunt） Vscode中的easyLess插件 例如，使用lessc命令行工具，你可以通过以下命令来编译LESS文件： 1lessc styles.less styles.css 以上就是LESS的基础知识和一些实用的示例。LESS让CSS变得更加模块化、可维护且易于扩展。随着对LESS的深入了解，你会发现它能极大地提升你的前端开发效率。 BootStrap开发框架简介Bootstrap 是全球最受欢迎的前端框架，用于构建响应式、移动设备优先的网站。利用 jsDelivr 和我们提供的入门模板帮助你快速掌握 Bootstrap。 使用1.下载 进入BootStrap官网：https://www.bootcss.com/ 选择合适的版本进行下载即可。 2.解压下载完后会得到这样的一个压缩包 我们进行解压即可，解压后，有两个文件分别是CSS文件和JS文件。我们按需引入即可 3.使用基础模板开始请确保使用最新的页面设计和开发标准来设置页面。也就是说，使用 HTML5 文档类型（doctype）、并包含一个设置 viewport（视口）的 &lt;meta&gt; 标签以实现正确的响应式布局行为。这些要求组合在一起之后，你的页面应当如下所示： 1234567891011121314151617181920212223242526272829&lt;!doctype html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;!-- 必须的 meta 标签 --&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;!-- Bootstrap 的 CSS 文件 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css&quot; integrity=&quot;sha384-xOolHFLEh07PJGoPkLv1IbcEPTNtaed2xpHsD9ESMhqIYd0nLMwNLD69Npy4HI+N&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;title&gt;Hello, world!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;!-- JavaScript 文件是可选的。从以下两种建议中选择一个即可！ --&gt; &lt;!-- 选项 1：jQuery 和 Bootstrap 集成包（集成了 Popper） --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js&quot; integrity=&quot;sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js&quot; integrity=&quot;sha384-7ymO4nGrkm372HoSbq1OY2DP4pEZnMiA+E0F3zPr+JQQtQ82gQ1HPY3QIVtztVua&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; &lt;!-- 选项 2：Popper 和 Bootstrap 的 JS 插件各自独立 --&gt; &lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js&quot; integrity=&quot;sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js&quot; integrity=&quot;sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.min.js&quot; integrity=&quot;sha384-Lge2E2XotzMiwH69/MXB72yLpwyENMiOKX8zS8Qo7LDCvaBIWGL+GlRQEKIpYR04&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; --&gt; &lt;/body&gt;&lt;/html&gt; Bootstrap布局容器BSP给我们提供了很多用来布局的容器，只需要指定class属性就可以。 布局容器地址：https://v4.bootcss.com/docs/layout/overview/ 容器容器是 Bootstrap 中最基本的布局元素，在使用我们的默认网格系统时必不可少。容器用于包含、填充和（有时）居中其中的内容。虽然容器可以嵌套，但大多数布局不需要嵌套容器。 Bootstrap 有三种不同的容器： .containermax-width，在每个响应断点处设置 .container-fluid，即width: 100%所有断点处 .container-&#123;breakpoint&#125;，直到width: 100%指定的断点 下表说明了每个容器max-width与原始容器.container以及.container-fluid每个断点的比较情况。 特小 &lt;576px 小 ≥576px 中 ≥768px 大号 ≥992px 特大 ≥1200px .container 100％ 540像素 720像素 960像素 1140像素 .container-sm 100％ 540像素 720像素 960像素 1140像素 .container-md 100％ 100％ 720像素 960像素 1140像素 .container-lg 100％ 100％ 100％ 960像素 1140像素 .container-xl 100％ 100％ 100％ 100％ 1140像素 .container-fluid 100％ 100％ 100％ 100％ 100％ 栅格系统使用我们强大的移动优先弹性框网格来构建各种形状和大小的布局，这得益于十二列系统、五个默认响应层、Sass 变量和混合以及数十个预定义类。 Bootstrap 的网格系统使用一系列容器、行和列来布局和对齐内容。它使用弹性框构建，并且完全响应。下面是一个示例，并深入介绍了网格的组成方式。 代码示例一定要深深的记住，我们的栅格系统是使用一系列的容器(container)，行(row)，列(column)来布局的 12345678910111213&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm&quot;&gt; One of three columns &lt;/div&gt; &lt;div class=&quot;col-sm&quot;&gt; One of three columns &lt;/div&gt; &lt;div class=&quot;col-sm&quot;&gt; One of three columns &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 网格选项 特小 &lt;576px 小 ≥576px 中 ≥768px 大号 ≥992px 特大 ≥1200px 最大容器宽度 无（自动） 540像素 720像素 960像素 1140像素 类前缀 .col- .col-sm- .col-md- .col-lg- .col-xl- 列数 12 12 12 12 12 天沟宽度 30px（每列两侧各 15px） 同前 同前 同前 同前 可嵌套 是的 是的 是的 是的 是的 列排序 是的 是的 是的 是的 是的 行(row)必须放到container里面 实现多列划分，需要给列添加类前缀，并指定份数，如果不指定份数则均分12份 列(column)大于12，多余的列所在的元素将被作为一个整体另起一行排列 每一行默认有左右15px的内边距 可以同时为一列指定多个设备的类名，以便划分不用份数，例如col-lg-3 col-md-4，这样写就意味着在不同屏幕下占不同的份数 列嵌套最好加一个行 row 这样可以取消父元素的padding值，而且高度自动和父元素一样 1234567891011121314&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg&quot;&gt; &lt;!-- 可以在插入一行来实现列嵌套 --&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-4&quot;&gt;a&lt;/div&gt; &lt;div class=&quot;col-lg-8&quot;&gt;b&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-lg&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;col-lg&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;col-lg&quot;&gt;4&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 列偏移您可以通过两种方式偏移网格列：1.响应式.offset-网格类2.我们的边距实用程序。网格类的大小与列的大小相匹配，而边距更适用于偏移宽度可变的快速布局。 偏移类使用类将列向右移动，语法：class=&quot;offset-md-偏移量&quot;，通过这个语法，我们将该列的左边相当于加了一列，列的长度就是我们指定的偏移量。，比如class=&quot;col-md-4 offset-md-4&quot;表示把列(col-md-4)向右偏移4份 添加偏移类后的代码 123456&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4&quot;&gt;A&lt;/div&gt; &lt;div class=&quot;col-md-4 offset-md-4&quot;&gt;B&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 效果： 列排序通过order实现列排序 order-first 把元素排列在第一位 order-last：把元素排列在最后一位 order-权重：这里的权重类似于优先级。可选数字的范围是 0~·12，权重越大，排序越靠前 示例代码 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;列排序.html&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./BootStrap/css/bootstrap.min.css&quot;&gt; &lt;style&gt; .row div &#123; width: 100%; background-color: skyblue; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;!-- 通过order实现列排序 order-first 把元素排列在第一位 order-last：把元素排列在最后一位 order-*：*这里指的是权重。可选数字的范围是 0~·12，权重越大， 排序越靠前 --&gt; &lt;div class=&quot;col-md-4 order-0&quot;&gt;A&lt;/div&gt; &lt;div class=&quot;col-md-8 order-1&quot;&gt;B&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 响应式工具display属性利用我们提供的 display 工具类可以快速改变组件的 display 属性等，并且支持响应式布局。还包括对一些常见值的支持，以及打印时用来控制 display 属性的一些额外工具类。 工作原理利用提供的工具类来控制元素的display属性。 命名如果 display 属性相关的工具类名称中间没有与断点相关的缩写（即 sm、md、lg、xl 等）的话，则能够影响所有 断点。 断点：可以理解为阈值，简单理解就是屏幕范围的分类，详见本笔记中的栅格系统下的网格选项小结 断点有：sm、md、lg、xl等。所以命名格式是下面这样的： .d-&#123;value&#125; for xs .d-&#123;断点&#125;-&#123;value&#125; for sm,md,lg,and xl。 ！！！注意：命名和语法不一样 其中，value的取值可以是下面任意一个 none inline inline-block block table table-cell table-row flex inline-flex 隐藏页面元素原理：控制元素的display属性值设置为none即可隐藏，如需隐藏某个页面元素，只需使用class=&quot;d-none&quot;即可，同时也可以在响应式布局下使用，比如class=&quot;d-&#123;断点&#125;-none&quot; 屏幕尺寸范围设p为屏幕尺寸 p &lt;576px 对应的断点名称为xs(特小屏幕) 576 &lt;&#x3D; p &lt;768px对应断点名称sm(小屏幕) 768px &lt;&#x3D; p &lt; 992px 对应断点名称为md(中等屏幕) 992px &lt;&#x3D; p &lt;&#x3D; 1200px 对应断点名称为lg(大屏幕) p&gt; 1200px 对应断点名称为xl(特大屏幕) 屏幕尺寸 类 在所有尺寸的屏幕上隐藏 .d-none 只在 xs 尺寸的屏幕上隐藏 .d-none .d-sm-block 只在 sm 尺寸的屏幕上隐藏 .d-sm-none .d-md-block 只在 md 尺寸的屏幕上隐藏 .d-md-none .d-lg-block 只在 lg 尺寸的屏幕上隐藏 .d-lg-none .d-xl-block 只在 xl 尺寸的屏幕上隐藏 .d-xl-none 在所有尺寸的屏幕上显示 .d-block 只在 xs 尺寸的屏幕上显示 .d-block .d-sm-none 只在 sm 尺寸的屏幕上显示 .d-none .d-sm-block .d-md-none 只在 md 尺寸的屏幕上显示 .d-none .d-md-block .d-lg-none 只在 lg 尺寸的屏幕上显示 .d-none .d-lg-block .d-xl-none 只在 xl 尺寸的屏幕上显示 .d-none .d-xl-block","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"手机，移动端，less","slug":"手机，移动端，less","permalink":"http://example.com/tags/%E6%89%8B%E6%9C%BA%EF%BC%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%8Cless/"}]},{"title":"JavaScript","slug":"JavaScript","date":"2024-07-30T09:46:48.000Z","updated":"2024-09-15T03:56:12.855Z","comments":true,"path":"2024/07/30/JavaScript/","permalink":"http://example.com/2024/07/30/JavaScript/","excerpt":"","text":"JS引入方式 内部脚本：将JS代码定义在HTML页面中 JavaScript代码必须位于script标签内 在HTML文档中，可以再任意地方 ，放置任意数量的script 一般会把脚本置于body元素的底部，可以改善显示速度 外部脚本：将JS代码定义在外部JS文件中，然后引入到HTML页面中 外部JS文件中，只包含JS代码，不包含script标签 script标签不能够自闭合，也就是不可以写成 JS基础语法书写语法 区分大小写：与java一样，变量名、函数名以及其他一切东西都是区分大小写的 每行结尾的分号可有可无 注释： 单行注释：&#x2F;&#x2F;注释内容 多行注释：&#x2F;注释内容 *&#x2F; 大括号代表代码块： 1234//判断if(count == 3)&#123;alert(count);&#125; 输出语句 1234window.alert() //写入警告框document.write()//写入HTML输出console.log()//在浏览器控制台输出内容console.dir()//在浏览器控制台输出对象 变量 JavaScript 中用 var关键字(variable 的缩写)来声明变量。 var的特点： 作用域比较大，全局变量。 可以重复定义同一个变量。相当于一个覆盖 JavaScript 是一门弱类型语言，变量可以存放不同类型的值。 123var a = &quot;张三&quot;;//定义a的值是字符串张三a = 20//把值20赋值给aalert(a)//输出20 变量名需要遵循如下规则: 组成字符可以是任何字母、数字、下划线(_)或美元符号($) 数字不能开头 建议使用驼峰命名(如userName) let 关键字来定义变量。它的用法类似于 var，但是所声明的变量，只在let 关键字所在的代码块内有效，且不允许重复声明。 const 关键字，用来声明一个只读的常量。一旦声明，常量的值就不能改变。 数据类型 JS中分为：原始类型和引用类型。 原始类型 运算符 算术运算符:+，-，*，&#x2F;，%，++，– 赋值运算符:&#x3D;，+&#x3D;，-&#x3D;，，&#x2F;&#x3D;,%&#x3D; 比较运算符:&gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;，!&#x3D;，&#x3D;&#x3D;，**&#x3D;&#x3D;&#x3D;** &#x3D;&#x3D;与&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;会进行类型转换，&#x3D;&#x3D;&#x3D;不会进行类型转换。 逻辑与(&amp;&amp;)与逻辑或(||)在编程中，&amp;&amp; 和 || 是逻辑运算符，它们用于组合布尔表达式。这些运算符在大多数支持C语言风格语法的编程语言中都是可用的，比如 C、C++、Java、JavaScript 等。 逻辑与 (&amp;&amp;)逻辑与运算符 &amp;&amp; 返回 true 当且仅当其两边的操作数都为 true。否则返回 false。 示例: 12345boolean a = true;boolean b = false;// 使用 &amp;&amp;boolean result = a &amp;&amp; b; // 结果为 false, 因为 b 是 false 逻辑或 (||)逻辑或运算符 || 返回 true 如果其任一操作数为 true。只有当两边的操作数都为 false 时才返回 false。 示例: 12345boolean x = true;boolean y = false;// 使用 ||boolean result = x || y; // 结果为 true, 因为 x 是 true 短路求值(重要)需要注意的是，这两个运算符具有短路求值的行为： 对于 &amp;&amp;，如果左边的操作数为 false，则右边的操作数不会被计算（因为无论右边是什么结果都不会改变最终结果）。 对于 ||，如果左边的操作数为 true，则右边的操作数不会被计算（同上）。 非运算符(!)非运算符 ! 接受一个操作数，并返回一个布尔值： 如果操作数是假值（falsy），则返回 true。 如果操作数是真的（truthy），则返回 false。 在 JavaScript 中，以下值被认为是假值： false 0 &quot;&quot; (空字符串) null undefined NaN 除了上述假值之外的所有值都被认为是真值。例如： 非零数值（如 1、-3） 非空字符串（如 &quot;hello&quot;） 数组（如 []、[1, 2, 3]） 对象（如 &#123;&#125;、new Date()） 三元运算符:条件表达式?true_value:false value 类型转换： 字符串类型转为数字： paseInt方法：这个方法能够将字符串转为数字，原理是从字符串左边开始读取，读取到不是数字的地方(如12A45他会读取到A这个为止而停下来)停下来，取该位置前面的输出。 alert(parseInt(&quot;12&quot;));//转为12 alert(parseInt(&quot;12A45&quot;));//转为12 alert(parseInt(&quot;A45&quot;));//转为NaN(not a number) 可以使用一元加号 (+) 前缀，来把字符串转为数字型。 其他类型转为boolean： Number类型：0和NaN转为false，其他均转为true。 String类型：空字符串转为false，其他 均转为true。 Null类型和undefined类型：均转为false。 隐式转换 检测数据类型 typeof + 检测的名字 流程控制 if…else if ….else…. switch for while do…while 值得注意的是，在JS中这些流程控制语句和我们的java是完全一致的。 break和continue JS函数函数的定义123456789function functionName(参数1，参数2...)&#123;//要执行的代码&#125;//另一种方式调用let functionName = function(参数1，参数2...)&#123; //要执行的代码&#125; 注意 形式参数不需要类型。因为JS是弱类型语言。 返回值类型也不需要定义，可以再函数内部直接使用return返回即可。 调用：函数名称(实际参数列表) 匿名函数 函数分为 函数表达式 &lt;script&gt; // 1.函数表达式 let fn = function (x,y)&#123; console.log( x + y ); &#125; fn(1,2); // 函数表达式 和具名函数(有名函数) 有什么不同呢？ // 1.具名函数的调用可以写到任何位置 // 2.匿名函数的函数表达式形式写法必须先声明在使用，否则会报错未声明 &lt;/script&gt; 123456789101112131415161718192021* 立即执行函数 * ```js // 1、立即执行函数 (function(x,y)&#123; console.log(x+y); &#125;)(1,2); // 2、第二种 写法 (function(x,y)&#123; console.log(x+y); &#125;(1,3)); // 上面结构中，第二个小括号是实参，function()中的小括号传递的是形参&#123;&#125;中写入要执行的逻辑 * 注意：多个立即执行函数要在函数末尾用分号隔开。 回调函数回调函数是编程中一个非常重要的概念，尤其在异步编程模型中极为常见。在JavaScript中，回调函数的应用尤为广泛，因为JavaScript是单线程的，但可以通过异步操作实现并发效果。 回调函数的基本概念回调函数就是一个作为参数传递给另一个函数的函数。当外部函数完成某些操作后，会“回调”这个函数作为处理结果的一种方式。这使得程序可以在等待某个耗时操作（如网络请求、文件读写等）的同时继续执行其他代码，而不会阻塞执行流程。 示例 假设你有一个函数doSomethingAsync，它需要一段时间才能完成操作。为了不让主线程等待，你可以传入一个回调函数，当doSomethingAsync完成时调用这个回调函数。 123456789101112function doSomethingAsync(callback) &#123; setTimeout(function() &#123; // 模拟异步操作 let result = &#x27;Data from async operation&#x27;; callback(result); &#125;, 2000); // 假设这个操作需要2秒&#125;// 使用回调函数doSomethingAsync(function(data) &#123; console.log(&#x27;Received data:&#x27;, data);&#125;); 在这个例子中，doSomethingAsync函数接受一个回调函数作为参数。当异步操作完成时，它调用回调函数并传递结果。这样，即使doSomethingAsync需要较长时间来完成，主线程也不会被阻塞，可以立即执行后续代码。 注意事项回调函数可以导致所谓的“回调地狱”（Callback Hell），特别是当多个异步操作嵌套在一起时。这种情况下，代码结构可能会变得难以阅读和维护，因为每个操作的回调都嵌套在前一个操作的回调内。为了解决这个问题，现代JavaScript倾向于使用Promise链和async&#x2F;await语法来使异步代码看起来更像同步代码。 递归函数什么叫递归函数呢？ 如果一个函数在内部可以调用其本身，那么这个函数就是递归函数 简单理解：函数内部自己调用自己，这就是递归函数。 递归函数的作用和循环效果类似。 由于递归很容易发生”栈溢出”错误，所以必须要有退出条件 return 生成一个范围随机数 Math.random()是随机数函数，返回一个0~1之间的浮点数，并且不包括1，包括0 Math.floor()向下取整，比如8.9就取8；10.4就取10 如生成0-10的随机数 1Math.floor(Math.random() * 11) 生成X~N之间的随机数 1Math.floor(Math.random() * (X + N)) JS对象Array(数组对象) 定义：let 变量名 &#x3D; new Array(元素列表)；或者let 变量名&#x3D; [元素列表]; 1234&lt;script&gt; //定义数组 let arr1 = new Array(1,2,3,4,5); //或者let arr1 = [1,2,3,4,5] JavaScript 数组方法 把数组转换为数组值（逗号分隔）的字符串。：toString() 将所有数组元素结合为一个字符串，可以指定分隔符：join() var fruits = [&quot;Banana&quot;, &quot;Orange&quot;,&quot;Apple&quot;, &quot;Mango&quot;]; document.getElementById(&quot;demo&quot;).innerHTML = fruits.join(&quot; * &quot;); &lt;!--结果是：Banana * Orange * Apple * Mango --&gt; 12345678910- 从数组中删除最后一个元素，并返回被删除的值：`pop()`- （在数组结尾处）向数组添加一个新的元素，并返回新数组的长度：`push()`- 向数组追加新元素的简易方法：`length` - ```js var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; fruits[fruits.length] = &quot;Kiwi&quot;; // 向 fruits 追加 &quot;Kiwi&quot; 删除首个数组元素，并把所有其他元素“位移”到更低的索引，返回被删除的值：shift() var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; fruits.shift(); // 从 fruits 删除第一个元素 &quot;Banana&quot; 1234567891011121314151617181920212223242526272829303132333435363738394041- 使用delete也可以删除数组元素，但是会导致留空洞，空洞会变为`undefine`推荐使用`pop或shift方法删除元素`。- （在开头）向数组添加新元素，并把旧元素向后移动，并返回新数组的长度：`unshift()`- 用于向数组添加新项，该函数接收两个参数：`splice()` - 第一个参数定义在某个索引位置之前添加新元素(拼接) - 第二个参数定义删除多少元素 - 剩下参数定义要添加的新元素 - 该函数返回值是被删除元素组成的数组 - 也可以使用该函数进行删除元素（第一个参数是要删除元素的索引，第二个参数是删除元素的个数，比如`fruits.splice(0, 1); `） - 比如：`fruits.splice(2, 0, &quot;Lemon&quot;, &quot;Kiwi&quot;);` - 通过合并（连接）现有数组来创建一个新数组：`concat()` - `concat()` 方法可以使用任意数量的数组参数 - `concat()` 方法不会更改现有数组。它总是返回一个新数组。 - 参数可以是具体的值，也可以是数组 - 用数组的某个片段切出新数组：`slice()` - `slice()` 方法创建新数组。它不会从源数组中删除任何元素。 - `slice()` 可接受两个参数(索引)，比如 (1, 3)。 - 切的区间是前闭后开的，也就是包括1，不包括3 - 如果结束参数没写，那么会从索引位置向后切出剩余部分，包括索引位置处的元素### JavaScript 数组排序- 以字母顺序对数组进行排序：`sort()`！！！只对字母生效，数字无效 - 如果想用该函数比较数字，**则应该通过比值函数**来修正 - 比值函数：`(a,b)=&gt; return a-b;`升序 **/** `(a,b)=&gt; return b-a;`降序- 反转数组中的元素：`reverse()`- 查找数组中的最高值：`Math.max.apply`，举例子： - ```js //在本例中，我们使用 apply() 来正确地将数组 arr 的所有元素作为单独的参数传递给 Math.max()。 //由于 Math.max() 不依赖于 this 的值，所以通常这里会传入 null 或者 undefined。 function myArrayMax(arr) &#123; return Math.max.apply(null, arr); &#125; 找数组中的最低值：Math.min.apply 比较字符串： cars.sort(function(a, b)&#123; var x = a.type.toLowerCase(); var y = b.type.toLowerCase(); if (x &lt; y) &#123;return -1;&#125; if (x &gt; y) &#123;return 1;&#125; return 0; &#125;); 1234567891011121314151617### JavaScript 数组迭代- 为每个数组元素调用一次函数（回调函数）：`forEach(function(value,index,array)&#123;&#125;)` - 该函数接收三个参数：value,index,array - 该函数只对数组进行遍历，不返回新数组。 - ```js var txt = &quot;&quot;; var numbers = [45, 4, 9, 16, 25]; numbers.forEach(myFunction); function myFunction(value, index, array) &#123; txt = txt + value + &quot;&lt;br&gt;&quot;; &#125; map(function(value,index,array)&#123;&#125;)方法 map() 方法通过对每个数组元素执行函数来创建新数组。 map() 方法不会对没有值的数组元素执行函数。 map() 方法不会更改原始数组。 该方法返回一个新数组。 同样，它也有3个参数：项目值，项目索引，数组本身 创建一个包含满足某些条件的数组元素的新数组：filter(function(value,index,array)&#123;&#125;) 它有3个参数：项目值，项目索引，数组本身 var numbers = [45, 4, 9, 16, 25]; var over18 = numbers.filter(myFunction); function myFunction(value, index, array) &#123; return value &gt; 18; &#125; 12345- 可以用来对数组中的所有元素进行聚合计算，比如求和、计算乘积、查找最大值/最小值：`reduce()` - ```js array.reduce(callback(returnData, currentValue[, currentIndex[, array]])[, initialValue]) reduce函数的执行顺序是从左到右，函数reduceRight()是从右到左，语法完全一致。 该函数接受一个回调函数（callback()），它会被执行数组中的每一个元素（除了第一个，除非提供了初始值）。 returnData：该参数是该回调函数的返回值，同时它也是下次调用时的第一个参数。 currentValue：当前元素的值。 currentIndex：可选的，当前元素的索引。 array：可选的，被遍历的数组本身。 initialValue：初始值，可选。 对于该方法做出如下特别解释： 可接受初始值，如果给出初始值那么给出的值会被赋值给returnData let arr = [1, 2, 3, 4, 5, 7]; let sum = arr.reduce((callback,value)=&gt;&#123; return callback + value &#125;) console.log(sum); 123456789- ```js var numbers1 = [45, 4, 9, 16, 25]; //调用回调函数的同时传入了初始值100 var sum = numbers1.reduce(myFunction, 100); function myFunction(total, value) &#123; return total + value; &#125; 检查所有数组值是否满足某个条件： every(function(value,index,array)&#123;&#125;) 接受3个参数：项目值(value)，项目索引(index)，数组本身(array) 如果所有值满足该条件，返回true，如果所有值当中有一个不满足，则返回false 检查某些数组值是否满足某个条件： some(function(value,index,array)&#123;&#125;) 接受3个参数：项目值(value)，项目索引(index)，数组本身(array) 如果数组当中的某些值满足条件，则返回true，否则返回false 在数组中搜索元素值并返回其位置： indexOf() 语法：array.indexOf(item, start)，item是查找的项目，start用来定义开始起点（start值小于0时，将从结尾开始的给定位置开始，并查到到结尾）。 如果未找到，则返回-1 如果某项目多次出现，则返回第一次出现的位置(索引) ！！！特别注意：一定要注意该函数执行的方向，开始位置可能会变，但执行顺序是不会变的 从数组结尾处开始查找： lastindexOf() 语法： item 必需。要检索的项目。 start 可选。从哪里开始搜索。负值将从结尾开始的给定位置开始，并搜索到开头。 ！！！特别注意：一定要注意该函数执行的方向，开始位置可能会变，但执行顺序是不会变的 返回数组中满足某个条件的第一个元素的值： find(function(value,index,array)&#123;&#125;) 接受3个参数：项目值(value)，项目索引(index)，数组本身(array) 返回数组中满足某个条件的第一个元素的索引值： findIndex(function(value,index,array)&#123;&#125;) 接受3个参数：项目值(value)，项目索引(index)，数组本身(array) String对象1234567&lt;script&gt; //String对象 //方式一： var stringTest = new String(&quot;zhangsan&quot;); //方式二： var stringTest1 =&quot;lisi&quot;;&lt;/script&gt; JavaScript 字符串方法查找字符串中的字符串 length 属性返回字符串的长度： var txt = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; var sln = txt.length; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465- `indexOf()` 方法返回字符串中指定文本*首次*出现的索引（位置）： - 从0计算 - 未找到返回-1 - 可传递起始位置参数- `lastIndexOf()` 方法返回指定文本在字符串中*最后*一次出现的索引： - 未找到返回-1 - 可传递起始位置参数 - 检索方向：从结尾向开始方向检索#### 检索字符串中的字符串- `search()` 方法搜索特定值的字符串，并返回匹配的位置： - 返回首次出现的位置。 - 可以使用正则表达式进行匹配#### 提取部分字符串**！！！！**值得注意的是，下面这三种切字符串的方法，索引值是负值的时候，只是指定了重字符串末尾开始，而没有改变切割方向，切割方向还是从左到右的- `slice()` 提取字符串的某个部分并在新字符串中返回被提取的部分。 - slice有切割，切片的意思 - 两个参数：开始索引和结束索引，切出来的片段不包括结束索引。 - 参数值可以是负数，如果出现负数则意味着从字符串结尾开始计数 - 如果只有一个参数，那么就是从该位置向后切- `substring()` 类似于 `slice()`，但不接受负值索引： - 两个参数：开始索引和结束索引，切出来的片段不包括结束索引。 - 如果只有一个参数，那么就是从该位置向后切 - 参数不能为**负值**#### 替换字符串内容- `replace()` 方法用另一个值替换在字符串中指定的值： - 返回值是一个新的字符串，对原字符串无影响。 - 默认只替换首个匹配 - 该函数对大小写敏感(注意字母的大小写) - 参数1：要替换谁？参数2：替换为谁#### 转换为大写和小写- 通过 `toUpperCase()` 把字符串转换为大写- 通过 `toLowerCase()` 把字符串转换为小写#### concat()方法- `concat()` 连接两个或多个字符串： - 可替换`+`，我们知道`+`有可以用来拼接字符串 - 不改变原来字符串，返回一个新的字符串#### trim()方法- `trim()`方法删除字符串两端的空白符#### 提取字符串字符- `charAt()` 方法返回字符串中指定下标（位置）的字符串： - 返回指定索引位置的字符- `charCodeAt()` 方法返回字符串中指定索引的字符 unicode 编码： - 返回指定索引位置字符的unicode编码#### 属性访问（Property Access）```jsvar str = &quot;HELLO WORLD&quot;;str[0]; // 返回 H 但不推荐这样使用。 把字符串转换为数组 split() 将字符串转换为数组： 可指定分隔符。如果指定了分隔符，那么它会把字符串中的每个字符按照给定的分隔符分割成一个单个的字符串并返回一个数组 let str2 = &quot;LI,ZE,WEI&quot; console.log(str2.split(&quot;,&quot;));//返回[&#39;LI&#39;, &#39;ZE&#39;, &#39;WEI&#39;] 123456- 指定了分隔符，但分隔符是空字符串(`&quot; &quot;`)，那么被返回的数组将是间隔单个字符的数组 - ```js let str2 = &quot;LI,ZE,WEI&quot; console.log(str2.split(&quot;&quot;)); //返回[&#x27;L&#x27;, &#x27;I&#x27;, &#x27;,&#x27;, &#x27;Z&#x27;, &#x27;E&#x27;, &#x27;,&#x27;, &#x27;W&#x27;, &#x27;E&#x27;, &#x27;I&#x27;] 如果未指定分隔符，则返回一个由该字符串本身组成的数组，该字符串就是数组的第一个元素 let str2 = &quot;LI,ZE,WEI&quot; console.log(str2.split()); //返回[&#39;LI,ZE,WEI&#39;] 1234567891011121314151617181920212223### JavaScript 字符串搜索- String.indexOf()- String.lastIndexOf()- String.startsWith()- String.endsWith()本小节着重介绍后两个方法，前两个方法在上一小节已经介绍过了#### String.match()- match() 方法根据正则表达式在字符串中搜索匹配项，并将匹配项作为 **Array 对象**返回。 - 参数是一个正则表达式 - 如果正则表达式没有加`g`修饰符，则匹配第一个符合表达式的字符串 - 若没有符合条件的字符串，则返回null - ```js let text = &quot;The rain in SPAIN stays mainly in the plain&quot;; text.match(/ain/g) // 返回数组 [ain,ain,ain] String.includes() 如果字符串包含指定值，includes() 方法返回 true。 两个参数：第一个为要检索的值，第二个参数为开始索引 该方法是ES6新引入的 开始索引如果是负值，改变了索引方向，也改变了检索方向 对大小写敏感 String.startsWith() 如果字符串以指定值开头，则 startsWith() 方法返回 true，否则返回 false：、 两个参数：第一个是要检索的值，必选；第二个开始位置，可选 对大小写敏感，区分大小写 String.endsWith() 如果字符串以指定值结尾，则 endsWith() 方法返回 true，否则返回 false： 两个参数：第一个是要检索的值，必选；第二个开始位置，可选 区分大小写 为了很好记忆做出的总结 数组： 添加元素的方法：push()在末尾添加，unshift()在头部添加，splice()能够更精确添加元素 删除元素的方法：pop()在末尾删除，shift()在头部删除，splice()也能够进行元素删除 对数组进行切片：slice()方法 把数组转换为字符串：join()方法 字符串： 字符串长度：length属性 把字符串转换为数组：split()，可以指定分隔符 对字符串进行切割：slice()方法 json对象 概念: JavaScript Object Notation，JavaScript，对象标记法 JSON 是通过JavaScript 对象标记法书写的文本。 由于其语法简单，层次结构鲜明，现多用于作为数据载体，在网络中进行数据传输。 数据格式： 123456&#123;&quot;name&quot; : &quot;xiaoli&quot;,&quot;age&quot;:25,&quot;sex&quot;:&quot;男性&quot;, &quot;key1&quot;:&quot;value1&quot;&#125; 定义json案例 1234567891011&lt;script&gt; //定义json var jsonStr = &#x27;&#123;&quot;name&quot; = &quot;小李&quot;,&quot;age&quot; = 25, &quot;address&quot; = &quot;北京&quot; &#125;&#x27;; //JSON字符串转为JS对象——JSON.parse()方法 var jsonStrObject = JSON.parse(jsonStr); console.log(jsonStrObject); //JS对象转为JS字符串——JSON.stringify()方法 var jsObject = JSON.stringify(jsonStrObject); console.log(jsObject);&lt;/script&gt; BOM对象 概念:Browser Object Model 浏览器对象模型，允许lavaScript与浏览器对话，lavaScript 将浏览器的各个组成部分封装为对象。 Window对象 介绍:浏览器窗口对象。 获取:直接使用window，其中 window.可以省略window.alert()和alert()效果一样 属性 history:对 History 对象的只读引用。请参阅 History 对象 location:用于窗口或框架的 Location 对象。请参阅Location 对象。 navigator:对 Navigator 对象的只读引用。请参阅Navigator 对象 介绍 windows是一个全局对象 所有通过var定义在全局作用域中的变量、函数都会变成window对象的属性和方法 window对象下的属性和方法调用的时候可以省略window 方法 alert():显示带有一段消息和一个确认按钮的警告框。 confirm():显示带有一段消息以及确认按钮和取消按钮的对话。 **setlnterval():**按照指定的周期(以毫秒计)来调用函数或计算表达式。 setTimeout():在指定的毫秒数后调用函数或计算表达式。 **setlnterval()和setTimeout()**都可以进行清除操作 123456789101112//延时函数参数有两个，一个是回调函数，一个是延时的秒数let timer1 = setTimeout(() =&gt; &#123; console.log(&quot;2秒后打印&quot;);&#125;, 2000);//清除延时函数clearTimeout(timer1)//周期执行函数参数有两个，一个是回调函数，一个是周期执行的秒数let timer2 = setInterval(() =&gt; &#123; console.log(&quot;1111&quot;);&#125;, 1000);//清除周期执行函数clearInterval(timer2) 示例代码： 123456789101112131415161718192021&lt;script&gt; //获取 window.alert(&quot;Hello BOM&quot;); alert(&quot;Hello BoM window&quot;); // 方法 // confirm-对话框--确认:true ，取消:false var flag = confirm(&quot;您确认删除该记录吗?&quot;); alert(flag); // 定时器-setInterval -- 周期性的执行某一个函数 var i=0; setInterval(function()&#123; i++; console.log(&quot;定时器执行了&quot;+i+&quot;次&quot;); &#125;,2000); //定时器延迟指定时间执行一次:-setTimeout setTimeout(function()&#123; alert(&quot;Js&quot;); &#125;,3000); &lt;/script&gt; Location对象 介绍：地址栏对象。 获取：使用window.location获取，其中window.可以省略不写 属性： href：设置或返回完整的URL，如果设置URL那么他会自动跳转所设置的URL。 search：返回地址中参数部分。 hash：用于获取或设置URL中的 “#（锚点）” 后面的部分。这个属性返回一个字符串，该字符串以 “#” 开头。 **reload()**：用于重新加载当前文档。传入参数true表示强制刷新，类似与ctrl+F5 代码示例： 123456&lt;script&gt; //获取当前完整的URL console.log(location.href); //设置URL自动跳转 location.href=&quot;http://www.itcast.cn&quot;&lt;/script&gt; navigator对象 navigator的数据类型是对象，该对象记录了浏览器自身的相关信息 常用属性和方法 userAgent：检测浏览器的版本以及平台 history对象 history的数据类型是对象，它管理历史记录，该对象与浏览器地址栏的操作相应，如前进、后退、历史记录等等 常用属性和方法 history对象方法 back() 可以后退 forword() 前进 go(参数) 前进后退功能，参数是1前进一个页面，如果是-1则后退一个页面 DOM对象什么是DOM 概念:Document Object Model，文档对象模型。 将标记语言的各个组成部分封装为对应的对象： Document：整个文档对象 Element：元素对象 Attribute：属性对象 Text：文本对象 Comment：注释对象 JavaScript 通过DOM，就能够对HTML进行如下操作： 改变 HTML元素的内容 改变 HTML元素的样式(CSS) 对 HTML DOM 事件作出反应 添加和删除 HTML元素 DOM节点让我们通过一些简单的例子来理解 DOM 节点： 文档节点（Document Node）文档节点代表整个 HTML 或 XML 文档。它是所有其他节点的父节点。 123&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;!-- &quot;document&quot; 是文档节点 --&gt; 元素节点（Element Node）元素节点是 HTML 标签，如 &lt;div&gt;、&lt;p&gt; 等。 12&lt;div id=&quot;example&quot;&gt;&lt;!-- &quot;&lt;div&gt;&quot; 和 &quot;&lt;/div&gt;&quot; 是元素节点 --&gt; 属性节点（Attribute Node）属性节点是 HTML 元素上的属性，例如 id、class 等。 12&lt;div id=&quot;example&quot; class=&quot;container&quot;&gt;&lt;!-- &quot;id&quot; 和 &quot;class&quot; 是属性节点 --&gt; 文本节点（Text Node）文本节点是元素内的纯文本，不包含任何 HTML 标签。 12&lt;p&gt;Hello, world!&lt;/p&gt;&lt;!-- &quot;Hello, world!&quot; 是文本节点 --&gt; 注释节点（Comment Node）注释节点是 HTML 文档中的注释。 12&lt;!-- This is a comment --&gt;&lt;!-- 这个是注释节点 --&gt; 查找节点在该小节，我们主要利用关系来查找 父节点查找(只能找到最近一级) 父节点查找 用途：获取当前元素的父节点。 语法：element.parentNode 子节点查找 子节点查找 用途：获取当前元素的所有子节点（包括文本节点和元素节点）。 语法：fatherElement.childNodes 用途：获取当前元素的第一个或最后一个子节点。 语法：fatherElement.firstChild 或 fatherElement.lastChild 用途：获取所有的元素节点 语法：fatherElement.children 该方法返回一个伪数组(1.索引访问：可以使用索引来访问元素，类似于数组的方式。2.长度属性：通常有一个 length 属性，表示对象中的元素数量。3.非数组：不是真正的 Array 类型对象，因此不支持数组的一些方法（如 .push()、.pop()、.slice() 等） 兄弟节点查找 下一个兄弟节点： 用途：获取当前元素的下一个同级元素节点。 语法：element.nextElementSibling 上一个兄弟节点： 用途：获取当前元素的上一个同级元素节点。 语法： element.previousElementSibling 新增节点创建节点使用 document.createElement(&#39;标签名&#39;) 方法来创建一个新的 HTML 元素。 1const newElement = document.createElement(&#x27;div&#x27;); 设置属性和内容你可以设置新元素的属性和内容。 12newElement.id = &#x27;newDiv&#x27;;newElement.textContent = &#x27;这是一个新的 div 元素。&#x27;; 添加节点到DOM中将新元素添加到文档树中的某个位置。常见的方法有： appendChild()：将新元素作为最后一个子节点添加到指定的父节点中。 **insertBefore()**：插入到父元素中某个子元素的前面，参数有两个：第一个是要插入的新元素，第二个参数是参考的元素 **replaceChild()**：替换父元素中某个子元素 **removeChild()**：移除指定的子节点。 举个例子 示例：添加到文档末尾 1document.body.appendChild(newElement); 在某个元素前插入 12const referenceElement = document.getElementById(&#x27;reference&#x27;);referenceElement.parentNode.insertBefore(newElement, referenceElement); 替换某一个元素 12const oldElement = document.getElementById(&#x27;old&#x27;);oldElement.parentNode.replaceChild(newElement, oldElement); 克隆节点使用背景 复制一个原有节点 把复制的节点放入到指定的元素内部 克隆节点 用途：复制出一个一模一样的节点 语法：element.cloneNode() 参数：若为true，则克隆时会包含后代节点以及内容一起克隆，若为false则不包含后代节点。 默认是false 删除节点 在JS中如要删除某个节点，必须通过其父元素进行删除 语法：fatherElemnet.removeChild(要删除的元素) 若不存在父子关系，则无法删除 如果该节点被删除，那么就会从html中移除该节点。 日期对象在JavaScript中，Date 对象用于处理日期和时间。这个内置对象可以用来获取、设置以及操作日期和时间数据。下面是一些关于 Date 对象的基本使用方法： 创建 Date 对象 无参数 - 创建一个表示当前日期和时间的对象： 1const now = new Date(); 带参数 - 创建一个指定日期和时间的对象： 1const specificDate = new Date(2024, 7, 17); // 注意月份是从 0 开始的，所以 8 月是 7 毫秒数 - 创建一个从1970年1月1日午夜开始经过的毫秒数所表示的日期： 这里的参数是从开始时间~结束时间所经过的毫秒数。 1const milliSecondsSinceEpoch = new Date(1692278827000); 日期对象的常用方法获取日期和时间的部分你可以使用 Date 对象的方法来获取日期和时间的不同部分，例如： getFullYear(), getMonth(), getDate() getHours(), getMinutes(), getSeconds(), getMilliseconds() getTime() - 返回从1970年1月1日午夜开始经过的毫秒数。 getDay()-返回星期，0~6 示例： 1234const today = new Date();console.log(today.getFullYear()); // 输出当前年份console.log(today.getMonth()); // 输出当前月份（0-11）console.log(today.getDate()); // 输出当前日期（1-31） 设置日期和时间的部分同样也可以设置日期和时间的不同部分，例如： setFullYear(), setMonth(), setDate() setHours(), setMinutes(), setSeconds(), setMilliseconds() setTime() - 设置从1970年1月1日午夜开始经过的毫秒数。 示例： 12345const today = new Date();today.setFullYear(2025);today.setDate(1);today.setMonth(0); // 设置为一月console.log(today); 格式化日期JavaScript 中没有内置的日期格式化函数，但你可以使用第三方库如 Moment.js 或者使用模板字符串和计算来实现简单的格式化，例如： 123const today = new Date();const formattedDate = `$&#123;today.getFullYear()&#125;-$&#123;(&#x27;0&#x27; + (today.getMonth() + 1)).slice(-2)&#125;-$&#123;(&#x27;0&#x27; + today.getDate()).slice(-2)&#125;`;console.log(formattedDate); // 输出 &quot;2024-08-17&quot; 在格式化日期中，遇到时分秒补0时，可以使用三元运算符 其他方法在JavaScript中，Date 对象提供了多个方法来格式化日期和时间。其中 toLocaleString() 是一个非常有用的内置方法，它返回一个表示日期&#x2F;时间的本地格式化的字符串。此外，还有其他一些相关的方法可以帮助你以不同的方式格式化日期。 1. toLocaleString()toLocaleString() 方法返回一个本地化格式的日期&#x2F;时间字符串。默认情况下，它会使用浏览器的语言环境设置来决定日期的格式。 12const date = new Date();console.log(date.toLocaleString()); // 输出本地格式的日期和时间 2. toLocaleDateString()toLocaleDateString() 方法仅返回日期部分的本地化格式字符串。 12const date = new Date();console.log(date.toLocaleDateString()); // 输出本地格式的日期 3. toLocaleTimeString()toLocaleTimeString() 方法仅返回时间部分的本地化格式字符串。 12const date = new Date();console.log(date.toLocaleTimeString()); // 输出本地格式的时间 参数选项这些方法都支持选项对象作为参数，允许你进一步定制输出格式。例如，你可以指定使用24小时制还是12小时制，是否显示秒等。 123const options = &#123; weekday: &#x27;long&#x27;, year: &#x27;numeric&#x27;, month: &#x27;long&#x27;, day: &#x27;numeric&#x27; &#125;;const date = new Date();console.log(date.toLocaleDateString(&#x27;en-US&#x27;, options)); // 自定义格式 更多方法除了上面提到的方法外，Date 对象还提供了其他一些有用的方法： toString()：返回日期&#x2F;时间的标准格式字符串。 toISOString()：返回一个符合 ISO 标准的日期&#x2F;时间字符串。 toJSON()：与 toISOString() 类似，用于 JSON 序列化。 toUTCString()：返回日期&#x2F;时间的 UTC 字符串格式。 toLocaleDateString() 和 toLocaleTimeString() 的更多选项：可以指定时区、时间格式等。 时间戳 使用场景：制作倒计时效果 什么是时间戳：指从1970年01月01日00时00分00秒起至现在的毫秒数。 获取时间戳要获取当前时间的时间戳，可以使用 Date.now() 方法： 12const timestamp = Date.now(); // 获取当前时间的时间戳console.log(timestamp); 如果你已经有了一个 Date 对象，可以通过调用 getTime() 方法来获取该日期对应的时间戳： 123const date = new Date();const timestampFromDate = date.getTime(); // 获取Date对象对应的时间戳console.log(timestampFromDate); 同样，如果有了Date对象，可以通过在 new Date()前面加一个转换获得 123const date = new Date();//通过隐式转换，把字符型转换为数字型来获取 console.log(+ new Date()); 第2,3中方法可以获取指定时间的时间戳。 时间戳转换为日期如果你有一个时间戳并想将其转换为 Date 对象，可以使用 new Date(timestamp) 构造函数： 123const timestamp = 1692278827000; // 给定的时间戳const dateFromTimestamp = new Date(timestamp); // 将时间戳转换为Date对象console.log(dateFromTimestamp); 使用时间戳时间戳在JavaScript中非常有用，尤其是在需要比较不同时间点或者执行定时任务时。例如，你可以使用时间戳来计算两个时间点之间的时间差： 12345const startTime = Date.now();// 执行某些操作...const endTime = Date.now();const timeDifference = endTime - startTime;console.log(`操作耗时 $&#123;timeDifference&#125; 毫秒`); 实际应用这里是一个示例，展示如何使用时间戳来计算从1970年1月1日到2024年8月17日这段时间的时间戳： 12345// 计算2024年8月17日的时间戳const targetDate = new Date(2024, 7, 17); // 注意月份是从0开始的const targetTimestamp = targetDate.getTime();console.log(targetTimestamp); // 输出时间戳 JS事件监听事件:HTML事件是发生在HTML元素上的“事情”。比如: 按钮被点击 鼠标移动到元素上 按下键盘按键 事件监听:JavaScript可以在事件被侦测到时 执行代码。 事件绑定 方式一：通过HTML标签中的时间属性进行绑定 1234567&lt;input type=&quot;button&quot; onclick=&quot;on()&quot; value=&quot;按钮1&quot;&gt;&lt;script&gt; function on() &#123; alert(&#x27;我被点击了!); &#125;&lt;/script&gt; 方式二：通过DOM元素属性绑定 1234567&lt;input type = &quot;button&quot; id =&quot;btn1&quot; value = &quot;按钮2&quot;&gt;&lt;script&gt;document.getElementById(&quot;btn1&quot;).onclick = function() &#123; alert(&quot;我被点击了！&quot;); &#125;&lt;/script&gt; 常见事件在JavaScript中，事件是用户或浏览器的动作，它们可以触发预定义的函数或代码块。事件驱动的编程是现代Web开发的核心部分，允许网站对用户的交互作出反应。以下是在JavaScript中常见的几种事件类型： 鼠标事件 click：当用户点击鼠标左键时触发。 dblclick：当用户双击鼠标左键时触发。 mousedown：当鼠标按钮被按下时触发。 mouseup：当鼠标按钮被释放时触发。 mousemove：当鼠标在页面上移动时持续触发。 mouseenter 和 mouseleave：当鼠标进入或离开一个元素时触发。这两个事件不会存在冒泡和捕获。 mouseover 和 mouseout：类似于 mouseenter 和 mouseleave，会存在捕获和冒泡阶段 contextmenu：当用户右击鼠标时触发。 键盘事件 keydown：当键盘上的一个键被按下时触发。 keypress：当按下有字符输出的键时触发。 keyup：当键盘上的一个键被释放时触发。 文档和窗口(window)事件 load：当页面或资源加载完成时触发。 unload：当页面正在卸载时触发。 beforeunload：页面即将卸载之前触发。 resize：当窗口大小改变时触发。 scroll：当页面滚动时触发。 表单事件 change：当表单元素（如输入框、下拉列表）的内容被改变时触发。 focus 和 blur：当元素获得或失去焦点时触发。 submit：当表单被提交时触发。 其他事件 error：当错误发生时触发，如图像加载失败。 resize 和 scroll：分别在窗口尺寸变化或滚动时触发。 touchstart, touchend, touchmove：触摸设备上的事件。 事件处理可以通过直接在HTML标签中设置事件属性（如onclick=&quot;someFunction()&quot;），或者通过JavaScript的addEventListener来监听事件 事件对象事件处理器通常会接收到一个事件对象，这个对象包含了关于事件的所有信息，如事件类型、触发事件的元素、鼠标的位置、键盘按键等。事件对象通常作为函数的第一个参数传递，例如： 123element.addEventListener(&#x27;click&#x27;, function(event) &#123; console.log(event.type); // 输出 &quot;click&quot;，这里的event指的是事件对象&#125;); 事件对象在JavaScript中提供了一系列的属性，用于描述触发事件的详细信息。下面列出了事件对象中一些常用的属性： type 描述事件的类型，如 ‘click’, ‘keydown’, ‘load’ 等。 target 指向事件最初触发的DOM元素。即使事件被冒泡到其他元素，target始终指向最初触发事件的元素。 currentTarget 指向当前正在处理事件的DOM元素。如果事件被冒泡或捕获，currentTarget将根据事件流而变化。 eventPhase 描述事件当前处于哪个阶段：AT_TARGET (2)，CAPTURING_PHASE (1)，或 BUBBLING_PHASE (3)。 timeStamp 事件发生的精确时间戳，单位通常是毫秒。 preventDefault() 方法，阻止事件的默认行为。例如，在链接上阻止页面跳转。 stopPropagation() 方法，阻止事件冒泡到父级元素。 stopImmediatePropagation() 类似于stopPropagation(), 但是它还会阻止事件处理函数队列中的后续函数执行。 clientX 和 clientY 对于鼠标事件，表示鼠标指针相对于视口的位置（不包括滚动条偏移）。 pageX 和 pageY 对于鼠标事件，表示鼠标指针相对于整个文档的位置（包括滚动条偏移）。 screenX 和 screenY 对于鼠标事件，表示鼠标指针相对于屏幕的位置。 button 对于鼠标事件，表示哪个鼠标按钮被按下：0（主按钮，通常是左键），1（中间按钮），2（次按钮，通常是右键）。 keyCode 或 key 对于键盘事件，keyCode 是一个数字，表示按下的键。在现代浏览器中，更推荐使用key属性，它是一个字符串，提供了更清晰的键标识。 which 类似于keyCode，但跨浏览器兼容性更好。 ctrlKey, altKey, shiftKey, metaKey 布尔值，表示是否同时按下了Ctrl, Alt, Shift, 或 Meta (Command) 键。 环境对象环境对象：指的是函数内部特殊的变量this，它代表着当函数运行时所处的环境 作用：弄清楚this的指向，this指代的对象也不同 函数调用方式不同，this指代的对象也不同。 谁调用该函数，this就指向谁，这是判断this指向的粗略规则 事件流定义：事件流指定是一个事件完整执行过程中的流动路径 在JavaScript中，事件流描述了事件是如何在文档对象模型（DOM）中传播的。事件流主要分为两个阶段：事件捕获和事件冒泡。还存在一个中间阶段，即目标阶段，在这个阶段事件直接作用于目标元素。 事件捕获 (Event Capturing)这是事件流第一阶段：从父到子 事件捕获是从DOM树的根节点（通常是document或window）开始，事件沿着元素层级向下传播，直到达到目标元素。在这一阶段，事件处理程序有机会在事件到达目标元素之前进行拦截和响应。 给addEvenListener函数写入第三个参数，true，意味着开启了捕获机制。 事件要同名。 目标阶段 (Target Phase)一旦事件到达目标元素，目标元素上的事件处理程序被调用。这是事件直接作用于触发事件的元素的阶段。 事件冒泡 (Event Bubbling)这是事件流第二阶段：从子到父 在事件冒泡阶段，事件从目标元素开始，沿DOM树向上逐级传播，直到达到DOM树的根节点。在这个过程中，事件处理程序可以被沿途的任何父元素捕获。 给addEvenListener函数写入第三个参数，false(这也是默认值，所以一般不写)，意味着开启了冒泡机制。 当触发冒泡机制时，一个元素触发事件后，会一次从触发事件的子元素向上调用所有父级元素的同名事件 事件冒泡默认存在。 事件流的传播方向 事件捕获：从外部到内部（从根节点到目标节点）。 事件冒泡：从内部到外部（从目标节点到根节点）。 使用事件处理程序你可以使用addEventListener方法来附加事件处理程序，并通过传递第三个布尔参数来选择事件流的哪个阶段来触发该处理程序： 如果第三个参数为true，则事件处理程序会在事件捕获阶段被调用。 如果第三个参数为false（或省略），则事件处理程序会在事件冒泡阶段被调用。 阻止冒泡目标:能够写出阻止冒泡的代码 问题:因为默认就有冒泡模式的存在，所以容易导致事件影响到父级元素 需求:若想把事件就限制在当前元素内，就需要阻止事件冒泡 前提:阻止事件冒泡需要拿到事件对象 语法: 事件对象.stopPropagation()，propagation有（动植物等的）繁殖，增殖，；（观点、理论等的）传播；（运动、光线、声音等的）传送的意思。 注意：此方法可以阻断事件流动传播，不光在冒泡阶段有效，捕获阶段也有效 事件解绑 解绑：onxxxx事件，利用on定义的事件存在冒泡不存在捕获。 12345btn.onclick = function()&#123; alert(&#x27;我被点击了&#x27;) //通过赋值空对象来解绑 btn.onclick = null&#125; 解绑：通过addEvenListener添加的事件 123456function fn()&#123; alert(&quot;我是通过addEvenListener添加的事件，点击之后我就被解绑了&quot;)&#125;btn.addEventListener(&quot;click&quot;,fn)//由于第二个参数需要传入函数的名字，所以匿名函数无法移除btn.removeEventListener(&quot;click&quot;,fn) 注意：匿名函数无法解绑！！！！ 事件委托事件委托（Event Delegation）是一种在父元素上处理子元素事件的技术。它的核心思想是，而不是在每个子元素上单独添加事件监听器，你可以在一个共同的祖先元素上添加一个监听器，然后根据事件的目标（event.target）来确定哪个子元素触发了事件。这种方法可以显著减少事件监听器的数量，从而提升性能，特别是在处理大量动态生成的元素时。 如何实现事件委托事件委托利用了事件冒泡的特性，即事件从最深层的触发元素开始，向上冒泡到DOM树的更高层。当事件冒泡至监听器所在的元素时，你可以检查事件的目标是否符合你的需求。 实现步骤 选择一个合适的祖先元素：选择一个包含所有相关子元素的共同祖先作为事件监听器的挂载点。 添加事件监听器：在选定的祖先元素上添加事件监听器，通常是在click、mouseover等常见事件类型上。 检查事件目标：在事件处理函数中，使用event.target来确定触发事件的实际元素，并根据需要做出响应。如果需要更确切的确定元素，可以通过元素的tagName来进一步判断 示例代码假设你有一个列表，其中包含许多链接，你想要在这些链接被点击时执行某个操作，但是你不想为每个链接单独添加事件监听器。 12345&lt;ul id=&quot;list&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link 1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link 2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link 3&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 1234567891011const list = document.getElementById(&#x27;list&#x27;);list.addEventListener(&#x27;click&#x27;, function(event) &#123; const target = event.target; // 检查目标是否是我们感兴趣的元素 if (target.tagName.toLowerCase() === &#x27;a&#x27;) &#123; console.log(&#x27;Link clicked:&#x27;, target.textContent); // 阻止默认行为，例如链接跳转 event.preventDefault(); &#125;&#125;); 在这个例子中，我们没有在每个&lt;a&gt;标签上添加事件监听器，而是将监听器添加到了&lt;ul&gt;元素上。当用户点击任何一个链接时，事件会冒泡到&lt;ul&gt;元素，然后我们检查event.target以确定哪个链接被点击。 阻止事件的默认行为在JavaScript中，阻止元素的默认行为通常是在事件处理函数中完成的，这样可以防止与该事件相关的默认动作被执行。例如，阻止链接的导航、表单的提交、或阻止某些键盘快捷键的默认行为。 要阻止元素的默认行为，可以使用 event.preventDefault() 方法。这个方法是事件对象的一个属性，当在事件处理函数中被调用时，会取消事件的默认行为。 以下是一个阻止链接点击时默认跳转行为的例子： 123456const link = document.querySelector(&#x27;a&#x27;);link.addEventListener(&#x27;click&#x27;, function(event) &#123; event.preventDefault(); console.log(&#x27;Link clicked, but default action prevented.&#x27;);&#125;); 在这个例子中，当链接被点击时，原本的跳转行为会被 event.preventDefault() 取消，而控制台将输出一条信息。 同样地，如果你想要阻止表单提交的默认行为，可以这样做： 1234567const form = document.querySelector(&#x27;form&#x27;);form.addEventListener(&#x27;submit&#x27;, function(event) &#123; event.preventDefault(); console.log(&#x27;Form submitted, but default action prevented.&#x27;); // 在这里执行自定义的提交逻辑&#125;); 在这个表单提交的例子中，event.preventDefault() 阻止了表单的默认提交动作，使页面不会重新加载或导航到表单的action URL。 需要注意的是，preventDefault() 并不影响事件的冒泡或捕获过程。如果你想阻止事件的进一步传播，可以使用 event.stopPropagation()。但通常，preventDefault() 用于取消事件的默认行为，而 stopPropagation() 用于阻止事件向父元素的传播。 在某些情况下，如阻止拖放行为或阻止某些键盘快捷键的默认行为，preventDefault() 也是必需的。例如，阻止用户使用 Ctrl+C 复制文本： 123456document.addEventListener(&#x27;keydown&#x27;, function(event) &#123; if (event.ctrlKey &amp;&amp; event.key === &#x27;c&#x27;) &#123; event.preventDefault(); console.log(&#x27;Copy operation prevented.&#x27;); &#125;&#125;); 元素在页面中的位置页面滚动在JavaScript中，scroll通常指的是与滚动条和滚动位置相关的操作。浏览器窗口或元素的滚动可以通过以下几种方式来访问或修改： window.scroll() 或 window.scrollTo()这些方法用于将浏览器窗口滚动到特定的位置。它们接受两个参数，第一个是水平位置（X坐标），第二个是垂直位置（Y坐标）。 1window.scrollTo(0, 500); // 滚动到页面顶部以下500像素的位置 或者使用 scroll() 方法： 1window.scroll(&#123;top: 500, left: 0, behavior: &#x27;smooth&#x27;&#125;); // 平滑滚动到指定位置 window.scrollBy()此方法相对于当前位置移动窗口。同样接受两个参数，分别表示水平和垂直方向上的偏移量。 1window.scrollBy(0, 100); // 向下滚动100像素 window.scrollX 和 window.scrollY这两个属性返回窗口当前的滚动位置。scrollX是水平滚动距离，scrollY是垂直滚动距离。 1console.log(window.scrollY); // 输出垂直滚动的距离 element.scrollTop 和 element.scrollLeft这些属性用于获取或设置特定元素的滚动位置。scrollTop表示垂直滚动距离，scrollLeft表示水平滚动距离。 123let element = document.getElementById(&#x27;someElement&#x27;);console.log(element.scrollTop); // 获取元素的垂直滚动距离element.scrollTop = 200; // 将元素的垂直滚动位置设置为200像素 element.scrollHeight 和 element.scrollWidth这些属性返回元素的内容高度和宽度，包括溢出的部分。 12let element = document.getElementById(&#x27;someElement&#x27;);console.log(element.scrollHeight); // 获取元素内容的高度，包括不可见部分 element.scrollIntoView()这个方法会将元素滚动到视图内，可选择性地使元素对齐到视口的顶部、中心或底部。 12let element = document.getElementById(&#x27;someElement&#x27;);element.scrollIntoView(&#123;behavior: &#x27;smooth&#x27;, block: &#x27;center&#x27;&#125;); // 平滑滚动并使元素居中显示 cliet家族“client”家族的一系列属性提供了关于浏览器窗口可视区域的信息，而不包括工具栏、滚动条、菜单栏等非内容区域。 clientWidth: 返回元素的宽度，包括内边距（padding），但不包括边框（border）和滚动条。如果应用于 window 对象，它返回浏览器窗口的可视宽度（不包括滚动条）。 clientHeight: 类似于 clientWidth，但返回高度。这包括元素的内边距，但不包括边框和滚动条。在 window 对象上，它返回浏览器窗口的可视高度。 clientLeft: 返回元素左侧边框的宽度。如果元素没有边框，此值为0。 clientTop: 返回元素顶部边框的宽度。如果元素没有边框，此值为0。 clientX: 这个属性通常与鼠标事件一起使用，表示相对于视口的鼠标水平位置。例如，在 mousedown、mousemove、mouseup 等事件中，event.clientX 提供了鼠标的水平坐标。 clientY: 与 clientX 类似，但表示垂直坐标。 offset家族在Web开发中，offset 家族的属性提供了一组与元素的位置和尺寸有关的信息。这些属性主要用于获取元素相对于其offset parent（偏移父元素）的位置和尺寸，而offset parent通常是元素最近的具有定位（positioned）的祖先元素或者是&lt;body&gt;元素本身（如果没有任何定位的祖先）。 offset 家族主要包括以下几个属性： offsetWidth: 返回元素的宽度，包括元素的内容、内边距（padding）、边框（border），但不包括外边距（margin）。单位是像素。 offsetHeight: 返回元素的高度，包括元素的内容、内边距、边框，但不包括外边距。单位是像素。 offsetLeft: 返回元素左边缘相对于其offset parent的左边缘的偏移量。单位是像素。**(只读属性)** offsetTop: 返回元素顶边缘相对于其offset parent的顶边缘的偏移量。单位是像素。**(只读属性)** offsetParent: 返回元素的offset parent。这个元素是最近的具有定位（position）属性的祖先元素，或者是&lt;body&gt;元素（如果没有定位的祖先）。 这些属性非常实用，尤其是在动态调整布局、响应式设计、元素对齐或动画效果中。由于它们返回的是实际的像素值，因此可以用于计算和调整元素的位置和大小。 值得注意的是，offset 家族的属性返回的值总是数值，而不是带有单位的字符串。这意味着，如果需要进行样式设置，你可能需要将这些数值转换为带有单位的字符串。 图解： 获取元素大小位置的另外方法 方法 ：getBoundingClientRect() 该方法返回元素的位置大小是相对于视口的位置来看的 总结 属性 作用 说明 scrollLeft和scrollTop 被卷去的头部和左侧 配合页面滚动事件来使用，可读写 cilentWidth和clientHeight 获得元素的宽度和高度 不包含元素的border、padding、滚动条等，用于利用js读取元素大小，只读属性 offsetWidth和offsetHeight 获取元素的宽度和高度 包含元素的border、padding、滚动条等，只读属性 offsetLeft和offsetTop 获取元素距离自己已经拥有定位属性的父级元素的左、上方向的距离 获取元素位置的时候可以使用，只读属性 变量语法：let 变量名 1.变量的赋值语法：变量 &#x3D; 要赋的值 1234567let ageage = 18//或者let age = 18；//弹出输入框prompt(&quot;请输入姓名&quot;)let name = prompt(&quot;请输入姓名&quot;) 2.var、const、let的区别在较旧的JavaScript，使用关键字 var 来声明变量 ，而不是 let。var现在开发中一般不再使用它，只是我们可能再老版程序中看到它。let 为了解决 var 的一些问题。 为什么不用var 声明 可以先使用 在声明(不合理) var 声明过的变量可以重复声明(不合理) 比如变量提升、全局变量、没有块级作用域等等 推荐使用 let 的情况： 当你需要声明一个变量，且这个变量的值可能会发生变化时，使用 let。 let 允许你在块级作用域内声明变量，这有助于避免变量之间的冲突和意外覆盖。 推荐使用 const 的情况： 当你声明一个变量并且知道它的值不会改变时，应该使用 const。 使用 const 可以明确表示该变量是不可变的，这有助于提高代码的可读性和可维护性。 即使是对象或数组，虽然你可以改变它们的内容，但 const 仍然有助于确保不会重新分配一个新的引用。 总结 **默认使用 const**：尽可能地使用 const 来声明变量。这样可以确保在变量值不需要改变的情况下，它们不会被意外修改。 **只有当需要改变时使用 let**：当你确定某个变量的值会在后续的代码中发生改变时，才使用 let 来声明。 webAPI基本认识获取DOM元素根据CSS选择器来获取DOM元素 选择匹配的第一个元素 语法 document.querySelector(&#39;css选择器&#39;) // 获取匹配的第一个元素(通过标签元素和类名来进行选择) const firstObj = document.querySelector(&#39;div&#39;) const firstObj2 = document.querySelector(&quot;.test&quot;) console.log(firstObj); console.log(firstObj2); const nav = document.querySelector(&quot;#nav&quot;) console.log(nav); const li = document.querySelector(&quot;ul li:first-child&quot;) console.log(li); 123456789101112 * 参数：包含一个或多个有效的CSS选择器字符串 * 返回值：CSS选择器匹配的**第一个元素**，一个HTMLElement对象* 选择多个元素* 语法： ```javascript const lis = document.querySelectorAll(&quot;ul li&quot;) console.log(lis); 返回值：返回一个数组 得到的是一个伪数组有长度有索引号的数组，但是没有 pop()push()等数组方法，想要得到里面的每一个对象，则需要遍历(for)的方式获得。 其他获取DOM元素的方法 操作元素内容对象.innerHtml属性 将文本内容添加&#x2F;更新到任意标签位置 能够解析标签，通常配合模板字符使用 对象.innerText属性 将文本内容添加&#x2F;更新到任意标签位置 显示纯文本，不能够解析标签 案例12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;修改元素内容.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;test1&quot;&gt; &lt;span&gt;这是修改前的内容&lt;/span&gt; &lt;button onclick=&quot;changeDom1()&quot;&gt;点我修改dom内容&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;test2&quot; style=&quot;margin-top: 10px;&quot;&gt; &lt;span&gt;这是修改前的内容&lt;/span&gt; &lt;button onclick=&quot;changeDom2()&quot;&gt;点我修改dom内容&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; function changeDom1()&#123; let obj = document.querySelector(&#x27;.test1&#x27;) obj.innerHTML = `&lt;span&gt;这是修改后的内容&lt;/span&gt;` &#125; function changeDom2()&#123; let obj = document.querySelector(&#x27;.test2&#x27;) obj.innerText = &quot;我是innerText，我只能修改文本，并不能识别HTML标签&quot; &#125; &lt;/script&gt;&lt;/html&gt; 操作元素的属性操作元素常用属性 通过JS设置&#x2F;修改标签的元素属性，比如通过src更换图片 最常见的属性比如：href，title，src等 语法：对象.属性 = 修改的值 举例123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;修改元素内容.html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;test1&quot;&gt; &lt;span&gt;这是修改前的内容&lt;/span&gt; &lt;button onclick=&quot;changeDom1()&quot;&gt;点我修改dom内容&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;test2&quot; style=&quot;margin-top: 10px;&quot;&gt; &lt;span&gt;这是修改前的内容&lt;/span&gt; &lt;button onclick=&quot;changeDom2()&quot;&gt;点我修改dom内容&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; function changeDom1()&#123; let obj = document.querySelector(&#x27;.test1&#x27;) obj.innerHTML = `&lt;span&gt;这是修改后的内容&lt;/span&gt;` &#125; function changeDom2()&#123; let obj = document.querySelector(&#x27;.test2&#x27;) obj.innerText = &quot;我是innerText，我只能修改文本，并不能识别HTML标签&quot; &#125;&lt;/script&gt;&lt;/html&gt; 操作元素样式属性 通过style属性来操作CSS 通过类名(className)来操作CSS 通过classList操作类控制CSS 通过style属性来操作CSS 语法：对象.style.属性 = 值 多单词采取小驼峰命名 注意单位 12345// 对象.style.属性 = 值let box = document.querySelector(&#x27;div&#x27;)box.style.width = &#x27;400px&#x27;box.style.backgroundColor = &quot;red&quot;box.style.border = &quot;2px solid blue&quot; 通过类名(className)来操作CSS 语法：dom对象.className = &quot;类名&quot; 修改较多样式，推荐使用该方法 因为class是关键字，所以这里要使用className来代替class。 通过这种方式是新值替换旧值，会顶替掉之前的类名。如果使用这种方法，要记得保留原来类名 123//通过类名(className)来操作CSSlet box1 = document.querySelector(&quot;div:nth-child(2)&quot;)box1.className = &quot;testStyle&quot; 通过classList操作类控制CSS 追加一个类： 对象.classList.add(&quot;类名&quot;) 删除一个类： 对象.classList.remove(&quot;类名&quot;) 切换一个类： 对象.classList.toggle(&quot;类名&quot;) 如果原来有切换的类，那么这个类通过切换就会被移除 如果没有，那么就会添加这个类 123456//通过classList操作类控制CSSlet box2 = document.querySelector(&quot;div:nth-child(3)&quot;)box2.classList.add(&quot;testStyle2&quot;) //添加这行代码。会让第三个盒子背景变为红色box2.classList.remove(&quot;test&quot;) box2.classList.toggle(&quot;test&quot;) 操作表单元素属性操作HTML表单及其元素的属性可以通过DOM（Document Object Model）来实现。以下是一些常见的操作，比如获取或设置表单元素的属性、值、样式等： 获取和设置表单元素的值12345// 获取文本框的值var value = document.getElementById(&#x27;myInput&#x27;).value;// 设置文本框的值document.getElementById(&#x27;myInput&#x27;).value = &#x27;Hello World&#x27;; 检查复选框的状态12// 检查复选框是否被选中var isChecked = document.getElementById(&#x27;myCheckbox&#x27;).checked; 设置复选框的状态12// 设置复选框为选中状态document.getElementById(&#x27;myCheckbox&#x27;).checked = true; 操作选择框（下拉列表）12345// 获取选择框的选中项的值var selectedValue = document.getElementById(&#x27;mySelect&#x27;).value;// 设置选择框的选中项document.getElementById(&#x27;mySelect&#x27;).value = &#x27;option2&#x27;; 添加和删除表单元素12345678910111213// 创建一个新的输入元素var newInput = document.createElement(&#x27;input&#x27;);// 设置新输入元素的类型和IDnewInput.type = &#x27;text&#x27;;newInput.id = &#x27;newInput&#x27;;// 将新输入元素添加到表单中var form = document.getElementById(&#x27;myForm&#x27;);form.appendChild(newInput);// 从表单中移除一个元素form.removeChild(document.getElementById(&#x27;someElementId&#x27;)); 设置和获取表单元素的CSS样式12345// 设置元素的背景颜色document.getElementById(&#x27;myInput&#x27;).style.backgroundColor = &#x27;#f0f0f0&#x27;;// 获取元素的背景颜色（注意这将返回计算后的样式，可能与设置的不同）var bgColor = window.getComputedStyle(document.getElementById(&#x27;myInput&#x27;)).backgroundColor; 监听表单事件1234// 当提交按钮被点击时，执行某些操作document.getElementById(&#x27;submitButton&#x27;).addEventListener(&#x27;click&#x27;, function() &#123; alert(&#x27;表单已提交&#x27;);&#125;); 本地存储localStorage 对象localStorage 对象提供对特定网站的本地存储的访问。它允许您存储、读取、添加、修改和删除该域的数据项。存储的数据没有到期日期，并且在浏览器关闭时不会被删除。这些数据将在几天、几周和几年内均可用。本地存储只能存为字符串。 ！温馨提示：本地存储在进行增删改等业务推荐使用同一个键，值推荐用数组存储多个，方便处理。 setItem(key,value) 用途：用于将数据项存储在 storage 中。 参数：它接受一个名称和一个值作为参数： 实例 12 //利用localStorage存储数据 以K-V形式存储localStorage.setItem(&#x27;name&#x27;, &#x27;小李&#x27;); getItem(key) 用途：用于从localStorage中读取相应键对应的值 参数：接收一个键值，字符串形式。 实例 12let name = localStorage.getItem(&#x27;name&#x27;);console.log(name);//小李 removeItem(key) 用途：删除对应键的值 参数：接收一个key值 实例 12//从localStorage中删除数据localStorage.removeItem(&#x27;name&#x27;); sessionStorage 对象sessionStorage 对象与 localStorage 对象相同。 不同之处在于 sessionStorage 对象存储会话的数据。 当浏览器关闭时，数据会被删除。 setItem(key,value) 用途：sessionStorage.setItem() 方法将数据项存储在存储（storage）中。 参数：它接受一个名称和一个值作为参数 实例 1sessionStorage.setItem(&quot;name&quot;, &quot;Bill Gates&quot;); getItem(key) 用途：sessionStorage.getItem() 方法从存储（storage）中检索数据项。 参数：它接受一个名称作为参数 实例 1sessionStorage.getItem(&quot;name&quot;); removeItem(key) 用途：删除对应键的值 参数：接收一个key值 存储复杂类型的数据这里以对象类型举例 如果要存储一个对象类型的数据，步骤如下 把对象类型转换成JSON字符串类型 语法：JSON.stringify(对象) 使用本地存储的存储方法存储数据 如果要取出一个字符串类型的对象数据，步骤如下 通过方法取出JSON字符串类型的对象数据 把取出来的JSON字符串类型数据转换成对象类型 语法：JSON.parse() Storage 对象属性和方法 属性&#x2F;方法 描述 key(n) 返回存储中第 n 个键的名称。 length 返回存储在 Storage 对象中的数据项数。 getItem(keyname) 返回指定的键名的值。 setItem(keyname, value) 将键添加到存储中，或者如果键已经存在，则更新该键的值。 removeItem(keyname) 从存储中删除该键。 clear() 清空所有键。 正则表达式在JavaScript中，正则表达式（Regular Expression）是一种用于匹配字符串中字符组合的强大工具。它们可以用来执行复杂的文本处理任务，如搜索、替换和提取文本。 使用场景： 来进行表单验证，过滤敏感词等等。 创建正则表达式 字面量表示法：flags是修饰符，详见修饰符小结 1let regex = /pattern/flags; 构造函数方式： 1let regex = new RegExp(&#x27;pattern&#x27;, &#x27;flags&#x27;); 常用的正则表达式模式 匹配特定字符: . 匹配任何单个字符（除了换行符）。 \\d 匹配数字。 \\w 匹配字母或数字。 \\s 匹配空白字符。 重复: * 匹配前面的子表达式零次或多次。 + 匹配前面的子表达式一次或多次。 ? 匹配前面的子表达式零次或一次。 &#123;n&#125; 匹配前面的子表达式恰好 n 次。 &#123;n,&#125; 匹配前面的子表达式至少 n 次。 &#123;n,m&#125; 匹配前面的子表达式至少 n 次但不超过 m 次。 选择: | 或运算符用于匹配多个表达式中的任意一个。 边界: ^ 表示行的开始。 $ 表示行的结束。 \\b 表示单词边界。 使用正则表达式的常见方法 test() 方法 12let regex = /abc/;console.log(regex.test(&#x27;abcdef&#x27;)); // 输出 true exec() 方法： 1234let regex = /(\\d+)/;let result = regex.exec(&#x27;The year is 2023.&#x27;);console.log(result[0]); // 输出 &quot;2023&quot;console.log(result[1]); // 输出 &quot;2023&quot; 元字符在JavaScript的正则表达式中，元字符（Metacharacters）是一些具有特殊含义的字符，它们被用来定义复杂的搜索模式。下面列出了一些常用的元字符及其功能： 常见元字符边界符 ^ (caret) 在方括号 [ ] 内表示取反，即匹配不在方括号内的字符。 不在方括号内时，如果位于正则表达式的开头，则表示匹配字符串的开始。 $ (美元符号) 如果位于正则表达式的末尾，则表示匹配字符串的结尾。 量词 * (星号) 表示匹配前面的字符零次或多次。 + (加号) 表示匹配前面的字符一次或多次。 ? (问号) 表示匹配前面的字符零次或一次。 &#123;n&#125; (花括号) 表示重复前面的字符 n 次。 &#123;n,&#125; (花括号) 表示重复前面的字符至少 n 次。 &#123;n,m&#125; (花括号) 表示重复前面的字符至少 n 次但不超过 m 次。 字符类 [] (方括号) 定义字符集，匹配方括号中的任何一个字符。 . (点) 表示匹配任何单个字符（除了换行符）。 [^...] (取反方括号) 定义非字符集，匹配不属于方括号中的任何字符。 () (圆括号) 定义捕获组，用于对匹配进行分组并捕获匹配的部分。 | (管道符号) 表示逻辑“或”，匹配两个或多个选项中的任意一个。 \\b (单词边界) 匹配单词边界，即单词字符和非单词字符之间的边界。 \\B (非单词边界) 匹配非单词边界，即两个单词字符或两个非单词字符之间的地方。 \\d (数字) 匹配任何十进制数字等同于 [0-9]。 \\D (非数字) 匹配任何非数字字符等同于 [^0-9]。 \\w (单词字符) 匹配任何单词字符等同于 [a-zA-Z0-9_]。 \\W (非单词字符) 匹配任何非单词字符等同于 [^a-zA-Z0-9_]。 \\s (空白字符) 匹配任何空白字符等同于 [ \\t\\n\\r\\f\\v]。 \\S (非空白字符) 匹配任何非空白字符等同于 [^ \\t\\n\\r\\f\\v]。 \\A (字符串开始) 表示匹配字符串的开始。 \\Z (字符串结束) 表示匹配字符串的结束。 \\z (字符串结束) 同样表示匹配字符串的结束。 \\G (上次匹配结束处) 表示从上次匹配的结束位置开始匹配。 \\n, \\r, \\t, \\f, \\v (转义字符) 分别代表新行、回车、制表符、换页符和垂直制表符。 修饰符语法：/正则表达式/修饰符，也就是在正则表达式后面的就是修饰符 g (全局匹配) 这个标志告诉正则表达式引擎在整个字符串中查找所有匹配项，而不仅仅是找到第一个匹配后就停止。如果没有使用这个标志，正则表达式默认是从左向右只匹配第一个符合条件的结果。 i (忽略大小写) 当使用此标志时，正则表达式在进行匹配时不区分大小写。例如，/abc/i 将会匹配 &quot;ABC&quot;, &quot;AbC&quot; 等。 m (多行模式) 此标志使 ^ 和 $ 能够分别匹配每行的开始和结束，而不仅仅是整个字符串的开始和结束。例如，在多行文本中，/^abc/m 将匹配每一行的开头为 “abc” 的部分。 s (单行模式) 也被称为 “dotall” 模式。此标志使得 . 可以匹配任何字符，包括换行符。没有此标志时，. 不匹配换行符。 u (Unicode 模式) 此标志使得正则表达式支持完整的 Unicode 字符范围。当使用 \\w, \\d, \\s 等预定义类时，将考虑所有 Unicode 字符，而不仅仅是 ASCII 字符。 y (粘贴模式) 该标志使得正则表达式只能从上次匹配的位置开始匹配。这通常与全局标志 g 一起使用，以便在连续的调用中保持匹配的位置。 示例让我们通过一些例子来看看这些元字符是如何使用的： 匹配任何数字12let regex = /\\d/;console.log(regex.test(&#x27;123&#x27;)); // true 匹配以数字开头的字符串12let regex = /^\\d/;console.log(regex.test(&#x27;123abc&#x27;)); // true 匹配以数字结尾的字符串12let regex = /\\d$/;console.log(regex.test(&#x27;abc123&#x27;)); // true 匹配连续三个或更多的字符12let regex = /a+/;console.log(regex.test(&#x27;aaa&#x27;)); // true 匹配连续一个到三次的字符12345let regex = /a&#123;1,3&#125;/;console.log(regex.test(&#x27;aaa&#x27;)); // trueconsole.log(regex.test(&#x27;aa&#x27;)); // trueconsole.log(regex.test(&#x27;a&#x27;)); // trueconsole.log(regex.test(&#x27;aaaa&#x27;)); // false 匹配任何数字或字母123let regex = /[a-zA-Z0-9]/;console.log(regex.test(&#x27;a&#x27;)); // trueconsole.log(regex.test(&#x27;9&#x27;)); // true 匹配任何非数字123let regex = /\\D/;console.log(regex.test(&#x27;a&#x27;)); // trueconsole.log(regex.test(&#x27;9&#x27;)); // false JavaScript异步JS中的Promise(更详细请移步笔记Vue前置知识.md) 概念：Promise 是一种处理异步操作的更优雅的方法。Promise 对象代表了一个最终会在未来完成（或失败）的值的初次计算结果。 基本语法12345678910111213//1.promise的基本语法const promise = new Promise(function(resolve,reject)&#123; //2.这里是用来执行异步任务的代码块 // 异步任务执行成功调用resolve() 此时可以通过 .then 方法访问结果。 //异步任务执行失败调用reject() 此时可以通过 .catch 方法处理错误。&#125;)//3.接收结果promise.then(result =&gt;&#123; //成功后获得数据 console.log(result);&#125;).catch(error =&gt;&#123; //处理失败&#125;) promise的三种状态Promise 有三种状态： pending：初始状态，既未成功也未失败。对应 new Promise() fulfilled：成功完成，此时可以通过 .then 方法访问结果。 ——调用了resolve()函数 rejected：操作失败，此时可以通过 .catch 方法处理错误。——调用了reject()函数 promise对象的使用1234567891011let myPromise = new Promise(function(myResolve, myReject) &#123;// 执行某些异步任务 myResolve(); // 成功时 myReject(); // 出错时&#125;);// 下面就是对promise对象的使用myPromise.then( function(value) &#123; /* 成功时的代码 */ &#125;).catch(function(error) &#123; /* 出错时的代码 */ &#125;) 回调地狱多个回调函数形成嵌套，形成回调地狱。 缺点： 可读性差 异常捕获困难 耦合性差、 promise链式调用 原理：promise对象.then()方法，利用then方法返回新的promise对象。和上一个对象不相同 概念：依靠then()方法返回一个新的promise对象特性，继续串联下一环任务，直到结束。 简单示例 12345678910111213141516171819const p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;北京市&#x27;) &#125;, 2000)&#125;)//获取//查看p.then()返回对象//函数返回了一个新的promise对象，const p2 = p.then((result) =&gt; &#123; //then方法返回一个新的promise对象。 return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(result + &#x27;-----北京市&#x27;) &#125;, 3000); &#125;)&#125;)p2.then(result =&gt;&#123; console.log(result); //北京市-----北京市&#125;) 结合Axios来使用链式调用(重点) 123456789101112131415//由于每发起一次请求，就会有一个新的promise对象所以可以下向下面这样写axios(&#123; url: &#x27;http://hmajax.itheima.net/api/province&#x27; &#125;).then(result =&gt; &#123; const pname = result.data.list[0] //在then函数中，继续向外层return一个新的promise对象 return axios(&#123; url: &#x27;http://hmajax.itheima.net/api/city&#x27;, params: &#123; pname: pname &#125; &#125;) //.then的位置要写在then函数外，因为利用的是该函数的返回值。&#125;).then(result =&gt; &#123; const pname = result.config.params.pname console.log(pname);//北京 const cname = result.data.list[0] return axios(&#123; url: &#x27;http://hmajax.itheima.net/api/area&#x27;, params: &#123; pname: pname, cname: cname &#125; &#125;) //.then的位置要写在then函数外，因为利用的是该函数的返回值。&#125;).then(result =&gt; &#123; console.log(result); //返回北京市下的城市名称&#125;) JavaScript Async(异步)“async and await make promises easier to write” async 使函数返回 Promise await 使函数等待 Promise Async 语法函数前的关键字 async 使函数返回 promise： 实例1 123async function myFunction() &#123; return &quot;Hello&quot;;&#125; 等同于： 123async function myFunction() &#123; return Promise.resolve(&quot;Hello&quot;);&#125; 以下是使用 Promise 的方法： 123myFunction().then( function(value) &#123; /* 成功时的代码 */ &#125;,).catch(function(error) &#123; /* 出错时的代码 */ &#125;) 实例2 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;JavaScript async / await&lt;/h1&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;function myDisplayer(some) &#123; document.getElementById(&quot;demo&quot;).innerHTML = some;&#125;//async 使函数返回promiseasync function myFunction() &#123;return &quot;Hello&quot;;&#125;//在这里调用promise返回时的动作myFunction().then( function(value) &#123;myDisplayer(value);&#125;, //成功的回调 function(error) &#123;myDisplayer(error);&#125; //失败的回调);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Await 语法函数前的关键字 await 使函数获得Promise对象”成功状态”的结果值。 await只能获取请求成功时，得到的结果。 await只能使用在被Async修饰的函数内部。 1let value = await promise; await 关键字只能在 async 函数中使用。 基础语法实例 12345678910//await只能获取请求成功时，得到的结果。//await只能使用在被Async修饰的函数内部。async function getData()&#123;//await等待请求成功时，将数据赋值给变量。const provinceName = await axios(&#123; url:&#x27;http://hmajax.itheima.net/api/province&#x27;&#125;)console.log(provinceName);&#125;getData() async和await捕获错误 使用try{} catch(error){}来捕获错误。 try包裹可能出现错误的代码块 如果在某一环节捕获到了错误，那么剩余的代码不会执行 catch来处理错误 12345678910111213141516async function getData() &#123; //捕获错误 ——利用try ....catch //try包裹可能出现错误的代码 try &#123; //await等待请求成功时，将数据赋值给变量。 const provinceName = await axios(&#123; url: &#x27;http://hmajax.itheima.net/api/provinc&#x27; &#125;) console.log(provinceName); //利用catch来接收错误信息 //如果在某一环节捕获到了错误，那么剩余的代码不会执行 &#125; catch (error) &#123; console.log(&#x27;1111&#x27;, error); &#125; &#125;getData() Ajax 概念:Asynchronous JavaScript And XML，异步的JavaScript和XML。 作用: AJAX 是开发者的梦想，因为您能够： 不刷新页面更新网页 在页面加载后从服务器请求数据 在页面加载后从服务器接收数据 在后台向服务器发送数据 数据交换:通过Ajax可以给服务器发送请求，并获取服务器响应的数据。 异步交互:可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如:搜索联想、用户名是否可用的校验等等。 AxiosAxios 是一个基于 promise 的 HTTP 库，可以用于浏览器和 node.js 中。它被广泛用于与 RESTful APIs 进行交互，特别是在前端开发中，用来发送 AJAX 请求。 基础语法123456789101112131415axios(&#123; //请求方式 method: //请求地址 url: //请求参数 data:&#123;/*向服务器发送数据用data选项，一般是post请求*/&#125; params:&#123; /*携带查询参数用params*/ 参数名：参数值 &#125; //回调函数&#125;).then(function(res)&#123; console.loh(res.data)&#125;) 请求配置常用配置项 url: (必需) 发送请求的 URL 地址。 method: (必需) 请求方法，如 &#39;get&#39;, &#39;post&#39;, &#39;put&#39;, &#39;delete&#39;, &#39;patch&#39;, &#39;head&#39;, &#39;options&#39;。 data: (可选) 发送到服务器的数据。对于 POST, PUT, PATCH 等方法来说，这个数据会被序列化并发送到服务器。 params: (可选) 发送到服务器的查询字符串参数。 headers: (可选) 自定义请求头。 timeout: (可选) 请求超时时间，单位为毫秒。如果请求超过了指定的时间，将抛出一个 Timeout 错误。 withCredentials: (可选) 是否携带 cookie，这对于跨域请求非常重要，默认为 false。 responseType: (可选) 指定响应的数据类型，如 &#39;arraybuffer&#39;, &#39;blob&#39;, &#39;json&#39;, &#39;text&#39;, &#39;stream&#39;。 validateStatus: (可选) 验证服务器响应的状态码是否成功。默认情况下，只有状态码在 2xx 范围内的才会被认为是成功的。 maxRedirects: (可选) 最大重定向次数，默认为 5。 cancelToken: (可选) 取消请求的 token，用于取消正在进行的请求。 auth: (可选) 包含用户名和密码的对象，用于 HTTP 基本身份验证。 错误处理错误处理的基本方式 使用 .catch() 处理错误： 当请求失败时，.catch() 函数会捕获错误，并允许你执行相应的错误处理逻辑。 1234567axios.get(&#x27;https://api.example.com/data&#x27;) .then(response =&gt; &#123; console.log(response.data); &#125;) .catch(error =&gt; &#123; console.error(&quot;Error:&quot;, error); &#125;); 请求方法下面是一些基本请求方法： GET - 用于获取资源。 POST - 用于创建资源。 PUT - 用于更新资源。 DELETE - 用于删除资源。 PATCH - 用于局部更新资源。 HEAD - 用于获取资源的元信息。 OPTIONS - 用于获取服务器支持的通信选项。 HTTP响应状态码下面是一些常用的状态码 成功状态码 200 OK：请求已成功，这是最常见的成功状态码。 201 Created：请求被成功创建，通常用于 POST 请求。 204 No Content：服务器成功处理了请求，但不需要返回任何内容。 重定向状态码 301 Moved Permanently：请求的资源已被永久移动到新位置。 302 Found（临时重定向）：请求的资源现在临时位于不同的 URI。 304 Not Modified：请求的资源未被修改，因此返回 304 并不包含资源的实体部分。 客户端错误状态码 400 Bad Request：服务器无法理解请求的格式。 401 Unauthorized：请求需要用户身份验证。 403 Forbidden：服务器理解请求客户端的请求，但是拒绝执行此请求。 404 Not Found：请求的资源不存在。 405 Method Not Allowed：请求的方法不允许对请求的资源使用。 服务器错误状态码 500 Internal Server Error：服务器遇到一个未曾预料的状况，导致它无法完成对请求的处理。 502 Bad Gateway：作为网关或代理工作的服务器收到了来自上游服务器的有效响应，但是无效的最终响应。 503 Service Unavailable：服务器目前无法使用，可能是由于服务器过载或维护。 什么是 AjaxAJAX &#x3D; Asynchronous JavaScript And XML. AJAX 并非编程语言。 AJAX 仅仅组合了： 浏览器内建的 XMLHttpRequest 对象（从 web 服务器请求数据） JavaScript 和 HTML DOM（显示或使用数据） Ajax 是一个令人误导的名称。Ajax 应用程序可能使用 XML 来传输数据，但将数据作为纯文本或 JSON 文本传输也同样常见。 Ajax 允许通过与场景后面的 Web 服务器交换数据来异步更新网页。这意味着可以更新网页的部分，而不需要重新加载整个页面。 Ajax如何工作 网页中发生一个事件（页面加载、按钮点击） 由 JavaScript 创建 XMLHttpRequest 对象 XMLHttpRequest 对象向 web 服务器发送请求 服务器处理该请求 服务器将响应发送回网页 由 JavaScript 读取响应 由 JavaScript 执行正确的动作（比如更新页面） Ajax基础语法 创建 XMLHttpRequest 对象 - 用于在后台与服务器交换数据。 定义回调函数 - 当从服务器请求数据返回后执行的函数。 发送请求到服务器 - 通常使用 GET 或 POST 方法。 处理服务器响应 - 在回调函数中处理数据。 12345678910111213141516171819// 创建 XMLHttpRequest 对象var xhr = new XMLHttpRequest();// 设置请求完成后的回调函数 --------------写法1xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; // 请求完成并且成功 console.log(xhr.responseText); // 输出服务器响应的数据 &#125;&#125;;//当然了，上面的回调函数也可以写成下面这样 --------------写法2xhr.addEventListener(&#x27;loadend&#x27;,()=&gt;&#123; //对响应回来的结果进行处理 console.log(xhr.responseText);&#125;)// 初始化请求xhr.open(&#x27;GET&#x27;, &#x27;https://api.example.com/data&#x27;, true);// 发送请求xhr.send(); Ajax传递参数携带查询参数查询参数直接拼接在URL后面，利用**?，来把查询参数以‘k &#x3D; v’**的形式写在后面 1234567 const xhr = new XMLHttpRequest()//参数直接拼接在url后面，利用?，来把查询参数以&#x27;k = v&#x27;的形式写在后面xhr.open(&#x27;get&#x27;,&#x27;http://hmajax.itheima.net/api/city?pname=辽宁省&#x27;)xhr.onload = function()&#123; console.log(JSON.parse(xhr.responseText));&#125;xhr.send() 携带要提交的数据 设置请求头(Content-Type)为application/json 12//设置请求头为application/json xhr.setRequestHeader(&#x27;Content-Type&#x27;,&#x27;application/json&#x27;) 准备数据，并转为JSON格式 12const userObj = &#123;username:&#x27;lizewei111&#x27;,password:&#x27;123456789&#x27;&#125;const userStr = JSON.stringify(userObj) 发送数据 12//发送请求 - 并把要发送的数据携带上xhr.send(userStr) 完整逻辑如下： 1234567891011121314const xhr = new XMLHttpRequest();xhr.open(&#x27;post&#x27;,&#x27;http://hmajax.itheima.net/api/register&#x27;)//设置请求头为application/jsonxhr.setRequestHeader(&#x27;Content-Type&#x27;,&#x27;application/json&#x27;)//把准备的数据转为JSON字符串const userObj = &#123;username:&#x27;lizewei111&#x27;,password:&#x27;123456789&#x27;&#125;const userStr = JSON.stringify(userObj)//设置回调函数xhr.addEventListener(&#x27;loadend&#x27;,()=&gt;&#123; //回调后执行的逻辑 console.log(JSON.parse(xhr.responseText));&#125;)//发送请求 - 并把要发送的数据携带上xhr.send(userStr) xhr对象获得xhr对象 xhr对象通过构造函数创建 1const xhr = new XMLHttpRequest(); xhr对象方法 方法 描述 new XMLHttpRequest() 创建新的 XMLHttpRequest 对象。 abort() 取消当前请求。 getAllResponseHeaders() 返回头部信息。 getResponseHeader() 返回特定的头部信息。 open(method, url, async, user, psw) 规定请求。method：请求类型 GET 或 POSTurl：文件位置async：true（异步）或 false（同步）user：可选的用户名psw：可选的密码 send() 向服务器发送请求，用于 GET 请求。 send(string) 向服务器发送请求，用于 POST 请求。 setRequestHeader() 将标签&#x2F;值对添加到要发送的标头。 xhr对象属性 属性 描述 onload 定义接收到（加载）请求时要调用的函数。 onreadystatechange 定义当 readyState 属性发生变化时调用的函数。 readyState 保存 XMLHttpRequest 的状态。0：请求未初始化1：服务器连接已建立2：请求已收到3：正在处理请求4：请求已完成且响应已就绪 responseText 以字符串形式返回响应数据。 responseXML 以 XML 数据返回响应数据。 status 返回请求的状态号200: “OK”403: “Forbidden”404: “Not Found”如需完整列表请访问 Http 消息参考手册 statusText 返回状态文本（比如 “OK” 或 “Not Found” 同步请求&#x2F;异步请求 同步代码：逐行执行，需原地等待结果，才继续向下执行。 异步代码：调用会耗用事件，不阻塞代码继续执行，完成后会执行一个回调函数。(耗时任务) 如需执行同步的请求，请把 open() 方法中的第三个参数设置为 false，默认执行异步请求，也就是true 1xhttp.open(&quot;GET&quot;, &quot;ajax_info.txt&quot;, false); 有时 async &#x3D; false 用于快速测试。你也会在更老的 JavaScript 代码中看到同步请求。 由于代码将等待服务器完成，所以不需要 onreadystatechange 函数： 实例 123xhttp.open(&quot;GET&quot;, &quot;ajax_info.txt&quot;, false);xhttp.send();document.getElementById(&quot;demo&quot;).innerHTML = xhttp.responseText; 我们不推荐同步的 XMLHttpRequest (async &#x3D; false)，因为 JavaScript 将停止执行直到服务器响应就绪。如果服务器繁忙或缓慢，应用程序将挂起或停止。 同步 XMLHttpRequest 正在从 Web 标准中移除，但是这个过程可能需要很多年。 现代开发工具被鼓励对使用同步请求做出警告，并且当这种情况发生时，可能会抛出 InvalidAccessError 异常。 同步和异步： 服务器响应请求服务器响应属性 属性 描述 responseText 获取字符串形式的响应数据 responseXML 获取 XML 数据形式的响应数据 responseText 属性responseText 属性以 JavaScript 字符串的形式返回服务器响应，因此您可以这样使用它： 实例 1document.getElementById(&quot;demo&quot;).innerHTML = xhttp.responseText; responseXML 属性XML HttpRequest 对象有一个內建的 XML 解析器。 ResponseXML 属性以 XML DOM 对象返回服务器响应。 服务器响应方法 方法 描述 getResponseHeader() 从服务器返回特定的头部信息 getAllResponseHeaders() 从服务器返回所有头部信息 getAllResponseHeaders() 方法getAllResponseHeaders() 方法返回所有来自服务器响应的头部信息。 实例123456var xhttp = new XMLHttpRequest();xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; document.getElementById(&quot;demo&quot;).innerHTML = this.getAllResponseHeaders(); &#125;&#125;; getResponseHeader() 方法getResponseHeader() 方法返回来自服务器响应的特定头部信息。 实例12345678var xhttp = new XMLHttpRequest();xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; document.getElementById(&quot;demo&quot;).innerHTML = this.getResponseHeader(&quot;Last-Modified&quot;); &#125;&#125;;xhttp.open(&quot;GET&quot;, &quot;ajax_info.txt&quot;, true);xhttp.send(); JavaScript进阶JS中的堆和栈栈（Stack）栈是一种先进后出（Last In First Out, LIFO）的数据结构。在JavaScript中，栈主要用来存储基本类型的值（也称为原始类型，如数字、字符串、布尔值、null、undefined）和对象的引用。 特点: 栈中的数据存取非常快，因为它是按照LIFO原则操作的。 栈空间的大小通常是固定的，超出范围会导致栈溢出错误。 栈中的数据一旦不再需要就会被自动释放。 堆（Heap）堆是一种无序的、动态的数据结构，在JavaScript中用于存储对象和数组的实际内容。 特点: 堆中的数据可以动态分配和释放，这意味着可以在运行时增加或减少内存。 堆中的数据访问速度比栈慢，因为它涉及到指针查找和间接访问。 堆中的数据不会自动释放，而是通过垃圾回收机制来清理不再使用的数据。 关键区别 存储位置: 栈存储基本类型的值和对象的引用。 堆存储对象本身及其属性。 内存管理: 栈中的数据通常在创建时就已经确定了大小，并且当作用域结束时自动释放。 堆中的数据会在运行时动态分配，并由垃圾回收器管理，当对象不再被引用时会被回收。 作用域 规定了变量能够被访问的范围，离开这个范围，变量无法被访问 作用域分为：局部作用域和全局作用域 局部作用域在JavaScript中，局部作用域指的是变量在一个特定的代码块（如函数内部）内可见和可访问的范围。当变量在一个函数内部被声明时，它只能在该函数内部被访问，这就是局部作用域的概念。 函数作用域 使用 var 关键字声明的变量在整个函数体内都是可见的。 这种作用域适用于整个函数，而不是某个具体的代码块。 块作用域块：被{}包裹的就是块 使用 let 和 const 关键字声明的变量只在声明它们的代码块内可见。 这种作用域适用于像循环或条件语句这样的代码块。 例子1234567891011121314function exampleFunction() &#123; var varExample = &quot;I am visible in the entire function scope&quot;; // 函数作用域 if (true) &#123; let letExample = &quot;I am visible only in this block scope&quot;; // 块作用域 const constExample = &quot;I am also visible only in this block scope&quot;; // 块作用域 console.log(varExample); // 输出: &quot;I am visible in the entire function scope&quot; console.log(letExample); // 输出: &quot;I am visible only in this block scope&quot; console.log(constExample); // 输出: &quot;I am also visible only in this block scope&quot; &#125; console.log(varExample); // 输出: &quot;I am visible in the entire function scope&quot; console.log(letExample); // ReferenceError: letExample is not defined console.log(constExample); // ReferenceError: constExample is not defined&#125;exampleFunction(); 全局作用域script标签和js文件是全局作用域，全局作用域内声明的变量可以被局部作用域访问 作用域链作用域链本质上是底层的变量查找机制 在函数执行时，会优先查找当前函数作用域中查找变量 如果当前作用域查找不到则会一次逐级查找父级作用域，直到全局作用域 JS垃圾回收机制 JavaScript 的垃圾回收机制（Garbage Collection, GC）是一种自动管理内存的过程，它负责释放不再使用的内存空间。这使得开发者无需手动管理内存分配和释放，从而降低了内存泄漏的风险。以下是 JavaScript 垃圾回收机制的一些关键方面： 标记与清除（Mark and Sweep）这是最基本的垃圾收集算法之一。它分为两个阶段： 标记（Mark）：垃圾收集器标记所有从根节点开始能够寻找到的对象。 清除（Sweep）：清理未被标记的对象，这些对象被认为是垃圾，可以被释放。 引用计数（Reference Counting）早期的 JavaScript 引擎还使用了引用计数的方法来跟踪对象的引用数量。当一个对象的引用计数变为 0 时，该对象就可以被回收。这种方法简单快速，但是容易导致循环引用的问题，即两个或多个对象相互引用而无法被垃圾收集器识别为垃圾。 分代收集（Generational Collection）现代 JavaScript 引擎使用了一种称为分代收集的技术。这种技术基于观察到的事实：新创建的对象往往很快就会被丢弃，而存活时间较长的对象则很可能继续存活下去。因此，JavaScript 对象被划分为几代，不同代的对象使用不同的策略进行垃圾回收。 年轻代（Young Generation）：新创建的对象通常放在这一代中。年轻代的垃圾回收频率较高，但每次回收的时间较短。 老年代（Old Generation）：经过多次年轻代垃圾回收后仍然存活的对象会被移动到老年代。老年代的垃圾回收频率较低，但每次回收可能需要更长的时间。 增量收集（Incremental Collection）增量收集将垃圾回收过程分成多个小步骤，这样可以在应用程序执行之间进行，从而减少长时间的暂停。 压缩（Compaction）随着垃圾回收的进行，内存中的空闲空间可能会变得碎片化。压缩是一种技术，它将存活的对象移动到连续的内存区域，从而消除内存碎片。 如何避免内存泄漏尽管 JavaScript 自动管理内存，但在某些情况下仍可能出现内存泄漏。以下是一些避免内存泄漏的方法： 解除事件监听器：确保在不再需要时移除事件监听器。 断开DOM引用：如果一个DOM元素被移除，确保断开与它的所有引用。 使用弱引用：在某些现代JavaScript引擎中支持弱引用，可以用来避免循环引用导致的内存泄漏。 清理定时器和回调：确保在不再需要时清除定时器和回调函数。 避免闭包中的大对象：闭包可以维持对大对象的引用，确保它们在不再需要时被正确释放。 闭包闭包（Closure）是 JavaScript 中一个非常重要的概念，简单来说，闭包就是函数和它所能访问的外部作用域变量的组合。 也就是闭包 &#x3D; 内层函数 + 外层函数的变量，也就是内层函数要用到外层函数的变量。 闭包的形成闭包的形成通常涉及到以下三个要素： 函数：必须有一个函数。 外部作用域：函数必须访问其外部作用域中的变量。 返回值：通常返回一个函数或者使外部作用域能够通过某种方式访问。 123456789101112function outerFunction() &#123; var externalVariable = &quot;Hello, world!&quot;; // 外部作用域变量 function innerFunction() &#123; console.log(externalVariable); // 访问外部作用域变量 &#125; return innerFunction; // 返回内部函数&#125;var closure = outerFunction(); // 创建闭包closure(); // 输出: &quot;Hello, world!&quot; 闭包的作用 保持数据私有：闭包可以用来隐藏变量，不让外部代码直接访问。 持久存储：闭包可以让变量在函数执行完毕后依然存在。 模拟私有成员：在面向对象编程中，闭包可以用来实现类的私有方法和属性。 闭包可能会造成内存泄漏这和它的持久存储有关系。 变量提升了解：仅针对于var来声明的变量。 机制： 把所有var声明的变量提升到当前作用域的最前面 只提升，不进行赋值。 12console.log(x); // 输出 undefinedvar x = 5; 在这个例子中，虽然x在使用之前被声明了，但由于变量提升的作用，var x;这一行被移到了作用域的顶部，而赋值操作x = 5;则保持原位。因此，在输出x的时候它还没有被赋值，所以输出的是undefined。 函数进阶函数提升机制： 会把所有函数声明提升到当前作用域的最前面 只提升函数声明，不提升调用 函数提升例子 12345console.log(helloWorld()); // 输出 &quot;Hello, World!&quot;function helloWorld() &#123; return &quot;Hello, World!&quot;;&#125; 在这个例子中，尽管函数helloWorld是在它被调用之后才被定义的，但是因为函数声明被提升到了作用域的顶部，所以可以正确地调用并返回结果。 警惕var定义的变量后给改该变量赋值。 12345console.log(goodbyeWorld()); // TypeError: goodbyeWorld is not a functionvar goodbyeWorld = function() &#123; return &quot;Goodbye, World!&quot;;&#125;; 在这个例子中，尽管goodbyeWorld看起来像是一个函数，但实际上它是一个赋值给变量的函数表达式。因此，只有变量名goodbyeWorld被提升到了作用域的顶部，而函数体没有被提升。试图在定义之前调用goodbyeWorld会导致一个类型错误。 函数参数默认参数ES6还支持默认参数，允许你在函数定义时为参数指定默认值。当调用函数时如果没有提供某些参数，那么这些参数就会使用默认值。 123456function greet(name, greeting = &quot;Hello&quot;) &#123; console.log(greeting + &quot;, &quot; + name);&#125;greet(&quot;John&quot;); // 输出 &quot;Hello, John&quot;greet(&quot;Jane&quot;, &quot;Hi&quot;); // 输出 &quot;Hi, Jane&quot; 动态参数 使用 arguments 对象 场景：参数个数不确定。 该对象返回了一个伪数组，该数据并没有真正数组的方法。 123456789function sum() &#123; let total = 0; for (let i = 0; i &lt; arguments.length; i++) &#123; total += arguments[i]; &#125; return total;&#125;console.log(sum(1, 2, 3, 4, 5)); // 输出 15 使用剩余参数(…)：剩余参数必须位于参数列表的最后。 从ES6开始，JavaScript引入了一种新的语法——剩余参数语法（Rest Parameters Syntax），它可以用于收集传递给函数的多余参数，并将它们作为一个数组来处理。 注意点： 该语法获取的是剩余的参数 比如：getSum(1,2,3)，传递三个参数， function getSum(a,b,...arr)&#123; &#125; 12345678910 - 在上面这个函数中，a是1，b是2，那么通过剩余参数获得参数将会被放在一个数组中，也就是3会出现在数组中。注意：要与展开运算符(...)，做一个区分：展开运算符，可以用来展开数组```jsconst arr = [1,2,3];console.log(...arr) // 输出1,2,3 应用场景： 求数组最大值、合并数组等。 箭头函数箭头函数有着更简洁的函数写法并且不绑定this，箭头函数语法要比函数表达式简洁 基本语法 1234const fn = ()=&gt;&#123; console.log(&#x27;我是箭头函数&#x27;);&#125;fn(); 箭头函数可以传递参数 1234const fn = (x)=&gt; &#123; console.log(&#x27;我是箭头函数,这是传递的参数&#x27;,x);&#125;fn(1); 只有一个形参时，可以省略参数的括号 1234const fn = x=&gt; &#123; console.log(&#x27;我是箭头函数,这是传递的参数&#x27;,x);&#125;fn(1); 函数体只有一行，可以省略大括号 12const fn = x =&gt; console.log(&#x27;我是箭头函数,这是传递的参数&#x27;,x);fn(1); 函数体只有一行代码，可以省略return 12const fn = x =&gt; xconsole.log(fn(1)); // 1 箭头函数可以直接返回一个对象 123456789const uname = (uname) =&gt; (&#123;uname:uname&#125;)console.log(uname(&#x27;刘德华&#x27;));//上面这种写法相当于下面这样写 const uname = (uname) =&gt; &#123; return &#123; uname:uname &#125; &#125; console.log(uname(&#x27;刘德华&#x27;)); 箭头函数的参数普通形参，和剩余参数。注意：箭头函数里面没有arguments 12345678910//使用箭头函数求和,这里用剩余参数去写let sum = 0;const getSum = (...arr) =&gt; &#123; for (let i = 0; i &lt; arr.length; i++) &#123; sum += arr[i]; &#125; return sum;&#125;const result = getSum(1, 5);console.log(result); 箭头函数中的this箭头函数不绑定自己的this，它使作用域中的this值。这意味着箭头函数内部的this值是根据它被定义的位置来决定的，而不是根据它被调用的位置。 解构赋值数组结构 作用：快速批量赋值变量。 基本语法： const [变量名] &#x3D; arr; 12345const arr = [100,3,2]; //使用数组解构 - 会把数组中的值，按照声明变量的顺序依次赋值,相当于 // a = 100,b=3,c=2 const [a,b,c] = arr; console.log(a,b,c); 忽略某些值有时你可能只想解构数组中的部分值。你可以通过在解构模式中留空来忽略某些值： 12345let colors = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;];let [firstColor, , thirdColor] = colors;console.log(firstColor); // 输出 &quot;red&quot;console.log(thirdColor); // 输出 &quot;blue&quot; 使用默认值123456let colors = [&#x27;red&#x27;, &#x27;green&#x27;];let [firstColor, secondColor, thirdColor = &#x27;default&#x27;] = colors;console.log(firstColor); // 输出 &quot;red&quot;console.log(secondColor); // 输出 &quot;green&quot;console.log(thirdColor); // 输出 &quot;default&quot; 解构嵌套数组1234567let nestedColors = [[&#x27;red&#x27;, &#x27;green&#x27;], [&#x27;blue&#x27;, &#x27;yellow&#x27;]];let [[firstColor, secondColor], [thirdColor, fourthColor]] = nestedColors;console.log(firstColor); // 输出 &quot;red&quot;console.log(secondColor); // 输出 &quot;green&quot;console.log(thirdColor); // 输出 &quot;blue&quot;console.log(fourthColor); // 输出 &quot;yellow&quot; 对象结构在JavaScript中，对象解构（Object Destructuring）是一种从对象中提取值并将其分配给变量的简洁方式。这种方法可以让你以更直观的方式处理对象中的属性，特别是当你需要从对象中提取特定的属性时非常有用。 对象解构的基本语法如下： 1let &#123; key1, key2 &#125; = object; 这里，&#123; key1, key2 &#125;是用于接收对象中属性值的变量列表，而object是要解构的对象。 解构基本对象1234567891011let person = &#123; firstName: &#x27;John&#x27;, lastName: &#x27;Doe&#x27;, age: 30&#125;;let &#123; firstName, lastName, age &#125; = person;console.log(firstName); // 输出 &quot;John&quot;console.log(lastName); // 输出 &quot;Doe&quot;console.log(age); // 输出 30 在这个例子中，我们创建了一个包含姓名和年龄的对象person，然后通过解构将对象中的属性分别赋值给了三个变量。 忽略某些属性有时你可能只想解构对象中的部分属性。你可以通过在解构模式中留空来忽略某些属性： 12345678910let person = &#123; firstName: &#x27;John&#x27;, lastName: &#x27;Doe&#x27;, age: 30&#125;;let &#123; firstName, , age &#125; = person;console.log(firstName); // 输出 &quot;John&quot;console.log(age); // 输出 30 这里，lastName属性被忽略了，因为它对应的解构位置为空。 使用默认值如果你希望在解构时为未提供的属性设置默认值，可以这样做： 12345678910let person = &#123; firstName: &#x27;John&#x27;, lastName: &#x27;Doe&#x27;&#125;;let &#123; firstName, lastName, age = 25 &#125; = person;console.log(firstName); // 输出 &quot;John&quot;console.log(lastName); // 输出 &quot;Doe&quot;console.log(age); // 输出 25 在这个例子中，age属性没有在原始对象中提供，所以我们为它指定了一个默认值25。 解构嵌套对象你还可以解构嵌套的对象：注意：要在前面写上要结构对象的名字 12345678910111213let person = &#123; name: &#123; first: &#x27;John&#x27;, last: &#x27;Doe&#x27; &#125;, age: 30&#125;;let &#123; name: &#123; first, last &#125;, age &#125; = person;console.log(first); // 输出 &quot;John&quot;console.log(last); // 输出 &quot;Doe&quot;console.log(age); // 输出 30 在这个例子中，我们有两个嵌套的对象，我们通过解构来分别获取每个对象中的属性。 解构并重命名属性如果你想在解构的同时给变量重新命名，可以这样做： 1234567891011let person = &#123; firstName: &#x27;John&#x27;, lastName: &#x27;Doe&#x27;, age: 30&#125;;let &#123; firstName: givenName, lastName: familyName, age &#125; = person;console.log(givenName); // 输出 &quot;John&quot;console.log(familyName); // 输出 &quot;Doe&quot;console.log(age); // 输出 30 深入对象创建对象1.通过字面量方式创建：直接使用大括号 &#123;&#125; 来定义一个对象 12345678let person = &#123; name: &quot;Alice&quot;, age: 30, sayHello: function() &#123; console.log(&quot;Hello, my name is &quot; + this.name); &#125;&#125;;person.sayHello(); // 输出: Hello, my name is Alice 2.使用new Object创建对象 12const o = new Object(&#123;name:佩奇&#125;);console.log(o) // &#123;name:佩奇&#125; 3.使用构造函数来创建 通过定义一个构造函数来创建对象。这种方式可以用来创建多个具有相同属性和方法的对象。 12345678910function Person(name, age) &#123; this.name = name; this.age = age; this.sayHello = function() &#123; console.log(&quot;Hello, my name is &quot; + this.name); &#125;;&#125;let alice = new Person(&quot;Alice&quot;, 30);alice.sayHello(); // 输出: Hello, my name is Alice 构造函数 这是一种特殊的函数，主要用来初始化对象。 通过构造函数可以快速创建多个类似的对象。 一般构造函数有两个约定： 命名以大写字母开头。 他们只能由’new’操作符来执行。 12345678//创建构造函数function Pig(name, age) &#123; this.name = name this.age = age&#125;//使用构造函数const pig = new Pig(&#x27;佩奇&#x27;, 6)console.log(pig); 实例成员&amp;静态成员这里要注意与java进行区别 1.实例成员：实例对象上的属性和方法就是实例属性和实例方法，被称为实例成员 2.静态成员：构造函数上的属性和方法就是静态属性和静态方法，称为静态成员。 存在的问题存在浪费内存的问题。 内置构造函数 Object—对象学习三个常用的静态方法（静态方法就是只有构造函数Object可以调用） Object.keys()静态方法获取对象中所有的属性 语法： 123const o = &#123;name:&#x27;佩奇&#x27;,age:6&#125;//获取对象的所有属性名，并且返回是一个数组const arr = Object.keys(o) 注意：返回的是一个数组。 Object.values()静态方法获取对象中所有的属性值 语法： 123const o = &#123;name:&#x27;佩奇&#x27;,age:6&#125;//获取对象的所有属性名，并且返回是一个数组const arr = Object.values(o) //[&#x27;佩奇&#x27;,6] 注意：返回的是一个数组。 Object.assign()静态方法常用于对象拷贝 语法： 1234const o = &#123;name:&#x27;佩奇&#x27;,age:6&#125;//获取对象的所有属性名，并且返回是一个数组const cloneObj = &#123;&#125;Object.assign(CloneObj,o) //把对象o的属性和属性值拷贝给对象cloneObj 注意：返回的是一个数组。 使用场景：一般用来给某个对象追加新属性，特别适用。 Array—数组详细用法请见：JS对象—数组对象小结 基本语法： 1const str = new Array(&#x27;这是通过构造函数创建的字符串&#x27;) 下面是一些字符串的基本方法。 Number—数值 作用：用于创建数组，是一个内置构造函数 12345678console.log(new Number(&#x27;123&#x27;)); // 123console.log(new Number(&#x27;45.67&#x27;)); // 45.67console.log(new Number(true)); // 1console.log(new Number(false)); // 0console.log(new Number(&#x27;abc&#x27;)); // NaNconsole.log(new Number(&#x27;100px&#x27;)); // NaNconsole.log(new Number(null)); // 0console.log(new Number(undefined)); // NaN 一些常用方法： toFixed()：设置保留小数位的长度 123const price = 12.345;//保留两位小数,四舍五入price.toFixed(2) // 12.35 两种编程思想面向过程编程（Procedural Programming）和面向对象编程（Object-Oriented Programming）。 1. 面向过程编程（Procedural Programming）面向过程编程是一种以过程为中心的编程范式。它将程序视为一系列的过程或函数调用，每个过程或函数完成特定的任务。这种编程方式强调的是如何一步步地解决问题。 特点包括： 代码组织：通过函数或子程序来组织代码，使得代码更易于理解和复用。 数据处理：数据通常作为参数传递给函数，并且结果也通过函数返回。 控制流：使用流程控制结构（如循环和条件语句）来控制程序执行的顺序。 2. 面向对象编程（Object-Oriented Programming, OOP）面向对象编程是一种以对象为中心的编程范式。它将程序视为对象的集合，这些对象可以包含数据（属性）和行为（方法）。OOP 强调的是对象之间的交互。 特点包括(三大特性)： 封装：将数据和操作数据的方法绑定在一起，隐藏内部细节，只对外提供接口。 继承：允许创建现有类的新版本，新版本可以继承原始类的特性并添加新的功能。 多态：允许一个接口代表多种类型，也就是说，同一个接口可以有多种不同的实现方式。 原型(重要)原型对象 构造函数通过原型分配的函数是所有对象所共享的。 JS规定，每一个构造函数都有一个prototype属性，指向另一个对象，所以我们也成为原型对象 该对象可以挂载函数，对象实例化不会多次创建原型上函数，节约内存 我们可以吧那些不变的方法，直接定义在prototype对象上，这样索引对象的实例就可以共享该方法 构造函数和原型对象中的this指向实例化对象。 示例 123456789101112131415161718192021//自己定义数组拓展方法 - 求和 和 最大值//1.定义的方法，任何数组都可以使用，所以定义在数组的原型对象上//求最大值const arr = [1,2,3]Array.prototype.max = function() &#123; //this在这里指向实例对象，也就是arr return Math.max(...this)&#125;console.log(arr.max());//3//求和Array.prototype.sum = function()&#123; //this在这里指向实例对象，也就是arr return this.reduce(function(prev,current)&#123; return prev + current &#125;,0)&#125;//调用console.log(arr.sum()); //6 constructor属性每个原型对象中都有construtor属性(该属性也被成为construtor构造函数) 作用：该属性指向该原型对象的构造函数，一图理解。 对象原型每个实例化的对象，都会有一个属性__proto__指向构造函数的prototype的原型对象，之所以我们的实例化对象可以使用构造函数原型对象的方法和属性，就是因为有__proto__对象原型的存在。 一图理解 注意： __proto__是JS非标准属性。 __proto__是只读属性。 [[prototype]] 和__proto__意义相同。 用来表示当前实例对象指向那个原型对象 最后一点：__proto__对象原型里面也有一个constructor属性，该属性指向创建该实例对象的构造函数。 三者最终关系，如下 原型继承假设我们有两个构造函数Parent和Child，我们想要让Child继承Parent的属性和方法。这可以通过将Child的prototype属性设置为Parent的实例来实现。 123456789101112131415161718192021function Parent() &#123; this.message = &#x27;Hello from Parent&#x27;;&#125;Parent.prototype.showMessage = function() &#123; console.log(this.message);&#125;;function Child() &#123; this.message = &#x27;Hello from Child&#x27;;&#125;// 设置 Child 的 prototype 为 Parent 的实例，这句代码是核心，继承就是通过这样实现。//但是切记要写成下面这种格式。Child.prototype = new Parent();// 修正 constructor 指向 ChildChild.prototype.constructor = Child;let childInstance = new Child();childInstance.showMessage(); // 输出 &quot;Hello from Parent&quot; 出现的问题 当你直接将Child.prototype设置为Parent时，所有Child实例共享Parent原型上的属性。这意味着如果你在一个实例中修改了原型上的属性，那么这个变化会影响到其他所有实例。 要注意修正 constructor 指向。不能丢失了constructor属性。 原型链JS的查找规则： 当我们在JavaScript中访问一个对象的属性时，如果该对象本身没有这个属性，JavaScript引擎会沿着该对象的原型链继续查找。更具体的查找规则如下： 当访问一个对象属性&#x2F;方法时，第一步查找该对象本身有没有该属性&#x2F;方法 如果没有，那么就查找它的原型(也就是__proto__指向的prototype原型对象)。 如果还没有那就查找原型对象的原型（也就Object的原型对象）。 依次类推一直找到Object为止，因为在往上找就是null了 __proto__对象原型存在的意义就在于为对象成员查找机制提供一个方向。或者说一条路线。 可以使用instanceof运算符用于检测构造函数中的prototype属性是否出现在某个实例对象的原型链上 原型链是由一系列原型对象组成的链式结构，最终会指向null，因为null没有原型。 原型链的工作原理 对象创建&#x2F;原型对象的概念：当使用new关键字创建一个对象时，该对象会自动获得一个原型对象，通常是构造函数的prototype属性所指向的对象。 属性查找：当访问一个对象的属性或方法时，JavaScript引擎首先会在该对象自身查找该属性。如果没有找到，它会沿着原型链向上查找，直到找到该属性或到达原型链的末端。 原型链的末端：原型链的末端是一个没有任何属性的空对象，即null。 原型链的构造 内置原型：每个内置的构造函数都有一个prototype属性，如Function.prototype、Array.prototype等。 自定义构造函数：自定义的构造函数同样拥有prototype属性，用于继承的目的。 原型链的构建：当创建一个新对象时，该对象的__proto__属性被设置为构造函数的prototype属性所指向的对象。 一图理解 上述红线的方向就是原型链的查找方向，也是原型链的方向 深浅拷贝在JavaScript中，对象的复制通常分为两种类型：浅拷贝（shallow copy）和深拷贝（deep copy）。这两种拷贝方式的主要区别在于它们处理对象内部可变数据结构的方式不同。 浅拷贝 (Shallow Copy)浅拷贝会创建一个新的对象，并尽可能地把原对象中的所有可枚举属性值复制到新对象中。如果原对象中有引用类型的属性（如数组、对象等），那么浅拷贝只会复制这些引用类型的地址而不是其内容。这意味着，对于引用类型的属性，浅拷贝后的对象和原对象指向的是同一个内存地址，因此改变其中一个对象会影响到另一个。 实现方法 使用 Object.assign(): 可以用来创建一个新对象，并将一个或多个现有对象的可枚举属性拷贝到新对象中。 使用扩展运算符 ...: 也可以用来实现对象的浅拷贝。 示例: 1234567891011let obj1 = &#123; a: 1, b: &#123; nested: 2 &#125;&#125;;let obj2 = Object.assign(&#123;&#125;, obj1);let obj3 = &#123; ...obj1 &#125;;obj1.b.nested = 3;console.log(obj2.b.nested); // 输出 3console.log(obj3.b.nested); // 输出 3 深拷贝 (Deep Copy)深拷贝会创建一个新的对象，并递归地复制原对象的所有属性，包括引用类型的数据也会被完全复制，从而保证了新对象与原对象不共享任何数据。这使得修改新对象不会影响到原对象。 实现方法 使用 JSON.parse() 和 JSON.stringify(): 这种方法可以简单地实现深拷贝，但不适用于循环引用的对象、函数、undefined、Symbol 等。 使用第三方库如 Lodash 的 _().cloneDeep() 方法。 手动实现递归深拷贝。 示例: 12345678let obj1 = &#123; a: 1, b: &#123; nested: 2 &#125;&#125;;let obj2 = JSON.parse(JSON.stringify(obj1));obj1.b.nested = 3;console.log(obj2.b.nested); // 输出 2 需要注意的是，使用 JSON.parse() 和 JSON.stringify() 方法有一些限制，比如不能处理函数、日期、正则表达式等特殊类型的对象。 如果你需要处理更复杂的数据结构或者有特殊需求，可以考虑使用一些成熟的库，例如 Lodash 的 _.cloneDeep() 方法。 手写深拷贝 12345678910111213141516171819202122232425262728//2.深拷贝//1.利用递归实现，手写一个拷贝递归函数const testObj = &#123;&#125;function deepClone(newObj, oldObj) &#123; for (let k in oldObj) &#123; //判断是否存在数组对象 if (oldObj[k] instanceof Array) &#123; //给新对象，创建一个新数组 newObj[k] = [] //接收方是新对象当中的新建的空数组，送的一方就是旧数组 deepClone(newObj[k], oldObj[k]) //处理对象类型的引用数据 &#125; else if (oldObj[k] instanceof Object) &#123; //创建一个新对象 newObj[k] = &#123;&#125; //接收方是新建的空对象，送的一方就是旧对象 deepClone(newObj[k], oldObj[k]) &#125; else &#123; console.log(typeof (k)); //k是String类型的。 //这种写法不可取newObj.k，会被认为是像对象newObj中追加一个属性名为K的属性。 //要采取下面这种写法， newObj[k] = oldObj[k] &#125; &#125;&#125;deepClone(testObj, obj)console.log(testObj); 异常处理在JavaScript中，异常处理是一种控制流结构，用于捕获和处理程序执行过程中发生的错误或异常情况。异常处理主要包括以下几个关键部分：try, catch, 和 finally 块。 异常处理语法 try 块: try 块包含了可能会抛出异常的代码。 如果 try 块中的代码执行正常，则 catch 块将被跳过。 catch 块: catch 块用于处理 try 块中抛出的异常。 catch 块接收一个参数，通常命名为 error 或 e，这个参数包含了异常信息。 finally 块: finally 块是可选的，它包含了无论是否发生异常都需要执行的代码。 finally 块在 try 和 catch 块之后执行。 使用 try-catch-finally 处理异常 下面是一个简单的示例，演示如何使用 try-catch-finally 结构来处理可能的异常： 12345678910try &#123; // 尝试执行可能会抛出异常的代码 let result = 10 / 0; // 这里会抛出异常&#125; catch (error) &#123; // 处理异常 console.error(&quot;捕获到了异常:&quot;, error.message);&#125; finally &#123; // 不管是否有异常，都会执行这里的代码 console.log(&quot;执行 finally 块&quot;);&#125; 使用 throw 抛出异常 你还可以使用 throw 语句手动抛出异常： 1234567 function fn(x,y) &#123; if(!x || !y)&#123; throw new Error(&#x27;没有参数传递进来&#x27;) &#125; return x + y &#125;console.log(fn()); 自定义异常 在JavaScript中，你还可以创建自定义异常类来处理特定类型的错误。例如： 12345678910111213141516171819202122232425class ValidationError extends Error &#123; constructor(message) &#123; super(message); this.name = &quot;ValidationError&quot;; &#125;&#125;function validateEmail(email) &#123; if (!email.includes(&quot;@&quot;)) &#123; throw new ValidationError(&quot;无效的电子邮件地址&quot;); &#125; console.log(&quot;电子邮件验证成功！&quot;);&#125;try &#123; validateEmail(&quot;example.com&quot;);&#125; catch (error) &#123; if (error instanceof ValidationError) &#123; console.error(&quot;验证错误:&quot;, error.message); &#125; else &#123; console.error(&quot;未知错误:&quot;, error); &#125;&#125; finally &#123; console.log(&quot;验证完成！&quot;);&#125; 深度学习thisthis指向this的指向在js中非常重要，下面就更加深层的理解this指向 针对普通函数总结一句话：普通函数的调用方式决定了this的指向，即谁调用函数，this就指向谁 普通函数没有明确调用者时，this指向window，严格模式下没有调用者this指向undefined 针对箭头函数事实上，箭头函数并不存在this！ 箭头函数会默认帮我们绑定外层this的值，所以在箭头函数中this的值和外层的this是一样的。 箭头函数中后的this引用的就是最近作用域中的this。 向外层作用域中，一层一层查找this，直到找到this。 需求：看需要不需要使用this，不需要this使用箭头函数更简洁方便。 改变this指向当然可以。下面是JavaScript中用于改变 this 指向的一些常用方法及其语法格式： 下面的参数中：thisArg，就是规定this指向谁，如果不需要指向，则可以写null 使用 .call()！该方法会调用函数 .call() 方法调用一个函数，并传入指定的 this 值和参数列表。 语法: 1functionName.call(thisArg, arg1, arg2, ...); 示例: 123456789function greet(greeting) &#123; console.log(greeting + &#x27;, &#x27; + this.name);&#125;const person = &#123; name: &#x27;Alice&#x27;&#125;;greet.call(person, &#x27;Hello&#x27;); // 输出: Hello, Alice 使用 .apply()！该方法会调用函数 .apply() 方法与 .call() 类似，但是它接受一个参数数组。 语法: 1functionName.apply(thisArg, [arg1, arg2, ...]); 示例: 123456789function greet(greeting) &#123; console.log(greeting + &#x27;, &#x27; + this.name);&#125;const person = &#123; name: &#x27;Alice&#x27;&#125;;greet.apply(person, [&#x27;Hello&#x27;]); // 输出: Hello, Alice 使用 .bind()注意：bind()方法不会调用函数。 .bind() 方法创建一个新的函数，这个新的函数的 this 被绑定到提供的值上。 该方法的返回值是一个新函数。 语法: 1functionName.bind(thisArg, arg1, arg2, ...); 示例: 12345678910function greet(greeting) &#123; console.log(greeting + &#x27;, &#x27; + this.name);&#125;const person = &#123; name: &#x27;Alice&#x27;&#125;;const boundGreet = greet.bind(person);boundGreet(&#x27;Hello&#x27;); // 输出: Hello, Alice 理解图 防抖和节流防抖单位时间内，频繁触发事件，但只执行最后一次触发。 简单理解：王者荣耀的回城。 使用场景 输入框的搜索建议 窗口尺寸变化时重新布局 鼠标移动时获取位置 实现方式 使用lodash提供的防抖来处理 手写防抖函数 手写防抖函数 12345678910111213141516171819202122//防抖的概念：单位时间内，频繁触发事件，但只执行最后一次触发。 let i = 1 function addNum() &#123; document.querySelector(&#x27;.box&#x27;).innerHTML = i++; console.log(&#x27;111&#x27;); &#125;//2.手写防抖函数:底层是使用定时器实现的。function debounce(fn, time) &#123; //定义一个定时器变量 let timer return function () &#123; //每次触发判断有没有定时器，如果有清除 if (timer) clearTimeout(timer) //没有就开启定时器，存入到定时器变量 timer = setTimeout(function () &#123; //在定时器里面调用函数 fn() &#125;, time) &#125;&#125; document.querySelector(&#x27;.box&#x27;).addEventListener(&#x27;mousemove&#x27;, debounce(addNum, 500)) 节流节流的目的则是确保一个函数在指定的时间间隔内最多只被调用一次。即使该函数被频繁触发，它也只会在上一次调用之后等待指定的时间间隔再次执行。 单位时间内，频繁触发事件，只执行一次 类似王者荣耀的技能，是存在CD的，CD时间内只执行一次。 使用场景 鼠标滚轮滚动 滚动事件 定时任务 手写节流函数 12345678910111213141516171819202122232425//防抖的概念：单位时间内，频繁触发事件，只执行一次 let i = 1 function addNum() &#123; document.querySelector(&#x27;.box&#x27;).innerHTML = i++; console.log(&#x27;111&#x27;); &#125;//2.手写节流函数:底层是使用定时器实现的。function throttle(fn, time) &#123; //定义一个定时器变量 let timer = null return function () &#123; //每次触发判断有没有定时器，如果有定时，不做任何操作 if (!timer) &#123; //没有就开启定时器，存入到定时器变量 timer = setTimeout(function () &#123; //在定时器里面调用函数 fn() //清空定时器 - 需要注意的是，在定时器内部清除定时器不能使用clearTimeout，而是要重新给定时器赋值为空才行 timer = null &#125;, time) &#125; &#125;&#125; document.querySelector(&#x27;.box&#x27;).addEventListener(&#x27;mousemove&#x27;, throttle(addNum, 1000)) 防抖和节流的总结 JS插件制作轮播图建议使用swiper插件 swiper官网：https://swiperjs.com/get-started(英文) swiper中文网：https://www.swiper.com.cn/ 快速收集表单内容建议使用form-serialize插件 该插件传递两个参数 要收集那个表单的数据 表单中的name属性会被作为属性名来展示在收集的数据中 建议name的值最好和接口文档一致。 配置对象&#123;hash:true,empty:true&#125; hash设置获取数据的结构 true：JS对象(推荐使用)，一般请求体里提交给服务器。 false：获取的是查询字符串。 empty设置是否获取表单中的空值。 true：获取表单中的空值。 false：不获取表单中的空值。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"}]},{"title":"uni-app框架之网易云音乐","slug":"uni-app框架之网易云音乐","date":"2024-07-26T09:29:13.000Z","updated":"2024-07-27T22:54:48.934Z","comments":true,"path":"2024/07/26/uni-app框架之网易云音乐/","permalink":"http://example.com/2024/07/26/uni-app%E6%A1%86%E6%9E%B6%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/","excerpt":"","text":"前排提示，该学习教程省略了开发软件的安装，和网易云音乐接口的配置与启动。本教程直接从新建项目开始 新建项目1.点击文件–&gt;新建–&gt;项目 2.设置详情 3.项目结构 填写微信小程序ID(建议)建议大家前往小程序网站，注册并填写小程序ID，以防止有些功能无法实现 小程序网站：https://mp.weixin.qq.com/ 在网站页面左侧菜单栏点击开发管理，复制你的小程序ID 回到开发工具中，按照如下勾选即可 字体和图标字体建议使用uniapp默认即可，图标建议使用uniapp官方提供的图标库插件，下载地址：https://uniapp.dcloud.net.cn/component/uniui/uni-icons.html#uni-icons-%E5%9B%BE%E6%A0%87 开始头部导航栏编写头部组件中 12345678910111213141516171819&lt;template&gt; &lt;view&gt; &#123;&#123;title&#125;&#125; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props:[&#x27;title&#x27;], data() &#123; return &#123; &#125; &#125;, methods: &#123; &#125; &#125;&lt;/script&gt; index主文件中： 1234567891011121314151617181920212223242526&lt;template&gt;&lt;view&gt; &lt;MusicHeadVue title=&#x27;网易云音乐&#x27;&gt;&lt;/MusicHeadVue&gt;&lt;/view&gt; &lt;/template&gt;&lt;script&gt;import MusicHeadVue from &quot;../../componets/MusicHead/MusicHead.vue&quot;export default &#123; //注册组件 components:&#123; MusicHeadVue &#125;, data()&#123; return&#123; title:&#x27;网易云音乐&#x27; &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt; &lt;/style&gt; 在头部组件中css样式代码 1234567891011121314151617.musicHead&#123; width: 100%; height: 75px; font-size: 16px; text-align: center; line-height: 80px; color: black; position: relative;&#125;.musicHeadIcon&#123; position: absolute; left: 8px; top: 33px; width: 90px; height: 31px; display: flex; justify-content: space-evenly; line-height: 31px; border-radius: 15px; background-color: rgb(0, 0, 0,0.3);&#125; 开发者工具中查看效果 紧接着，控制返回图标的有无，因为我们在首页面时是不需要显示返回上一页和返回主页的，所以需要添加方法来控制 在头部组件中写入以下代码： 12345678910&lt;view&gt; &lt;div class=&quot;musicHead&quot;&gt; &lt;div class=&quot;musicHeadIcon&quot; v-if=&quot;icon&quot;&gt; &lt;uni-icons type=&quot;back&quot; size=&quot;30&quot; @click=&quot;handleToBack()&quot;&gt;&lt;/uni-icons&gt; | &lt;uni-icons type=&quot;home&quot; size=&quot;30&quot; @click=&quot;handleToHome()&quot;&gt;&lt;/uni-icons&gt; &lt;/div&gt; &#123;&#123; title &#125;&#125; &lt;/div&gt;&lt;/view&gt; 在methods中添加方法 1234567891011methods: &#123; handleToBack()&#123; uni.navigateBack() &#125;, handleToHome()&#123; uni.navigateTo(&#123; url:&#x27;/pages/index/index&#x27; &#125;) &#125; &#125; 这里使用了uni-app中的页面和路由API 下面只给出地址，有需要可以去对应查找 页面和路由官网网址：https://uniapp.dcloud.net.cn/api/router.html#navigateto 搜索框的编写这里还用到了创建滚动条的语法，官网地址：https://uniapp.dcloud.net.cn/component/scroll-view.html来看代码 123456789101112131415&lt;template&gt; &lt;view&gt; &lt;MusicHeadVue title=&#x27;网易云音乐&#x27; :icon=&quot;false&quot;&gt;&lt;/MusicHeadVue&gt; &lt;view class=&quot;container&quot;&gt; &lt;scroll-view scroll-y=&quot;true&quot;&gt; &lt;view class=&quot;index-search&quot;&gt; &lt;span&gt; &lt;uni-icons type=&#x27;search&#x27;&gt;&lt;/uni-icons&gt; &lt;input type=&quot;text&quot; placeholder=&quot;搜索歌曲&quot; /&gt; &lt;/span&gt; &lt;/view&gt; &lt;/scroll-view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt; &lt;scroll-view scroll-y=&quot;true&quot;&gt;开启垂直方向的滚动条，里面包的内容就是可滚动内容。 样式： 12345678910111213141516171819202122&lt;style&gt;.index-search span&#123; display: flex; margin: 70rpx,30px,30rpx,30rpx; background-color: rgb(0, 0, 0,0.1); height: 35px; align-items: center; border-radius: 50rpx; margin-top: 15px; margin-left: 10px; width: 90%; &#125;.index-search input&#123; font-size: 20px; flex: 1;&#125;.index-search uni-icons&#123; margin-right: 26rpx; margin-left: 28rpx;&#125;&lt;/style&gt; 成果图： 首页音乐分类布局及样式要点：设计好对应的内容，定好分类最好是准确分类，我给出参考代码： 1234567891011&lt;view class=&quot;index-list&quot;&gt; &lt;view class=&quot;index-list-item&quot;&gt; &lt;view class=&quot;index-list-img&quot;&gt; &lt;img src=&quot;../../static/touxiang.jpg&quot; /&gt; &lt;text&gt;每天更新&lt;/text&gt; &lt;/view&gt; &lt;view class=&quot;index-list-text&quot;&gt; &lt;view&gt;1.与我无关 - 阿撋&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; 样式如下： 12345678910111213141516171819202122232425262728293031323334.index-list&#123; margin: 0 30px;&#125;.index-list-item&#123; display: flex; margin-bottom: 34rpx;&#125;.index-list-img&#123; top: 10px; width: 212rpx; height: 212rpx; position: relative; border-radius: 30rpx; overflow: hidden; margin-right: 22rpx; &#125;.index-list-img text&#123; position: absolute; left: 12rpx; bottom:16rpx; color: white; font-size: 24rpx; line-height: 66rpx; &#125;.index-list-img img&#123; width: 100%; height: 100%;&#125;.index-list-text&#123; margin-top: 10px;&#125; 图示： 首页音乐分类数据渲染接下来就是通过接口获取数据了，首先定义一个通用的url用来请求 在config.js中写入下面的内容，这里采用按需导出。 1export const baseUrl = &#x27;http://154.9.25.84:3000&#x27; 创建api.js用来请求数据：这里采用按需导入，将url导入进来后进行请求 1234567891011121314151617import &#123; baseUrl &#125; from &quot;./config&quot;;export function topList()&#123; //返回一个Promise对象 return new Promise(function(reslove,reject)&#123; uni.request(&#123; url:`$&#123;baseUrl&#125;/toplist/detail`, success:res=&gt;&#123; let result = res.data.list; //因为数据太长，这里只要前4个数据即可 result.length =4; //成功时会调用该函数并将数据返回。 reslove(result) &#125; &#125;) &#125;)&#125; ·在index中的onload函数中，引入并调用函数topList 12345678910import &#123; topList &#125; from &quot;../../common/api&quot;export default &#123; //....省略部分代码 onLoad() &#123; //因为下面的函数返回一个Promise对象，这样就可以.then进行接下来的处理了 topList().then((res)=&gt;&#123; this.topList = res; &#125;) &#125;, &#125; 然后再模板中通过v-for来遍历即可，下面给出模板代码 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;view&gt; &lt;MusicHeadVue title=&#x27;网易云音乐&#x27; :icon=&quot;false&quot;&gt;&lt;/MusicHeadVue&gt; &lt;view class=&quot;container&quot;&gt; &lt;scroll-view scroll-y=&quot;true&quot;&gt; &lt;view class=&quot;index-search&quot;&gt; &lt;span&gt; &lt;uni-icons type=&#x27;search&#x27;&gt;&lt;/uni-icons&gt; &lt;input type=&quot;text&quot; placeholder=&quot;搜索歌曲&quot; /&gt; &lt;/span&gt; &lt;/view&gt; &lt;view class=&quot;index-list&quot; v-for=&quot;(item,index) in topList&quot; :key=&quot;index&quot;&gt; &lt;view class=&quot;index-list-item&quot;&gt; &lt;view class=&quot;index-list-img&quot;&gt; &lt;img :src=&#x27;item.coverImgUrl&#x27; /&gt; &lt;text&gt;&#123;&#123;item.updateFrequency&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;view class=&quot;index-list-text&quot;&gt; &lt;view v-for=&quot;(item,index) in item.tracks&quot; :key=&#x27;index&#x27;&gt; &#123;&#123;index + 1&#125;&#125;.&#123;&#123;item.first&#125;&#125; - &#123;&#123;item.second&#125;&#125; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/scroll-view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt; 效果图：","categories":[],"tags":[{"name":"uni-app框架","slug":"uni-app框架","permalink":"http://example.com/tags/uni-app%E6%A1%86%E6%9E%B6/"}]},{"title":"Pinia状态管理工具","slug":"Pinia状态管理工具","date":"2024-07-22T06:11:34.000Z","updated":"2024-09-10T13:57:03.843Z","comments":true,"path":"2024/07/22/Pinia状态管理工具/","permalink":"http://example.com/2024/07/22/Pinia%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/","excerpt":"","text":"简介Pinia 起始于 2019 年 11 月左右的一次实验，其目的是设计一个拥有组合式 API 的 Vue 状态管理库。从那时起，我们就倾向于同时支持 Vue 2 和 Vue 3，并且不强制要求开发者使用组合式 API，我们的初心至今没有改变。除了安装和 SSR 两章之外，其余章节中提到的 API 均支持 Vue 2 和 Vue 3。虽然本文档主要是面向 Vue 3 的用户，但在必要时会标注出 Vue 2 的内容，因此 Vue 2 和 Vue 3 的用户都可以阅读本文档。 开始安装用你喜欢的包管理器安装 pinia： 123yarn add pinia# 或者使用 npmnpm install pinia 创建一个 pinia 实例 (根 store) 并将其传递给应用： 123456789import &#123; createApp &#125; from &#x27;vue&#x27;import &#123; createPinia &#125; from &#x27;pinia&#x27;import App from &#x27;./App.vue&#x27;const pinia = createPinia()const app = createApp(App)app.use(pinia)app.mount(&#x27;#app&#x27;) Store 是什么？Store (如 Pinia) 是一个保存状态和业务逻辑的实体，它并不与你的组件树绑定。换句话说，它承载着全局状态。它有点像一个永远存在的组件，每个组件都可以读取和写入它。它有三个概念，state、getter 和 action，我们可以假设这些概念相当于组件中的 data、 computed 和 methods。 定义 Store在深入研究核心概念之前，我们得知道 Store 是用 defineStore() 定义的，它的第一个参数要求是一个独一无二的名字： 12345678import &#123; defineStore &#125; from &#x27;pinia&#x27;// 你可以任意命名 `defineStore()` 的返回值，但最好使用 store 的名字，同时以 `use` 开头且以 `Store` 结尾。// (比如 `useUserStore`，`useCartStore`，`useProductStore`)// 第一个参数是你的应用中 Store 的唯一 ID。export const useAlertsStore = defineStore(&#x27;alerts&#x27;, &#123; // 其他配置...&#125;) defineStore() 的第二个参数可接受两类值：Setup 函数或 Option 对象。 类似于选项式定义Store与 Vue 的选项式 API 类似，我们也可以传入一个带有 state、actions 与 getters 属性的 Option 对象 1234567891011export const useCounterStore = defineStore(&#x27;counter&#x27;, &#123; state: () =&gt; (&#123; count: 0 &#125;), getters: &#123; double: (state) =&gt; state.count * 2, &#125;, actions: &#123; increment() &#123; this.count++ &#125;, &#125;,&#125;) 你可以认为 state 是 store 的数据 (data)，getters 是 store 的计算属性 (computed)，而 actions 则是方法 (methods)。 类似于组合式定义Store与Vue3的组合式API类似，第二个参数可以时类似于setup的函数：比如： 123456789101112export const useCounterStore = defineStore(&#x27;counter&#x27;, //定义成一个类似于setup的函数 () =&gt; &#123; const count = ref(0) const doubleCount = computed(() =&gt; count.value * 2) function increment() &#123; count.value++ &#125; return &#123; count, doubleCount, increment &#125;&#125;) 在这个和函数中 ref() 就是 state 属性 computed() 就是 getters function() 就是 actions 注意，要将定义的属性返回出去，否则在别的地方使用会无法读取数据。 使用 Store123456&lt;script setup&gt; import &#123; useCounterStore &#125; from &#x27;@/stores/counter&#x27;// 可以在组件中的任意位置访问 `store` 变量 ✨const store = useCounterStore()&lt;/script&gt; 注意，store 是一个用 reactive 包装的对象，这意味着不需要在 getters 后面写 .value。就像 setup 中的 props 一样，我们不能对它进行解构： 如何从Store中解构解构赋值会是数据失去响应性。！！！！ 为了从 store 中提取属性时保持其响应性，你需要使用 storeToRefs()。它将为每一个响应式属性创建引用。当你只使用 store 的状态而不调用任何 action 时，它会非常有用。请注意，你可以直接从 store 中解构 action，因为它们也被绑定到 store 上： 12345678910&lt;script setup&gt;import &#123; storeToRefs &#125; from &#x27;pinia&#x27;const store = useCounterStore()// `name` 和 `doubleCount` 是响应式的 ref// 同时通过插件添加的属性也会被提取为 ref// 并且会跳过所有的 action 或非响应式 (不是 ref 或 reactive) 的属性const &#123; name, doubleCount &#125; = storeToRefs(store)// 作为 action 的 increment 可以直接解构const &#123; increment &#125; = store&lt;/script&gt; Store上的$subscribe方法$subscribe方法的作用类似于watch，当store中的数据发生变化时，会触发该函数 123TestStore.$subscribe(()=&gt;&#123; console.log(&#x27;TestTwo的Store中的数据发生了变化&#x27;);&#125;) 效果： 该函数注意点有： $subscribe(()&#x3D;&gt;{})，要传入一个箭头函数，若要使用this，传入常规函数即可 该函数可以收到两个参数，mutate和state,mutate是本次修改的信息，state就是我们在store中定义的state。 State访问 state默认情况下，你可以通过 store 实例访问 state，直接对其进行读写。 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div class=&quot;count&quot;&gt; &lt;h2&gt;当前求和为：&#123;&#123; TestStore.sum &#125;&#125;&lt;/h2&gt; &lt;select v-model.number=&quot;n&quot;&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;/select&gt; &lt;button @click=&quot;add&quot;&gt;加&lt;/button&gt; &lt;button @click=&quot;catDown&quot;&gt;减&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;; //引入store实例对象import &#123;useTestStore&#125; from &#x27;@/store/TestTwo&#x27;let n = ref(0)//调用函数来进行访问const TestStore = useTestStore()console.log(TestStore);//方法function add()&#123;&#125;function catDown()&#123;&#125;&lt;/script&gt; 如果你的属性没有定义在state函数中，那么自然也访问不到。 变更 state(修改数据)1.最基本的方法12//这里拿上边的例子TestStore.sum = 4(新值即可) 2.$pacth方法依旧是上面的例子，写法这么写，可以传入一个对象 1234TestStore.$patch(&#123; //写入要更改的内容 sum:9&#125;) 写法2 针对于对集合的修改，我们也可以传入一个函数来实现 1234TestStore.$patch((state)=&gt;&#123; state.items.push(&#123;name:&#x27;小李&#x27;,quantity:1&#125;) state.hasChanged = true&#125;) 3.通过定义Action选项修改1.首先我们需要在store中配置actions选项 123456actions:&#123; //加 increment()&#123; console.log(&#x27;increment被调用了&#x27;); &#125; &#125; 2.通过store实例调用这个方法(actions) 1TestStore.increment() GetterGetter完全等同于store中state的计算值，类似于计算属性 在defineStore函数中定义getters配置项 1234567891011getters:&#123; //实际上this就相当于state，可以使用this也可以使用state //箭头函数 testSum:(state)=&gt;&#123; return state.sum+1 &#125;, //一般函数 bigSum()&#123; return this.sum * 20 &#125;&#125; 12//解构赋值const &#123;bigSum,testSum&#125; = TestStore 123456&lt;!--页面渲染--&gt;&lt;template&gt; &lt;div class=&quot;count&quot;&gt; &lt;h2&gt;原始数据是：&#123;&#123; TestStore.sum &#125;&#125;,测试数据+1：&#123;&#123; testSum &#125;&#125;,将数据放大20倍:&#123;&#123; bigSum &#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt; 效果 ActionAction 相当于组件中的 method。它们可以通过 defineStore() 中的 actions 属性来定义，并且它们也是定义业务逻辑的完美选择。 12345678910111213export const useCounterStore = defineStore(&#x27;main&#x27;, &#123; state: () =&gt; (&#123; count: 0, &#125;), actions: &#123; increment() &#123; this.count++ &#125;, randomizeCounter() &#123; this.count = Math.round(100 * Math.random()) &#125;, &#125;,&#125;) 组合式定义Store上面的写法，是选项式写法，下面介绍一些组合式定义Store 注意点有2： 在组合式中，我们并不需要去写state，getters，actions，而是用vue中的ref或者reactive定义state中的响应式变量，直接通过function + 函数名字来定义函数即可。 要记得把要用到的数据和方法return出去 示例写法如下： 12345678910111213141516171819202122//组合式写法import &#123; ref, computed &#125; from &quot;vue&quot;;export const useTestStore = defineStore(&#x27;TestTwo&#x27;, () =&gt; &#123; //相当于data(vue2) //切记，使用ref定义响应式时，操作数据不要忘记加.value let sum = ref(6) let testNum = ref(0) let testSum = ref(0) //组合式的actions function increment() &#123; testNum.value = testSum.value +=1 return testNum.value &#125; //组合式的getters const bigSum = computed(()=&gt;&#123; return sum.value * 20 &#125;) return &#123;increment,bigSum,testNum&#125;&#125;,)","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"状态管理工具(vue3.js)","slug":"状态管理工具-vue3-js","permalink":"http://example.com/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-vue3-js/"}]},{"title":"HTML5+CSS3","slug":"HTML5+CSS3","date":"2024-07-21T10:50:51.000Z","updated":"2024-09-05T10:38:55.830Z","comments":true,"path":"2024/07/21/HTML5+CSS3/","permalink":"http://example.com/2024/07/21/HTML5+CSS3/","excerpt":"","text":"HTML块级元素与行内元素定义: 块级元素默认占据整行，形成一个块容器。 行内元素默认在同一行内与其他元素并排显示。 块级元素示例 &lt;h1&gt;: 标题 &lt;p&gt;: 段落 &lt;div&gt;: 通用容器 块级元素特点 默认情况下，每个块级元素都会在其前后形成换行。 宽度和高度可以设置，并且可以填充整个容器宽度。 可以设置 margin 和 padding 的上下左右值。 通常作为其他元素的容器。 行内元素示例 &lt;a&gt;: 链接 &lt;span&gt;: 通用行内容器 &lt;img&gt;: 图像（默认为行内元素） 行内元素特点 不会在前后形成换行，多个行内元素可以在一行内显示。 宽度和高度默认由内容决定，不能设置宽度和高度。 只能设置左右 margin 和 padding。 通常用于文本或小部件。 示例假设我们有以下 HTML 结构： 123&lt;h1&gt;Title&lt;/h1&gt;&lt;p&gt;This is a paragraph. &lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/p&gt;&lt;div&gt;Block level &lt;span&gt;inline&lt;/span&gt; elements.&lt;/div&gt; 我们可以观察到以下默认行为： &lt;h1&gt; 和 &lt;p&gt; 是块级元素，它们各自占据一行。 &lt;a&gt; 和 &lt;span&gt; 是行内元素，它们在 &lt;p&gt; 和 &lt;div&gt; 内与其他文本并排显示。 转换元素类型你可以使用 display 属性来转换元素的显示方式： 将行内元素转换为块级元素： 123a &#123; display: block;&#125; 将块级元素转换为行内元素： 123div &#123; display: inline;&#125; 行内块元素 元素可以与其他行内元素或行内块元素在同一行显示。 可以直接设置宽度和高度。 可以设置内边距和外边距，包括上下值。 注意事项 块级元素和行内元素的行为可以通过 display 属性进行修改。 根据布局需求选择合适的元素类型可以提高页面的可读性和可维护性。 了解元素的默认行为有助于更有效地进行样式设计。 h1~h6标签不能相互嵌套 p标签中不要写块级元素 文本标签HTML 文本标签 是用来格式化网页上的文本内容的。合理使用这些标签可以使你的网页更加易读和语义化。 基础文本格式化标签 &lt;strong&gt;: 强调文本的重要性，通常以粗体显示。 &lt;em&gt;: 强调文本，通常以斜体显示。 &lt;mark&gt;: 高亮文本，通常以黄色背景色显示。 &lt;small&gt;: 缩小文本尺寸，常用于版权信息等。 &lt;del&gt;: 删除线效果，表示文本已被删除。 &lt;ins&gt;: 下划线效果，表示文本被插入。 &lt;sub&gt;: 下标，用于化学公式等。 &lt;sup&gt;: 上标，用于指数等。 &lt;u&gt;: 为文本添加下划线，不建议使用，推荐使用 &lt;ins&gt; 或 CSS。 &lt;s&gt;: 为文本添加删除线，不建议使用，推荐使用 &lt;del&gt; 或 CSS。 &lt;b&gt;: 粗体文本，不表示重要性，仅用于视觉效果。 注意事项 使用语义化的标签，例如 &lt;article&gt;、&lt;section&gt;、&lt;header&gt; 和 &lt;footer&gt; 等，可以使文档结构更加清晰。 保持良好的编码习惯，如闭合标签、缩进等，以便于阅读和维护。 确保所有标签正确嵌套，避免交叉嵌套。 通过使用 CSS 进一步增强样式和布局。 超链接标签HTML 超链接 是网页中不可或缺的一部分，它允许用户从一个页面跳转到另一个页面或其他资源。超链接由 &lt;a&gt;（anchor）标签定义。 基本语法1&lt;a href=&quot;URL&quot;&gt;Link Text&lt;/a&gt; href: 指定链接的目标地址。 Link Text: 显示给用户的链接文本。 示例1&lt;a href=&quot;https://www.example.com&quot;&gt;Visit Example&lt;/a&gt; 不同类型的超链接 内部链接 链接到同一网站内的其他页面。 可以使用相对路径或绝对路径。 1&lt;a href=&quot;/about.html&quot;&gt;About Us&lt;/a&gt; 外部链接 链接到其他网站。 必须使用完整的URL。 1&lt;a href=&quot;https://www.google.com&quot; target=&quot;_blank&quot;&gt;Google&lt;/a&gt; 锚点链接 在当前页面内跳转到指定位置。 通过在目标元素上设置 id 属性，并在链接中使用 # 加上该 id。 12&lt;a href=&quot;#section2&quot;&gt;Jump to Section 2&lt;/a&gt;&lt;h2 id=&quot;section2&quot;&gt;Section 2&lt;/h2&gt; 电子邮件链接 直接打开用户的默认邮件客户端。 使用 mailto: 协议。 1&lt;a href=&quot;mailto:support@example.com&quot;&gt;Contact Support&lt;/a&gt; 文件下载链接 当链接指向一个文件时，浏览器会尝试下载这个文件。 1&lt;a href=&quot;/downloads/report.pdf&quot;&gt;Download Report&lt;/a&gt; JavaScript 功能 可以使用 javascript: 协议来触发 JavaScript 代码。 1&lt;a href=&quot;javascript:alert(&#x27;Hello!&#x27;)&quot;&gt;Click me&lt;/a&gt; 属性 target: 控制链接打开的方式。 _self: 默认值，链接在当前窗口或标签页打开。 _blank: 链接在新窗口或标签页打开。 _parent: 链接在父框架集打开。 _top: 链接在顶层窗口打开。 rel: 定义与链接文档的关系。 noopener: 告诉浏览器不要给予新打开的窗口访问当前窗口的权限。 noreferrer: 隐藏 HTTP Referer 头。 nofollow: 告诉搜索引擎不要跟踪此链接。 noopener noreferrer nofollow: 综合以上三个属性。 download: 如果出现，则强制将链接作为文件下载而不是导航。 可选地，可以提供一个文件名提示。 1&lt;a href=&quot;/downloads/report.pdf&quot; download&gt;Download Report&lt;/a&gt; 最佳实践 可用性: 确保链接文本描述了链接的目的。 可访问性: 使用 aria-label 或 title 属性提供额外的信息。 安全性: 对外部链接使用 rel=&quot;noopener noreferrer&quot;。 性能: 对于较大的文件，考虑使用渐进式加载技术。 表单HTML 表单 是收集用户输入的主要方式之一。表单由 &lt;form&gt; 标签定义，并包含一系列表单控件，如文本框、按钮、下拉列表等。 基本语法123456&lt;form action=&quot;submit.php&quot; method=&quot;post&quot;&gt; &lt;!-- 表单控件 --&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;Username&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;Password&quot;&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt; action: 表单数据提交的URL。 method: 提交表单数据的方式，常见值为 get 和 post。 表单控件 文本输入 (&lt;input type=&quot;text&quot;&gt;): 单行文本输入。 密码输入 (&lt;input type=&quot;password&quot;&gt;): 输入字符被隐藏。 复选框 (&lt;input type=&quot;checkbox&quot;&gt;): 多选输入。 单选按钮 (&lt;input type=&quot;radio&quot;&gt;): 互斥选择。 下拉列表 (&lt;select&gt;): 下拉选择列表。 文本区域 (&lt;textarea&gt;): 多行文本输入。 文件上传 (&lt;input type=&quot;file&quot;&gt;): 文件选择器。 提交按钮 (&lt;input type=&quot;submit&quot;&gt;): 提交表单。 重置按钮 (&lt;input type=&quot;reset&quot;&gt;): 重置表单。 按钮 (&lt;button&gt;): 通用按钮，可以定义 type 为 button, submit, 或 reset。 示例123456789101112131415161718192021&lt;form action=&quot;/submit.php&quot; method=&quot;post&quot;&gt; &lt;label for=&quot;username&quot;&gt;Username:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; required&gt; &lt;label for=&quot;email&quot;&gt;Email:&lt;/label&gt; &lt;input type=&quot;email&quot; id=&quot;email&quot; name=&quot;email&quot; required&gt; &lt;label for=&quot;password&quot;&gt;Password:&lt;/label&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; required&gt; &lt;label for=&quot;gender&quot;&gt;Gender:&lt;/label&gt; &lt;select id=&quot;gender&quot; name=&quot;gender&quot;&gt; &lt;option value=&quot;male&quot;&gt;Male&lt;/option&gt; &lt;option value=&quot;female&quot;&gt;Female&lt;/option&gt; &lt;/select&gt; &lt;label for=&quot;newsletter&quot;&gt;Subscribe to newsletter:&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;newsletter&quot; name=&quot;newsletter&quot; value=&quot;yes&quot;&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt; 表单属性 name: 表单控件的名称，用于标识表单数据。 id: 表单控件的唯一标识符，用于关联标签。 value: 表单控件的初始值。 placeholder: 提供给用户的提示文本。 required: 标记控件为必需填写。 disabled: 禁用控件。 readonly: 只读控件，用户无法更改内容。 pattern: 设置输入模式，用于验证输入。 min 和 max: 限制数值或日期范围。 multiple: 允许用户选择多个文件或选项。 最佳实践 使用 &lt;label&gt;: 为每个表单控件添加 &lt;label&gt;，提高可访问性。 表单验证: 使用 HTML5 的内置验证属性（如 required, pattern）或 JavaScript 进行验证。 响应式设计: 确保表单在不同设备上都能良好显示。 安全: 使用 HTTPS 加密传输数据，保护用户隐私。 用户体验: 提供即时反馈，减少不必要的步骤。 注意事项 服务器端验证: 即使进行了客户端验证，也需要在服务器端再次验证数据。 数据保护: 不要在表单中收集敏感信息，除非必要。 错误消息: 提供清晰的错误消息，帮助用户理解问题所在。 字符实体特殊字符 数学符号 货币符号 箭头 下面是一个包含上述字符实体的HTML文档示例： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;HTML Character Entities Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;字符实体示例&lt;/h1&gt; &lt;p&gt;Special characters: &amp;lt; &amp;gt; &amp;amp; &amp;quot; &amp;apos; &amp;nbsp;&lt;/p&gt; &lt;p&gt;Math symbols: &amp;plusmn; &amp;times; &amp;divide; &amp;frac12; &amp;frac14; &amp;frac34; &amp;deg; &amp;infin; &amp;ne;&lt;/p&gt; &lt;p&gt;Currency symbols: &amp;euro; &amp;yen; &amp;pound; &amp;cent;&lt;/p&gt; &lt;p&gt;Arrows: &amp;larr; &amp;uarr; &amp;rarr; &amp;darr;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 在这个示例中，我们使用了各种字符实体来展示特殊字符、数学符号、货币符号以及箭头。 其他标签video视频标签HTML5 的 &lt;video&gt; 标签用于在网页中嵌入视频内容。它提供了一种简单的方式让用户在浏览器中观看视频，而不需要额外的插件如 Flash。以下是 &lt;video&gt; 标签的一些关键属性和用法的总结： 基本用法12345&lt;video controls&gt; &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot;&gt; Your browser does not support the video tag.&lt;/video&gt; 主要属性 controls: 显示播放控件，如播放&#x2F;暂停按钮、音量控制等。 示例：1&lt;video controls&gt;&lt;/video&gt; autoplay: 视频将自动播放。 前提是开启静音 示例：1&lt;video autoplay&gt;&lt;/video&gt; loop: 视频结束后自动重新播放。 示例：1&lt;video loop&gt;&lt;/video&gt; muted: 默认情况下静音播放视频。 这是自动播放的前提 示例：1&lt;video muted&gt;&lt;/video&gt; preload: 指定视频加载方式： auto: 自动加载整个视频（默认） metadata: 只加载元数据 none: 不预先加载任何数据 示例：1&lt;video preload=&quot;metadata&quot;&gt;&lt;/video&gt; src: 视频文件的 URL。 示例：1&lt;video src=&quot;movie.mp4&quot;&gt;&lt;/video&gt; poster: 在视频开始播放之前显示的图像。 示例：1&lt;video poster=&quot;thumbnail.jpg&quot;&gt;&lt;/video&gt; width 和 height: 设置视频播放器的宽度和高度。 示例：1&lt;video width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/video&gt; playsinline: 视频将在标准模式下播放，而不是全屏模式。 示例：1&lt;video playsinline&gt;&lt;/video&gt; autoplay=&quot;true&quot;: 同 autoplay，但明确指定了布尔值 true。 &lt;source&gt; 元素 &lt;source&gt; 元素用于指定多个视频源，以确保在不同浏览器中都能播放视频。 示例：123456&lt;video controls&gt; &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot;&gt; &lt;source src=&quot;movie.webm&quot; type=&quot;video/webm&quot;&gt; Your browser does not support the video tag.&lt;/video&gt; audio音频标签HTML5 的 &lt;audio&gt; 标签用于在网页中嵌入音频内容。它提供了一种简单的方式让用户在浏览器中播放音频文件，而不需要额外的插件如 Flash。以下是 &lt;audio&gt; 标签的一些关键属性和用法的总结： 基本用法12345&lt;audio controls&gt; &lt;source src=&quot;song.mp3&quot; type=&quot;audio/mpeg&quot;&gt; &lt;source src=&quot;song.ogg&quot; type=&quot;audio/ogg&quot;&gt; Your browser does not support the audio element.&lt;/audio&gt; 主要属性 controls: 显示播放控件，如播放&#x2F;暂停按钮、音量控制等。 示例：1&lt;audio controls&gt;&lt;/audio&gt; autoplay: 音频将自动播放。 示例：1&lt;audio autoplay&gt;&lt;/audio&gt; loop: 音频结束后自动重新播放。 示例：1&lt;audio loop&gt;&lt;/audio&gt; muted: 默认情况下静音播放音频。 示例：1&lt;audio muted&gt;&lt;/audio&gt; preload: 指定音频加载方式： auto: 自动加载整个音频文件（默认） metadata: 只加载元数据(例如歌曲长度) none: 不预先加载任何数据 示例：1&lt;audio preload=&quot;metadata&quot;&gt;&lt;/audio&gt; src: 音频文件的 URL。 示例：1&lt;audio src=&quot;song.mp3&quot;&gt;&lt;/audio&gt; width: 设置音频播放器的宽度。 示例：1&lt;audio width=&quot;320&quot;&gt;&lt;/audio&gt; autoplay=&quot;true&quot;: 同 autoplay，但明确指定了布尔值 true。 &lt;source&gt; 元素 &lt;source&gt; 元素用于指定多个音频源，以确保在不同浏览器中都能播放音频。 示例：123456&lt;audio controls&gt; &lt;source src=&quot;song.mp3&quot; type=&quot;audio/mpeg&quot;&gt; &lt;source src=&quot;song.ogg&quot; type=&quot;audio/ogg&quot;&gt; &lt;source src=&quot;song.wav&quot; type=&quot;audio/wav&quot;&gt; Your browser does not support the audio element.&lt;/audio&gt; 事件 &lt;audio&gt; 元素支持多种事件，可以使用 JavaScript 来监听这些事件。 示例：1234var myAudio = document.querySelector(&#x27;audio&#x27;);myAudio.addEventListener(&#x27;play&#x27;, function() &#123; console.log(&#x27;The audio has started playing.&#x27;);&#125;); 表格标签 标签：table 1&lt;table&gt;&lt;/table&gt; 属性border：规定表格边框的宽度，width：规定表格的宽度，cellspacing：规定单元之间的空间 tr：表格的行，可以包裹多个td td：表格的单元格(普通)，可以包裹内容，如果是表头单元格可以用标签th 全局属性1. 什么是全局属性？ 定义：全局属性是可以应用于所有HTML元素的属性。这意味着无论你使用什么元素，都可以附加这些属性以增加更多的功能或信息。 2. 常见的全局属性 class: 定义元素的一个或多个类名，用于CSS样式或JavaScript操作。 1&lt;div class=&quot;container&quot;&gt;&lt;/div&gt; id: 定义元素的唯一标识符，用于CSS样式或JavaScript操作。 1&lt;div id=&quot;main&quot;&gt;&lt;/div&gt; title: 定义元素的额外信息，通常作为工具提示显示。 1&lt;a href=&quot;#&quot; title=&quot;Click here for more information&quot;&gt;Link&lt;/a&gt; style: 定义元素的内联样式。 1&lt;p style=&quot;color: red;&quot;&gt;This is a styled paragraph.&lt;/p&gt; tabindex: 定义元素在文档中的Tab顺序。 1&lt;input type=&quot;text&quot; tabindex=&quot;1&quot;&gt; lang: 定义元素的语言。 1&lt;p lang=&quot;es&quot;&gt;Este es un párrafo en español.&lt;/p&gt; dir: 定义元素的文本方向。 1&lt;p dir=&quot;rtl&quot;&gt;This is right-to-left text.&lt;/p&gt; hidden: 表示元素不可见。 1&lt;div hidden&gt;This is a hidden element.&lt;/div&gt; contenteditable: 允许用户编辑元素的内容。 1&lt;p contenteditable=&quot;true&quot;&gt;Edit this text.&lt;/p&gt; draggable: 指示元素是否可拖动。 1&lt;img draggable=&quot;true&quot; src=&quot;image.jpg&quot; alt=&quot;Draggable Image&quot;&gt; spellcheck: 指示浏览器是否应该检查拼写和语法。 1&lt;textarea spellcheck=&quot;false&quot;&gt;&lt;/textarea&gt; accesskey: 定义一个键盘快捷键来激活元素。 1&lt;button accesskey=&quot;1&quot;&gt;Button&lt;/button&gt; data-\\*: 自定义数据属性，用于存储页面或应用程序的私有数据。 1&lt;div data-user-id=&quot;123&quot;&gt;User Profile&lt;/div&gt; 对于自定义属性来说，访问方式如下： 通过dataset来读取 1&lt;div id=&quot;example&quot; data-custom-attribute=&quot;hello&quot;&gt;&lt;/div&gt; 12var element = document.getElementById(&#x27;example&#x27;);var customAttribute = element.dataset.customAttribute; // &quot;hello&quot; 通过dataset来设置属性 12var element = document.getElementById(&#x27;example&#x27;);element.dataset.customAttribute = &#x27;world&#x27;; 如果你的自定义属性名包含连字符，如 data-my-attr，在 dataset 对象中，连字符会被转换成驼峰式命名，即 myAttr。 如果你的自定义属性名与某个标准属性名冲突（比如 data-class），那么在 dataset 对象中，你必须使用 class_（带下划线）的形式来引用它。 自定义属性只应该用于存储简单的字符串数据。如果需要存储复杂的数据结构，考虑使用JSON格式的字符串。 CSS基础1.行内样式直接写在标签上，通过style属性来指定样式 123&lt;body&gt; &lt;h1 style=&quot;color: aqua;&quot;&gt;这是一段话&lt;/h1&gt;&lt;/body&gt; 效果 2.内部样式一般位于head标签内，这时，我们需写style标签，并在其中指定样式 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; h1&#123; color: aqua; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这是一段话&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 效果 3.外部样式通过外部引入的方式，来进行样式的匹配。 语法: 通过href来指定外部css文件的路径 1&lt;link rel=&quot;stylesheet&quot; href=&quot;&quot;&gt; 1234/*这outCSS.css内的内容 */h1&#123; color: red;&#125; 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;./外部CSS文件/outCSS.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这是一段话&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 效果 4.样式表的优先级 优先级规则：行内样式 &gt; 内部样式 &#x3D; 外部样式 内部样式 和外部样式优先级相同，但是后面写的会覆盖前面写的样式 同一个样式表中，优先级也和编写顺序有关，同样后面的也会覆盖前面的样式。 分类 优点 缺点 使用频率 作用范围 行内样式 优先级最高 1.结构与样式未分离2.代码结构混乱3.样式不能复用 很低 当前标签 内部样式 1.样式可以复用2.代码结构清晰 1.结构与样式未彻底分离2.样式不能多页面使用 一般 当前页面 外部样式 1.样式可以多页面复用 2.代码结构清晰3.可触发游览器缓存机制4.结构与样式彻底分离 需要引入才能使用 最高 多个页面 5.CSS语法规范CSS语法由两部分构成： 选择器：找到要添加样式的元素 声明块：设置具体的样式，可以有多个，格式：属性名：属性值; CSS选择器CSS基本选择器 通配选择器 元素选择器 类选择器 id选择器 1.通配选择器 选中html中所有元素 语法： * &#123; 属性名:属性值 &#125; 1234567* 例子 * ```css * &#123; color: red; &#125; 2.元素选择器 作用：为页面中 某种元素 统一设置样式 语法： 标签名 &#123; 属性名:属性值; &#125; 12345678* 例子： * ```css /* 选中所有h1元素 */ h1 &#123; color: blue; &#125; 3.类选择器 作用：根据元素的class值，来选中某些元素 语法： 123.类名 &#123; 属性名:属性值;&#125; 举例 123456/* 选中所有class值为test的元素 */.test&#123; color:red; font-size:90px;&#125; 4.ID选择器 作用：根据元素的id属性来精准选择某个元素。 语法： 123#id值 &#123; 属性值:属性名;&#125; 举例 12345/* 选中id为test的元素 */#test &#123; color: red; font-size:40px;&#125; CSS复合选择器1.交集选择器 交集选择器是由两个或多个选择器直接连接（没有空格）组成。 它们匹配同时符合所有组成部分的选择器的元素。 如果其中一个部分是类型选择器（例如 div），它通常被省略，因为所有元素都是某种类型的元素。 交集有并且的含义 语法示例：123div.myClass &#123; /* styles go here */&#125; 这个选择器会选择所有带有 myClass 类的 &lt;div&gt; 元素。 示例假设我们有以下 HTML 结构： 123456&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;item myItem&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;otherItem&quot;&gt;&lt;/div&gt; 我们可以使用交集选择器来选择同时具有 item 和 myItem 类的 &lt;div&gt; 元素： 123.item.myItem &#123; color: blue;&#125; 这会使得第一个 &lt;div&gt;（即 .item.myItem）的文字颜色变为蓝色，而其他元素则不受影响。 注意事项： 交集选择器不会选择那些只具有其中一个类的元素。 如果一个选择器包含多个类，那么元素必须拥有这些类的所有值。 2.并集选择器定义: 并集选择器由多个选择器通过逗号分隔组成。 这些选择器匹配的是各自独立选择的元素集合的并集。 并集选择器是或的意思。 语法: 123selector1, selector2, selector3 &#123; /* styles go here */&#125; 例如，以下选择器会选择所有的 &lt;p&gt; 元素和所有带有 highlight 类的元素： 123p, .highlight &#123; color: red;&#125; 示例假设我们有以下 HTML 结构： 123&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;This is highlighted text.&lt;/div&gt;&lt;span&gt;This is a span element.&lt;/span&gt; 我们可以使用并集选择器来选择所有的 &lt;p&gt; 元素以及带有 highlight 类的任何元素： 123p, .highlight &#123; color: red;&#125; 这会使得 &lt;p&gt; 元素和 .highlight 类的 &lt;div&gt; 的文字颜色都变为红色。 注意事项： 并集选择器中的每个选择器都是独立的，它们之间没有关系。 每个选择器都会应用样式规则到其匹配的元素上。 可以通过这种方式组合不同类型的选择器（如类型选择器、类选择器等）。 3.后代选择器定义: 后代选择器用于选择某个元素的所有后代元素（子元素的子元素等等）。 后代选择器由两个或多个选择器通过空格分隔组成。 语法: 123parent-selector child-selector &#123; /* styles go here */&#125; 例如，以下选择器会选择所有 &lt;ul&gt; 下的 &lt;li&gt; 元素： 123ul li &#123; color: blue;&#125; 示例假设我们有以下 HTML 结构： 1234567891011121314&lt;div class=&quot;container&quot;&gt; &lt;p&gt;Outside the list.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3 &lt;ul&gt; &lt;li&gt;Sub-item 1&lt;/li&gt; &lt;li&gt;Sub-item 2&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Another paragraph outside the list.&lt;/p&gt;&lt;/div&gt; 我们可以使用后代选择器来选择所有位于 &lt;ul&gt; 内的 &lt;li&gt; 元素： 123.container ul li &#123; color: blue;&#125; 这会使得所有 &lt;ul&gt; 内的 &lt;li&gt; 元素的文字颜色变为蓝色。 注意事项： 后代选择器中的选择器是按照从父到子的顺序排列的。 空格表示“后代”关系，意味着选择器匹配的是第一个选择器所选元素的所有后代元素。 可以通过这种方式选择特定层级的元素或者更深层的元素。 图示 4.子代选择器定义: 子代选择器用于选择某个元素的**直接子元素(儿子元素)**。 子代选择器由两个或多个选择器通过大于号 (&gt;) 分隔组成。 语法: 123parent-selector &gt; child-selector &#123; /* styles go here */&#125; 例如，以下选择器会选择所有 &lt;ul&gt; 的直接子元素 &lt;li&gt;： 123ul &gt; li &#123; color: blue;&#125; 示例假设我们有以下 HTML 结构： 1234567891011121314&lt;div class=&quot;container&quot;&gt; &lt;p&gt;Outside the list.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3 &lt;ul&gt; &lt;li&gt;Sub-item 1&lt;/li&gt; &lt;li&gt;Sub-item 2&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Another paragraph outside the list.&lt;/p&gt;&lt;/div&gt; 我们可以使用子代选择器来选择所有 &lt;ul&gt; 的直接子元素 &lt;li&gt;： 123.container ul &gt; li &#123; color: blue;&#125; 这会使得 &lt;ul&gt; 的直接子元素 &lt;li&gt; 的文字颜色变为蓝色，但不会影响 &lt;ul&gt; 内部的子 &lt;ul&gt; 中的 &lt;li&gt;。 注意事项： 子代选择器中的选择器是按照从父到子的顺序排列的。 大于号 (&gt;) 表示“直接子元素”关系，意味着选择器仅匹配第一个选择器所选元素的直接子元素。 可以通过这种方式精确地选择特定层级的元素。 5.兄弟选择器定义: 兄弟选择器用于选择与另一个元素具有相同父元素的元素。 CSS 提供了两种主要类型的兄弟选择器：相邻兄弟选择器 (+) 和一般兄弟选择器 (~)。 相邻兄弟选择器 (+): 相邻兄弟选择器用于选择紧接在另一个元素后的元素，且这两个元素有相同的父元素。 语法：element1 + element2 选择紧接在 element1 后面的 element2 元素。 一般兄弟选择器 (~): 一般兄弟选择器用于选择前面有另一个元素的元素，且这两个元素有相同的父元素。 语法：element1 ~ element2 选择位于 element1 后面的所有 element2 元素。 示例假设我们有以下 HTML 结构： 1234567&lt;div class=&quot;container&quot;&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt; &lt;div&gt;Some div content&lt;/div&gt; &lt;p&gt;Paragraph 3&lt;/p&gt; &lt;p&gt;Paragraph 4&lt;/p&gt;&lt;/div&gt; 我们可以使用相邻兄弟选择器来选择紧接在第一个 &lt;p&gt; 元素后面的 &lt;p&gt; 元素： 123p + p &#123; color: blue;&#125; 这会使得紧接在第一个 &lt;p&gt; 元素后面的 &lt;p&gt; 元素的文字颜色变为蓝色。 我们也可以使用一般兄弟选择器来选择所有位于第一个 &lt;p&gt; 元素后面的 &lt;p&gt; 元素： 123p ~ p &#123; color: green;&#125; 这会使得所有位于第一个 &lt;p&gt; 元素后面的 &lt;p&gt; 元素的文字颜色变为绿色。 注意事项： 相邻兄弟选择器 (+) 仅选择紧接在前一个元素后面的元素。 一般兄弟选择器 (~) 选择所有位于前一个元素后面的元素。 这些选择器要求元素有相同的父元素。 6.属性选择器定义: 属性选择器用于选择具有指定属性或属性值的元素。 这种选择器允许你根据元素的属性来选择元素，非常灵活且强大。 语法: [attribute]: 选择具有给定属性的元素。 [attribute=value]: 选择具有给定属性和值的元素。 [attribute^=value]: 选择属性值以指定字符串开头的元素。 [attribute$=value]: 选择所有属性值以指定的字符串 value 结尾的元素。 [attribute*=value]: 选择属性值包含指定字符串的元素。 示例假设我们有以下 HTML 结构： 1234&lt;a href=&quot;https://example.com&quot;&gt;Link to Example&lt;/a&gt;&lt;a href=&quot;https://google.com&quot;&gt;Google&lt;/a&gt;&lt;a href=&quot;https://example.com/about&quot;&gt;About Example&lt;/a&gt;&lt;a href=&quot;https://example.org&quot;&gt;Example Org&lt;/a&gt; 我们可以使用属性选择器来选择所有具有 href 属性的 &lt;a&gt; 元素，并将它们的颜色设置为蓝色： 123a[href] &#123; color: blue;&#125; 如果我们要选择所有链接到 example.com 的 &lt;a&gt; 元素，并将它们的颜色设置为绿色： 123a[href^=&quot;https://example.com&quot;] &#123; color: green;&#125; 如果我们要选择所有链接以 .com 结尾的 &lt;a&gt; 元素，并将它们的颜色设置为红色： 123a[href$=&quot;.com&quot;] &#123; color: red;&#125; 如果我们要选择所有链接中包含 example 字符串的 &lt;a&gt; 元素，并将它们的颜色设置为 orange： 123a[href*=&quot;example&quot;] &#123; color: orange;&#125; 注意事项： 属性选择器可以非常具体，因此它们的优先级高于大多数其他类型的选择器。 使用这些选择器可以更精细地控制样式，特别是在处理具有特定属性或属性值的元素时。 属性选择器可以与其他选择器结合使用，例如类选择器或 ID 选择器。 7.伪类选择器定义: 伪类选择器用于选择处于特定状态的元素。 这些状态通常是用户交互的结果，比如鼠标悬停或激活链接。 常见伪类选择器用户动作相关的伪类 :hover: 当用户将鼠标指针悬停在元素上时选择该元素。 :active: 当元素被激活（例如，鼠标点击时）时选择该元素。 :focus: 当元素获得焦点（例如，通过键盘导航）时选择该元素。 :focus-within: 当元素或其后代获得焦点时选择该元素。 :focus-visible: 当元素获得焦点且浏览器认为应显示焦点指示时选择该元素。 链接相关的伪类 :link: 选择未被访问过的链接。 :visited: 选择已被用户访问过的链接。 :target: 选择当前被激活的 URL 锚点的目标元素。 :scope: 选择当前作用域内的元素，通常与自定义伪元素一起使用。 结构相关的伪类 :first-child: 选择其父元素的第一个子元素。 :last-child: 选择其父元素的最后一个子元素。 :only-child: 选择其父元素中唯一的一个子元素。 :nth-child(n): 选择其父元素的第 n 个子元素。 :nth-last-child(n): 选择其父元素倒数第 n 个子元素。 :nth-of-type(n): 选择其父元素的第 n 个同类型子元素。 :nth-last-of-type(n): 选择其父元素倒数第 n 个同类型子元素。 :first-of-type: 选择其父元素的第一个同类型子元素。 :last-of-type: 选择其父元素的最后一个同类型子元素。 :only-of-type: 选择其父元素中唯一的同类型子元素。 状态相关的伪类 :checked: 选择被选中的 &lt;input type=&quot;checkbox&quot;&gt; 或 &lt;input type=&quot;radio&quot;&gt; 元素。 :enabled: 选择可交互的 &lt;input&gt; 或 &lt;button&gt; 元素。 :disabled: 选择不可交互的 &lt;input&gt; 或 &lt;button&gt; 元素。 :indeterminate: 选择未完全选中的 &lt;input type=&quot;checkbox&quot;&gt; 或 &lt;progress&gt; 元素。 :valid: 选择有效表单控件。 :invalid: 选择无效表单控件。 :in-range: 选择在范围内的 &lt;input type=&quot;number&quot;&gt; 或 &lt;input type=&quot;range&quot;&gt; 元素。 :out-of-range: 选择超出范围的 &lt;input type=&quot;number&quot;&gt; 或 &lt;input type=&quot;range&quot;&gt; 元素。 :placeholder-shown: 选择显示占位符文本的 &lt;input&gt; 或 &lt;textarea&gt; 元素。 :read-only: 选择只读的 &lt;input&gt; 或 &lt;textarea&gt; 元素。 :read-write: 选择可编辑的 &lt;input&gt; 或 &lt;textarea&gt; 元素。 :required: 选择被标记为必填的 &lt;input&gt; 或 &lt;select&gt; 元素。 :optional: 选择未被标记为必填的 &lt;input&gt; 或 &lt;select&gt; 元素。 否定伪类语法： :not(选择器):排除满足括号中条件的元素。 假设我们有以下 HTML 结构： 1234567&lt;a href=&quot;https://example.com&quot; class=&quot;link&quot;&gt;Visit Example&lt;/a&gt;&lt;button&gt;Click Me&lt;/button&gt;&lt;ul&gt; &lt;li&gt;First Item&lt;/li&gt; &lt;li&gt;Second Item&lt;/li&gt; &lt;li&gt;Third Item&lt;/li&gt;&lt;/ul&gt; 我们可以使用伪类选择器来改变链接在不同状态下的颜色： 1234567891011.link:hover &#123; color: blue;&#125;.link:active &#123; color: red;&#125;.link:visited &#123; color: purple;&#125; 我们还可以使用伪类选择器来高亮列表的第一项和最后一项： 1234567li:first-child &#123; background-color: yellow;&#125;li:last-child &#123; background-color: lightblue;&#125; 注意事项： 伪类选择器不改变文档的实际结构，只影响样式。 伪类选择器可以与其他选择器组合使用，例如类选择器或属性选择器。 伪类选择器可以用来实现复杂的交互效果和动态样式变化。 伪类选择器要注意状态的执行顺序。一个标准的执行状态是lvha 伪类选择器中link和visted是a标签独有的 伪类选择器中focus在表单类元素(输入等)中使用 伪类选择器中的有关n的值 8.伪元素选择器定义: 伪元素选择器用于选择元素的特定部分，而不是整个元素本身。 这些选择器通常用于添加装饰性内容或调整元素内部的布局。 常见伪元素选择器 ::before: 在元素的内容之前插入内容。 ::after: 在元素的内容之后插入内容。 ::first-letter: 选择元素的第一字母。 ::first-line: 选择元素的第一行。 ::selection: 选择用户选取的文本。 ::placeholder: 选择 &lt;input&gt; 或 &lt;textarea&gt; 元素的占位符文本。（注意：此伪元素在某些浏览器中可能不可用） 语法伪元素选择器使用两个冒号 (::) 来表示，这是因为早期的单冒号 (:) 语法被保留给伪类选择器。 示例假设我们有以下 HTML 结构： 12&lt;p&gt;这是一个段落。&lt;/p&gt;&lt;input type=&quot;text&quot; placeholder=&quot;输入文字&quot;&gt; 我们可以使用伪元素选择器来向段落的开始添加一个图标： 1234p::before &#123; content: &quot;👉&quot;; color: green;&#125; 我们还可以使用伪元素选择器来更改输入框的占位符文本颜色： 123input::placeholder &#123; color: gray;&#125; 注意事项： 伪元素选择器创建的内容不会成为文档的一部分，因此不能通过 JavaScript 访问。 content 属性通常与伪元素选择器一起使用，用于插入实际的内容。 伪元素选择器可以与其他选择器组合使用，例如类选择器或属性选择器。 选择器的优先级行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 元素选择器 &gt; 通配选择器 &gt; 继承过来的样式 选择器的权重 在CSS中，选择器的权重（也称为优先级或特异性）决定了当多个规则应用于同一个元素时，哪个规则将被应用。权重越高，该规则就越有可能被浏览器采用。了解选择器的权重对于预测和控制样式如何显示非常重要。 CSS 选择器权重规则 内联样式 (style 属性)： 权重: 1000 示例: &lt;p style=&quot;color: red;&quot;&gt;Text&lt;/p&gt; ID 选择器： 权重: 100 示例: #uniqueId &#123; color: red; &#125; 类选择器、属性选择器、伪类： 权重: 10 示例: .className &#123; color: red; &#125; [attr=value] &#123; color: red; &#125; :hover &#123; color: red; &#125; 类型选择器、伪元素： 权重: 1 示例: p &#123; color: red; &#125; ::before &#123; content: &#39; &#39;; &#125; 通配符、子代选择器、相邻兄弟选择器、通用兄弟选择器等： 权重: 0 示例: * &#123; color: red; &#125; div &gt; p &#123; color: red; &#125; h1 + p &#123; color: red; &#125; p ~ div &#123; color: red; &#125; 继承： 不计算权重，但继承的样式会根据其来源元素的规则来决定。 重要性 (!important)： 权重: 无限大 示例: .className &#123; color: red !important; &#125; 计算方法 将每个选择器分解为其组成部分，并为每种类型分配一个权重值。 将这些值相加以得出最终的权重总和。 如果两个规则具有相同的权重，则最后定义的规则会覆盖之前的规则（除非其中一个使用了 !important）。 示例假设我们有以下CSS规则： .classA .classB &#123; color: blue; &#125; —— 类选择器 (10 + 10 &#x3D; 20) #idA.classA &#123; color: green; &#125; —— ID 选择器 (100 + 10 &#x3D; 110) div &gt; p &#123; color: yellow; &#125; —— 类型选择器 (1) body p &#123; color: red; &#125; —— 类型选择器 (1) 如果 &lt;p&gt; 元素同时具有 .classB 和 #idA，则将应用绿色文本，因为它的权重最高 (110)。 注意事项 !important 应谨慎使用，因为它可以导致意外的结果并使得样式难以维护。 使用更具体的选择器通常会导致更高的权重，但这可能会使代码变得复杂且难以管理。 在实际开发中，尽量避免复杂的嵌套选择器和不必要的 !important 使用。 CSS的三大特性 能继承的属性不会影响元素的布局。简单来说就是和盒子模型相关的都不可以继承 CSS像素像素说白了就是屏幕上的一个个小的像素点。 CSS颜色属性1. 概述 用途：在网页设计中设置元素的背景色、文字颜色等。 语法：color: value; 值：CSS 支持多种颜色表示方式，包括颜色名、十六进制数、RGB、RGBA、HSL、HSLA等。 2. 基本颜色名称 提供了140种预定义的颜色名称，例如： red, blue, green, yellow, purple, orange等。 3. 十六进制数（HEX） 格式：#RRGGBB 说明：每个RR, GG, BB分别代表红、绿、蓝三色的亮度值（00到FF）。 示例：#FF0000 (红色), #00FF00 (绿色), #0000FF (蓝色). 4.十六进制颜色加Alpha通道（HEXA）格式 HEXA颜色采用#RRGGBBAA的格式，其中RR、GG和BB与HEX相同，而AA表示Alpha通道的透明度值，范围同样是从00到FF。 Alpha通道的值同样由两位十六进制数表示，00表示完全透明，FF表示不透明。 示例 不透明的红色：#FF0000FF 半透明的红色（50%透明度）：#FF000080 （因为80大约是FF的一半） 完全透明：#00000000 5.RGB1. RGB (Red, Green, Blue) 格式：rgb(r, g, b) 或 rgb(r g b) 说明：r, g, b 分别代表红、绿、蓝三色的亮度值（0到255）。 示例：rgb(255, 0, 0) (红色) 2. RGBA (Red, Green, Blue, Alpha) 格式：rgba(r, g, b, a) 或 rgba(r g b / a) 说明：r, g, b 同上；a 是透明度（0.0 到 1.0）。 示例：rgba(255, 0, 0, 0.5) (半透明红色) 6.HSL (Hue, Saturation, Lightness)1. HSL (Hue, Saturation, Lightness) 格式：hsl(h, s%, l%) 或 hsl(h s% l%) 说明：h 表示色调角度（0到360），s 表示饱和度（0%到100%），l 表示亮度（0%到100%）。 示例：hsl(0, 100%, 50%) (红色) 2. HSLA (Hue, Saturation, Lightness, Alpha) 格式：hsla(h, s%, l%, a) 或 hsla(h s% l% / a) 说明：同HSL，a 表示透明度（0.0 到 1.0）。 示例：hsla(0, 100%, 50%, 0.5) (半透明红色) HSL和HSLA依靠色相环来定颜色，下面是色相环 CSS字体属性1. 概述 用途：用于控制文本的外观，包括字体家族、大小、样式等。 适用性：这些属性主要应用于文本元素，如&lt;p&gt;, &lt;h1&gt;, &lt;span&gt;等。 2. font-size 作用：设置字体大小。 语法：font-size: value; 单位：像素(px)，百分比(%), em, rem等。 示例：font-size: 16px; 或 font-size: 1.5em; 3. font-family 作用：指定字体家族。 语法：font-family: value; 值：一个或多个字体名称，或通用字体家族名称。 示例：font-family: Arial, sans-serif; font-family: &quot;微软雅黑&quot;; font-family: &quot;楷体&quot;; font-family: &quot;宋体&quot;; font-family: &quot;华文彩云&quot;; 多个字体家族，会按顺序查找，如果找到即可用，找到能用的为止。并且写多个字体族时，通常在最后写上serif(衬线字体)或sans-serif(非称线字体) 衬线字体：有棱有角，笔画分明 非衬线字体：棱角不明显或根本没有，圆润。 4.font-stylefont-style 属性用于设置或更改文本的字体样式，主要用于控制文本是否以斜体 (italic) 或正常 (normal) 显示。此外，还有一个特殊的值 oblique，它会倾斜文本但不使用真正的斜体字体。 语法 1font-style: normal | italic | oblique; normal: 使用字体的正常样式。 这是默认值，如果一个元素没有定义 font-style，那么它将使用正常样式。 italic: 使用字体的斜体样式。 如果字体系列包含斜体字体，则使用该斜体字体；如果没有，则浏览器会尝试模拟斜体效果。 oblique: 倾斜文本。 与 italic 类似，但是它不会查找斜体字体，而是直接倾斜文本来模仿斜体效果。 5.font-weightfont-weight 属性用于设置或更改文本的粗细程度。它可以让你控制文本显示为粗体、正常体或其他粗细等级。 语法 1font-weight: normal | bold | bolder | lighter | 100 | 200 | ... | 900; normal: 使用字体的正常粗细。 默认值通常是400（除非字体特别指定）。 bold: 使用字体的粗体版本。 如果字体系列包含粗体字，则使用该粗体字；如果没有，则通常会使用加粗效果。 bolder: 设置文本比其父元素更粗。 这是一个相对值，取决于父元素的 font-weight。 lighter: 设置文本比其父元素更细。 同样是一个相对值。 100 至 900: 数字值，表示字体的粗细级别。 100是最细的，900是最粗的。 常见的数值包括100、200、300、400（正常）、500、600、700（粗体）、800和900。 6.字体复合属性 定义：在 CSS 中，font 是一个复合属性，它允许开发者同时设置多个与字体相关的单一属性。 优点：简化 CSS 代码，提高可维护性和可读性。 1. 字体复合属性包含哪些子属性？ 字体风格 (font-style)：normal | italic | oblique 字体变体 (font-variant)：normal | small-caps 字体加粗 (font-weight)：normal | bold | 100 | 200 … 900 字体尺寸 (font-size)：16px | 1em | 100% 行高 (line-height)：24px | 1.5 | 150% 字体家族 (font-family)：Arial | sans-serif | serif | monospace 2. 使用顺序 顺序：font-style → font-variant → font-weight → font-size&#x2F;[line-height] → font-family 注意：font-size 和 font-family 是必需的，其他属性是可选的。line-height 可以写在 font-size 后面，用 / 分隔。 3.示例123p &#123; font: italic small-caps bold 16px/1.5 Georgia, serif;&#125; CSS常用文本属性1.文本颜色1. 什么是文本颜色属性？ 定义：CSS 中的文本颜色属性用于控制文本的颜色。 主要属性：color 和 text-decoration-color。 2.color 属性 用途：设置文本颜色。 语法：color: &lt;color-value&gt;; 值： 关键字：如 red, blue, green。 十六进制：如 #FF0000（红色）。 RGB：如 rgb(255, 0, 0)（红色）。 RGBA：如 rgba(255, 0, 0, 0.5)（半透明红色）。 HSL：如 hsl(0, 100%, 50%)（红色）。 HSLA：如 hsla(0, 100%, 50%, 0.5)（半透明红色）。 2.文本间距1. 什么是文本间距？ 定义：文本间距指的是文本字符之间的空间，包括字符间距、单词间距、行间距等。 2. letter-spacing 属性 用途：设置字符之间的间距。 语法：letter-spacing: &lt;spacing-value&gt;; 值： 正数增加字符间的间距。 负数减少字符间的间距。 示例 123p &#123; letter-spacing: 2px; /* 字符间增加 2px 的间距 */&#125; 3. word-spacing 属性 用途：设置单词之间的间距。 语法：word-spacing: &lt;spacing-value&gt;; 值： 正数增加单词间的间距。 负数减少单词间的间距。 4. line-height 属性 用途：设置行间距。 语法：line-height: &lt;line-height-value&gt;; 值： 单位值（如 24px）：固定行高。 无单位值（如 1.5）：基于字体大小的比例行高。 5. text-indent 属性 用途：设置首行缩进。 语法：text-indent: &lt;indent-value&gt;; 值： 单位值（如 2em）：首行缩进的距离。 3.文本修饰1. 什么是文本修饰？ 定义：文本修饰是指对文本进行额外的视觉处理，如添加下划线、删除线等。 2. text-decoration 属性 用途：设置文本的修饰效果。 语法：text-decoration: none | underline | overline | line-through; 值： none：取消所有修饰。 underline：在文本下方添加下划线。 overline：在文本上方添加一条线。 line-through：在文本中间添加一条线，表示文本被删除。 1234567891011a &#123; text-decoration: none; /* 取消链接的默认下划线 */&#125;.highlight &#123; text-decoration: underline; /* 添加下划线 */&#125;.deleted &#123; text-decoration: line-through; /* 添加删除线 */&#125; 3.text-decoration 复合属性下面的组合实际上是text-decoration-line 属性，text-decoration-style 属性，text-decoration-color 属性的组合 我们可以把这三个属性写在一个当中 示例 123a &#123; text-decoration:underline wavy red &#125; text-decoration-line的属性值有： none：无修饰线。 underline：下划线。 overline：上划线。 line-through：中划线。 text-decoration-style 的属性值有： solid：实线。 double：双线。 dotted：点线。 dashed：虚线。 wavy：波浪线。 text-decoration-color即是颜色属性。 4.文本对齐1. 什么是文本对齐？ 定义：文本对齐是指文本在容器内的水平或垂直方向上的排列方式。 2. text-align 属性(水平对齐) 用途：设置文本的水平对齐方式。 语法：text-align: left | right | center | justify; 值 ： left：文本左对齐。 right：文本右对齐。 center：文本居中对齐。 justify：文本两端对齐，自动调整单词间距使每行文本长度相等。 示例： 123456789101112131415p &#123; text-align: center; /* 文本居中对齐 */&#125;.left-align &#123; text-align: left; /* 文本左对齐 */&#125;.right-align &#123; text-align: right; /* 文本右对齐 */&#125;.justify-text &#123; text-align: justify; /* 文本两端对齐 */&#125; 3.垂直对齐 5.行高1. 什么是行高？ 定义：行高是指文本行之间的垂直间距。 重要性：良好的行高可以提高文本的可读性和美观度。 2. line-height 属性 用途：设置或更改文本的行高。 语法：line-height: &lt;line-height-value&gt;; 值： 单位值：如 24px，表示固定的高度。 比例值：如 1.5 或 150%，表示相对于当前字体大小的比例高度。数字比较常用 3. 示例1234p &#123; font-size: 16px; /* 字体大小 */ line-height: 1.5; /* 行高为字体大小的 1.5 倍 */&#125; 4. 计算行高 计算公式：行高 = 字体大小 * 行高比例值 示例： 如果字体大小为 16px，并且 line-height 设置为 1.5，那么行高就是 16px * 1.5 = 24px。 5.行高的应用场景 调整多行文字 单行文字的垂直居中 写法：height=line-height即可 p &#123; heigth: 100px; line-height:100px; &#125; 123456789101112131415161718**要注意是单行文字**。### 6.关于行高的一些注意事项![image-20240729153706567](../images/JavaScript/image-20240729153706567.png)## 6.vertical-align### 1. 什么是 `vertical-align`？- **定义**：`vertical-align` 属性用于设置行内元素（如 `&lt;span&gt;`、`&lt;img&gt;` 或 `&lt;input&gt;`）在其包含块中的垂直对齐方式。- **适用范围**：**仅适用于行内元素或行内块元素。**### 2. `vertical-align` 的语法```cssvertical-align: baseline | sub | super | top | text-top | middle | bottom | text-bottom | &lt;percentage&gt; | &lt;length&gt;; 3. vertical-align 的值 **baseline**：默认值，元素底部与文本基线对齐。 **sub**：元素作为下标对齐。 **super**：元素作为上标对齐。 **top**：元素顶部与包含块的顶部对齐。 **text-top**：元素顶部与文本顶部对齐。 **middle**：元素垂直居中对齐。 **bottom**：元素底部与包含块的底部对齐。 **text-bottom**：元素底部与文本底部对齐。 **&lt;percentage&gt;**：元素垂直对齐的百分比，相对于包含块的高度。 **&lt;length&gt;**：元素垂直对齐的具体长度，如 2px。 123456789101112131415span &#123; vertical-align: middle; /* 垂直居中对齐 */&#125;img &#123; vertical-align: bottom; /* 图像底部与文本底部对齐 */&#125;sup &#123; vertical-align: super; /* 上标对齐 */&#125;sub &#123; vertical-align: sub; /* 下标对齐 */&#125; 4. 注意事项 行内元素：vertical-align 只适用于行内元素。 块级元素：对于块级元素，可以使用 Flexbox 或 Grid 布局来实现垂直居中。 百分比值：使用百分比时，该百分比是相对于包含块的高度计算的。 长度值：使用长度值时，可以精确控制元素的垂直位置 CSS列表相关属性1. 什么是列表？ 定义：列表是一种常见的 HTML 元素，用于展示一系列条目。 类型 ：主要有两种类型的列表： 有序列表（&lt;ol&gt;）：带有编号的列表。 无序列表（&lt;ul&gt;）：带有项目符号的列表。 2. list-style 属性 用途：list-style 是一个复合属性，用于设置列表项的样式。 语法：list-style: &lt;list-style-type&gt; &lt;list-style-position&gt; &lt;list-style-image&gt;; 值： **list-style-type**：定义列表项的标记类型。 **list-style-position**：定义列表项标记相对于文本的位置。 **list-style-image**：定义列表项标记为图像。 3. list-style-type 属性 用途：设置列表项的标记类型。 语法：list-style-type: disc | circle | square | decimal | lower-roman | upper-roman | ...; 值： disc：实心圆点。 circle：空心圆圈。 square：方块。 decimal：阿拉伯数字。 lower-roman：小写罗马数字。 upper-roman：大写罗马数字。 更多值，如 lower-alpha、upper-alpha 等。 4. list-style-position 属性 用途：设置列表项标记的位置。 语法：list-style-position: inside | outside; 值： inside：列表标记位于文本之内。 outside：列表标记位于文本之外（默认值）。 5. list-style-image 属性 用途：设置列表项标记为图像。 语法：list-style-image: url(&quot;image-url&quot;); 值： url(&quot;image-url&quot;)：指定图像 URL。 6. list-style 复合属性 用途：同时设置 list-style-type、list-style-position 和 list-style-image。 语法：list-style: &lt;list-style-type&gt; &lt;list-style-position&gt; &lt;list-style-image&gt;; 示例： 123ul &#123; list-style: square inside url(&quot;marker.png&quot;);&#125; 7.示例123456789101112131415/* 无序列表 */ul &#123; list-style-type: square; list-style-position: inside;&#125;/* 有序列表 */ol &#123; list-style-type: lower-roman;&#125;/* 自定义列表项图像 */ul.custom-list &#123; list-style-image: url(&quot;marker.png&quot;);&#125; CSS边框相关属性1. 什么是边框？ 定义：边框是在元素周围绘制的线，用于定义元素的边界。 用途：边框可以用来美化元素、强调内容或分隔不同的区域。 2. border 属性 用途：设置边框的宽度、样式和颜色。 语法：border: &lt;width&gt; &lt;style&gt; &lt;color&gt;; 值： &lt;width&gt;：边框的宽度，如 1px。 &lt;style&gt;：边框的样式，如 solid、dashed、dotted 等。 &lt;color&gt;：边框的颜色，可以是颜色名称、十六进制值、RGB 值等。 3. border-width 属性 用途：设置边框的宽度。 语法：border-width: &lt;top&gt; &lt;right&gt; &lt;bottom&gt; &lt;left&gt;; 值： &lt;top&gt;：上边框宽度。 &lt;right&gt;：右边框宽度。 &lt;bottom&gt;：下边框宽度。 &lt;left&gt;：左边框宽度。 简写形式：可以使用一个值（四边相同），两个值（上下、左右），或三个值（上、左右、下）。 4. border-style 属性 用途：设置边框的样式。 语法：border-style: &lt;top&gt; &lt;right&gt; &lt;bottom&gt; &lt;left&gt;; 值： none：没有边框。 hidden：隐藏边框，类似于 none，但在表格中有所不同。 dotted：点线。 dashed：虚线。 solid：实线。 double：双线。 groove：三维凹槽。 ridge：三维凸起。 inset：三维内嵌。 outset：三维外嵌。 简写形式：同 border-width。 5. border-color 属性 用途：设置边框的颜色。 语法：border-color: &lt;top&gt; &lt;right&gt; &lt;bottom&gt; &lt;left&gt;; 值： &lt;top&gt;：上边框颜色。 &lt;right&gt;：右边框颜色。 &lt;bottom&gt;：下边框颜色。 &lt;left&gt;：左边框颜色。 简写形式：同 border-width。 6. border-radius 属性(C3) 用途：设置边框的圆角。 语法：border-radius: &lt;top-left&gt; &lt;top-right&gt; &lt;bottom-right&gt; &lt;bottom-left&gt;; 值： &lt;top-left&gt;：左上角圆角半径。 &lt;top-right&gt;：右上角圆角半径。 &lt;bottom-right&gt;：右下角圆角半径。 &lt;bottom-left&gt;：左下角圆角半径。 简写形式：可以使用一个值（四个角相同），两个值（水平、垂直），三个值（第一个值用于顶部角，第二个值用于右下角，第三个值用于左下角，顶部角使用第一个值。），或四个值（第一和第三为水平，第二和第四为垂直）。 7. border-top, border-right, border-bottom, border-left 属性 用途：分别设置顶部、右侧、底部和左侧的边框。 语法：border-top: &lt;width&gt; &lt;style&gt; &lt;color&gt;; 简写形式：border-top-width, border-top-style, border-top-color。 8. 示例123456789101112div &#123; border: 2px solid #000; /* 2px 实线黑色边框 */ border-radius: 10px; /* 圆角半径为 10px */ padding: 20px; /* 内边距 */ margin: 10px; /* 外边距 */&#125;button &#123; border: 1px dashed #ccc; /* 1px 虚线灰色边框 */ border-radius: 5px; /* 圆角半径为 5px */ padding: 10px 20px; /* 内边距 */&#125; 9. 小贴士 简写形式：border 属性可以一次性设置边框的宽度、样式和颜色。 **border-radius**：可以给元素添加圆角效果，使界面更加友好。 兼容性：这些属性在所有现代浏览器中都得到了很好的支持。 如果只写了边框的宽度，但是没有样式，会造成边框不显示 CSS表格独有属性1. border-collapse 属性 用途：控制表格边框是否合并为单一线条。 语法：border-collapse: collapse | separate; 值： collapse：边框合并为单一线条。 separate：边框各自独立（默认值）。 2. border-spacing 属性 用途：设置表格单元格之间的间距。 语法：border-spacing: &lt;horizontal-spacing&gt; &lt;vertical-spacing&gt;; 值： &lt;horizontal-spacing&gt;：水平间距。 &lt;vertical-spacing&gt;：垂直间距。 注意：仅在 border-collapse: separate; 时有效。 3. empty-cells 属性 用途：控制是否显示空白单元格的边框和背景。 语法：empty-cells: show | hide; 值： show：显示空白单元格的边框和背景（默认值）。 hide：隐藏空白单元格的边框和背景。 4. caption-side 属性 用途：设置表格标题的位置。 语法：caption-side: top | bottom; 值： top：标题位于表格上方（默认值）。 bottom：标题位于表格下方。 5. table-layout 属性 用途：控制表格的布局算法。 语法：table-layout: auto | fixed; 值： auto：根据内容自动调整列宽（默认值）。 fixed：使用固定的列宽，即使内容超出也会截断。 6. 示例123456789101112131415161718table &#123; border-collapse: collapse; /* 合并边框 */ border: 1px solid #ccc; /* 添加边框 */ width: 100%; /* 表格宽度 */ table-layout: fixed; /* 固定列宽 */ empty-cells: show; /* 显示空白单元格 */ caption-side: bottom; /* 标题位于下方 */&#125;th, td &#123; border: 1px solid #ddd; /* 单元格边框 */ padding: 8px; /* 内边距 */ text-align: left; /* 文本左对齐 */&#125;th &#123; background-color: #f2f2f2; /* 表头背景色 */&#125; 7. 小贴士 **border-collapse: collapse;**：通常用于创建清晰的表格边框。 **table-layout: fixed;**：适用于需要固定列宽的情况，例如打印或限制宽度的设计。 **empty-cells: hide;**：可以隐藏空白单元格的边框，使表格看起来更整洁。 CSS背景相关属性1. background-color 用途：设置元素的背景颜色。 语法：background-color: &lt;color&gt;; 示例： 123.example &#123; background-color: #ff0000; &#125; 2. background-image 用途：设置元素的背景图像。 语法：background-image: url(&lt;image-url&gt;); 示例： 123.example &#123; background-image: url(&#x27;path/to/image.jpg&#x27;);&#125; 3. background-repeat 用途：控制背景图像的重复方式。 可选值： repeat (默认) - 横向和纵向重复 no-repeat - 不重复 repeat-x - 横向重复 repeat-y - 纵向重复 语法：background-repeat: &lt;repeat-style&gt;; 示例： 123.example &#123; background-repeat: no-repeat;&#125; 4. background-position 用途：设置背景图像的位置。 语法：background-position: &lt;horizontal-value&gt; &lt;vertical-value&gt;; 可选值： 关键字：top, center, bottom, left, right 百分比：如 50% 50% 表示居中位置 长度：如 20px 40px 示例： 123.example &#123; background-position: center bottom; &#125; 5. background-size(C3) 用途：定义背景图像的尺寸。 可选值： auto (默认) - 图像保持原始大小 cover - 图像会拉伸以覆盖整个容器，可能会被裁剪 contain - 图像会拉伸以适应容器，但不改变比例 长度或百分比 语法：background-size: &lt;size&gt;; 示例： 123.example &#123; background-size: cover;&#125; 6. background-attachment 用途：设置背景图像是否随页面滚动而滚动。 可选值： scroll (默认) - 背景图像随页面滚动 fixed - 背景图像固定在视窗上 语法：background-attachment: &lt;attachment&gt;; 示例： 123.example &#123; background-attachment: fixed;&#125; 7. background(C3) 用途：组合多个背景属性为一个声明。 语法：background: &lt;color&gt; &lt;image&gt; &lt;repeat-style&gt; &lt;attachment&gt; &lt;position&gt;; 示例： 123.example &#123; background: #f0f0f0 url(&#x27;pattern.jpg&#x27;) repeat-x scroll 0 0;&#125; 8. background-blend-mode(C3) 用途：指定背景图层间的混合模式。 语法：background-blend-mode: &lt;blend-mode&gt;; 示例： 1234.example &#123; background-image: url(&#x27;bg1.jpg&#x27;), url(&#x27;bg2.jpg&#x27;); background-blend-mode: multiply;&#125; 属性值 normal (默认值) 表示背景图层之间没有特殊混合效果，即上层背景完全覆盖下层背景。 multiply 乘法混合模式。上层背景的颜色与其下的背景颜色相乘，得到的结果颜色通常比原始颜色更深。 screen 屏幕混合模式。上层背景的颜色与其下的背景颜色的补色相乘，得到的结果颜色通常比原始颜色更亮。 overlay 覆盖混合模式。根据底层颜色的不同，可能会使上层颜色变暗或变亮。 darken 取两层颜色中较暗的颜色作为结果颜色。 lighten 取两层颜色中较亮的颜色作为结果颜色。 color-dodge 避开颜色混合模式。通常会使颜色变得更亮，除非下层颜色接近黑色。 color-burn 烧灼颜色混合模式。通常会使颜色变得更暗，除非下层颜色接近白色。 hard-light 硬光混合模式。如果混合色比50%灰亮，则混合色变亮；否则混合色变暗。 soft-light 柔光混合模式。类似于硬光，但过渡更加平滑。 difference 差异混合模式。取上层和下层颜色的差值作为结果颜色。 exclusion 排除混合模式。类似差异混合模式，但对比度较低。 hue 色相混合模式。保持下层背景的亮度和饱和度，而使用上层背景的颜色作为色相。 saturation 饱和度混合模式。保持下层背景的亮度和色相，而使用上层背景的颜色作为饱和度。 color 颜色混合模式。保持下层背景的亮度，而使用上层背景的颜色作为色相和饱和度。 luminosity 亮度混合模式。保持下层背景的颜色（色相和饱和度），而使用上层背景的颜色作为亮度。 9. background-origin(C3) 用途：确定背景图像的位置相对于哪个盒子边缘。 可选值： padding-box (默认) border-box content-box 语法：background-origin: &lt;origin&gt;; 示例： 123.example &#123; background-origin: border-box;&#125; 属性值 padding-box: 背景图像相对于内边距区域定位。 这意味着背景图像不会延伸到内边距以外的部分，即不会覆盖边框和外边距。 border-box: 背景图像相对于边框区域定位。 这意味着背景图像会延伸到边框的外部边缘，覆盖边框区域。 content-box: 背景图像相对于内容区域定位。 这意味着背景图像仅在内容区域内显示，不会延伸到内边距或边框以外的部分。 10. background-clip(C3) 用途：确定背景剪切到哪个边界盒。 可选值： border-box(默认值) padding-box content-box text：背景图只呈现在文字上，前提是该文字是透明的 语法：background-clip: &lt;clip-area&gt;; 示例： 123.example &#123; background-clip: content-box;&#125; CSS鼠标相关属性 作用：控制鼠标在某元素上显示的图示 语法：cursor:value 下面列举几个比较常用的属性值 pointer:小手 move：移动图标 text：文字选择器 crosshair：十字架 wait：等待 help：帮助 拓展：自定义鼠标图片 123div &#123; cursor: url(image),pointer;&#125; !!!注意 不要忘了指定光标类型poniter。 CSS盒子模型(重点)1.常用的长度单位 像素（px） 最常用的长度单位。 在大多数情况下，1px等于屏幕上的一个物理像素。 注意不同设备的像素密度可能不同。 百分比（%） 相对于父元素的尺寸。 非常适合响应式设计。 例如，如果一个元素的宽度设置为50%，那么它的宽度将是其父元素宽度的一半。 视口单位（vw, vh, vmin, vmax） vw: 视口宽度的百分比（1vw &#x3D; 1% of viewport width）。 vh: 视口高度的百分比（1vh &#x3D; 1% of viewport height）。 vmin: 视口较小尺寸的百分比（或两个百分比中的较小者）。 vmax: 视口较大尺寸的百分比（或两个百分比中的较大者）。 这些单位非常适合响应式设计，因为它们基于浏览器窗口的尺寸。 em 相对于当前元素的字体大小。 如果当前元素没有显式设置字体大小，则相对于父元素的字体大小。 例如，如果一个元素的字体大小为16px，并且设置了2em的宽度，那么该元素的宽度就是32px。 rem 相对于根元素（通常是&lt;html&gt;元素）的字体大小。 与em类似，但是更易于全局控制，因为它始终相对于根元素。 rpx（Responsive Pixel） 定义：rpx 是一种基于屏幕宽度的相对单位，它可以根据屏幕的宽度自动调整大小，从而实现不同屏幕尺寸下的适配。 计算方式： 750rpx &#x3D; 设备宽度（对于iPhone 6&#x2F;7&#x2F;8来说，设备宽度为375px） 因此，1rpx &#x3D; 375px &#x2F; 750 &#x3D; 0.5px 适用场景： 主要用于微信小程序、React Native、Weex等移动应用开发环境。 特别适合用于跨平台的移动应用开发，可以简化不同屏幕尺寸的适配工作。 示例代码： 在微信小程序中使用rpx的例子如下： 123456789/* 微信小程序中的CSS样式 */.view &#123; width: 100rpx; /* 宽度为屏幕宽度的1/7.5 */ height: 200rpx; /* 高度为屏幕宽度的2/7.5 */&#125;.text &#123; font-size: 32rpx; /* 字体大小为屏幕宽度的32/750 */&#125; 总结 rpx 单位可以确保在不同屏幕尺寸的设备上元素的尺寸保持一致的比例。 750rpx 相当于 iPhone 6&#x2F;7&#x2F;8 的屏幕宽度（375px），这意味着1rpx 大约等于 0.5px。 rpx 单位非常适合用于微信小程序和跨平台移动应用开发，能够轻松处理不同设备的屏幕适配问题。 2.元素的显示模型块级元素 (Block Elements) 定义：块级元素默认独占一行，即每个块级元素都会从新的一行开始，并且其后的块级元素也会在新的一行开始。 特性： 宽度默认为容器的100%。 可以设置高度、宽度、对齐等属性。 内部可以包含块级元素和其他类型的元素。 示例： &lt;div&gt;、&lt;p&gt;、&lt;ul&gt;、&lt;table&gt;、&lt;h1&gt; 到 &lt;h6&gt; 等。 ol、ul、li、dl、dt、dd form 行内元素 (Inline Elements) 定义：行内元素不会独占一行，它们只占据实际所需的宽度，并与相邻的行内元素位于同一行。 特性： 不可设置宽度和高度。 默认宽度由内容撑开 默认高度由内容撑开 示例： &lt;span&gt;、&lt;a&gt;、&lt;img&gt;、&lt;strong&gt;、&lt;em&gt; 等。 行内块元素 (Inline-Block Elements) 定义：行内块元素结合了块级元素和行内元素的特点，它们像行内元素一样在同一行显示，但又像块级元素那样可以设置宽度和高度。 特性： 可以设置宽度和高度。 不会独占一行，可以与其他行内元素并排显示。 默认宽度由内容撑开 默认高度由内容撑开 示例： 使用 CSS 属性 display: inline-block; 将任何元素变为行内块元素。 总结 块级元素：独占一行，可设置宽高。 行内元素：不独占一行，不可设置宽高。 行内块元素：在同一行显示，可设置宽高。 3.盒子模型的组成1. 盒子模型概述 定义：CSS盒子模型描述了HTML元素如何在页面上渲染，每个元素都被视为一个矩形盒子。 组成部分 ：盒子由四个部分组成： **Content (内容)**：元素的实际内容，如文本或图片。 **Padding (内边距)**：内容与边框之间的空间。 **Border (边框)**：围绕内容和内边距的一条线。 **Margin (外边距)**：边框与周围元素之间的空白区域。 2. 盒子模型的计算 元素的总宽度 &#x3D; width + padding + border + margin 元素的总高度 &#x3D; height + padding + border + margin 3.盒子模型图示 4.盒子的内边距(padding)padding实际上是一个复合属性。使用方法如下 padding:10px：会在四个方向上同时使用10px的内边距 padding:10px 20px：10px会应用在上下方向，20px会应用在左右方向 padding:10px 20px 30px：依次是上10px，左右20px，下30px padding:10px 20px 30px 40px：依次是上10px，右20px，下30px，左40px 你也可以单独给一个方向去设置。语法如下 padding-方向:value 方向可以写left，right，top，bottom 注意： padding不能为负数 padding设置于行内元素时，上下方向的内边距有可能会出现占位问题。左右方向没有问题 块级元素和行内块级元素没有问题 5.盒子的边框(border)详见CSS边框相关属性 6.盒子的外边距(margin)margin实际上是一个复合属性。使用方法如下 margin:10px：会在四个方向上同时使用10px的外边距 margin:10px 20px：10px会应用在上下方向，20px会应用在左右方向 margin:10px 20px 30px：依次是上10px，左右20px，下30px margin:10px 20px 30px 40px：依次是上10px，右20px，下30px，左40px 你也可以单独给一个方向去设置。语法如下 margin-方向:value 方向可以写left，right，top，bottom 注意事项： 子元素的 margin ，是参考父元素的 content 计算的。(因为是父亲的 content 中承装着子元素) 上 margin、左 margin:影响自己的位置;下 margin、右 margin:影响后面兄弟元素的位置。 块级元素、行内块元素，均可以完美地设置四个方向的 margin;但行内元素，左右 margin 可以完美设置，上下 margin 设置无效。 margin 的值也可以是 auto，如果给一个块级元素设置左右 margin 都为 auto，该块级元素会在父元素中水平居中。 margin 的值可以是负值。 7.margin塌陷问题什么是 margin 塌陷?第一个子元素的上 margin 会作用在父元素上，最后一个子元素的下 margin 会作用在父元素上。如何解决 margin 塌陷? 方案一:给父元素设置不为0的 padding。 方案二:给父元素设置宽度不为0的 border。 方案三:给父元素设置 css样式 overflow:hidden 8.margin合并问题 9.处理内容溢出 CSS属性名 功能 属性值 overflow 溢出内容的处理方式 visible：显示，默认值hidden：隐藏scroll：显示滚动条，不论内容是否溢出auto：自动显示滚动条，内容不溢出不显示 overflow-x 水平溢出内容的处理方式 同overflow overflow-y 垂直溢出内容的处理方式 同overflow CSS元素隐藏1.visibility属性visibility属性默认值是show，如果设置为hidden，元素会隐藏，虽然元素看不到了，但是还占有原来的位置 2.display属性设置display:none，就可以让元素隐藏了，元素会彻底隐藏，不会占位。 CSS默认样式对于一个元素，我们不设置任何样式，那么浏览器也会自动的为其添加一些样式，这些样式就被成为默认样式。 如果查看默认样式呢？ 通过F12打开浏览器工具，找到要查看的元素，找到右上角写着user agent stylesheet就是默认样式。 优先级：元素的默认样式 &gt; 继承的样式。可以通过选中该元素来重置元素的默认样式。 CSS布局技巧(重要) 1.元素间的空白问题 2.行内块的幽灵空白问题 CSS浮动什么是浮动？ 浮动让一个元素从正常的文档流中“浮出”，并且可以向左或向右移动，直到碰到容器的边缘或其他浮动元素。 其他非浮动元素会围绕着浮动元素排列。 基本语法123.element &#123; float: left; /* 或 right, none */&#125; 可选值 left: 元素向左浮动。 right: 元素向右浮动。 none: 元素不浮动（默认值）。 浮动的例子假设我们有三个&lt;div&gt;元素，我们将第一个设置为向左浮动，第二个设置为向右浮动，第三个保持不浮动。 123&lt;div class=&quot;box box1&quot;&gt;Box 1&lt;/div&gt;&lt;div class=&quot;box box2&quot;&gt;Box 2&lt;/div&gt;&lt;div class=&quot;box box3&quot;&gt;Box 3&lt;/div&gt; 12345678910111213141516171819.box &#123; width: 100px; height: 100px; margin: 10px;&#125;.box1 &#123; float: left; background-color: red;&#125;.box2 &#123; float: right; background-color: blue;&#125;.box3 &#123; background-color: green;&#125; 在这个例子中，Box 1将向左浮动，Box 2将向右浮动，而Box 3将根据Box 1和Box 2的位置来排列自身。 清除浮动(处理浮动后的影响)当元素浮动时，它们会影响后续的非浮动元素，有时需要使用清除（clear）属性来避免这种情况。 123.clear &#123; clear: both; /* 或 left, right, none */&#125; both: 在元素之前不允许任何浮动元素。 left: 在元素之前不允许左侧的浮动元素。 right: 在元素之前不允许右侧的浮动元素。 none: 不清除任何浮动元素（默认值）。 其他方法： 方案一：给父元素指定高度。 方案二: 给父元素也设置浮动，带来其他影响。 方案三:给父元素设置 overflow:hidden 方案四: 在所有浮动元素的最后面，添加一个块级元素，并给该块级元素设置 clear:both。 方案五: 给浮动元素的父元素，设置伪元素，通过伪元素清除浮动，原理与方案四相同。&#x3D;-&#x3D;&gt;推荐使用 12345.parent::after &#123; content:&#x27;&#x27;; display:block; clear:both&#125; 注意事项 浮动可能会导致父容器的高度塌陷问题。可以使用额外的clearfix类或者overflow属性来解决这个问题。 浮动元素不能被包含在一个固定高度的容器内，因为浮动元素会使容器自动扩展以容纳它们。 浮动只适用于块级元素。对于内联元素，可以先将其转换为块级元素再应用浮动。 浮动的特点 浮动后的影响 对兄弟元素的影响：浮动元素后面的兄弟元素，会占据浮动之前的位置，在浮动元素的下面显示；而位于浮动元素前面的兄弟元素无影响 对父元素的影响：不能撑起父元素的高度，导致父元素高度塌陷；但父元素的宽度依然控制着浮动元素。 CSS定位(重要)1.CSS相对定位1.如何设置相对定位在CSS中，可以通过设置position属性为relative来使一个元素成为相对定位元素。相对定位意味着元素相对于其正常位置进行偏移。换句话说，元素的位置相对于它原本应有的位置（即如果该元素没有被定位）进行调整。 123456/* 示例代码 */.element &#123; position: relative; left: 20px; /* 向右移动20像素 */ top: -10px; /* 向上移动10像素 */&#125; left和top属性用于控制元素在其原始位置的基础上向右或向上移动的距离。 可以使用right和bottom属性来指定向左或向下移动的距离。 如果同时设置了left和right或者top和bottom，则仅最后一个声明有效。 2.相对定位的参考点当元素被设置为相对定位时，其定位参考点是基于自身未被定位前的位置。也就是说，相对定位的元素会相对于它自己的原始位置进行移动。这种定位不会影响文档流中的其他元素，即其他元素仍然会像该元素不存在一样进行布局。 例如： 1234&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;element&quot;&gt;A&lt;/div&gt; &lt;div class=&quot;element&quot;&gt;B&lt;/div&gt;&lt;/div&gt; 1234567891011121314.element &#123; position: relative; width: 50px; height: 50px;&#125;.element:first-child &#123; background-color: red; left: 20px;&#125;.element:last-child &#123; background-color: blue;&#125; 在这个例子中，第一个.element会向右移动20像素，但它仍然占据原来的空间，并且不会影响到第二个.element的位置。 3.相对定位的特点 不影响文档流：相对定位元素仍然占据原来的空间，因此不会影响其他元素的位置。 相对于自身移动：相对定位元素是相对于它们自己在文档流中的初始位置进行移动的。 层叠上下文：相对定位元素不会创建新的层叠上下文，这意味着位于它上面的元素可能会覆盖它。 可与其他定位方式结合使用：相对定位可以与绝对定位或固定定位等其他定位类型结合使用，为元素提供更多灵活的布局选项。 相对定位通常用于微调元素的位置，或者作为更复杂布局的一部分，比如当一个父元素需要相对于自身定位一个绝对定位的子元素时。 当然可以。下面是关于CSS绝对定位的学习笔记概要，从如何设置绝对定位、绝对定位的参考点以及绝对定位的特点这三个方面来编写，力求简单易懂。 2.CSS绝对定位1.如何设置绝对定位在CSS中，可以通过设置position属性为absolute来使一个元素成为绝对定位元素。绝对定位意味着元素相对于最近的已定位祖先元素（具有非静态定位的父级元素）进行定位。 123456/* 示例代码 */.element &#123; position: absolute; left: 20px; /* 距离左侧20像素 */ top: 10px; /* 距离顶部10像素 */&#125; left 和 top 属性用于确定元素距离其最近的已定位祖先元素的左侧和顶部的距离。 还可以使用 right 和 bottom 属性来指定距离右侧和底部的距离。 如果同时设置了 left 和 right 或者 top 和 bottom，则取值较小的那个属性生效。 2.绝对定位的参考点 参考它的包含块 什么是包含块呢？ 对于没有脱离文档流的元素，包含块就是父元素 对于脱离了文档流的元素：包含块是第一个拥有定位属性的祖先元素（如果所有祖先都没有定位，那包含块就是整个页面） 3.绝对定位的特点 脱离文档流：绝对定位元素不再占据文档流中的空间，即其他元素会像它不存在一样进行布局。 相对于最近的已定位祖先元素定位：绝对定位元素会相对于最近的具有非静态定位（position: relative, position: absolute, position: fixed 或 position: sticky）的祖先元素进行定位。 创建新的层叠上下文：绝对定位元素会创建一个新的层叠上下文，这意味着它后面的元素不会覆盖它。 可与其他定位方式结合使用：绝对定位可以与相对定位的父元素结合使用，以实现更复杂的布局效果。 无论什么元素（行内、行内块、块级）只要设置了绝对定位后，就会变为定位元素 4.！！！何为定位元素？默认宽高都被内容撑开，且能自由设置宽高。 3.CSS固定定位1.如何设置固定定位在CSS中，可以通过设置position属性为fixed来使一个元素成为固定定位元素。固定定位意味着元素相对于浏览器窗口进行定位，而不是相对于文档或其他元素。 123456/* 示例代码 */.element &#123; position: fixed; left: 20px; /* 距离左侧20像素 */ top: 10px; /* 距离顶部10像素 */&#125; left 和 top 属性用于确定元素距离浏览器窗口左侧和顶部的距离。 还可以使用 right 和 bottom 属性来指定距离右侧和底部的距离。 如果同时设置了 left 和 right 或者 top 和 bottom，则取值较小的那个属性生效。 2.固定定位的参考点当元素被设置为固定定位时，其定位参考点始终是浏览器窗口。这意味着无论用户如何滚动页面，固定定位的元素都会保持在相同的位置。 例如： 1234&lt;div class=&quot;content&quot;&gt; &lt;p&gt;Some content here...&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;fixed-element&quot;&gt;Fixed Element&lt;/div&gt; 12345.fixed-element &#123; position: fixed; left: 20px; top: 10px;&#125; 在这个例子中，.fixed-element 不论页面如何滚动，都会保持在浏览器窗口左上角20像素、顶部10像素的位置不变。 3.固定定位的特点 脱离文档流：固定定位元素不再占据文档流中的空间，即其他元素会像它不存在一样进行布局。 相对于浏览器窗口定位：固定定位元素的位置始终相对于浏览器窗口，不会随着页面滚动而改变位置。 创建新的层叠上下文：固定定位元素会创建一个新的层叠上下文，这意味着它后面的元素不会覆盖它。 屏幕边缘定位：固定定位元素总是定位在浏览器窗口的边缘，即使浏览器窗口大小发生变化，位置也不会改变。 固定定位通常用于创建导航栏、侧边栏或者其他始终可见的界面元素，这些元素需要在整个页面滚动时保持不变的位置。 4.CSS黏性定位1.如何设置黏性定位在CSS中，可以通过设置position属性为sticky来使一个元素成为黏性定位元素。黏性定位允许元素在滚动到特定位置时变成固定定位。 12345/* 示例代码 */.element &#123; position: sticky; top: 0; /* 当元素滚动到视口顶部时，距离顶部0像素 */&#125; top 属性用于确定元素变为固定定位时距离顶部的距离。 还可以使用 left, right, 和 bottom 属性来指定其他方向的距离。 如果同时设置了多个方向的偏移量，那么它们分别应用于对应的边缘。 2.黏性定位的参考点黏性定位的参考点：是离该元素最近的具有滚动行为的祖先元素。 初始行为：默认情况下，黏性定位元素的行为类似于相对定位元素，占据文档流中的空间并相对于其正常位置进行偏移。 转换为固定定位：当页面滚动使得黏性定位元素达到视口边界时（例如，滚动到视口顶部），它会变成固定定位元素，并保持在视口内特定的位置。 恢复相对定位：当页面再次滚动时，如果黏性定位元素离开了视口边界，它将恢复为相对定位，并回到其原始位置。 边界检测：黏性定位元素的边界检测依赖于视口的位置，因此当页面滚动时，它会根据视口的位置自动调整其定位状态。 3.黏性定位的特点 动态行为：黏性定位元素根据页面滚动自动切换定位模式，从相对定位变为固定定位，再从固定定位变回相对定位。 不影响文档流：黏性定位元素在文档流中占据空间，即使在变为固定定位时，其他元素也不会因此移动。 视口相关：黏性定位元素的位置与视口边界有关，而不是与文档流中的其他元素相关。 可定制的触发条件：通过设置top、right、bottom和left属性，可以控制黏性定位何时启动。 示例假设我们有一个黏性定位的头部导航栏： 12345678&lt;header class=&quot;sticky-header&quot;&gt; &lt;nav&gt; &lt;!-- 导航链接 --&gt; &lt;/nav&gt;&lt;/header&gt;&lt;main&gt; &lt;!-- 主要内容 --&gt;&lt;/main&gt; 123456.sticky-header &#123; position: sticky; top: 0; /* 当滚动到距离顶部0像素时，元素变为固定定位 */ background-color: #f9f9f9; padding: 20px;&#125; 5.CSS定位的层级 定位元素的显示层级比普通元素高，无论什么定位，显示层级都是一样的。 如果位置发生重叠，默认情况是:后面的元素，会显示在前面元素之上。 可以通过 css 属性 z-index 调整元素的显示层级。 z-index 的属性值是数字，没有单位，值越大显示层级越高。 只有定位的元素设置 z-index 才有效。 如果 z-index 值大的元素，依然没有覆盖掉 z-index 值小的元素，那么请检査其包含块的层级。 6.定位的特殊应用！！！以下所说的特殊应用，只针对绝对定位和固定定位，不包括相对定位的元素。 1.让定位元素的宽充满包含块 宽想与包含块一致，可以给定位元素同时设定left:0和right:0 高想与包含块一致，可以给定位元素同时设置top:0和bottom:0 2.让定位元素在包含块中居中 方案一： 12345678910/* 在CSS代码中设置以下属性,切记要是定位元素 */.test &#123; /* 必须要有定位 */ position:fixed | absolute left:0; right:0; top:0; bottom:0; margin:auto;&#125; 方案二：执行方案二的定位元素必须设置宽高 123456789/* 在CSS代码中设置以下属性,切记要是定位元素 */.test &#123; /* 必须要有定位 */ position:fixed | absolute left:50%; top:50%; margin-left:-宽的一半; magin-top:-高的一半&#125; CSS布局1.版心 在PC端网页中，一般都会有一个水平居中的盒子，来显示网页的主要内容，这就是版心。 版心的宽度一般是960~1200像素之间。 版心可以有多个。 2.常用布局名称 3.重置页面样式1.使用全局选择器12345* &#123; margin:0; padding:0; ......&#125; 2.reset.css选择到具有默认样式的元素，清除其默认样式。一般是程序员封装好的css文件。 3.Normalize.cssNormalize.css是一种新方案，它在清除默认样式的基础上，保留了一些有价值的默认样式。 需要可以直接去官网直接下载使用 官网：https://github.com/necolas/normalize.css/ 4.多列布局(C3)在CSS3中，多列布局是一个非常实用的功能，可以让你轻松地创建报纸或杂志风格的布局。这种布局允许你将内容分成多个等宽的列，并且浏览器会自动处理内容的分布。以下是使用CSS3实现多列布局的一些关键属性： column-count 描述: 指定元素应该被分成多少列。 语法: column-count: &lt;number&gt;; 可能的值: &lt;number&gt;: 一个整数，表示要分成的列数。 column-width 描述: 设置每列的宽度。 语法: column-width: &lt;length&gt;; 可能的值: &lt;length&gt;: 一个长度单位值，例如 px, em, rem 等。 columns 描述: 这是一个简写属性，可以同时设置 column-width 和 column-count。 语法: columns: &lt;column-width&gt; &lt;column-count&gt;; 可能的值: &lt;column-width&gt;: 列的宽度。 &lt;column-count&gt;: 列的数量。 column-gap 描述: 设置列与列之间的间距。 语法: column-gap: &lt;length&gt;; 可能的值: &lt;length&gt;: 一个长度单位值，例如 px, em, rem 等。 column-rule 描述: 定义列边框的样式、宽度和颜色。 语法: column-rule: &lt;column-rule-style&gt; &lt;column-rule-width&gt; &lt;column-rule-color&gt;; 可能的值: &lt;column-rule-style&gt;: 边框的样式，例如 solid, dashed, dotted 等。 &lt;column-rule-width&gt;: 边框的宽度，例如 thin, medium, thick 或者具体的长度值。 &lt;column-rule-color&gt;: 边框的颜色，可以是颜色名称、十六进制、RGB 或 HSL 值。 break-before 描述: 控制元素前的分页。 语法: break-before: &lt;break-token&gt;; 可能的值: &lt;break-token&gt;: 可以是 auto, avoid, page, left, right, region, column. break-after 描述: 控制元素后的分页。 语法: break-after: &lt;break-token&gt;; 可能的值: &lt;break-token&gt;: 同 break-before. column-span 描述: 指定元素是否应跨越所有列。 语法: column-span: &lt;column-span-value&gt;; 可能的值: &lt;column-span-value&gt;: 可以是 normal 或 all. 希望这可以帮助你更好地理解CSS3多列布局的相关属性和它们的可能值。如果你有任何进一步的问题，请随时提问！ HTML5HTML5 是超文本标记语言（HyperText Markup Language）的第五个主要版本，它是用来创建网页的标准标记语言。HTML5 在之前的 HTML4 标准基础上进行了大量的改进和扩展，以适应现代网络的需求。 H5的特点 简化语法： HTML5 语法更加宽松，允许某些标签不闭合等，以提高兼容性和易用性。 新的语义化标签： 引入了 &lt;article&gt;, &lt;section&gt;, &lt;header&gt;, &lt;footer&gt;, &lt;nav&gt; 等标签来定义页面的不同部分，增强文档结构的清晰度。 多媒体支持： 内置了 &lt;audio&gt; 和 &lt;video&gt; 标签，使得在网页中嵌入音频和视频文件变得更加简单直接，减少了对第三方插件如 Flash 的依赖。 表单控件增强： 新增了日期选择器、电子邮件输入验证等功能，简化了表单的创建和处理过程。 离线存储： 提供了 Web Storage API，允许网站在用户的浏览器上存储数据，从而实现离线访问某些功能。 图形绘制： &lt;canvas&gt; 元素提供了绘制图形的能力，可以用于图表、游戏和其他动态图形应用。 拖放功能： 支持直接通过浏览器进行文件拖放操作，增强了用户体验。 Web Workers： 允许脚本在后台线程运行，不会影响页面的交互性能。 WebSockets： 实现了浏览器与服务器之间的双向通信，可以实时更新数据而无需频繁地请求服务器。 地理位置API： 提供了获取用户地理位置的功能，方便开发基于位置的服务。 应用场景 开发响应式网站 创建复杂的 Web 应用程序 建立跨平台的移动应用程序 制作在线游戏 构建数据可视化工具 HTML5 的出现极大地丰富了 Web 的功能，使得开发者能够构建更强大、更互动的网页体验。 H5新增语意标签 &lt;article&gt;: 代表文档、页面或者应用程序中的独立内容区块，比如新闻文章、博客帖子、论坛帖子等。 &lt;aside&gt;: 表示与页面主要内容相关但又可以被独立出来的信息，例如侧边栏、注释、广告等。 &lt;details&gt;: 用于创建一个可显示或隐藏详细信息的下拉菜单。通常与 &lt;summary&gt; 元素一起使用。 &lt;figcaption&gt;: 用于为 &lt;figure&gt; 元素添加标题或说明文字。 &lt;figure&gt;: 代表媒体内容，如图片、图表、视频等，通常带有 &lt;figcaption&gt; 作为标题或描述。 &lt;footer&gt;: 用于定义文档或区域的底部信息，如版权信息、联系方式等。 &lt;header&gt;: 定义文档或某个区域的头部，常包含导航链接、logo、搜索框等。 &lt;mark&gt;: 用于高亮显示文本中的关键词或短语，以吸引用户的注意。 &lt;nav&gt;: 用于定义文档中的导航链接部分，如菜单、目录列表等。 &lt;section&gt;: 页面中的某段文字，或文章中的某段文字(里面文字通常里面会包含标题) &lt;summary&gt;: 与 &lt;details&gt; 元素一起使用，定义下拉菜单的可见标题。 关于aritcle和section artical里面可以有多个section section强调的是分段或分块，如果你想将一块内容分成几段的时候可以用section article比section更强调独立性，一款内容如果比较独立或比较完整，应该使用article H5新增状态标签HTML5 引入了一些新的状态标签，这些标签用于提供额外的信息或强调特定的状态或功能。以下是一些 HTML5 中新增的状态标签： &lt;time&gt;: 用于表示时间或日期。它可以是一个具体的日期或时间点，也可以是持续时间（duration）。例如：1&lt;p&gt;Published on &lt;time datetime=&quot;2023-08-04&quot;&gt;August 4, 2023&lt;/time&gt;.&lt;/p&gt; &lt;progress&gt;: 用于显示任务的完成进度。它通常包含一个最大值和当前值。例如：1&lt;progress value=&quot;75&quot; max=&quot;100&quot;&gt;&lt;/progress&gt; &lt;meter&gt;: 用于表示指定范围内的数值。它可以用来显示测量结果或分数。例如：12&lt;meter value=&quot;0.6&quot; min=&quot;0&quot; max=&quot;1&quot; low=&quot;0.4&quot; high=&quot;0.6&quot; optimum=&quot;0.8&quot;&gt;60%&lt;/meter&gt; &lt;ruby&gt;: 用于展示注音或拼音，通常用于东亚语言中需要注音的文字。例如：123&lt;ruby&gt; 漢字&lt;rt&gt;かんじ&lt;/rt&gt;&lt;/ruby&gt; &lt;wbr&gt;: 用于指示浏览器可以在单词内部断行的位置。这对于长单词或URL特别有用，避免过长的文本导致布局问题。例如：123&lt;a href=&quot;http://www.example.com/this-is-a-really-long-url-or-something-similar&quot;&gt; http://www.example.com/this-is-a-really-long-url-or-something-similar&lt;wbr&gt;&lt;/a&gt; &lt;dialog&gt;: 用于创建对话框或模态窗口。它可以作为一个弹出框或提示框使用。例如：12345&lt;dialog open&gt; &lt;p&gt;Are you sure you want to delete this item?&lt;/p&gt; &lt;button type=&quot;button&quot; onclick=&quot;this.parentNode.close()&quot;&gt;Cancel&lt;/button&gt; &lt;button type=&quot;button&quot; onclick=&quot;this.parentNode.close()&quot;&gt;Delete&lt;/button&gt;&lt;/dialog&gt; &lt;mark&gt;: 虽然 &lt;mark&gt; 不完全是一个状态标签，但它可以用来标记文本中的重要部分或高亮显示。例如：1&lt;p&gt;The &lt;mark&gt;important part&lt;/mark&gt; of the text.&lt;/p&gt; H5新增列表标签 H5新增文本标签 ruby：用于给文字注音的标签，实现该功能需要包裹rt标签 1234&lt;ruby&gt; &lt;span&gt;魑隗魍魉&lt;/span&gt; &lt;rt&gt;chī wěi wǎng liǎng&lt;/rt&gt;&lt;/ruby&gt; mark：用于标记关键字(建议标记搜索中的关键字) H5新增表单控件属性 placeholder: 为输入字段提供一个提示信息，当字段为空时显示，当用户开始输入时消失。 示例： 1&lt;input type=&quot;text&quot; placeholder=&quot;Enter your name&quot;&gt; required: 表示该字段是必须填写的。 示例： 1&lt;input type=&quot;text&quot; required&gt; autofocus 让输入字段获得初始焦点。 示例： 1&lt;input type=&quot;text&quot; autofocus&gt; autocomplete: 控制是否启动输入记忆，（即当输入提交表单后，下次在输入相同内容时会有一个提示功能） 不适用于：多行输入，单选框(radio)，多选框(checkbox) 示例： 12&lt;!--off是关闭，on是开启--&gt;&lt;input type=&quot;text&quot; autocomplete=&quot;off&quot;&gt; pattern: 使用正则表达式来验证输入字段的内容。 使用范围：账号，密码登输入类型的控件，但请注意，对于多行输入来说无法进行正则校验 使用前提：该控件必须为必选项，即必须填写项 示例： 1&lt;input type=&quot;text&quot; pattern=&quot;[A-Za-z]+&quot;&gt; H5中input的type选项在 HTML5 中，&lt;input&gt; 元素的 type 属性定义了输入字段的类型。不同的 type 值会改变输入字段的行为和外观。以下是一些常见的 type 属性值及其用途： text: 默认类型，用于输入单行文本。 示例：1&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; password: 显示为一串星号（*），用于输入密码。 示例：1&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; email: 用于输入电子邮件地址，并自动进行格式验证。 示例：1&lt;input type=&quot;email&quot; name=&quot;email&quot; required&gt; url: 用于输入 URL 地址，并自动进行格式验证。 示例：1&lt;input type=&quot;url&quot; name=&quot;website&quot;&gt; tel: 用于输入电话号码。 示例：1&lt;input type=&quot;tel&quot; name=&quot;phone&quot;&gt; number: 用于输入数字，可以设置最小值、最大值和步长。步长默认为1 示例：1&lt;input type=&quot;number&quot; name=&quot;age&quot; min=&quot;18&quot; max=&quot;100&quot; step=&quot;1&quot;&gt; range: 用于输入数值范围，通常显示为滑块。 示例：1&lt;input type=&quot;range&quot; name=&quot;volume&quot; min=&quot;0&quot; max=&quot;100&quot;&gt; date: 用于输入日期，提供了一个日期选择器。 示例：1&lt;input type=&quot;date&quot; name=&quot;birthdate&quot;&gt; month: 用于输入月份和年份。 示例：1&lt;input type=&quot;month&quot; name=&quot;join_month&quot;&gt; week: 用于输入周数和年份。 示例：1&lt;input type=&quot;week&quot; name=&quot;holiday_week&quot;&gt; time: 用于输入时间。 示例：1&lt;input type=&quot;time&quot; name=&quot;appointment_time&quot;&gt; datetime-local: 用于输入日期和时间（不包括时区）。 示例：1&lt;input type=&quot;datetime-local&quot; name=&quot;event_datetime&quot;&gt; search: 类似于文本输入，但可能显示为具有放大镜图标的输入框。 示例：1&lt;input type=&quot;search&quot; name=&quot;query&quot;&gt; color: 用于选择颜色。 示例：1&lt;input type=&quot;color&quot; name=&quot;favorite_color&quot;&gt; checkbox: 用于勾选框，可以选中或取消选中。 示例：1&lt;input type=&quot;checkbox&quot; name=&quot;terms&quot; value=&quot;agree&quot;&gt; radio: 用于单选按钮，只能在一个组内选择一个选项。 示例：12&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt; file: 用于上传文件。 示例：1&lt;input type=&quot;file&quot; name=&quot;profile_picture&quot; multiple&gt; submit: 用于提交表单。 示例：1&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt; reset: 用于重置表单。 示例：1&lt;input type=&quot;reset&quot; value=&quot;Reset&quot;&gt; image: 用于提交表单，同时可以使用图像作为按钮。 示例：1&lt;input type=&quot;image&quot; src=&quot;submit.gif&quot; alt=&quot;Submit&quot;&gt; hidden: 用于创建一个隐藏的输入字段。 示例：1&lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;123&quot;&gt; button: 用于创建一个按钮，可以绑定 JavaScript 事件。 示例：1&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(&#x27;Hello!&#x27;)&quot;&gt; H5中新增全局属性HTML5 引入了一些新的全局属性，这些属性可以应用于大多数 HTML 元素，以提供更多的功能和控制。以下是一些 HTML5 中新增的全局属性： tabindex: 用于定义元素在页面上的 tab 键导航顺序。 示例：12&lt;button tabindex=&quot;1&quot;&gt;Button 1&lt;/button&gt;&lt;button tabindex=&quot;2&quot;&gt;Button 2&lt;/button&gt; draggable: 指定元素是否可以被拖动。 示例：1&lt;div draggable=&quot;true&quot;&gt;Drag me!&lt;/div&gt; hidden: 表示元素不可见，与 CSS 的 display: none 类似。 示例：1&lt;p hidden&gt;This text is not visible.&lt;/p&gt; contenteditable: 表示元素的内容可以被编辑。 示例：1&lt;p contenteditable=&quot;true&quot;&gt;Edit me!&lt;/p&gt; spellcheck: 控制是否对元素内容进行拼写检查。 示例：1&lt;textarea spellcheck=&quot;false&quot;&gt;&lt;/textarea&gt; data-* 属性: 用于存储自定义数据私有属性。 示例：1&lt;div data-my-custom-attribute=&quot;value&quot;&gt;Custom data attribute&lt;/div&gt; H5兼容性问题 示例 123456&lt;!--[if IE 8]&gt;仅IE8可见&lt;![endif]--&gt;&lt;!--[if gt IE 8]&gt;仅IE8以上可见&lt;![endif]-&gt;&lt;!--[if 1t IE 8]&gt;仅IE8以下可见&lt;![endif]-&gt;&lt;!--[if gte IE 8]&gt;IE8及以上可见&lt;![endif]-&gt;&lt;!--[if lte IE 8]&gt;IE8及以下可见&lt;![endif]-&gt;&lt;!--[if !IE 8]&gt;非IE8的IE可见&lt;![endif]--&gt; CSS31.CSS3简介 2.CSS3的私有前缀1.为什么要有私有前缀W3C 标准所提出的某个 css 特性，在被浏览器正式支持之前浏览器厂商会根据浏览器的内核，使用私有前缀来测试该 CSS 特性，在浏览器正式支持该 CSS 特性后，就不需要私有前缀了。 举个例子 12345-webkit-border-radius:20px;-moz-border-radius:20px;-ms-border-radius:20px;-o-border-radius:20px;border-radius:20px; 查询CSS3兼容性的网站：https://caniuse.com 2.常见浏览器的私有前缀 3.CSS3新增的长度单位详见：盒子模型中的第一条–常用长度单位小结 4.CSS3新增颜色的设计方式详见：CSS颜色属性小结，具体新增的颜色设置方式有：HXL，HXLA，rgb，rgba 5.CSS3新增的选择器有动态伪类选择器，伪元素选择器，详见CSS选择器章节 6.CSS3新增的盒子模型相关属性1.box-sizing属性使用box-sizing属性可以设置盒模型的两种类型 可选值 含义 content-box width和height设置的盒子是内容区的大小。(默认值) border-box width和height设置的盒子的总大小。(也被成为怪异盒模型) 2.resize属性使用resize属性设置用户能否拖动盒子 可选值 含义 none 不可拖动 horizontal 仅可水平方向拖动 vertical 仅可垂直方向拖动 both 水平、垂直方向均可推动 注：请配合overflow来处理内容溢出，该属性才能生效。 3.box-shadow属性基本语法 1box-shadow: h-offset v-offset blur spread color inset; 属性 描述 h-offset 水平偏移量（可正可负）必填 v-offset 垂直偏移量（可正可负）必填 blur 阴影模糊程度（非负值）可选 spread 阴影扩展大小（非负值）可选 color 阴影的颜色 可选 inset 可选关键字，用于创建内阴影效果 可选 示例 示例 CSS 代码 效果描述 简单阴影 .box &#123; box-shadow: 10px 10px 5px #888888; &#125; 水平偏移 10px、垂直偏移 10px、模糊程度 5px、颜色为灰色 模糊阴影 .box &#123; box-shadow: 10px 10px 20px 5px rgba(0, 0, 0, 0.5); &#125; 水平偏移 10px、垂直偏移 10px、模糊程度 20px、扩展大小 5px、半透明的黑色 内阴影 .box &#123; box-shadow: inset 0 0 10px 5px #000; &#125; 创建一个内部阴影效果 多重阴影 .box &#123; box-shadow: 10px 10px 5px #888888, 20px 20px 10px #666666, inset 0 0 5px #000; &#125; 为同一个元素添加三个不同的阴影效果 4.opacity属性opacity 属性在 CSS 中用于设置元素的不透明度。它可以应用于任何元素，并影响该元素及其所有子元素的不透明度。下面是关于 opacity 属性的一些基本信息和示例： 基本语法1opacity: value; value: 不透明度值，取值范围从 0 到 1。 0: 完全透明。 1 (默认值): 完全不透明。 示例 设置一个元素为半透明： 123.box &#123; opacity: 0.5;&#125; 设置一个元素为完全透明： 123.box &#123; opacity: 0;&#125; 设置一个元素为几乎完全不透明： 123.box &#123; opacity: 0.95;&#125; 注意事项 当你改变一个元素的 opacity 时，它的所有子元素也会受到影响。如果你只想改变某个特定子元素的不透明度，你需要单独对该子元素应用 opacity。 opacity 属性可以与 CSS 动画或过渡一起使用来创建淡入淡出的效果。 浏览器兼容性opacity 属性在现代浏览器中都有很好的支持，包括 IE9 及以上版本。 示例代码1234567891011121314151617/* 设置一个 div 的不透明度为 0.5 */div &#123; width: 100px; height: 100px; background-color: blue; opacity: 0.5;&#125;/* 设置一个 div 的不透明度为 0.2 */div.transparent &#123; opacity: 0.2;&#125;/* 设置一个 div 的不透明度为 1 (完全不透明) */div.opaque &#123; opacity: 1;&#125; 表格总结 属性 描述 value 不透明度值，范围从 0 到 1 示例 CSS 代码 效果描述 半透明 .box &#123; opacity: 0.5; &#125; 元素不透明度为 50% 完全透明 .box &#123; opacity: 0; &#125; 元素完全透明 几乎不透明 .box &#123; opacity: 0.95; &#125; 元素几乎完全不透明 7.CSS3新增背景属性详见CSS背景属性小结 8.CSS3新增边框属性详见本笔记这小结：CSS边框属性 9.CSS3新增文本属性1.text-shadow（文本阴影） 描述：为文本添加阴影效果。 语法：text-shadow: h-offset v-offset blur color; 示例：123p &#123; text-shadow: 2px 2px 3px rgba(0, 0, 0, 0.5);&#125; 属性 描述 h-offset 水平偏移量（可正可负）必填 v-offset 垂直偏移量（可正可负）必填 blur 阴影模糊程度（非负值）可选 color 阴影的颜色 可选 2.white-space（处理空白符）white-space 属性在 CSS 中用于控制元素中的空白符（空格、制表符、换行符等）如何被处理。这个属性对于文本布局非常重要，尤其是在需要精确控制文本格式的情况下。 基本语法1white-space: value; value: 控制空白符处理的方式。 可接受的值 normal: 默认值，空白符会被压缩为一个空格，并且换行符会被替换为一个空格。 pre: 保留所有空白符，并且换行符也会保留。 nowrap: 合并空白符为空格，但是不允许换行。 pre-wrap: 保留空白符，允许换行。 pre-line: 合并空白符为空格，允许换行，但换行符会被替换为空格。 break-spaces: 保留空格，即使在换行时也保留空格。 示例 正常处理空白符: 123p &#123; white-space: normal;&#125; 这是默认行为，所有空白符会被压缩为一个空格。 保留所有空白符: 123pre &#123; white-space: pre;&#125; 适用于预格式化文本，保留所有空白符和换行符。 禁止换行: 123.nowrap &#123; white-space: nowrap;&#125; 所有空白符会被压缩为一个空格，不允许自然换行。 保留空白符并允许换行: 123.pre-wrap &#123; white-space: pre-wrap;&#125; 保留所有空白符，但允许自然换行。 合并空白符为空格并允许换行: 123.pre-line &#123; white-space: pre-line;&#125; 合并空白符为空格，允许自然换行。 保留空格并允许换行: 123.break-spaces &#123; white-space: break-spaces;&#125; 保留空格，即使在换行时也保留空格。 示例代码1234567891011121314151617181920212223242526272829/* 正常处理空白符 */p.normal &#123; white-space: normal;&#125;/* 保留所有空白符 */pre &#123; white-space: pre;&#125;/* 禁止换行 */p.nowrap &#123; white-space: nowrap;&#125;/* 保留空白符并允许换行 */p.pre-wrap &#123; white-space: pre-wrap;&#125;/* 合并空白符为空格并允许换行 */p.pre-line &#123; white-space: pre-line;&#125;/* 保留空格并允许换行 */p.break-spaces &#123; white-space: break-spaces;&#125; 表格总结 属性 描述 normal 默认值，空白符会被压缩为一个空格 pre 保留所有空白符 nowrap 合并空白符为空格，不允许换行 pre-wrap 保留空白符，允许自然换行 pre-line 合并空白符为空格，允许自然换行 break-spaces 保留空格，即使在换行时也保留空格 3.text-overflow（文本溢出）text-overflow 属性在 CSS 中用于指定当内容被裁剪时应如何显示。当一个元素的内容超出其边界并且设置了 overflow: hidden 或 overflow: scroll 时，text-overflow 属性就会生效。 基本语法1text-overflow: value; value: 指定当内容被裁剪时的显示方式。 可接受的值 clip: 裁剪内容，不显示任何指示内容被裁剪的信息。 ellipsis: 显示省略号（…）来表示被裁剪的内容。 string: 可以指定一个字符串来替代省略号。 示例 显示省略号: 123456.ellipsis &#123; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; width: 200px;&#125; 这个例子中，如果内容超出 200px 的宽度，多余的内容会被裁剪，并且在结尾处显示一个省略号。 使用自定义字符串: 123456.custom-ellipsis &#123; overflow: hidden; white-space: nowrap; text-overflow: &quot;[...]&quot;; /* 自定义省略标记 */ width: 200px;&#125; 如果内容超出 200px 的宽度，多余的内容会被裁剪，并且在结尾处显示自定义的省略标记。 示例代码123456789101112131415/* 显示省略号 */.ellipsis &#123; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; width: 200px;&#125;/* 使用自定义字符串 */.custom-ellipsis &#123; overflow: hidden; white-space: nowrap; text-overflow: &quot;[...]&quot;; /* 自定义省略标记 */ width: 200px;&#125; 表格总结 属性 描述 clip 裁剪内容，不显示任何指示内容被裁剪的信息 ellipsis 显示省略号（…）来表示被裁剪的内容 string 可以指定一个字符串来替代省略号 4.text-stroke（文本描边）text-stroke 属性在 CSS3 中用于为文本添加描边效果，类似于为文本添加轮廓。这个属性允许你在文本周围添加一条或多条线条，可以用来增强文本的视觉效果，特别是在背景颜色复杂或需要突出显示文本的情况下。 基本语法1text-stroke: thickness color; thickness: 描边的厚度，可以是长度单位（如 1px）或者 none。 color: 描边的颜色。 示例 添加黑色描边: 12345p &#123; font-size: 30px; text-stroke: 2px black; color: white;&#125; 这个例子中，文本将以白色显示，并在其周围添加 2px 的黑色描边。 添加蓝色描边: 12345p &#123; font-size: 30px; text-stroke: 1px blue; color: yellow;&#125; 这个例子中，文本将以黄色显示，并在其周围添加 1px 的蓝色描边。 示例代码12345678910111213/* 添加黑色描边 */p.black-stroke &#123; font-size: 30px; text-stroke: 2px black; color: white;&#125;/* 添加蓝色描边 */p.blue-stroke &#123; font-size: 30px; text-stroke: 1px blue; color: yellow;&#125; 表格总结 属性 描述 thickness 描边的厚度，可以是长度单位（如 1px）或者 none color 描边的颜色 这个表格概括了 text-stroke 属性的基本用法及其示例，希望对你有所帮助！ 请注意，text-stroke 属性在某些浏览器中可能需要使用前缀 -webkit- 来实现兼容性，例如在 Safari 和 Chrome 中。因此，为了确保跨浏览器兼容性，你可能需要这样使用： 123456p &#123; font-size: 30px; -webkit-text-stroke: 2px black; text-stroke: 2px black; color: white;&#125; 10.CSS3新增渐变在CSS3中，渐变是一种非常实用且强大的功能，可以用来创建平滑的颜色过渡效果。渐变主要分为两种类型：线性渐变（linear-gradient）和径向渐变（radial-gradient）。下面是一些关于这两种渐变的基本使用方法和示例。 1. 线性渐变 (Linear Gradient)线性渐变沿着一个方向平滑地从一种颜色过渡到另一种颜色。 基本语法: 1background-image: linear-gradient(direction, color-stop1, color-stop2, ...); direction 可以是角度或者关键词来定义渐变的方向。 color-stop 定义颜色以及颜色的位置（可选）。 方向关键词: to top, to bottom, to left, to right 表示方向为垂直或水平。 to top left, to bottom right, to bottom left, to top right 表示对角线方向。 示例: 123div &#123; background-image: linear-gradient(to right, red, yellow);&#125; 带角度的示例: 123div &#123; background-image: linear-gradient(45deg, red, yellow);&#125; 带位置的颜色停靠点示例: 123div &#123; background-image: linear-gradient(to right, red 0%, yellow 100%);&#125; 2. 径向渐变 (Radial Gradient)径向渐变是从中心点开始向外扩散的颜色变化。 基本语法: 1background-image: radial-gradient(shape size at position, start-color, end-color); shape 可以为 circle 或 ellipse。 size 定义渐变的大小。(x方向，y方向的size必须同时给出才能生效) position 可以是百分比、关键词（如 center）或两者结合。 start-color 和 end-color 分别表示渐变开始和结束时的颜色。 形状与大小示例: 123div &#123; background-image: radial-gradient(circle at center, red, yellow);&#125; 具体位置示例: 123div &#123; background-image: radial-gradient(circle at 50% 50%, red, yellow);&#125; 兼容性为了确保兼容性，你可能需要同时使用浏览器前缀 -webkit-、-moz-、-o- 和 -ms-。 示例: 12345678910111213141516div &#123; /* Standard syntax */ background-image: linear-gradient(to right, red, yellow); /* For IE10+ */ background-image: -ms-linear-gradient(right, red, yellow); /* For Webkit browsers */ background-image: -webkit-linear-gradient(right, red, yellow); /* For Opera 11.1 to 12.0 */ background-image: -o-linear-gradient(right, red, yellow); /* For Firefox 3.6 to 15 */ background-image: -moz-linear-gradient(right, red, yellow); &#125; 11.Web字体1. @font-face 规则@font-face 是 CSS 中用于定义字体文件的一种规则。它允许开发者将自定义的字体文件加载到网站上，并应用于页面中的文本。 基本语法： 12345@font-face &#123; /*用的时候名字就是MyFont */ font-family: &#x27;MyFont&#x27;; src: url(&#x27;myfont.eot&#x27;); &#125; 使用示例： 123body &#123; font-family: &#x27;MyFont&#x27;, Arial, sans-serif;&#125; 12.CSS3—2D变换(transform)CSS3 的 2D 变换允许你在二维空间中改变元素的位置、大小和形状。这包括旋转、缩放、倾斜和移动等操作。以下是 CSS3 中 2D 变换的一些基本介绍和示例。 1. transform 属性transform 属性是一个可以接受多个变换函数的属性，这些函数可以组合使用。变换函数可以是旋转 (rotate)、缩放 (scale)、倾斜 (skew) 或移动 (translate)。 基本语法:1transform: function(value); 2. rotate（旋转）rotate 函数用于旋转元素。角度值可以是度数 (deg)、弧度 (rad)、梯度 (grad) 或者转 (turn)。 示例: 123div &#123; transform: rotate(45deg);&#125; 3. scale（缩放）scale 函数用于缩放元素。它可以接受一个或两个参数，第一个参数用于横向缩放，第二个参数用于纵向缩放。如果只提供一个值，则两个方向都按该值缩放。 示例: 1234div &#123; transform: scale(2); /* 缩放两倍 */ transform: scale(0.5, 0.5); /* 缩小一半 */&#125; 4. skew（倾斜）skew 函数用于倾斜元素。可以单独倾斜X轴或Y轴，也可以同时倾斜。 示例: 123456div &#123; transform: skew(45deg); /* X轴倾斜 */ transform: skewX(45deg); /* X轴倾斜 */ transform: skewY(45deg); /* Y轴倾斜 */ transform: skew(45deg, 30deg); /* 同时倾斜X轴和Y轴 */&#125; 5. translate（位移）translate 函数用于沿X轴和&#x2F;或Y轴移动元素。可以分别移动X轴和Y轴，也可以同时移动。 示例: 12345div &#123; transform: translate(50px, 100px); /* 沿X轴移动50像素，沿Y轴移动100像素 */ transform: translateX(50px); /* 沿X轴移动50像素 */ transform: translateY(100px); /* 沿Y轴移动100像素 */&#125; 位移的注意点 6. 组合变换可以将多个变换函数组合在一起使用，顺序很重要。由于旋转会改变元素原有的坐标系，所以建议旋转放在最后。 示例: 123div &#123; transform: rotate(45deg) scale(2) translate(50px, 100px);&#125; 7. 原点变换transform-origin 属性用于定义变换的原点，即变换发生的点。默认情况下，原点是元素的中心。 变换原点 使用关键词（left，right，top，bottom）来变换原点 使用具体像素值来变换原点(如果使用像素值要写两个值，第一个代表x轴，第二个代表y轴) 变换之后的原点，对于缩放和旋转都有影响，而对位移没有影响。 示例: 1234div &#123; transform-origin: top left; /* 设置原点为左上角 */ transform: rotate(45deg);&#125; 8. 兼容性为了保证兼容性，可以使用浏览器前缀 -webkit-、-moz-、-o- 和 -ms-。 示例: 12345678910111213141516div &#123; /* Standard syntax */ transform: rotate(45deg); /* For Webkit browsers */ -webkit-transform: rotate(45deg); /* For Firefox 3.6 to 15 */ -moz-transform: rotate(45deg); /* For Opera 11.1 to 12.0 */ -o-transform: rotate(45deg); /* For IE9 */ -ms-transform: rotate(45deg);&#125; 9. 浏览器支持目前大多数现代浏览器都已经很好地支持 CSS3 的变换特性，因此通常不需要添加前缀。 示例代码下面是一个简单的示例，演示如何使用 CSS3 的 2D 变换来创建一个旋转并移动的方块。 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;2D Transform Example&lt;/title&gt; &lt;style&gt; .box &#123; width: 100px; height: 100px; background-color: blue; margin: 50px; transition: transform 1s; &#125; .box:hover &#123; transform: rotate(45deg) translate(50px, 100px); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在这个示例中，当鼠标悬停在方块上时，方块会旋转 45 度并移动 50 像素和 100 像素。transition 属性使变换过程平滑进行。 这些就是 CSS3 中 2D 变换的基本概念和用法。通过这些变换，你可以创建动态和交互式的网页布局。 13.CSS3—3D变换(transform)在 CSS3 中，要使用3D变换，首先得开启 3D 空间，你需要在父元素中使用 transform-style 和 perspective 属性。这两个属性一起工作，使得子元素能够在三维空间中正确地呈现。 1. transform-style: preserve-3d该属性还有一个值，是flat，指的是2D空间，也就是默认值。而transform-style: preserve-3d 属性用于指定一个元素及其子元素是否应该在 3D 空间中渲染。如果设置了此属性，那么子元素可以被放置在不同的 z 轴位置上，并且它们之间的遮挡关系也会被正确处理。 示例: 123456.parent &#123; transform-style: preserve-3d;&#125;.child &#123; transform: translateZ(100px);&#125; 2. perspectiveperspective 属性用于设置观察者的距离，它决定了元素的透视效果。当元素被放置在 3D 空间中时，perspective 会影响元素看起来的远近程度。较大的值会使透视效果减弱，较小的值会使透视效果加强。 该属性默认值不是0 示例: 123.container &#123; perspective: 1000px;&#125; 3.透视点的位置透视点的默认位置在开启了3D空间的元素的正中心，通常情况下我们并不需要去调整。如需调整： 使用perspective-origin属性来调整 语法：perspective-origin:x-position y-position x-position 和 y-position 可以是百分比、长度单位（如 px、em 等）或关键词（如 left、center、right、top、bottom）。 4.3D位移在 CSS3 中，3D 位移（也称为 3D 平移）允许你在一个三维空间中移动元素。这可以通过 translate3d 函数实现，它允许你在 x、y 和 z 轴上移动元素。 translate3d 函数translate3d 函数接受三个参数，分别对应 x、y 和 z 轴上的位移量。 基本语法: 1transform: translate3d(tx, ty, tz); tx 表示 x 轴上的位移量。 ty 表示 y 轴上的位移量。 tz 表示 z 轴上的位移量。 示例下面是一个简单的示例，演示如何使用 translate3d 函数来在 3D 空间中移动一个元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;3D Translate Example&lt;/title&gt; &lt;style&gt; .container &#123; perspective: 800px; /* 设置透视点距离 */ width: 300px; height: 300px; margin: 50px auto; &#125; .cube &#123; width: 200px; height: 200px; position: relative; transform-style: preserve-3d; transform: rotateY(45deg); transition: transform 1s; &#125; .face &#123; position: absolute; width: 200px; height: 200px; background-color: #f00; &#125; .front &#123; transform: translateZ(100px); &#125; .back &#123; transform: rotateY(180deg) translateZ(100px); &#125; .right &#123; transform: rotateY(90deg) translateZ(100px); &#125; .left &#123; transform: rotateY(-90deg) translateZ(100px); &#125; .top &#123; transform: rotateX(90deg) translateZ(100px); &#125; .bottom &#123; transform: rotateX(-90deg) translateZ(100px); &#125; /* 添加 3D 位移 */ .cube &#123; transform: translate3d(50px, 100px, 200px); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;cube&quot;&gt; &lt;div class=&quot;face front&quot;&gt;&lt;/div&gt; &lt;div class=&quot;face back&quot;&gt;&lt;/div&gt; &lt;div class=&quot;face right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;face left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;face top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;face bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 示例解释在这个示例中，我们创建了一个 3D 旋转的立方体，并使用 translate3d 函数将整个立方体在 3D 空间中进行了位移。translate3d(50px, 100px, 200px) 表示立方体在 x 轴上移动了 50 像素，在 y 轴上移动了 100 像素，在 z 轴上移动了 200 像素。 不同的位移方向你还可以通过更改 translate3d 的参数来探索不同的位移方向。例如： 向前移动：translate3d(0, 0, 200px) 表示仅在 z 轴上向前移动 200 像素。 向后移动：translate3d(0, 0, -200px) 表示仅在 z 轴上向后移动 200 像素。 向左移动：translate3d(-50px, 0, 0) 表示仅在 x 轴上向左移动 50 像素。 向右移动：translate3d(50px, 0, 0) 表示仅在 x 轴上向右移动 50 像素。 向上移动：translate3d(0, -100px, 0) 表示仅在 y 轴上向上移动 100 像素。 向下移动：translate3d(0, 100px, 0) 表示仅在 y 轴上向下移动 100 像素。 5.3D旋转3D 旋转是在 2D 旋转的基础上，可以让元素沿x轴和y轴旋转，具体使用方式如下1.先给元素添加 转换属性 transform2.编写 transform 的具体值， 3D 相关可选值如下: 值 含义 rotate3D 前三个参数分别表示坐标轴：x，y，z，第四个参数表示旋转的角度，参数不允许省略，比如transform:rotate3D(1,1,1,30deg)表示x，y，z分别旋转30° rotateX 设置x轴旋转角度，需指定一个角度值(单位deg)，面对x轴正方向：正值顺时针，负值逆时针 rotateY 设置y轴旋转角度，需指定一个角度值(单位deg)，面对y轴正方向：正值顺时针，负值逆时针 6.3D缩放3D 缩放是在 2D 缩放的基础上，可以让元素沿z轴缩放，具体使用方式如下1.先给元素添加 转换属性 transform2.编写 transform 的具体值，3D 相关可选值如下 值 含义 scaleZ 设置Z轴方向的缩放比例，值是一个数字，1表示不缩放，大于1放大，小于1缩小。 scale3d 第一个参数对应x轴，第二个参数对应y轴，第三个参数对应z轴，注意：参数不能够省略 14.CSS3过渡(transition)在CSS3中，过渡（transitions）是一种效果，可以平滑地改变一个元素从一种样式到另一种样式的过渡效果。这使得网页设计更加生动和有趣。 ！！！过渡有触发条件，即过渡前元素的状态和过渡后的都需要设置 基本概念 过渡属性 (transition-property): 定义应该对哪些CSS属性应用过渡效果。 过渡持续时间 (transition-duration): 过渡效果完成所需要的时间。单位是s或者ms 过渡函数类型 (transition-timing-function): 过渡效果的速度曲线。 linear: 动画从头到尾速度相同。 这意味着过渡在整个过程中保持恒定速度。 ease: 默认值，动画以低速开始，然后加快，在结束前变慢。 这是浏览器默认使用的函数类型，通常给人一种更自然的感觉。 ease-in: 动画以低速开始。 开始时速度较慢，然后逐渐加速直至结束。 ease-out: 动画以低速结束。 开始时速度较快，然后逐渐减速直至结束。 ease-in-out: 动画以低速开始和结束。 开始和结束时速度较慢，中间速度快。 step-start: 动画瞬间改变，之后保持不变直到下一个关键点。 动画在开始时立即跳转到最终状态，然后保持该状态直到过渡结束。 step-end: 动画在最后瞬间改变。 动画保持初始状态，直到过渡结束时才瞬间跳转到最终状态。 过渡延迟 (transition-delay): 在过渡开始前等待的时间。 语法你可以使用 transition 属性来简写以上所有过渡相关的属性： 1transition: property duration timing-function delay; 例如: 1transition: width 2s ease 1s; 这段代码表示宽度将在2秒内平滑变化，使用默认的 ease 函数，并且在开始之前等待1秒。 示例假设我们有一个按钮，当鼠标悬停在其上时，按钮的颜色会改变，我们可以添加过渡效果来使颜色变化平滑。 HTML1&lt;button class=&quot;button&quot;&gt;Hover Me&lt;/button&gt; CSS1234567891011.button &#123; background-color: blue; color: white; padding: 10px 20px; border: none; transition: background-color 0.5s ease-in-out; /* 过渡属性、持续时间和函数类型 */&#125;.button:hover &#123; background-color: red;&#125; 在这个例子中，当我们把鼠标悬停在按钮上时，背景色会从蓝色变为红色，并且这个变化过程会在0.5秒内平滑进行。 多个过渡效果如果需要对多个属性应用不同的过渡效果，可以使用逗号分隔多个值： 1transition: width 2s, color 1s; 注意事项 如果不指定过渡属性，默认会对所有可动画化的属性应用过渡。 可以使用 all 关键字来指定所有属性都应该应用过渡效果。 在某些情况下，可能需要JavaScript来触发过渡效果，特别是当涉及到状态变化或者非用户交互事件时。 15.CSS3动画当我们讨论动画时，“帧”和“关键帧”是非常基础的概念。在计算机图形学和动画领域，这两个术语经常被提及。让我们来详细了解它们的意义以及它们如何应用于CSS3动画。 帧 (Frame)在动画中，每一幅单独的画面被称为一帧（frame）。动画是由一系列连续显示的帧组成的，当这些帧快速连续播放时，就会产生动态的效果。例如，在电影中，每秒通常会有24帧，而在电视中可能是25帧或30帧。 关键帧 (Keyframe)关键帧是指动画中定义变化点的帧。在传统的动画制作中，关键帧是由动画师手动绘制的，它们代表动作的主要转折点。在两个关键帧之间，通过插值或者其他技术来生成过渡帧，从而创建流畅的运动。 CSS3 中的关键帧在CSS3中，我们可以使用 @keyframes 规则来定义关键帧动画。这使得我们能够在不使用任何脚本的情况下创建复杂的动画效果。 @keyframes 规则的基本语法12345@keyframes animation-name &#123; 0% &#123; /* 开始时的样式 */ &#125; 50% &#123; /* 中间的样式 */ &#125; 100% &#123; /* 结束时的样式 */ &#125;&#125; 这里的关键帧百分比（如0%，50%，100%）指定了动画过程中各个关键点的时间点。CSS3动画引擎会计算这些关键帧之间的中间值，以创建平滑的过渡效果。 使用 @keyframes 规则(animation属性的属性值)一旦定义了 @keyframes 动画，就需要将其应用到HTML元素上。这可以通过使用 animation 属性来完成： 它的属性如下 12345678div &#123; /*动画的名称*/ animation-name: animation-name; animation-duration: 3s; /* 动画持续时间 */ animation-timing-function: ease-in-out; /* 动画的速度曲线 */ animation-iteration-count: infinite; /* 动画重复次数 */ animation-direction:reserve; /*动画播放的方向*/&#125; animation-timing-function(动画的速度曲线) ease: 默认值。动画以慢速开始，然后加快，最后慢慢结束。这是最常用的函数值，模拟了自然界的加速度和减速度。 linear: 动画从头到尾都以相同的速度执行。这通常给人一种更加机械的感觉。 ease-in: 动画以慢速开始，逐渐加速到结束。 ease-out: 动画以快速开始，然后逐渐减速到结束。 ease-in-out: 动画以慢速开始，加速到中间，然后再减速到结束。 step-start: 动画在每个关键帧的开始阶段跳跃到下一个值，其他时间保持静止。 step-end: 动画在每个关键帧的结束阶段跳跃到下一个值，其他时间保持静止。 cubic-bezier(x,y,z,w): 这个函数允许开发者自定义动画的速度曲线。x 和 y 的值范围都是 [0, 1]。其中 x 是时间进度，y 是完成值。z 和 w 分别是 x 和 y 的结束值。通过改变这些值，可以创建各种不同的速度曲线。 animation-iteration-count(动画播放次数) infinite：表示无限循环播放 具体数字：指动画播放的次数 animation-direction(动画播放方向) normal (默认值): 每次迭代完成后动画会按照原始方向重复播放。 reverse: 每次迭代完成后动画会反向重复播放。 alternate: 动画第一次迭代按正常顺序播放，下一次则反向播放，之后再正常顺序播放，如此交替进行。 alternate-reverse: 类似于 alternate，但首次迭代就是反向播放，之后再正常顺序播放，以此类推。 animation-fill-mode(不发生动画时，位于哪里) none (默认值): 动画前后没有样式应用。 forwards: 动画结束后保留最后一个关键帧的样式。 backwards: 动画开始前应用第一个关键帧的样式。 both: 结合了 forwards 和 backwards 的效果，即动画开始前应用第一个关键帧的样式，结束后保留最后一个关键帧的样式。 initial: 设置为初始值。 inherit: 从父元素继承值。 animation-play-state(动画状态) running (默认值): 动画正常播放。 paused: 动画暂停。 示例假设我们要创建一个简单的动画，让一个 &lt;div&gt; 元素在10秒内从屏幕左侧移动到右侧，并在过程中改变背景颜色。 12345678910111213141516171819202122/* 定义关键帧动画 */@keyframes moveAndChangeColor &#123; 0% &#123; left: 0; background-color: red; &#125; 50% &#123; background-color: yellow; &#125; 100% &#123; left: 100%; background-color: blue; &#125;&#125;/* 应用动画到元素 */div &#123; position: absolute; /* 使 left 属性生效 */ width: 100px; height: 100px; animation: moveAndChangeColor 10s ease-in-out infinite;&#125; 在这个例子中： @keyframes 定义了一个名为 moveAndChangeColor 的动画，它会使元素从屏幕左侧移动到右侧，并在移动过程中改变背景颜色。 animation 属性设置了动画的名称、持续时间、速度曲线和重复次数。 关键帧的细节 0% 表示动画开始时的样式。 50% 表示动画进行到一半时的样式。 100% 表示动画结束时的样式。 CSS3动画引擎会自动计算出这些关键帧之间的过渡效果，使得动画看起来非常平滑自然。 动画的复合属性CSS中的animation是一个复合属性，它可以用来定义一个元素的动画效果。这个属性允许你设置多个与动画相关的子属性，以便更简洁地定义动画行为。这些子属性包括： animation-name: 指定一个关键帧动画的名称。 animation-duration: 规定动画完成一个周期所花费的时间。 animation-timing-function: 规定动画的速度曲线（线性、缓动等）。 animation-delay: 规定动画开始之前的延迟时间。 animation-iteration-count: 规定动画应该播放的次数，或者infinite表示无限循环。 animation-direction: 规定动画完成后是否反向播放下一个周期。 animation-fill-mode: 规定动画在开始前和结束后元素的状态。 animation-play-state: 规定动画是运行还是暂停。 示例假设我们想要创建一个简单的动画，使一个 &lt;div&gt; 元素旋转一周，我们可以这样写： 12345678910111213/* 定义关键帧动画 */@keyframes rotate &#123; from &#123; transform: rotate(0deg); &#125; to &#123; transform: rotate(360deg); &#125;&#125;/* 应用动画 */div &#123; width: 100px; height: 100px; background-color: red; animation: rotate 2s linear infinite; /* 使用复合属性 */&#125; 复合属性的使用在上面的例子中，animation复合属性包含了： rotate: 关键帧动画的名字。 2s: 动画持续时间为2秒。 linear: 动画的速度曲线是线性的。 infinite: 动画无限重复。 动画复合属性的语法复合属性的语法如下： 1animation: &lt;property-value&gt; || &lt;property-value&gt; || ... || &lt;property-value&gt;; 你可以只指定部分属性，未指定的属性将会采用其默认值。例如： 123div &#123; animation: rotate 2s infinite;&#125; 这会应用名为 rotate 的动画，动画的持续时间为2秒，并且无限循环播放。其他属性如 timing-function 和 play-state 将采用默认值（linear 和 running）。 ！！！提醒：顺序只需要注意duration和delay即可，先写的时间是动画持续时间（duration）后写的是延迟播放时间（delay）。 使用多个动画复合属性还支持同时应用多个动画。你只需要为每个动画分别指定所有必要的属性，然后用逗号分隔： 12345div &#123; animation: rotate 2s linear infinite, fadeIn 3s ease-in-out 1s;&#125; 在这个例子中，div 元素将同时执行两个动画：rotate 和 fadeIn。每个动画都有一组独立的属性值。 伸缩盒模型(C3，重要)1.伸缩盒模型介绍 伸缩盒模型又被称为弹性盒子，英文Flexible Box 它可以轻松的控制：元素分布方式、元素对齐方式、元素视觉顺序……. 截至目前，除了在部分IE浏览器不支持时，其他浏览器均已全部支持 伸缩盒模型的出现，演变成了一种布局方案————flex布局 2.主轴和侧轴主轴：从左到右，水平方向 侧轴：从上到下，垂直方向 3.容器与项目伸缩盒模型（Flexbox）是一种用于网页布局的强大工具，它能够帮助开发者更容易地创建响应式的多列或多行布局。Flexbox 主要有两个核心组成部分：Flex Container（弹性容器）和 Flex Items（弹性项目）。 伸缩盒模型（Flexbox）是一种用于网页布局的强大工具，它能够帮助开发者更容易地创建响应式的多列或多行布局。Flexbox 主要有两个核心组成部分：Flex Container（弹性容器）和 Flex Items（弹性项目）。 Flex Container (弹性容器) 定义: 当一个元素被赋予 display: flex 或 display: inline-flex 属性时，这个元素就变成了一个弹性容器。 作用: 弹性容器决定了其内部的 Flex Items 如何排列以及如何利用可用的空间。 开启时，其子元素会横向排列。 语法: 123.flex-container &#123; display: flex; /* 或者 display: inline-flex */&#125; Flex Items (弹性项目) 定义: 弹性容器内的直接子元素被称为弹性项目。 特点: 默认情况下，Flex Items 会根据容器的大小和方向进行排列和伸缩。 Flex Items 可以通过自身的属性进一步控制其行为。 只要称为了弹性项目，该项目就会”块状化” 弹性容器 的属性Flex Direction (方向) flex-direction 属性: 决定了 Flex Items 的排列方向。 值: row: Flex Items 水平排列，从左至右。 row-reverse: Flex Items 水平排列，从右至左。 column: Flex Items 垂直排列，从上至下。 column-reverse: Flex Items 垂直排列，从下至上。 Flex Wrap (换行) flex-wrap 属性: 控制 Flex Items 是否允许换行。 值: nowrap: 默认值，不允许换行。 wrap: 当空间不足时，Flex Items 会换行显示。 wrap-reverse: 当空间不足时，Flex Items 会换行显示，并且反向排列。 Justify Content (主轴对齐) justify-content 属性: 控制 Flex Items 沿主轴的对齐方式。 值: flex-start: Flex Items 聚集在主轴的起始位置。 flex-end: Flex Items 聚集在主轴的结束位置。 center: Flex Items 居中对齐。 space-between: 在 Flex Items 之间平均分配可用空间。 space-around: 在每个 Flex Item 周围平均分配可用空间。 space-evenly: 在每个 Flex Item 之间以及两端平均分配可用空间。 Align Items (交叉轴对齐，也被称为侧轴对齐) align-items 属性: 控制 Flex Items 沿交叉轴的对齐方式。 值: stretch: 默认值，使 Flex Items 填充整个侧轴。(生效条件：当伸缩项目没有指定高度时生效) flex-start: Flex Items 聚集在交叉轴的起始位置。 flex-end: Flex Items 聚集在交叉轴的结束位置。 center: Flex Items 居中对齐。 baseline: 对齐元素的基线。 Align Content (多行对齐) align-content 属性: 当 Flex Container 有多行时，控制 Flex Lines 沿侧轴的对齐方式。 值: stretch: 默认值，使 Flex Lines 填充整个侧轴。(生效条件：当伸缩项目没有指定高度时生效) flex-start: Flex Lines 聚集在交叉轴的起始位置。 flex-end: Flex Lines 聚集在交叉轴的结束位置。 center: Flex Lines 居中对齐。 space-between: 在 Flex Lines 之间平均分配可用空间。 space-evenly:在每个 Flex Item 之间以及上下两端平均分配可用空间。 space-around: 在每个 Flex Line 周围平均分配可用空间。 小技巧利用弹性盒子实现元素水平和垂直居中 方法1： 给父元素设置如下属性 1234567.father &#123; display:flex; /* 设置水平居中*/ justify-content: center; /* 设置垂直居中*/ align-items: center;&#125; 方法2： 给弹性元素和父元素设置以下属性 123456.father &#123; display:flex;&#125;.child &#123; margin: auto;&#125; 弹性项目的属性Flex Grow (伸展) flex-grow 属性: 确定当有多余空间时，Flex Item 如何扩展。 值: &lt;number&gt;: 一个非负数值，表示当有多余空间时，Flex Item 扩展的比例。 如果值为1，那么则等分剩余空间。 如果三个弹性元素的设置的值分别为1,2,3，则分别分到1/6，2/6，3/6的空间。 该属性默认值是0 Flex Shrink (收缩) flex-shrink 属性: 确定当空间不足时，Flex Item 如何收缩。 值: &lt;number&gt;: 一个非负数值，表示当空间不足时，Flex Item 收缩的比例。 Flex Basis (基础大小) flex-basis 属性: 确定 Flex Item 的默认大小。 值: &lt;length&gt;: 一个长度单位值，例如 px, em, rem 等。 &lt;percentage&gt;: 相对于容器的百分比。 content: Flex Item 的大小基于其内容。 auto: 默认值，基于内容的大小。 设置该属性会代替元素本身的width Flex (复合属性) flex 属性: 是一个简写属性，用于同时设置 flex-grow, flex-shrink, 和 flex-basis。 语法: 123.flex-item &#123; flex: &lt;flex-grow&gt; &lt;flex-shrink&gt; &lt;flex-basis&gt;;&#125; 默认值: flex:0 1 auto。可以简写为flex:0 auto 不可以拉伸，可以压缩，不设置基准长度 flex:1 1 auto 可以再次简写为flex:auto 可以拉伸，可以压缩，不设置基准长度 flex:1 1 0可以再次简写为flex:1 可以拉伸，可以压缩，基准长度设置为0 flex:0 0 auto可以再次简写为flex:none 不可以拉伸，不可以压缩，不设置基准长度 Order (排序) order 属性: 控制 Flex Items 在容器中的显示顺序。 值: &lt;integer&gt;: 一个整数值，用于确定项目的显示顺序。 order值小的元素会排在前面，order可以是负值。 默认值是0 align-self(单独对齐)可以用于控制单个元素的对齐方式 auto: 使用容器的 align-items 属性值。 flex-start: 项目靠拢交叉轴的起点。 flex-end: 项目靠拢交叉轴的终点。 center: 项目在交叉轴上居中。 baseline: 项目对齐到基线。 stretch: 默认值，项目拉伸以填充容器的交叉轴空间（如果项目没有明确的高度或最小高度，则会拉伸）。 示例代码下面是一个简单的Flexbox布局示例，展示如何创建一个弹性容器，并设置其Flex Items的排列和对齐方式： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Flexbox Example&lt;/title&gt; &lt;style&gt; .flex-container &#123; display: flex; justify-content: center; /* 沿主轴居中对齐 */ align-items: center; /* 沿交叉轴居中对齐 */ height: 200px; /* 设置容器高度 */ background-color: lightblue; &#125; .flex-item &#123; flex: 1; /* 等宽分配 */ background-color: tomato; margin: 10px; /* 项目间距 */ padding: 20px; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;flex-container&quot;&gt; &lt;div class=&quot;flex-item&quot;&gt;Item 1&lt;/div&gt; &lt;div class=&quot;flex-item&quot;&gt;Item 2&lt;/div&gt; &lt;div class=&quot;flex-item&quot;&gt;Item 3&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在这个示例中，我们创建了一个具有三个Flex Items的Flex Container。容器的Flex Items将沿水平方向居中对齐，并且在垂直方向上也居中对齐。每个Flex Item都会等宽分配空间，并且有一定的间距。 媒体查询1.媒体类型 值 含义 all 检测所有设备 screen 检测电子屏幕，包括电脑屏幕，平板屏幕，手机屏幕等 print 检测打印机 基本语法 123@media [not | only] [mediatype] [and (expression)]* &#123; CSS-Code;&#125; [not | only]: 这些关键词是可选的。(运算符) [mediatype]: 指定媒体类型，例如 screen、print 等。 [and (expression)]: 表达式用来限定应用样式的条件，例如 min-width: 320px。 2.媒体特性常用媒体特性(应用于条件) width: 视口宽度。 height: 视口高度。 orientation: 屏幕方向（portrait 或 landscape）。 aspect-ratio: 宽高比。 device-aspect-ratio: 设备的宽高比。 resolution: 分辨率。 min-width: 最小宽度。 max-width: 最大宽度。 min-height: 最小高度。 max-height: 最大高度。 3.运算符CSS3 中的媒体查询支持几种逻辑运算符，这些运算符可以帮助你构建更复杂和精确的媒体特性组合。以下是常用的逻辑运算符： and 作用: 连接两个或多个媒体特性，只有当所有特性都为真时，整个媒体查询才成立。 示例:123@media only screen and (min-width: 600px) and (max-width: 900px) &#123; /* 在屏幕宽度至少为600px但不超过900px时应用的样式 */&#125; not 作用: 否定一个媒体查询，即只有当媒体查询不成立时，样式才应用。 示例: 123@media not all and (min-width: 600px) &#123; /* 不满足min-width: 600px时应用的样式 */&#125; 注意：not后面跟的是一个完整的媒体查询，而不仅仅是媒体特性。 only 作用: 保证整个媒体查询只在指定的媒体类型上有效，并且阻止老式浏览器解析媒体查询（因为它们不支持媒体查询）。 示例:123@media only screen and (min-width: 600px) &#123; /* 只在屏幕设备上且最小宽度为600px时应用的样式 */&#125; **逗号 ,**或者or 作用: 将多个媒体查询合并为一个规则，只要其中一个查询成立，样式就会被应用。 示例: 123@media (min-width: 600px), (max-width: 900px) &#123; /* 当屏幕宽度至少为600px或不超过900px时应用的样式 */&#125; 例子下面是一个更复杂的媒体查询示例，展示了如何使用上述运算符： 1234567891011121314151617181920/* 当屏幕宽度至少为600px但不超过900px，并且设备的方向为竖直时应用的样式 */@media only screen and (min-width: 600px) and (max-width: 900px) and (orientation: portrait) &#123; body &#123; background-color: lightblue; &#125;&#125;/* 当屏幕宽度不是至少为600px时应用的样式 */@media not only screen and (min-width: 600px) &#123; body &#123; background-color: lightgreen; &#125;&#125;/* 当屏幕宽度至少为600px或不超过900px时应用的样式 */@media (min-width: 600px), (max-width: 900px) &#123; body &#123; background-color: lightyellow; &#125;&#125; 注意事项 使用only时，必须指定媒体类型（如screen、print等）。 使用not时，也必须包含媒体类型，除非整个查询被not所否定。 逗号分隔的媒体查询列表中，每个查询都是独立评估的，只要有任意一个查询为真，样式就会被应用。 4.使用方式媒体查询可以直接写在CSS文件中，也可以通过@import或&lt;link&gt;标签引入 直接在CSS文件中使用: 123@media (min-width: 600px) &#123; /* styles for screens wider than 600px */&#125; 使用@import导入: 1234@import url(&quot;default.css&quot;);@media (min-width: 600px) &#123; @import url(&quot;wide.css&quot;);&#125; 使用&lt;link&gt;标签: 12&lt;link rel=&quot;stylesheet&quot; href=&quot;default.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; media=&quot;screen and (min-width: 600px)&quot; href=&quot;wide.css&quot;&gt; BFCBFC可以想象成一个隔离的独立容器，在这个容器内部的元素不会影响到容器外部的元素。换句话说，BFC内部的元素布局规则不会影响到外部元素，同时外部元素也不会影响到内部元素的布局。 1.BFC的作用 元素开启BFC后，其子元素不会在产生margin塌陷问题。 元素开启BFC后，自己不会被其他浮动元素所覆盖 元素开启BFC后，就算其子元素浮动，元素自身高度也不会塌陷 2.如何开启BFC开启BFC（Block Formatting Context，块级格式化上下文）可以通过多种CSS属性来实现。以下是一些常见的方式： 浮动元素： 设置元素的 float 属性为 left 或 right。 示例:123.element &#123; float: left;&#125; 绝对定位元素： 设置元素的 position 属性为 absolute 或 fixed。 示例:123.element &#123; position: absolute;&#125; 溢出隐藏： 设置元素的 overflow 属性为 hidden, auto 或 scroll。 示例:123.element &#123; overflow: hidden;&#125; Flex容器： 设置元素的 display 属性为 flex 或 inline-flex。 示例:123.element &#123; display: flex;&#125; Grid容器： 设置元素的 display 属性为 grid 或 inline-grid。 示例:123.element &#123; display: grid;&#125; Inline-block元素： 设置元素的 display 属性为 inline-block。 示例: 123.element &#123; display: inline-block;&#125; **display: flow-root**： 这个值在CSS3中引入，专门用于创建BFC，而不会改变元素的显示行为。 示例:123.element &#123; display: flow-root;&#125; IE6 兼容性： 对于IE6及更低版本，可以使用 zoom 属性来模拟BFC的行为。 示例:1234.element &#123; zoom: 1; /* IE6及更低版本 */ *zoom: 1; /* IE7及更高版本 */&#125; 示例这里有一个具体的示例，展示如何使用overflow: hidden来创建BFC并解决高度塌陷问题： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;BFC Example&lt;/title&gt;&lt;style&gt; .container &#123; border: 1px solid black; padding: 10px; overflow: hidden; /* 创建BFC */ &#125; .box &#123; width: 100px; height: 100px; background-color: lightblue; float: left; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;p&gt;Some text here...&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在这个示例中，.container设置了overflow: hidden来创建一个BFC，这样即使.box是浮动的，.container的高度也会正确地包含浮动元素和文本。 请注意，选择哪种方法取决于你的具体需求。例如，如果你想保留元素的默认行为，可以选择overflow: hidden或者display: flow-root。如果你需要创建一个容器来布局其子元素，那么display: flex或display: grid可能是更好的选择。 前端学习路径","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"HTML,CSS","slug":"HTML-CSS","permalink":"http://example.com/tags/HTML-CSS/"}]},{"title":"Vuex","slug":"Vuex","date":"2024-07-17T10:18:47.000Z","updated":"2024-07-22T06:12:48.903Z","comments":true,"path":"2024/07/17/Vuex/","permalink":"http://example.com/2024/07/17/Vuex/","excerpt":"","text":"1.Vuex 是什么？Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。是一个状态共享框架 Vuex是采用集中式管理组件依赖的共享数据的一个工具，可以解决不同组件数据共享的问题 2.vuex基础-初始化功能每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的**状态 (state)**。Vuex 和单纯的全局对象有以下两点不同： Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 建立一个新的脚手架项目, 在项目中应用vuex 1$ vue create learnvuex 初始化： 第一步：npm i vuex --save &#x3D;&gt; 安装到**运行时依赖** &#x3D;&gt; 项目上线之后依然使用的依赖 ,开发时依赖 &#x3D;&gt; 开发调试时使用 (注意对应版本，vue2对应vuex3，vue3对应vuex4) 第二步： 在main.js中 import Vuex from &#39;vuex&#39; 第三步：在main.js中 Vue.use(Vuex) &#x3D;&gt; 调用了 vuex中的 一个install方法 第四步：const store = new Vuex.Store(&#123;...配置项&#125;) 第五步：在根实例配置 store 选项指向 store 实例对象 1234567891011121314151617//这是main.js中(第一步是安装vuex)import Vue from &#x27;vue&#x27;//第二步import Vuex from &#x27;vuex&#x27;import App from &#x27;./App.vue&#x27;//第三步全局注册vuexVue.use(Vuex)Vue.config.productionTip = false//第四步const store = new Vuex.Store(&#123;&#125;)new Vue(&#123; //第五步,把store应用于vue实例对象 store, render: h =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;) 3.Vuex基础—state单一状态树Vuex 使用单一状态树——是的，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT (opens new window))”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。 在 Vue 组件中获得 Vuex 状态从 store 实例中读取状态最简单的方法就是在计算属性 (opens new window)中返回某个状态： 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div&gt;&#123;&#123; countPlusLocalState &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapState &#125; from &#x27;vuex&#x27;;export default &#123; data()&#123; return &#123; &#125; &#125;, computed: &#123; ...mapState(&#123; count: state =&gt; state.count, countPlusLocalState(state) &#123; return state.count &#125; &#125;) &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 在main.js中，我们定义了store对象(该对象是面向所有组件的)，这时我们在定义state 12345const store = new Vuex.Store(&#123; state:&#123; //管理数据 count:0 &#125; 那么页面上就会呈现我们的0 每当 this.$store.state.count 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。 mapState 辅助函数当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键： 12//导入辅助函数import &#123; mapState &#125; from &#x27;vuex&#x27; 使用该函数会自动帮我们生成计算属性 这里的...是ES6中的延展运算符，它相当于会解析数组的内容并展开为多个独立的参数，比如 12let arr1 = [1, 2, 3];let arr2 = [...arr1, 4]; // arr2 现在就成为了 [1, 2, 3, 4] 123456789101112131415computed: &#123; ...mapState(&#123; count: state =&gt; state.count, countPlusLocalState(state) &#123; return state.count &#125; &#125;) //也可以这么写，传入一个数组 ...mapState([&#x27;count&#x27;]) //上面的写法就相当写一个下面这样的计算属性 count()&#123; return this.$store.state.count &#125; &#125; 当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"状态管理工具(vue2.js)","slug":"状态管理工具-vue2-js","permalink":"http://example.com/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-vue2-js/"}]},{"title":"WebPack","slug":"WebPack","date":"2024-07-15T10:16:52.000Z","updated":"2024-09-14T00:58:33.292Z","comments":true,"path":"2024/07/15/WebPack/","permalink":"http://example.com/2024/07/15/WebPack/","excerpt":"","text":"1.webpack基本概念本质上，webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的内容。 2.webpack使用步骤2.1基础使用默认入口: ./src/index.js 默认出口: ./dist/main.js 初始化包环境 1yarn init 安装依赖包 1yarn add webpack webpack-cli -D 配置scripts 123&quot;scripts&quot;:&#123;&quot;build&quot;:&quot;webpack&quot;&#125; 新建目录src新建src&#x2F;add&#x2F;add.js - 定义求和函数导出 1234//导出该函数export const addFun = (a,b)=&gt;&#123; return a + b&#125; 新建src&#x2F;index.js导入使用 123//导入求和模块import &#123; addFun &#125; from &quot;./add/add&quot;;console.log(addFun(9,8)); 运行打包命令 12yarn build#或者 npm run build 总结: src并列处, 生成默认dist目录和打包后默认main.js文件 2.2webpack 更新打包目标: 以后代码变更, 如何重新打包呢 新建src&#x2F;tool&#x2F;tool.js - 定义导出数组求和方法 1234//定义导出数组的求和方法export const getArrSum = arr=&gt;&#123;arr.reduce((sum,val)=&gt;&#123; sum += val,0&#125;)&#125; src&#x2F;index.js - 导入使用 123456//导入求和模块import &#123; addFun&#125; from &quot;./add/add.js&quot;;import &#123; getArrSum &#125; from &quot;./tool/tool.js&quot;;console.log(addFun(9,8));console.log(getArrSum[0,1,2]); 重新打包 1yarn build 总结1: src下开发环境, dist是打包后, 分别独立 总结2: 打包后格式压缩, 变量压缩等 3.webpack的配置目标: 告诉webpack从哪开始打包, 打包后输出到哪里 默认入口: ./src/index.js 默认出口: ./dist/main.js webpack配置 - webpack.config.js(默认) 在scr同级目录下新建webpack.config.js文件 填入配置项 用法：entry: string | [string] 1.单个入口（简写）语法123module.exports = &#123; entry: &#x27;./path/to/my/entry/file.js&#x27;,&#125;; entry 属性的单个入口语法，是以下形式的简写： 12345module.exports = &#123; entry: &#123; main: &#x27;./path/to/my/entry/file.js&#x27;, &#125;,&#125;; 我们也可以将一个文件路径数组传递给entry属性。 123456789module.exports = &#123; //传入路径数组 entry: [&#x27;./src/file_1.js&#x27;, &#x27;./src/file_2.js&#x27;], //出口 output: &#123; //出口文件名称 filename: &#x27;bundle.js&#x27;, &#125;,&#125;; 2.对象语法用法：entry: &#123; &lt;entryChunkName&gt; string | [string] &#125; | &#123;&#125; 123456module.exports = &#123; entry: &#123; app: &#x27;./src/app.js&#x27;, adminApp: &#x27;./src/adminApp.js&#x27;, &#125;,&#125;; 2.1.描述入口的对象用于描述入口的对象。你可以使用如下属性： dependOn: 当前入口所依赖的入口。它们必须在该入口被加载前被加载。 filename: 指定要输出的文件名称。 import: 启动时需加载的模块。 library: 指定 library 选项，为当前 entry 构建一个 library。 runtime: 运行时 chunk 的名字。如果设置了，就会创建一个新的运行时 chunk。在 webpack 5.43.0 之后可将其设为 false 以避免一个新的运行时 chunk。 publicPath: 当该入口的输出文件在浏览器中被引用时，为它们指定一个公共 URL 地址。请查看 output.publicPath。 3.示例webpack.config.js 1234567891011const path = require(&#x27;path&#x27;)//向外共享模块module.exports = &#123; //入口 entry: &#x27;./src/index.js&#x27;, output: &#123; path: path.join(__dirname, &#x27;dist&#x27;), //出口路径 filename: &#x27;bundle.js&#x27; //出口文件名称 &#125;&#125; 4.打包流程 重点: 所有要被打包的资源都要跟入口产生直接&#x2F;间接的引用关系 5.案例—webpack隔行变色目标: 工程化模块化开发前端项目, webpack会对ES6模块化处理 新建目录结构如下 scr下新建main.js写入下面的内容 1234567import $ from &quot;jquery&quot;;$(function()&#123; $(&#x27;#app li:nth-child(odd)&#x27;).css(&#x27;color&#x27;,&#x27;red&#x27;) $(&#x27;#app li:nth-child(even&#x27;).css(&#x27;color&#x27;,&#x27;blue&#x27;)&#125;) :nth-child(an+b) 是更通用的形式，其中a和b是整数，n是一个循环变量，从0开始。 当a=1且b=0时，简写为:nth-child(odd)，意味着每两个元素取一个，即选择了所有奇数位置的子元素（1, 3, 5, …）。 相对应的，:nth-child(even) 也就是 :nth-child(2n)，会选择偶数位置的子元素（2, 4, 6, …）。 public下新建index.html，写入下面的内容 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;&lt;script src=&quot;./dist.js&quot;&gt;&lt;/script&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt;&lt;li&gt;2&lt;/li&gt;&lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在package.json中加入下面的内容 注：记得安装webpack命令如下 1yarn add webpack webpack-cli -D 执行yarn build进行打包dist目录下会出现下面的内容 特别注意： index.html是从public复制过来的，打包后没有自动生成这个文件 在index.html中引入打包后生成的js文件 &lt;script src=&quot;./dist.js&quot;&gt;&lt;/script&gt; 1234567891011121314151617效果图：![image-20240716143411574](../images/WebPack/image-20240716143411574.png)## 6.自动生成html文件(使用插件)插件的用法：由于**插件**可以携带参数/选项，你必须在 webpack 配置中，向 `plugins` 属性传入一个 `new` 实例。取决于你的 webpack 用法，对应有多种使用插件的方式。为了解决上面的案例并没有直接为我们生成html文件，这时通过 **html-webpack-plugin**插件, 让webpack打包后生成html文件并自动引入打包后的js### 6.1.安装```bashyarn add html-webpack-plugin -D 6.2.配置webpack.config.js文件1234567891011121314151617181920const path = require(&#x27;path&#x27;)//引入HtmlWebpackPlugin插件const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123; //入口 entry:&#123; main:&#x27;./src/main.js&#x27; &#125;, output:&#123; path:path.join(__dirname,&#x27;dist&#x27;), filename:&#x27;dist.js&#x27; &#125;, plugins:[ //实例化HtmlWebPackPlugin对象 new HtmlWebpackPlugin(&#123; // 以此为模板生成打包后html文件 template:&#x27;./public/index.html&#x27; &#125;) ] 6.3.重新打包运行yarn build进行重新打包，查看是否自动生成了html文件可以看到，确实自动生成了index文件查看运行是没有问题的。 总结: webpack就像一个人, webpack.config.js是人物属性, 给它穿什么装备它就干什么活 4.加载器(loader)Webpack 支持使用 loader 对文件进行预处理。你可以构建包括 JavaScript 在内的任何静态资源。并且可以使用 Node.js 轻松编写自己的 loader。 在 require() 语句中使用 loadername! 作为前缀的方式来使用 loader，或者在 webpack 配置中配置 regex 来自动应用它们 4.1.使用 loader在你的应用程序中，有两种使用 loader 的方式： 配置方式（推荐）：在 webpack.config.js 文件中指定 loader。 内联方式：在每个 import 语句中显式指定 loader。 注意在 webpack v4 版本可以通过 CLI 使用 loader，但是在 webpack v5 中被弃用。 配置module.rules 允许你在 webpack 配置中指定多个 loader。 这种方式是展示 loader 的一种简明方式，并且有助于使代码变得简洁和易于维护。同时让你对各个 loader 有个全局概览： loader 从右到左（或从下到上）地取值(evaluate)&#x2F;执行(execute)。在下面的示例中，从 sass-loader 开始执行，然后继续执行 css-loader，最后以 style-loader 为结束。 4.2.loader-处理CSS文件 loaders加载器, 可让webpack处理其他类型的文件, 打包到js中原因: webpack默认只认识 js 文件和 json文件 使用 loader 告诉 webpack 加载 CSS 文件，为此，首先要安装loader 1npm install --save-dev css-loader ts-loader 随后在webpack.config.js中配置对每个.css文件使用css-loader推荐将 style-loader 与 css-loader 一起使用 12345678910111213module.exports = &#123; module: &#123; // loader的规则 rules: [ &#123; // 匹配所有的css文件 test: /\\.css$/i, // 先用 css-loader 让webpack能够识别 css 文件的内容并打包再用 style-loader 将样式, 把css插入到dom中，详见loader执行顺序 use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;], &#125;, ], &#125;,&#125;; 接下来新建scr&#x2F;css&#x2F;li.css文件，写一段去掉li样式的css代码 123ul li &#123; list-style: none;&#125; 最重要的一步，引入css文件到入口。 1import &#x27;./css/li.css&#x27; 运行打包后dist&#x2F;index.html观察效果和css引入情况可以看到默认的有序列表的小圆点已经被去除了 4.3.loader-处理less文件目标: less-loader让webpack处理less文件, less模块翻译less代码 less-loader文档1.下载依赖包 1yarn add less less-loader -D 2.配置webpack.config.js文件 12345678910module:&#123; rules:[ &#123; //匹配以.less结尾的文件 test:/\\.less$/, // 使用less-loader, 让webpack处理less文件, 内置还会 用less翻译less代码成css内容 use:[&#x27;style-loader&#x27;,&#x27;css-loader&#x27;,&#x27;less-loader&#x27;] &#125; ]&#125; 3.新建scr&#x2F;less&#x2F;index.less -设置li字体大小为24px 12345@size:24px;ul li &#123; font-size:@size&#125; 4.(重点)引入index.less文件到入口文件 1import &#x27;./less/index.less&#x27; 5.打包运行查看效果。字体确实变了。 4.4.loder-处理图片文件目标: 用asset module方式(webpack5版本新增) asset module文档 如果webpack的版本是webpack5，直接在webpack.config.js配置即可 1234&#123; test: /\\.(png|jpg|gif|jpeg)$/i, type: &#x27;asset&#x27;&#125; 如果你用的是webpack4及以前的，请按照下面的步骤进行配置url-loader文档 file-loader文档 1.下载依赖包 1yarn add url-loader file-loader -D 2.webpack.config.js配置 12345678910111213141516171819module:&#123; rules:[ &#123; &#123; test: /\\.(png|jpg|gif|jpeg)$/i, use: [ &#123; // 匹配文件, 尝试转base64字符串打包到js中 loader: &#x27;url-loader&#x27;, // 配置limit, 超过8k, 不转, file-loader复制, 随机名, 输出文 件 options: &#123; limit: 8 * 1024, &#125;, &#125;, ],&#125; &#125; ]&#125; 图片转成 base64 字符串 好处就是浏览器不用发请求了，直接可以读取 坏处就是如果图片太大，再转base64就会让图片的体积增大 30% 左右 3.在src&#x2F;assets目录下准备两个图片4.在css&#x2F;less&#x2F;index.less中把小图片用做背景 123body &#123; background: url(../assets/image.png) no-repeat center&#125; 5.在src&#x2F;main.js - 把大图插入到创建的img标签上, 添加body上显示 123456789101112131415import $ from &quot;jquery&quot;;import &#x27;./css/li.css&#x27;import &#x27;./less/index.less&#x27;//导入图片并命名import imageUrl from &#x27;./assets/李泽伟 (3).jpg&#x27;//通过dom创建元素let theImg = document.createElement(&#x27;img&#x27;)//给theImg标签的src属性进行赋值theImg.src = imageUrl//展示到页面上document.body.appendChild(theImg)$(function()&#123; $(&#x27;#app li:nth-child(odd)&#x27;).css(&#x27;color&#x27;,&#x27;red&#x27;) $(&#x27;#app li:nth-child(even&#x27;).css(&#x27;color&#x27;,&#x27;blue&#x27;)&#125;) 6.打包运行dist&#x2F;index.html观察2个图片区别 4.5.loader-处理字体文件用asset module技术, asset&#x2F;resource直接输出到dist目录下 if webpack version &gt; &#x3D; 5 &#123; // webpack5默认内部不认识这些文件, 所以当做静态资源直接输出即可 test: /\\.(eot|svg|ttf|woff|woff2)$/, type: &#39;asset/resource&#39;, generator: &#123; filename: &#39;font/[name].[hash:6][ext]&#39; &#125; &#125; 12345678910111213141516171819* if f webpack version &lt;= 4 * ```js &#123; // 处理字体图标的解析 test: /\\.(eot|svg|ttf|woff|woff2)$/, use: [ &#123; loader: &#x27;url-loader&#x27;, options: &#123; limit: 2 * 1024, // 配置输出的文件名 name: &#x27;[name].[ext]&#x27;, // 配置输出的文件目录 outputPath: &quot;fonts/&quot; &#125; &#125; ] &#125; 2.scr&#x2F;assets&#x2F;目录下放入字体库fonts文件3.在main.js中(入口文件)引入iconfonts.css 12//引入字体库文件import &#x27;./assets/fonts/iconfonts.css&#x27; 4.在public&#x2F;index.html使用字体图标样式 1&lt;i class=&quot;iconfont icon-weixin&quot;&gt;&lt;/i&gt; 5.执行打包命令-观察打包后网页效果 总结: url-loader和file-loader 可以打包静态资源文件 4.6.loader-处理高版本的js语法高版本的js代码，比如箭头函数，在打包后原封不动的打包在了js文件中，当遇到一些低版本的浏览器就会报错。报错的原因是：webpack默认仅设内置了模块化的 兼容性处理，也就是在使用import export时。 解决方案：让webpack配合babel-loader对js语法做处理 babel官网babel-loader 1.安装 1npm install -D babel-loader @babel/core @babel/preset-env webpack 或者 1yarn add -D babel-loader @babel/core @babel/preset-env 2.配置webpack.config.js 123456789101112131415module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: &#x27;babel-loader&#x27;, options: &#123; // 预设:转码规则(用bable开发环境本来预设的) presets: [&#x27;@babel/preset-env&#x27;], &#125;, &#125;, &#125;, ];&#125; 3.在main.js中使用箭头函数 1234let fn =()=&gt;&#123; console.log(&#x27;你好babel&#x27;);&#125;console.log(fn); 注意：这里必须打印，不能调用&#x2F;不使用, 不然webpack会精简成一句打印不要函数了&#x2F;不会编译未使用的代码 没有babel集成时, 原样直接打包进lib&#x2F;bundle.js有babel集成时, 会翻译成普通函数打包进lib&#x2F;bundle.js 4.打包后观察lib&#x2F;bundle.js - 被转成成普通函数使用了 - 这就是babel降级翻译的功能 5.webpack开发服务器文档地址：https://webpack.docschina.org/configuration/dev-server/ 为什么要使用webpack开发服务器？ 答： 开启一个开发服务器, 在电脑内存中打包, 缓存一些已经打包过的内容, 只重新打包修改的文件, 最终运行加载在内存中给浏览器使用 5.1.webpack-dev-server自动刷新启动本地服务, 可实时更新修改的代码, 打包变化代码到内存中, 然后直接提供端口和网页访问 1.下载包 1yarn add webpack-dev-server -D 2.配置自定义命令 1234scripts: &#123; &quot;build&quot;: &quot;webpack&quot;, &quot;serve&quot;: &quot;webpack serve&quot;&#125; 3.运行命令-启动webpack开发服务器 1yarn serve #或者 npm run server 5.2.webpack-dev-server配置1.在webpack.config.js中添加服务器配置 更多配置项请参考文档：https://webpack.docschina.org/configuration/dev-server/#devserverafter 123456module.exports = &#123; // ...其他配置 devServer: &#123; port: 3000 // 端口号 &#125;&#125; 6.webpack的两种模式1.Development 模式特点: 快速编译: 开发模式追求的是快速的编译速度，以便于开发者能够快速看到代码更改的效果。它不会进行大量的压缩和优化，从而加速重新打包的过程。 源码映射 (Source Maps): 默认情况下，此模式会生成详细的源码映射，这有助于开发者在浏览器的开发者工具中轻松地追踪源代码中的错误和警告，即使代码经过了加载器和插件的转换。 保持模块热替换 (Hot Module Replacement, HMR) 功能: 这使得在不刷新页面的情况下更新变更的模块成为可能，极大地提升了开发效率。 使用场景: 在日常开发过程中，当你需要频繁修改代码并查看效果时，应使用开发模式。它可以帮助你快速迭代，即时查看代码更改的结果，同时保持调试的便利性。 2.Production 模式特点: 优化输出: 生产模式会对最终的输出进行各种优化，包括代码压缩、模块和资源的最小化，以及去除死代码（Tree Shaking），以减小文件体积，提高加载速度。 性能提升: 通过减少文件大小和优化资源加载顺序等手段，显著提升应用在生产环境中的性能。 更少的源码映射信息: 默认情况下，生产模式生成的源码映射信息被优化以减小其体积，并且通常不会包含原始源代码的每一行详细信息，而是为了错误报告而设计的。 静态资源处理: 包括对静态资源如图片和字体进行更高效的处理，如压缩和更合理的文件名哈希，以利用缓存机制。 使用场景: 当你的项目准备部署到线上或者生产环境时，应该使用生产模式。这个模式确保了应用以最优的状态运行，不仅提高了用户体验，还考虑到了性能和资源管理的最佳实践。 设置方式在 webpack.config.js 配置文件中，你可以通过设置 mode 属性来指定构建模式： 12341module.exports = &#123;2 mode: &#x27;development&#x27;, // 或 &#x27;production&#x27;3 // 其他配置...4&#125;; 或者在命令行中通过 --mode 参数指定： 123451// 开发模式2npx webpack --mode development34// 生产模式5npx webpack --mode production 确保在适当的环境下选择正确的模式，这对于保持开发效率和保障线上应用的性能至关重要。 面试题1、什么是webpack（必会）​ webpack是一个打包模块化javascript的工具，在webpack里一切文件皆模块，通过loader转换文件，通过plugin注入钩子，最后输出由多个模块组合成的文件，webpack专注构建模块化项目 2、Webpack的优点是什么？（必会） 专注于处理模块化的项目，能做到开箱即用，一步到位 通过plugin扩展，完整好用又不失灵活 通过loaders扩展, 可以让webpack把所有类型的文件都解析打包 区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展 3、webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全（必会）​ Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程： ​ 1. 初始化参数：从配置文件读取与合并参数，得出最终的参数 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，开始执行编译 确定入口：根据配置中的 entry 找出所有的入口文件 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。 在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果 4、说一下 Webpack 的热更新原理(必会)​ webpack 的热更新又称热替换（Hot Module Replacement），缩写为 HMR。这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。 ​ HMR的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上 WDS 与浏览器之间维护了一个 Websocket，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起 Ajax 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 jsonp 请求获取该chunk的增量更新。 ​ 后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 HotModulePlugin 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像react-hot-loader 和 vue-loader 都是借助这些 API 实现 HMR。 5、webpack与grunt、gulp的不同？（必会）​ 1) 三者之间的区别 ​ 三者都是前端构建工具，grunt和gulp在早期比较流行，现在webpack相对来说比较主流，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。 ​ grunt和gulp是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。 ​ webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。 ​ 2) 从构建思路来说 ​ gulp和grunt需要开发者将整个前端构建过程拆分成多个Task，并合理控制所有Task的调用关系 webpack需要开发者找到入口，并需要清楚对于不同的资源应该使用什么Loader做何种解析和加工 ​ 3) 对于知识背景来说 ​ gulp更像后端开发者的思路，需要对于整个流程了如指掌 webpack更倾向于前端开发者的思路 6、有哪些常见的Loader？他们是解决什么问题的？（必会）1、 file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 2、 url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去 3、 source-map-loader：加载额外的 Source Map 文件，以方便断点调试 4、 image-loader：加载并且压缩图片文件 5、 babel-loader：把 ES6 转换成 ES5 6、 css-loader：加载 CSS，支持模块化、压缩、文件导入等特性 7、 style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。 8、 eslint-loader：通过 ESLint 检查 JavaScript 代码 7、Loader和Plugin的不同？（必会）​ 1) 不同的作用 ​ Loader直译为”加载器”。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。 ​ Plugin直译为”插件”。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 2) 不同的用法 ​ Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options） ​ Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"打包工具，模块","slug":"打包工具，模块","permalink":"http://example.com/tags/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%EF%BC%8C%E6%A8%A1%E5%9D%97/"}]},{"title":"vue前置知识","slug":"vue前置知识","date":"2024-07-15T04:02:37.000Z","updated":"2024-08-27T10:41:44.963Z","comments":true,"path":"2024/07/15/vue前置知识/","permalink":"http://example.com/2024/07/15/vue%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/","excerpt":"","text":"ES6模块化在学习Node.js时，我已经知道了Node.js遵循的是CommonJS的模块化规范。 下面来学习ES6模块化。 ES6模块化规范浏览器端与服务器端通用的模块化开发规范。它的出现极大地降低了前端开发者的模块化学习成本，开发者不需要再额外学习AMD、CMD或CommonJS等模块化规范 ES6模块化规范中定义 每个JS文件都是一个独立的模块 导入其他模块成员使用import关键字 向外共享模块成员使用export关键字 在Node.js中使用ES6模块化 确保node保本高于14。 在package.json根节点添加&quot;type&quot;:&quot;module&quot; ES6模块化基本语法默认导出与默认导入基础语法 export default 默认导出的成员 1234567891011121314let n1 = 10let n2 = 20function show()&#123;&#125;//默认导出向外共享export default &#123; n1, show&#125; 默认导入语法：import 接收名称 from ‘模块标识符’ 1234//在2中导入1import DefaultInput from &#x27;./1默认导出.js&#x27;console.log(DefaultInput); 查看控制台如下 1默认导出和默认导入的注意事项 一个模块内，export default只允许使用一次，否则会报错 接收被导入的模块时，名称合法即可，切记不能以数字开头 按需导出和按需导入语法：export +要导出的内容 12345export let s1 = &#x27;aaa&#x27;;export let s2 = &#x27;123&#x27;;export function show()&#123;&#125; 语法：import { } from ‘模块标识符’ 12345import &#123;s1,s2,show&#125; from &#x27;./3按需导出.js&#x27;console.log(s1);console.log(s2);console.log(show); 按需导出和按需导入的注意事项 可以使用多个按需导出，允许多个export存在 按需导入的成员名称和按需导入的成员名称必须一致 按需导入时可以通过关键字as进行重命名 按需导入可以和默认导入一起使用，即允许export和export default&#123;&#125;同时存在 直接导入并执行模块中的代码语法： import ‘模块标识符’ 控制台输出 PromisePromise的基本概念1.Promise是一个构造函数 可以通过**const p &#x3D; new Promise()**创建Promise实例对象 new出来的Promise实例对象代表一个异步操作 2.Promise.propertype(原型对象)中包含.then方法 每次new Promise()构造函数得到的实例对象都可以通过原型链的方式访问到.then方法，例如p.then() .then()方法可以用来预先指定成功和失败的回调函数 p.then(成功回调，失败回调) p.then(result&#x3D;&gt;{},error&#x3D;&gt;{}) 成功回调函数必选，失败回调函数是可选的 基于回调函数按顺序读取文件内容下面这种无法保证读取文件的顺序。 12345import thenFs from &quot;then-fs&quot;;//readFile返回的是Promise的实例对象thenFs.readFile(&#x27;./file/1.txt&#x27;,&#x27;utf-8&#x27;).then((r1)=&gt;&#123;console.log(r1);&#125;)thenFs.readFile(&#x27;./file/2.txt&#x27;,&#x27;utf-8&#x27;).then((r2)=&gt;&#123;console.log(r2);&#125;)thenFs.readFile(&#x27;./file/3.txt&#x27;,&#x27;utf-8&#x27;).then((r3)=&gt;&#123;console.log(r3);&#125;) Promise支持链式调用，上述代码按顺序读取文件改为如下：由于readFile返回的是Promise的实例对象，所以： 12345678910111213141516import thenFs from &quot;then-fs&quot;;thenFs.readFile(&#x27;./file/1.txt&#x27;,&#x27;utf-8&#x27;).then((r1)=&gt;&#123;console.log(r1);//该函数返回的是promise return thenFs.readFile(&#x27;./file/2/txt&#x27;,&#x27;utf-8&#x27;)&#125;)//因为上述函数的返回值是promise的对象所以可以继续调用.then.then((r2)=&gt;&#123; console.log(r2); return thenFs.readFile(&#x27;./file/3.txt&#x27;,&#x27;utf-8&#x27;)&#125;).then((r3)=&gt;&#123; console.log(r3);&#125;) 通过.catch方法捕获错误在可能会出错的位置进行捕获，如果放在最后，那么前面出现问题了会导致后面的无法执行从而直接进入.catch处理错误 12345678910111213141516171819import thenFs from &quot;then-fs&quot;;thenFs.readFile(&#x27;./file/1.txt&#x27;,&#x27;utf-8&#x27;).then((r1)=&gt;&#123;console.log(r1);//把promise对象返回出去 return thenFs.readFile(&#x27;./file/2/txt&#x27;,&#x27;utf-8&#x27;)&#125;)//因为上述函数的返回值是promise的对象所以可以继续调用.then.then((r2)=&gt;&#123; console.log(r2); return thenFs.readFile(&#x27;./file/3.txt&#x27;,&#x27;utf-8&#x27;)&#125;).then((r3)=&gt;&#123; console.log(r3);&#125;)//通过.catch捕获错误.catch(err=&gt;&#123; console.log(err.message);&#125;) Promise.all()方法Promise.all()方法会发起并行的 Promise 异步操作，等所有的异步操作全部结束后才会执行下一步的.then()操作(等待机制)。示例代码如下: 代码 123456789101112131415161718import thenFs from &quot;then-fs&quot;;const promiseAll = [ //该顺序就是最后结果顺序 thenFs.readFile(&#x27;./file/1.txt&#x27;,&#x27;utf-8&#x27;), thenFs.readFile(&#x27;./file/2.txt&#x27;,&#x27;utf-8&#x27;), thenFs.readFile(&#x27;./file/3.txt&#x27;,&#x27;utf-8&#x27;),]//调用promise.all方法来进行并行操作Promise.all(promiseAll).then((result)=&gt;&#123; //成功 console.log(result);&#125;)// 通过.catch捕获错误.catch(err=&gt;&#123; console.log(err.message);&#125;) Promise.race()方法Promise.race()方法会发起并行的 Promise 异步操作，只要任何一个异步操作完成，就立即执行下一步的.then 操作(赛跑机制)。示例代码如下: 123456789101112131415161718import thenFs from &quot;then-fs&quot;;const promiseAll = [ //该顺序就是最后结果顺序 thenFs.readFile(&#x27;./file/1.txt&#x27;,&#x27;utf-8&#x27;), thenFs.readFile(&#x27;./file/2.txt&#x27;,&#x27;utf-8&#x27;), thenFs.readFile(&#x27;./file/3.txt&#x27;,&#x27;utf-8&#x27;),]//调用promise.all方法来进行并行操作Promise.race(promiseAll).then((result)=&gt;&#123; //成功 console.log(result);&#125;)// 通过.catch捕获错误.catch(err=&gt;&#123; console.log(err.message);&#125;) 可以看出每次执行都会产生不同的结果，这就意味着Promise.race方法是谁先执行完，就继续往下执行，不会等待全部执行完成 案例—基于Promise封装一个异步读取文件的方法方法的封装要求 方法的名称要定义为 getFile 方法接收一个形参 fpath，表示要读取的文件的路径 方法的返回值为 Promise 实例对象 完整代码： 123456789101112const fs = require(&#x27;fs&#x27;)//定义方法function getFile(fPath)&#123; //定义功能 // resolve代表成功，reject代表失败 return new Promise(function(resolve,reject)&#123; fs.readFile(fPath,&#x27;utf-8&#x27;,(err,dataStr)=&gt;&#123; if(err) return reject(err) resolve(dataStr) &#125;) &#125;)&#125; async和awaitasync&#x2F;await是ES8(ECMAScript 2017)引入的新语法，用来简化 Promise 异步操作。在 async&#x2F;await 出现之前，开发者只能通过链式 .then()的方式处理 Promise 异步操作。 12345678import thenFs from &#x27;then-fs&#x27;async function getFile()&#123; const r1 = await thenFs.readFile(&#x27;./file/1.txt&#x27;,&#x27;utf-8&#x27;) console.log(r1);&#125;getFile(); 结果：通过aysnc和await可以直接获取到结果，从而简化了执行过程 注意： 使用了await，那么该方法必须使用async来修饰。 在async方法中，第一个await之前的方法会同步执行，await之后的会异步执行。 EventLoop(事件循环)同步任务和异步任务为了防止某个耗时任务导致程序假死的问题，JavaScript 把待执行的任务分为了两类: 同步任务(synchronous) 又叫做非耗时任务，指的是在主线程上排队执行的那些任务 只有前一个任务执行完毕，才能执行后一个任务 异步任务(asynchronous) 又叫做耗时任务，异步任务由JavaScript委托给宿主环境进行执行 当异步任务执行完成后，会通知JavaScript 主线程执行异步任务的回调函数 同步任务和异步任务的执行过程(重点)一图了解： EventLoop(事件循环)基本概念JS有一个基于事件循环的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列的子任务。 下面是一个面试题： 输出顺序是：ADCB 分析：AD是同步任务，会在javascript主线程中执行，CB是耗时任务，异步任务，会放在宿主环境中执行，然而由于延时器是0s所以一但进入宿主环境变会进行执行。 最终顺序是ADCB 宏任务和微任务(重点)JS中异步任务又分为宏任务和微任务 宏任务 异步的Ajax请求 setTimeout、setinterval(该函数作用是设置某个时间，按照一定的时间间隔进行循环执行) 文件操作 其他 微任务 Promise.then()、.catch和.fianlly process.nextTick 其他 执行顺序 同步任务：先执行 宏任务：放入宏任务队列等待执行 微任务：放入微任务队列等待执行 在执行下一个宏任务时，要检查该宏任务中是否包含微任务 总结","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"vue.js前置知识","slug":"vue-js前置知识","permalink":"http://example.com/tags/vue-js%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"}]},{"title":"身份认证相关内容","slug":"身份认证相关内容","date":"2024-07-13T07:21:39.000Z","updated":"2024-07-18T02:16:25.921Z","comments":true,"path":"2024/07/13/身份认证相关内容/","permalink":"http://example.com/2024/07/13/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/","excerpt":"","text":"1.身份认证的概念 身份认证又被称为鉴权，身份验证，是通过一定的手段，完成对用户身份的确认。 2.身份认证方案对于服务端渲染和前后端分离这两种开发模式来说，分别有着不同的身份认证方案。 服务端渲染推荐使用 Session认证机制 前后端分离推荐使用 JWT认证机制 3.Session认证机制1.了解HTTP协议的无状态性 http协议的无状态性指的是客户端每次的HTTP请求都是独立的，连续多个请求之间没有直接的关系，服务器不会主动保留每次HTTP请求的状态 简单来说就是，服务器并不会记录你的状态，比如你登录过一次，那么下次再起发起请求时还需要再次登录。 在我们Web开发中，利用Cookie突破Http无状态协议 2.什么是CookieCookie是存储在用户浏览器中一段不超过4KB的字符串。它由一个名称(name)、一个值(value)和其他几个用于控制Cookie有效期、安全性、使用范围的可选属性组成。 不同域名下的Cookie各自独立，每当客户端发起请求时，会自动把当前域名下所有未过期的Cookie一同发送到服务器。 Cookie的特性：1.自动发送 2.域名独立 3.过期时限 4.4KB限制 3.Cookie在身份认证中的作用客户端第一次请求服务器的时候，服务器通过响应头的形式，向客户端发送一个身份认证的 Cookie，客户端会自动将 Cookie 保存在浏览器中。 随后，当客户端浏览器每次请求服务器的时候，浏览器会自动将身份认证相关的Cookie，通过请求头的形式发送给服务器，服务器即可验明客户端的身份 4.Cookie不具有安全性由于Cookie是存储在浏览器中，而且浏览器也提供了读写Cookie的API，因此Cookie很容易被伪造，不具有安全性。 5.提高身份认证的安全性方法：客户端出示的Cookie后，在服务器端进行Cookie验证，通过了，才可以。这也是Session认证机制的精髓。 6.Session的工作原理一图来了解工作原理 4.在Express中使用Session认证1.安装1npm i express-session 2.配置123456789//导入安装的session模块const session = require(&#x27;express-session&#x27;)const app = express()app.use(session(&#123; secret:&#x27;anything all can&#x27;, //secret属性值可以是任意字符串 resave:false, //固定写法 saveUninitialized: true //固定写法&#125;)) secret: secret属性是一个必需的选项，用于签名session cookie。这个字符串应该是一个复杂的、随机的、且对于外部不可预测的值，以保证session数据的安全性。它作为加密cookie的密钥。您设置的&#39;anything all can&#39;仅作为一个示例，实际部署时应使用更安全的随机字符串。 resave: 设置为false意味着只有当session数据发生改变时，才会保存到session store中。如果设置为true，即使session数据没有变化，每次请求也会尝试保存session。设置为false可以减少不必要的I&#x2F;O操作。 saveUninitialized: 当设置为true时，即使session数据没有被修改，也会在每个响应结束前保存未初始化的session。一个未初始化的session是指客户端新建立连接但尚未存储任何数据的session。这个选项通常在开发阶段开启，以确保新用户总是能获得一个session，但在生产环境中可能需要根据实际情况调整，因为它可能导致无用session的累积。 3.向session中存储数据123456789101112131415161718192021222324//导入安装的session模块const session = require(&#x27;express-session&#x27;)const app = express()app.use(session(&#123; secret:&#x27;anything all can&#x27;, //secret属性值可以是任意字符串 resave:false, //固定写法 saveUninitialized: true //固定写法&#125;))app.post(&#x27;/api/user&#x27;,function(req,res)&#123; //判断用户输入的信息是否正确 if(req.body.username !==&#x27;admin&#x27; || req.body.password! == &#x27;123456&#x27;)&#123; res.send(status: 1+&#x27;登录失败，用户名或密码不正确&#x27;) &#125; //如果成功登录后把信息存储到session中 req.session.user = req.body //存储用户登录状态 req.session.islogin = true res.send(status: 0 +&#x27;登录成功&#x27;)&#125;) 通过白框中的代码，将用户信息存入session中，req.session这个对象是在导入了express-session模块后才有的，.user是们自定义的一个属性。 4.从Session中取数据可以从req.session对象上获取之前存储的数据 123456789101112//获取用户账号接口app.get(&#x27;/api/getUserName&#x27;,(req,res)=&gt;&#123; //判断用户是否登录 if(!req.session.islogin)&#123; return res.send(&#x27;未登录&#x27;) &#125; red.send(&#123; status: 0, msg: &#x27;成功&#x27;, username: req.session.user.username &#125;)&#125;) 5.清空session调用**req.session.destory()**函数即可 情景模拟：当用户退出登录时，清空session 123456//退出接口app.post(&#x27;/api/logout&#x27;,(req,res)=&gt;&#123; //清空session req.session.destory() res.send(&#x27;退出成功&#x27;)&#125;) 5.JWT认证机制 JWT适用于跨域认证 JWT全称为JSON Web Token。 1.JWT工作原理 核心：用户信息通过Token字符串的形式，保存在客户端浏览器中，服务器通过还原Token字符串的形式来认证用户的身份。 而Session是把客户信息存储在了服务器端 2.JWT的组成部分 JWT通常有三部分组成，分别是Header（头部）、Payload（有效载荷）、Signature（签名） 三者之间通过.分割 字符串示例： 其中： Payload部分是用户信息，加密之后生成的 Header和Signature是安全性相关部分，保证Token的安全性 3.JWT的使用方式客户端收到服务器返回的 JWT 之后，通常会将它储存在 localStorage 或 sessionStorage 中。此后，客户端每次与服务器通信，都要带上这个JWT的字符串，从而进行身份认证。推荐的做法是把JWT 放在 HTTP请求头的 Authorization 字段中,格式如下: 1Authorization: Bearer &lt;token&gt; 6.在Express中使用JWT1.安装安装两个包，分别是：jsonwebtoken和express-jwt 1npm i jsonwebtoken express-jwt jsonwebtoken用于生成JWT字符串 express-jwt用于将JWT字符串解析还原 12345678910111213const express = require(&#x27;express&#x27;)const app = express()//导入express-jwtconst expressJwt = require(&#x27;express-jwt&#x27;)//导入jsonwebtokenconst jwt = require(&#x27;jsonwebtoken&#x27;)//开启在80端口上的服务器app.listen(80,()=&gt;&#123; console.log(&quot;开启了服务器&quot;);&#125;) 2.定义secret密钥为了保证JWT字符串的安全性，防止JWT字符串在网络传输过程中被别人破解，我们需要专门定义一个用于加密和解密的密钥： 当生成JWT字符串的时候，需要使用密钥对用户的信息进行加密，最终得到加密好的jt字符串 当把JWT字符串解析还原成JSON对象的时候，需要使用密钥进行解密 12//定义密钥const secretKey = &#x27;sadasdasdasda ^_^&#x27;//随便一个字符串，越是复杂越好 3.生成Token字符串在登录成功之后，调用 jwt.sign() 方法生成 JWT 字符串。并通过 token 属性发送给客户端 该方法接收三个参数： 参数1：用户的信息对象、 参数2：加密的秘钥 参数3：配置对象，可以配置当前 token 的有效期 下面是示例 1234567891011121314151617181920// 登录接口app.post(&#x27;/api/login&#x27;, function (req, res) &#123; // 将 req.body 请求体中的数据，转存为 userinfo 常量 const userinfo = req.body // 登录失败 if (userinfo.username !== &#x27;admin&#x27; || userinfo.password !== &#x27;000000&#x27;) &#123; return res.send(&#123; status: 400, message: &#x27;登录失败！&#x27;, &#125;) &#125;// 记住：千万不要把密码加密到 token 字符中 const tokenStr = jwt.sign(&#123; username: userinfo.username &#125;, secretKey, &#123; expiresIn: &#x27;30s&#x27; &#125;) res.send(&#123; status: 200, message: &#x27;登录成功！&#x27;, token: tokenStr, // 要发送给客户端的 token 字符串 &#125;)&#125;) 4.将JWT字符串还原为JSON对象12app.use(expressJWT(&#123; secret: secretKey &#125;).unless(&#123; path: [/^\\/api\\//] &#125;))//通过正则表达式去匹配以api开头的接口 通过.unless方法可以指定不需要权限的接口，在访问有权限的接口时，需要携带tonken进行鉴权认证。通过才能够访问，而token就是我们自主操作加密生成的。 5.使用req.user获取用户信息注意：只要配置成功了 express-jwt 这个中间件，就可以把解析出来的用户信息，挂载到 req.user 属性上 user属性上包含哪些信息，是我们在进行加密时决定的。 1const tokenStr = jwt.sign(&#123; username: userinfo.username &#125;, secretKey, &#123; expiresIn: &#x27;30s&#x27; &#125;) 在上面这条加密代码中，我们把用户的username进行加密，那么在访问时，就只能获取username不会获取其他信息。expiresIn: &#39;30s&#39;指该token有效期时30s 6.JWT解析失败捕获错误使用全局错误处理中间件，捕获解析 JWT 失败后产生的错误 123456789101112131415app.use((err,req,res,next)=&gt;&#123;// 这次错误是由 token 解析失败导致的 if(err.name ==&#x27;UnauthorizedError&#x27; )&#123; return res.send(&#123; status:401, msg:&#x27;无效的tonken&#x27; &#125;)else&#123; res.send(&#123; status:500, msg:&#x27;未知错误&#x27; &#125;) &#125; &#125;&#125;) 该案例完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// 导入 express 模块const express = require(&#x27;express&#x27;)// 创建 express 的服务器实例const app = express()// TODO_01：安装并导入 JWT 相关的两个包，分别是 jsonwebtoken 和 express-jwtconst jwt = require(&#x27;jsonwebtoken&#x27;)const expressJWT = require(&#x27;express-jwt&#x27;)// 允许跨域资源共享const cors = require(&#x27;cors&#x27;)app.use(cors())// 解析 post 表单数据的中间件const bodyParser = require(&#x27;body-parser&#x27;)app.use(bodyParser.urlencoded(&#123; extended: false &#125;))// TODO_02：定义 secret 密钥，建议将密钥命名为 secretKeyconst secretKey = &#x27;itheima No1 ^_^&#x27;// TODO_04：注册将 JWT 字符串解析还原成 JSON 对象的中间件// 注意：只要配置成功了 express-jwt 这个中间件，就可以把解析出来的用户信息，挂载到 req.user 属性上app.use(expressJWT(&#123; secret: secretKey &#125;).unless(&#123; path: [/^\\/api\\//] &#125;))// 登录接口app.post(&#x27;/api/login&#x27;, function (req, res) &#123; // 将 req.body 请求体中的数据，转存为 userinfo 常量 const userinfo = req.body // 登录失败 if (userinfo.username !== &#x27;admin&#x27; || userinfo.password !== &#x27;000000&#x27;) &#123; return res.send(&#123; status: 400, message: &#x27;登录失败！&#x27;, &#125;) &#125; // 登录成功 // TODO_03：在登录成功之后，调用 jwt.sign() 方法生成 JWT 字符串。并通过 token 属性发送给客户端 // 参数1：用户的信息对象 // 参数2：加密的秘钥 // 参数3：配置对象，可以配置当前 token 的有效期 // 记住：千万不要把密码加密到 token 字符中 const tokenStr = jwt.sign(&#123; username: userinfo.username &#125;, secretKey, &#123; expiresIn: &#x27;30s&#x27; &#125;) res.send(&#123; status: 200, message: &#x27;登录成功！&#x27;, token: tokenStr, // 要发送给客户端的 token 字符串 &#125;)&#125;)// 这是一个有权限的 API 接口app.get(&#x27;/admin/getinfo&#x27;, function (req, res) &#123; // TODO_05：使用 req.user 获取用户信息，并使用 data 属性将用户信息发送给客户端 console.log(req.user) res.send(&#123; status: 200, message: &#x27;获取用户信息成功！&#x27;, data: req.user, // 要发送给客户端的用户信息 &#125;)&#125;)// TODO_06：使用全局错误处理中间件，捕获解析 JWT 失败后产生的错误app.use((err, req, res, next) =&gt; &#123; // 这次错误是由 token 解析失败导致的 if (err.name === &#x27;UnauthorizedError&#x27;) &#123; return res.send(&#123; status: 401, message: &#x27;无效的token&#x27;, &#125;) &#125; res.send(&#123; status: 500, message: &#x27;未知的错误&#x27;, &#125;)&#125;)// 调用 app.listen 方法，指定端口号并启动web服务器app.listen(8888, function () &#123; console.log(&#x27;Express server running at http://127.0.0.1:8888&#x27;)&#125;)","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"jwt,身份认证,cookie","slug":"jwt-身份认证-cookie","permalink":"http://example.com/tags/jwt-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81-cookie/"}]},{"title":"web框架Express","slug":"web框架Express","date":"2024-07-12T06:53:27.000Z","updated":"2024-09-01T11:02:02.324Z","comments":true,"path":"2024/07/12/web框架Express/","permalink":"http://example.com/2024/07/12/web%E6%A1%86%E6%9E%B6Express/","excerpt":"","text":"1.认识express 简介：基于 Node.js 平台，快速、开放、极简的 Web 开发框架 类似于Node.js中的内置模块http模块，专门用来创建Web服务器。 安装首先假定你已经安装了 Node.js，接下来为你的应用创建一个目录，然后进入此目录并将其作为当前工作目录。 12$ mkdir myapp$ cd myapp 通过 npm init 命令为你的应用创建一个 package.json 文件。 欲了解 package.json 是如何起作用的，请参考 Specifics of npm’s package.json handling. 1$ npm init 此命令将要求你输入几个参数，例如此应用的名称和版本。 你可以直接按“回车”键接受大部分默认设置即可，下面这个除外： 1entry point: (index.js) 键入 app.js 或者你所希望的名称，这是当前应用的入口文件。如果你希望采用默认的 index.js 文件名，只需按“回车”键即可。 接下来在 myapp 目录下安装 Express 并将其保存到依赖列表中。如下： 1$ npm install express --save 如果只是临时安装 Express，不想将它添加到依赖列表中，可执行如下命令： 1$ npm install express --no-save 使用1234567891011121314//第一步：导入express模块const express = require(&#x27;express&#x27;)//第三步：创建一个app对象const app = express()const port = 3000//发送get请求，请求路径是&#x27;/&#x27;app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; //响应了&#x27;Hello World!&#x27; res.send(&#x27;Hello World!&#x27;)&#125;)//第二步：开启web服务器。app.listen(port, () =&gt; &#123; console.log(`Example app listening on port $&#123;port&#125;`)&#125;) 我们注意到，它的这个用法和node.js里面的http模块很相似，所以express相当于我们的http模块，但是express功能更强大。 获取请求路径中的参数使用req.query()方法，该方法的默认值是一个空对象，当客户端携带了query参数(?age&#x3D;20&amp;name&#x3D;zhangsan)时，可以获取到该参数 12345app.get(&#x27;/&#x27;,function(req,res)&#123; let queryParams = req.query() log(queryParams.age) //20 log(queryParams.name)//zhangsan&#125;) 获取请求路径中的动态参数语法：req.params() 通过该方法可以访问到请求路径中通过:匹配的动态参数 示例访问路径:localhost:8080&#x2F;user&#x2F;4 1234app.get(&#x27;/user/:id&#x27;,function(req,res)&#123; let Params = req.params() console.log(Params.id)//4&#125;) 注意：id时动态参数 匹配多个动态参数的写法：user/:id/:name/:xxx... 2.基本路由直接使用路由路由是指确定应用程序如何响应客户端对特定端点的请求，该端点是一个 URI（或路径）和特定的 HTTP 请求方法（GET、POST 等）。 每个路由可以有一个或多个处理程序函数，这些函数在路由匹配时执行。 路由定义采用以下结构： 1app.METHOD(PATH, HANDLER) 对参数的解释： app是express的实例(对象) METHOD是一个小写HTTP请求方法(post，get，put，delete) PATH是所请求的资源在服务器上的路径 HANDLER是路由匹配时执行的函数。 举个例子 在主页上响应’Hello World!’ 123app.get(&#x27;/&#x27;,function(req,res)&#123; res.send(&#x27;Hello World!&#x27;)&#125;) 响应 POST请求在根路径/ 123app.post(&#x27;/&#x27;,function(req,res)&#123; res.send(&#x27;这是一个POST请求&#x27;)&#125;) 响应一个PUT请求在路径/user 123app.put(&#x27;/user&#x27;,function(req,res)&#123; res.send(&#x27;这是一个在/user的put请求&#x27;)&#125;) 注意： 按照定义的先后顺序进行匹配 请求类型和请求URL同时匹配成功，才会调用对应的处理函数 模块化路由express不建议直接将路由挂载到app上，推荐把路由抽离为单独的模块 模块化路由步骤如下 创建路由模块对应的.js文件 调用express.Router()函数创建路由对象 向路由对象上挂载具体路由 使用module.exports共享路由 使用app.use()函数注册路由模块 123456789101112131415//引入express模块const express = require(&#x27;express&#x27;)//实例化对象const router = express.Router()//处理请求路径以及进行响应router.get(&#x27;/user/list&#x27;,function(req,res)&#123; res.send(&#x27;这是一个用户表请求&#x27;)&#125;)router.post(&#x27;/app/list&#x27;,function(req,res)&#123; res.send(&#x27;这是一个应用列表请求&#x27;)&#125;)//共享路由module.exports(router) 注册路由步骤： 导入路由模块 注册路由模块 这里我们用上面自定义的模块路由演示 12345//导入路由自定义模块const router = require(&#x27;./模块化路由.js&#x27;)//注册路由模块app.use(router)//app.use()函数的作用是用来注册全局中间件 为路由模块添加前缀类似于托管静态资源，为静态资源添加前缀，给路由模块添加前缀的如下 1234//导入路由自定义模块const router = require(&#x27;./模块化路由.js&#x27;)//注册路由模块app.use(&#x27;/api&#x27;,router) 当我们为路由模块添加了前缀时，在访问时，路径变成了/api/xxx 3.托管静态资源托管资源为了提供诸如图像、CSS 文件和 JavaScript 文件之类的静态文件，请使用 Express 中的 express.static 内置中间件函数。 此函数特征如下： 1express.static(root, [options]) 例如，通过如下代码就可以将 public 目录下的图片、CSS 文件、JavaScript 文件对外开放访问了： 1app.use(express.static(&#x27;public&#x27;)) 现在，你就可以访问 public 目录中的所有文件了： 12345http://localhost:3000/images/kitten.jpghttp://localhost:3000/css/style.csshttp://localhost:3000/js/app.jshttp://localhost:3000/images/bg.pnghttp://localhost:3000/hello.html Express 在静态目录查找文件，因此，存放静态文件的目录名不会出现在 URL 中。 托管多个静态资源如果要使用多个静态资源目录，请多次调用 express.static 中间件函数： 12app.use(express.static(&#x27;public&#x27;))app.use(express.static(&#x27;files&#x27;)) 访问静态资源文件时，express.static 中间件函数会根据目录的添加顺序查找所需的文件。 为托管的静态资源添加前缀语法： 1app.use(&#x27;/static&#x27;, express.static(&#x27;public&#x27;)) 现在，你就可以通过带有 /static 前缀地址来访问 public 目录中的文件了。 12345http://localhost:3000/static/images/kitten.jpghttp://localhost:3000/static/css/style.csshttp://localhost:3000/static/js/app.jshttp://localhost:3000/static/images/bg.pnghttp://localhost:3000/static/hello.html 4.nodemon工具nodemon会在我们的代码修改时，自动的重启服务器，极大地提高了开发效率 安装1npm i nodemon -g 使用12#安装nodemon后通过下面命令启动项目即可nodemon app.js 5.中间件简介Express 是一个路由和中间件 Web 框架，它本身具有最少的功能：Express 应用程序本质上是一系列中间件函数调用。 简单理解 中间件函数是可以访问请求对象 (req)、响应对象 (res) 以及应用程序请求-响应周期中的下一个中间件函数的函数。下一个中间件函数通常由名为next的变量表示。 中间件函数可以执行以下任务： 执行任何代码。 对请求和响应对象进行更改。 结束请求-响应周期。 调用堆栈中的下一个中间件函数。 如果当前中间件函数未结束请求-响应周期，则必须调用 next() 将控制权传递给下一个中间件函数。否则，请求将悬而未决。 您可以使用可选的挂载路径加载应用程序级和路由器级中间件。您还可以将一系列中间件函数一起加载，从而在挂载点创建中间件系统的子堆栈。 中间件的调用流程当一个请求达到Express服务器之后。可以连续调用多个中间件，从而对这个请求进行预处理 中间件的执行顺序和我们定义的顺序一样 中间件处理函数Express的中间件，本质上就是一个function处理函数，他的格式如下 在中间件函数中，必须包含next参数，但是在路由处理函数的参数中只有req和res next函数中间件中的流转通过next函数实现，用于多个中间件连续调用。非常重要 中间件函数例子以下是一个简单的“Hello World” Express 应用程序示例。名为 myLogger 的函数用于打印简单的日志消息。 准备web服务器12345678var express = require(&#x27;express&#x27;)var app = express()app.get(&#x27;/&#x27;, function (req, res) &#123; res.send(&#x27;Hello World!&#x27;)&#125;)app.listen(3000) 定义中间件函数 myLogger下面是一个名为“myLogger”的中间件函数的简单示例。当应用程序的请求通过该函数时，该函数只会打印“LOGGED”。中间件函数被分配给一个名为 myLogger 的变量。 12345var myLogger = function (req, res, next) &#123; console.log(&#x27;LOGGED&#x27;) //通过next函数把流转关系转交给下一个中间件或路由 next()&#125; 注意：请注意上面对 next() 的调用。调用此函数会调用应用中的下一个中间件函数。next() 函数不是 Node.js 或 Express API 的一部分，而是传递给中间件函数的第三个参数。next() 函数可以命名为任意名称，但按照惯例，它始终命名为“next”。为避免混淆，请始终使用此惯例。 要加载中间件函数，请调用 app.use()，并指定中间件函数。例如，以下代码在路由挂载到根路径 (&#x2F;) 之前加载 myLogger 中间件函数。 123456789101112131415var express = require(&#x27;express&#x27;)var app = express()var myLogger = function (req, res, next) &#123; console.log(&#x27;LOGGED&#x27;) next()&#125;//调用app.use()来加载中间件函数，并且是全局生效的app.use(myLogger)app.get(&#x27;/&#x27;, function (req, res) &#123; res.send(&#x27;Hello World!&#x27;)&#125;)app.listen(3000) 每次应用程序收到请求时，它都会将消息“LOGGED”打印到终端。 中间件加载的顺序很重要：首先加载的中间件函数也会首先执行。 如果 myLogger 在路由到根路径之后加载，则请求永远不会到达它，并且应用程序不会打印“LOGGED”，因为根路径的路由处理程序会终止请求-响应循环。 中间件函数 myLogger 只是打印一条消息，然后通过调用 next() 函数将请求传递给堆栈中的下一个中间件函数。 中间件的作用多个中间件之间，共享同一份req和res，基于特性，我们可以再上一个中间件中，统一为req或res对象添加自定义的属性或方法，供下一个中间件或路由进行使用。 局部中间件我们知道用app.use()方法挂载的是全局中间件，下面我们介绍一下局部中间件 1234567891011121314151617181920212223const express = require(&#x27;express&#x27;)//实例化对象const app = express()//定义中间件函数function mw1 (req,res,next)&#123; console.log(&#x27;这是局部生效的中间件&#x27;) next()&#125;//挂载路由app.get(&#x27;/user&#x27;,mw1,function(req,res)&#123; res.send(&#x27;User页面&#x27;)&#125;)//挂载路由app.post(&#x27;user/list&#x27;,function(req,res)&#123; res.send(&#x27;userList页面&#x27;)&#125;)//开启一个web服务器listen(80,()=&gt;&#123; &#125;) 当我们**没有使用app.use()**定义中间件时，那他就是一个局部中间件。使用局部中间件时，想用到那个路由，就在请求方法列表中加入该中间件的名称，比如上面，中间件只对/user路由生效，而下面的不会生效。 当我们使用多个局部中间件时，只需要把多个局部中间件用,隔开即可。或者用数组的形式也可以。 中间件的注意事项 一定要在路由之前注册中间件 客户端发送来的请求，可以调用多个中间件进行处理 执行完中间件的业务代码之后，不要忘记调用next()函数 多个中间件之间，共享req(请求对象)和res(响应对象) 6.中间件的分类Express 应用程序可以使用以下类型的中间件： 应用程序级中间件 路由器级中间件 错误处理中间件 内置中间件 第三方中间件 应用程序级中间件使用 app.use() 和 app.METHOD() 函数将应用程序级中间件绑定到 app 对象的实例，其中 METHOD 是中间件函数处理的请求的 HTTP 方法（例如 GET、PUT 或 POST），以小写形式表示。 此示例显示了一个没有挂载路径的中间件函数。每次应用程序收到请求时都会执行该函数。 1234567var express = require(&#x27;express&#x27;)var app = express()app.use(function (req, res, next) &#123; console.log(&#x27;Time:&#x27;, Date.now()) next()&#125;) 路由器级中间件路由器级中间件的工作方式与应用程序级中间件相同，只是它绑定到 express.Router() 的实例。 1234567891011121314var express = require(&#x27;express&#x27;)var app = express()//实例化路由对象var router = express.Router()// 没有挂载路径的中间件函数。每次向路由器发出请求时都会执行此代码router.use(function (req, res, next) &#123; console.log(&#x27;Time:&#x27;, Date.now()) next()&#125;)//挂载到/user/:id 路径的处理程序，用于呈现特殊页面router.get(&#x27;/user/:id&#x27;, function (req, res, next) &#123; console.log(req.params.id) res.render(&#x27;special&#x27;)&#125;) 错误处理中间件错误处理中间件始终需要四个参数。您必须提供四个参数来将其标识为错误处理中间件函数。即使您不需要使用下一个对象，也必须指定它以维护签名。否则，下一个对象将被解释为常规中间件，并且无法处理错误。 定义错误处理中间件函数的方式与其他中间件函数相同，只是使用四个参数而不是三个，具体来说是使用 (err, req, res, next)： 1234app.use(function (err, req, res, next) &#123; console.error(err.stack) res.status(500).send(&#x27;Something broke!&#x27;)&#125;) 内置中间件Express 具有以下内置中间件功能： express.static 提供静态资产，例如 HTML 文件、图像等。express.json 使用 JSON 负载解析传入请求。注意：适用于 Express 4.16.0+ 12//使用express.json中间件,将数据挂载req.body属性上app.use(express.json()) express.urlencoded 使用 URL 编码负载解析传入请求（application&#x2F;x-www-form-urlencoded格式数据）。注意：适用于 Express 4.16.0+ 12//使用express.urlencoded中间件,将数据挂载req.body属性上app.use(express.urlencoded(&#123;extended:false&#125;)) 第三方中间件使用第三方中间件为 Express 应用添加功能。 安装所需功能的 Node.js 模块，然后在应用程序级别或路由器级别将其加载到您的应用中。 以下示例说明了如何安装和加载 cookie 解析中间件函数 cookie-parser。 1$ npm install cookie-parser 1234567var express = require(&#x27;express&#x27;)var app = express()//通过require方式来导入var cookieParser = require(&#x27;cookie-parser&#x27;)// 挂载到app上app.use(cookieParser()) 7.自定义中间件1.实现步骤 2.监听req的data事件 12345678app.use((req,res,next)=&gt;&#123; //定义一个str字符，存储客户端发送数据 let str =&#x27;&#x27; //监听req的data事件 req.on(&#x27;data&#x27;,(chunk)=&gt;&#123; str += chunk &#125;)&#125;) 3.监听req的end事件1234567891011121314151617app.use((req,res,next)=&gt;&#123; //定义一个str字符，存储客户端发送数据 let str =&#x27;&#x27; //监听req的data事件 req.on(&#x27;data&#x27;,(chunk)=&gt;&#123; str += chunk &#125;) //监听req的end事件 req.on(&#x27;end&#x27;,function()&#123; //该str存储的就是完整的客户端数据 console.log(str) &#125;)&#125;)app.post(&#x27;/user&#x27;,(req,res)=&gt;&#123; res.send(&#x27;ok!&#x27;)&#125;) 4.使用querystring模块解析请求数据12345678910111213141516171819202122const express = require(&#x27;express&#x27;)const app = express()//搭配node.js中的querystring模块const qs = require(&#x27;querystring&#x27;)app.use((req,res,next)=&gt;&#123; //定义一个str字符，存储客户端发送数据 let str =&#x27;&#x27; //监听req的data事件 req.on(&#x27;data&#x27;,(chunk)=&gt;&#123; str += chunk &#125;) //监听req的end事件 req.on(&#x27;end&#x27;,function()&#123; //该str存储的就是完整的客户端数据 //通过qs模块解析数据 console.log(qs.parse(str) &#125;)&#125;)app.post(&#x27;/user&#x27;,(req,res)=&gt;&#123; res.send(req.body)&#125;) 5.将解析出来的数据对象挂载到req的body属性上12345678req.on(&#x27;end&#x27;,function()&#123; //该str存储的就是完整的客户端数据 //通过qs模块解析数据 let bodyObj =qs.parse(str) req.body = bodyObj next() &#125;)&#125;) 6.将自定义中间件封装为模块新建一个custom-body-parser.js文件 写入以下内容 12345678910111213141516171819202122//搭配node.js中的querystring模块const qs = require(&#x27;querystring&#x27;)const bodyParser = (req,res,next)=&gt;&#123; //定义一个str字符，存储客户端发送数据 let str =&#x27;&#x27; //监听req的data事件 req.on(&#x27;data&#x27;,(chunk)=&gt;&#123; str += chunk &#125;) //监听req的end事件 req.on(&#x27;end&#x27;,function()&#123; //该str存储的就是完整的客户端数据 //通过qs模块解析数据 let bodyObj =qs.parse(str) req.body = bodyObj next(); &#125;)&#125;//通过module.exports暴露该模块module.exports = bodyParser 1234//在需要用解析功能的js文件中导入js文件即可const bp = require(&#x27;./custom-body-parser.js&#x27;)//注册自定义的中间件模块app.use(bp) 完整代码12345678910111213141516171819202122232425const express = require(&#x27;express&#x27;)const app = express()//搭配node.js中的querystring模块const qs = require(&#x27;querystring&#x27;)app.use((req,res,next)=&gt;&#123; //定义一个str字符，存储客户端发送数据 let str =&#x27;&#x27; //监听req的data事件 req.on(&#x27;data&#x27;,(chunk)=&gt;&#123; str += chunk &#125;) //监听req的end事件 req.on(&#x27;end&#x27;,function()&#123; //该str存储的就是完整的客户端数据 //通过qs模块解析数据 let bodyObj =qs.parse(str) req.body = bodyObj next(); &#125;)&#125;)app.post(&#x27;/user&#x27;,(req,res)=&gt;&#123; res.send(req.body)&#125;) 8.基于express写接口写一个自定义路由模块123456const express = require(&#x27;express&#x27;)//实例化路由对象const apiRouter = express.Router()//暴露module.exports = apiRouter 导入模块12345678910111213//导入路由模块const Router = require(&#x27;./apiRouter.js&#x27;)app.get(&#x27;/get&#x27;(req,res)=&gt;&#123; //通过req.query()方法拿到客户端携带的查询参数 const query = req.query() res.send(&#123; status:0 // 0表示成功 1表示失败 msg:&#x27;Get请求成功&#x27; data:query &#125;)&#125;)//注册全局app.use(&#x27;/api&#x27;,Router) 上面这个就是get接口。 下面来举例post接口 12345678910111213141516//解析post请求的数据,详见目录内置中间件app.use(express.urlencoded(&#123;extends:false&#125;))//导入路由模块const Router = require(&#x27;./apiRouter.js&#x27;)app.get(&#x27;/post&#x27;(req,res)=&gt;&#123; //通过req.query()方法拿到客户端携带的查询参数 const body = req.body() res.send(&#123; status:0 // 0表示成功 1表示失败 msg:&#x27;Get请求成功&#x27; data:body &#125;)&#125;)//注册全局app.use(&#x27;/api&#x27;,Router)","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"前端,web,框架","slug":"前端-web-框架","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF-web-%E6%A1%86%E6%9E%B6/"}]},{"title":"npm,yarn与包","slug":"npm与包","date":"2024-07-11T06:54:54.000Z","updated":"2024-07-15T11:46:34.821Z","comments":true,"path":"2024/07/11/npm与包/","permalink":"http://example.com/2024/07/11/npm%E4%B8%8E%E5%8C%85/","excerpt":"","text":"1.包的概念在Node.js中，导入的第三方模块被称为包 利用包能够提高开发效率，并且包时基于内置模块封装出来的‘ 搜索包：https://www.npmjs.com/ 通过服务器地址：https://registry.npmjs.org/来下载包 2.npm以安装格式化时间的包来介绍npm使用方式 npm包管理工具在项目中安装格式化时间的包moment 使用require()导入格式化时间的包 1.安装包基础语法： 1234# 完整写法npm install + 包名# 简写npm i + 包名 2.安装包后多的文件 node_modules：node modules 文件夹用来存放所有已安装到项目中的包。require( 导入第三方包时，就是从这个目录中查找并加载包. package-lock.json：package-lock.ison 配置文件用来记录 node modules 日录下的每一个包的下载信息，例如包的名字、版本号、下载地址等 3.安装指定版本的包默认执行：npm i +包名 会安装这个包的最新版本 指定版本安装包的基础语法:在包名后面加@版本号即可 1npm i moment@2.22.2 4.包的版本号解释 4.npm的包管理配置文件npm规定在项目根目录必须提供一个叫package.json的包管理配置文件 。用来记录与项目有关的一些配置信息 项目名称、版本号、描述等 项目中用到了那些包 那些包只在开发期间用到 那些包在开发和部署时都需要用 4.1记录安装的包在项目根目录中，创建一个叫做 package.json 的配置文件，即用来记录项目中安装了哪些包。从而方便剔除node_modules 目录之后，在团队成员之间共享项目的源代码。 今后在项目开发中，一定要把 node_modules 文件夹，添加到.gitignore 忽略文件中。 创建 package.json命令 123# 创建 package.jsonnpm init -y#注意，项目路径要求英文，通过npm i 安装包时，包的信息会被自动记录到 package.json里 4.2devDependencies节点1234# 安装指定的包，并记录到devDependedencies中npm install webpack -D#或者完整写法npm install webpack --save-dev 注意：如果某些包只在项目开发阶段会用到，在项目上线之后不会用到，则建议把这些包记录到 devDependencies 节点中。与之对应的，如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到 dependencies 节点中。 4.3改变npm下载源，解决下载速度慢的问题4.3.1使用淘宝npm镜像服务器 # 查看当前的下包镜像源 npm config get registry #将下包镜像源换为淘宝镜像 npm config set registry=https://registry.npmtaobao.org/ #检测镜像源下载是否成功 npm config get registry 1234567891011121314##### 4.3.2工具nrm* 为了更方便的切换下包的镜像源，我们可以安装 nrm 这个工具，利用 nrm 提供的终端命令，可以快速查看和切换下包的镜像源安装步骤：```bash#全局安装nrmnpm install nrm -g#查看所有可用镜像源nrm ls#切换淘宝镜像源nrm use taobao 5.卸载包命令 1npm uninstall + 包名 案例—格式化时间123456789101112131415161718192021222324252627282930313233343536// 1. 定义格式化时间的方法function dateFormat(dtStr) &#123; const dt = new Date(dtStr) //获取年 const y = dt.getFullYear() //getMonth()获取的是0-11月，所以加1 const m = padZero(dt.getMonth() + 1) //获取日 const d = padZero(dt.getDate()) //获取小时 const hh = padZero(dt.getHours()) //获取分钟数 const mm = padZero(dt.getMinutes()) //获取秒数 const ss = padZero(dt.getSeconds()) //通过模板字符串拼接成一个完整的时间 return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`&#125;// 定义补零的函数function padZero(n) &#123; return n &gt; 9 ? n : &#x27;0&#x27; + n&#125;//把模块暴露出去供其他模块导入使用module.exports = &#123; dateFormat&#125; 3.yarn1.简介Yarn 对你的代码来说是一个软件包管理器， 你可以通过它使用全世界开发者的代码，或者分享自己的代码给全世界的开发者。Yarn 做这些事情快捷、安全、可靠，所以你不用担心什么。 代码通过 软件包（package） 的方式被共享。一个软件包里包含了所有需要共享的代码，以及一个描述软件包信息的文件 package.json （叫做 清单）。 2.安装管理 Yarn 的首选方式是通过 Corepack，这是从 16.10 开始随所有 Node.js 版本附带的新二进制文件。它充当您和 Yarn 之间的中介，并允许您在多个项目中使用不同的包管理器版本，而无需再签入 Yarn 二进制文件。 2.1Node.js 版本大于等于16.10所有 Node.js 安装都默认包含 Corepack，但目前可选择加入。要启用它，请运行以下命令： 1corepack enable 2.2Node.js 版本小于16.10Corepack 不包含在 16.10 之前的 Node.js 版本中；为了解决这个问题，请运行： 1npm i -g corepack 3.更新全局 Yarn 版本3.1Node.js ^16.17 or &gt;&#x3D;18.6意味着你可以使用Node.js 16.17及之后的小版本更新，或者直接使用18.6.0及之后的任何版本。 1corepack prepare yarn@stable --activate 3.2Node.js &lt;16.17 or &lt;18.6查看最新的 Yarn 版本，记下版本号，然后运行： 1corepack prepare yarn@&lt;version&gt; --activate 4.初始化项目只需运行以下命令。它将在当前目录中生成一些文件；将它们全部添加到您的下一个提交中，您就完成了！ 1yarn init -2 5.更新到最新版本如果以后要将 Yarn 更新到最新版本，请运行： 1yarn set version stable 6.使用yarn与npm类似, 可以试试, 新建一个空白文件夹, 执行以下命令尝试一下 1234567891011121314151617181920212223# 1. 初始化, 得到package.json文件(终端路径所在文件夹下)yarn init# 2. 添加依赖(下包)# 命令: yarn add [package]# 命令: yarn add [package]@[version]yarn add jqueryyarn add jquery@3.5.1# 3. 移除包# 命令: yarn remove [package]yarn remove jquery # 4. 安装项目全部依赖(一般拿到别人的项目时, 缺少node_modules) yarn# 会根据当前项目package.json记录的包名和版本, 全部下载到当前工程中# 5. 全局# 安装: yarn global add [package]# 卸载: yarn global remove [package]# 注意: global一定在add左边yarn global add @vue/cli# 如何使用, 为明天学习vue做铺垫 4.包的分类1.项目包 2.全局包在执行npm install命令时，如果提供了-g参数，则会把包安装为全局包 1234#安装全局包npm install 包名 -g#卸载全局包npm uninstall 包名 -g 不清楚是否安装为全局包，建议去npm官网查看。 5.模块加载机制1.优先从缓存中加载模块在第一次加载后会被缓存。这也意味着多次调用 require() 不会导致模块的代码被执行多次。注意:不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率 2.内置模块的加载机制内置模块是由 Node.js 官方提供的模块，内置模块的加载优先级最高。例如，require(‘fs’)始终返回内置的 fs 模块，即使在 node_modules 目录下有名字相同的包也叫做 fs。 3.自定义模块的加载机制使用 require() 加载自定义模块时，必须指定以./或../开头的路径标识符。在加载自定义模块时，如果没有指定**.&#x2F;或..&#x2F;**这样的路径标识符，则 node 会把它当作内置模块或第三方模块进行加载。 4.目录作为模块的加载机制","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"npm,yarn","slug":"npm-yarn","permalink":"http://example.com/tags/npm-yarn/"}]},{"title":"Node.js学习","slug":"Node-js学习","date":"2024-07-09T09:25:29.000Z","updated":"2024-09-02T11:33:03.460Z","comments":true,"path":"2024/07/09/Node-js学习/","permalink":"http://example.com/2024/07/09/Node-js%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"1.Node与终端在终端用node命令去运行文件，比如有一个名为1.js的文件 那么打开终端 1node 1.js 2.Node模块1.fs文件系统模块使用方法： fs.readFile()方法，用来读取指定文件中的内容 fs.writeFile()方法，用来向指定文件中写入内容 1.1读取指定文件在使用之前，我们需导入 1const fs = require(&#x27;fs&#x27;) 12345678910111213141516// 1. 导入 fs 模块，来操作文件const fs = require(&#x27;fs&#x27;)// 2. 调用 fs.readFile() 方法读取文件// 参数1：读取文件的存放路径// 参数2：读取文件时候采用的编码格式，一般默认指定 utf8// 参数3：回调函数，拿到读取失败和成功的结果 err dataStrfs.readFile(&#x27;./files/1.txt&#x27;, &#x27;utf8&#x27;, function(err, dataStr) &#123; // 2.1 打印失败的结果 // 如果读取成功，则 err 的值为 null // 如果读取失败，则 err 的值为 错误对象，dataStr 的值为 undefined console.log(err) console.log(&#x27;-------&#x27;) // 2.2 打印成功的结果 console.log(dataStr)&#125;) 1.1.1.判断文件是否读取成功12345678910// 1. 导入 fs 模块，来操作文件const fs = require(&#x27;fs&#x27;)fs.readFile(&#x27;./files/1.txt&#x27;, &#x27;utf8&#x27;, function(err, dataStr) &#123; //利用能否把err转为true来判断if(err)&#123; console.log(&quot;读取文件失败&quot;+err.message);&#125;else&#123; console.log(&quot;读取文件成功,文件内容是:&quot;+dataStr);&#125;&#125;) 1.2向指定文件写入内容基础语法: 1fs.writeFile(file,data,[options],callback) file是写入文件的路径（必选） data是写入文件的内容（必选） [options]是一个可选内容，表示写入文件的格式，默认为utf-8（可选） callback是写入文件成功后的回调函数（必选） 123456789101112131415161718// 1. 导入 fs 文件系统模块const fs = require(&#x27;fs&#x27;)// 2. 调用 fs.writeFile() 方法，写入文件的内容// 参数1：表示文件的存放路径// 参数2：表示要写入的内容// 参数3：回调函数fs.writeFile(&#x27;./files/3.txt&#x27;, &#x27;ok123&#x27;, function(err) &#123; // 2.1 如果文件写入成功，则 err 的值等于 null // 2.2 如果文件写入失败，则 err 的值等于一个 错误对象 // console.log(err) if (err) &#123; return console.log(&#x27;文件写入失败！&#x27; + err.message) &#125; console.log(&#x27;文件写入成功！&#x27;)&#125;) 1.2.1.判断文件是否写入成功123456789// 1. 导入 fs 模块，来操作文件const fs = require(&#x27;fs&#x27;)fs.wirteFile(&#x27;./files/2.txt&#x27;, &#x27;ok111&#x27;, function(err) &#123; //利用能否把err转为true来判断if(err)&#123; console.log(&quot;写入文件失败&quot;+err.message);&#125;else&#123; console.log(&quot;写入文件成功！&quot;);&#125; 案例：考试成绩整理 1234567891011121314151617181920212223242526272829303132//引入fs模块const &#123; log &#125; = require(&#x27;console&#x27;);const fs = require(&#x27;fs&#x27;)let oldArr = []let newArr = []//第一步获取数据并把数据整合成理想格式 K : Vfs.readFile(&#x27;./成绩.txt&#x27;,&#x27;utf-8&#x27;,function(err,fileData)&#123;if(err)&#123; console.log(&quot;文件读取失败，原因是：&quot;+err.message);&#125;else&#123; console.log(fileData); //转换成字符串数组 oldArr = fileData.split(&#x27; &#x27;) //用foreach不用for因为for会把数据变成一列不好处理 oldArr.forEach(element =&gt; &#123; newArr.push(element.replace(&#x27;=&#x27;,&#x27;：&#x27;)) &#125;); //使用\\r\\n进行拼接 let newStr = newArr.join(&#x27;\\r\\n&#x27;) console.log(newStr); //第二步写入数据 fs.writeFile(&#x27;./处理后的成绩.txt&#x27;,`$&#123;newStr&#125;`,function(err)&#123; if(err)&#123; console.log(&#x27;写入失败&#x27;+err.message); &#125;else&#123; console.log(&#x27;文件写入成功&#x27;); &#125; &#125;) &#125;&#125;) 注意：\\r\\n 是回车（Carriage Return, \\r）和换行（Line Feed, \\n）的组合，常用于表示一行的结束并开始新的一行，尤其在Windows操作系统中的文本文件格式里广泛使用 1.3fs路径动态拼接的问题 出现路径拼接错误的问题，是因为提供了 .&#x2F; 或 ..&#x2F; 开头的相对路径 如果要解决这个问题，可以直接提供一个完整的文件存放路径就行 但是往往提供的绝对路径它移植性很差，并且不利于维护，那么接下来学习一种新的方式 使用node提供的成员：__dirname __dirname 表示当前文件所处的目录 示例代码： 123456fs.readFile(__dirname + &#x27;/files/1.txt&#x27;, &#x27;utf8&#x27;, function(err, dataStr) &#123; if (err) &#123; return console.log(&#x27;读取文件失败！&#x27; + err.message) &#125; console.log(&#x27;读取文件成功！&#x27; + dataStr)&#125;) 2.path路径模块概念：是node.js官方提供，用来处理路径的模块，提供了一系列的方法和属性，用来满足用户对路径的处理需求 使用前需导入path路径模块 1const path = require(&#x27;path&#x27;) 2.1路径拼接 path.join([…paths]) …path：String类型的路径片段序列 返回值：String类型 1234const path = require(&#x27;path&#x27;)// 注意：‘../’会抵消前面的路径let pathStr = path.join(&#x27;a&#x27;,&#x27;b/c&#x27;,&#x27;../&#x27;,&#x27;/d&#x27;,&#x27;e&#x27;)console.log(pathStr); 2.2获取路径中的文件名基础语法 1path.basename(path[, ext]) 参数： path：必选参数，表示一个路径的字符串 ext 可选参数，文件拓展名 返回：String类型，返回来的是路径中最后一部分 示例代码： 1234567891011const path = require(&#x27;path&#x27;)// 定义文件的存放路径const fpath = &#x27;/a/b/c/index.html&#x27;// const fullName = path.basename(fpath)// console.log(fullName) //返回index.htmlconst nameWithoutExt = path.basename(fpath, &#x27;.html&#x27;)console.log(nameWithoutExt) //返回index 2.3获取路径中的扩展名基础语法 1path.extname(path) 参数： path：传入路径 返回：String类型返回。 示例代码： 12345678const path = require(&#x27;path&#x27;)// 这是文件的存放路径const fpath = &#x27;/a/b/c/index.html&#x27;const fext = path.extname(fpath)console.log(fext) //返回.html 案例—时钟案例案例难点：匹配script标签和style标签的正则表达式不容易写出 案例步骤： 1.创建写入CSS文件的js文件 123456789101112131415161718192021222324//导入文件处理模块const fs = require(&#x27;fs&#x27;)//导入路径处理模块const path = require(&#x27;path&#x27;)//读取index文件fs.readFile(path.join(__dirname,&#x27;./index.html&#x27;),&#x27;utf-8&#x27;,function(err,dataStr)&#123;if(err)&#123; console.log(&#x27;错误信息是&#x27;+ err.message);&#125;else&#123; // console.log(dataStr); let newCSS = dataStr.match(/&lt;style&gt;[\\s\\S]*&lt;\\/style&gt;/) //拿着匹配的结果，写入到css文件中 fs.writeFile(path.join(__dirname,&#x27;./css/new.css&#x27;),`$&#123;newCSS&#125;`,function(err)&#123; if(err)&#123; console.log(&quot;文件写入失败，原因是:&quot;+err.message); &#125;else&#123; console.log(&quot;文件写入成功&quot;); &#125; &#125;)&#125;&#125;) 2.创建写入JS文件的JS文件 123456789101112131415161718192021222324//导入文件处理模块const fs = require(&#x27;fs&#x27;)//导入路径处理模块const path = require(&#x27;path&#x27;)//读取index文件fs.readFile(path.join(__dirname,&#x27;./index.html&#x27;),&#x27;utf-8&#x27;,function(err,dataStr)&#123;if(err)&#123; console.log(&#x27;错误信息是&#x27;+ err.message);&#125;else&#123; // console.log(dataStr); let newJS = dataStr.match(/&lt;script&gt;[\\s\\S]*&lt;\\/script&gt;/) //拿着匹配的结果，写入到css文件中 fs.writeFile(path.join(__dirname,&#x27;./js/new.js&#x27;),`$&#123;newJS&#125;`,function(err)&#123; if(err)&#123; console.log(&quot;文件写入失败，原因是:&quot;+err.message); &#125;else&#123; console.log(&quot;文件写入成功&quot;); &#125; &#125;)&#125;&#125;) 3.创建写入HTML文件的js 1234567891011121314151617181920212223242526//导入文件处理模块const fs = require(&#x27;fs&#x27;)//导入路径处理模块const path = require(&#x27;path&#x27;)let regpStyle = /&lt;style&gt;[\\s\\S]*&lt;\\/style&gt;/let regpJS=/&lt;script&gt;[\\s\\S]*&lt;\\/script&gt;///读取index文件fs.readFile(path.join(__dirname,&#x27;./index.html&#x27;),&#x27;utf-8&#x27;,function(err,dataStr)&#123;if(err)&#123; console.log(&#x27;错误信息是&#x27;+ err.message);&#125;else&#123; // console.log(dataStr); let newHTML = dataStr.replace(regpStyle,&#x27;&lt;link rel=&quot;stylesheet&quot; href=&quot;../css/new.css&quot;/&gt;&#x27;) .replace(regpJS,&#x27;&lt;script src=&quot;../js/new.js&quot;&gt;&lt;/script&gt;&#x27;) //拿着匹配的结果，写入到css文件中 fs.writeFile(path.join(__dirname,&#x27;./新HTML文件/index.html&#x27;),`$&#123;newHTML&#125;`,function(err)&#123; if(err)&#123; console.log(&quot;文件写入失败，原因是:&quot;+err.message); &#125;else&#123; console.log(&quot;文件写入成功&quot;); &#125; &#125;)&#125;&#125;) 注意：在新写入的HTML文件中，需要进行正则匹配然后替换，已外部文件的形式引入CSS和JS文件，注意路径 3.Node—Http模块1.什么是Http模块 使用方法： 先导入 1const http = require(&#x27;http&#x27;) 下面我们进一步理解一下Http模块的作用 2.服务器相关概念——ip地址 3.服务器相关概念——域名和域名服务器域名是一套字符型的地址方案 ip地址和域名是一一对应的关系，这份对应该系存放在一种名为域名服务器(DNS)的电脑中，使用者只需要通过好记的域名访问对应的服务器即可，对应的转换工作由域名服务器实现。因此，域名服务器就是提供IP和域名之间转换服务的服务器 这里说一下：我们的localhost对应的ip是127.0.0.1 4.服务器相关概念——端口号就好比门牌号一样。在电脑中每一个web服务对应唯一端口号。请求通过端口号可以准确的交给对应的web服务进行处理。 实际应用中，80端口号可以被省略 4.创建web服务器步骤如下导包，创建web服务实例，为服务器绑定request事件，启动服务器 123456789101112//导入http模块const http = require(&#x27;http&#x27;)//创建服务器let webServer = http.createServer()//绑定访问事件webServer.on(&#x27;request&#x27;,function(req,res)&#123; console.log(&quot;有人访问了我的服务器&quot;);&#125;)//开启服务webServer.listen(8081,function()&#123; console.log(&quot;服务开启成功，地址是http://127.0.0.1:8081&quot;);&#125;) 4.1req请求对象这是客户端相关的数据和属性 这里我们介绍req.url和req.method，分别对应的是请求的路径，和请求的方法 123456789101112131415const http = require(&#x27;http&#x27;)const server = http.createServer()// req 是请求对象，包含了与客户端相关的数据和属性server.on(&#x27;request&#x27;, (req, res) =&gt; &#123; // req.url 是客户端请求的 URL 地址 const url = req.url // req.method 是客户端请求的 method 类型 const method = req.method const str = `Your request url is $&#123;url&#125;, and request method is $&#123;method&#125;` console.log(str)&#125;)server.listen(80, () =&gt; &#123; console.log(&#x27;server running at http://127.0.0.1&#x27;)&#125;) 4.2res响应对象在request时间处理函数中，想访问与服务器相关的数据和属性 介绍res.end()方法：响应一些内容，并结束这次请求。 12345678910111213141516const http = require(&#x27;http&#x27;)const server = http.createServer()// req 是请求对象，包含了与客户端相关的数据和属性server.on(&#x27;request&#x27;, (req, res) =&gt; &#123; // req.url 是客户端请求的 URL 地址 const url = req.url // req.method 是客户端请求的 method 类型 const method = req.method const str = `Your request url is $&#123;url&#125;, and request method is $&#123;method&#125;` console.log(str) // 调用 res.end() 方法，向客户端响应一些内容 res.end(str)&#125;)server.listen(80, () =&gt; &#123; console.log(&#x27;server running at http://127.0.0.1&#x27;)&#125;) 4.3解决中文乱码问题只需调用res.setHeand()方法即可。 在这个方法中 123456789101112131415server.on(&#x27;request&#x27;, (req, res) =&gt; &#123; // 定义一个字符串，包含中文的内容 const str = `您请求的 URL 地址是 $&#123;req.url&#125;，请求的 method 类型为 $&#123;req.method&#125;` // 调用 res.setHeader() 方法，设置 Content-Type 响应头，解决中文乱码的问题 res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;) // res.end() 将内容响应给客户端 res.end(str)&#125;) 5.根据不同url响应不同的内容创建基本web服务器，获取请求url地址，设置默认请求内容，采用分支结构，对用户的不同访问url做出不同的结果，最后调用res.end()响应内容 1234567891011121314151617181920212223const http = require(&#x27;http&#x27;)const webServer = http.createServer()webServer.on(&#x27;request&#x27;,function(req,res)&#123; const reqUrl = req.url //定义一个默认的404页面 let content = &#x27;&lt;h1&gt;抱歉，您访问的页面不存在&lt;/h1&gt;&#x27; if(reqUrl === &#x27;/&#x27; || reqUrl === &#x27;/index.html&#x27;)&#123; content = &#x27;&lt;h1&gt;这是首页&lt;/h1&gt;&#x27; &#125;else if(reqUrl===&#x27;/about.html&#x27;)&#123; content= &#x27;&lt;h1&gt;这是关于页面&lt;/h1&gt;&#x27; &#125; //设置响应头，防止中文乱码 res.setHeader(&#x27;Content-Type&#x27;,&#x27;text/html; charset=utf8&#x27;) res.end(content)&#125;) 案例——对时钟案例进行web服务器化思路： 把我们本机当做一台服务器 先定位文件资源在服务器路径 随后利用node的文件处理模块去去读取文件资源 然后渲染在页面上即可 1.把本机当做一台服务器 123456789//导入响应http模块const http = require(&#x27;http&#x27;)const fs = require(&#x27;fs&#x27;)const path = require(&#x27;path&#x27;)//实例化一个web服务器const webServer = http.createServer()webServer.listen(90,function()&#123; console.log(&#x27;服务器在90端口上开启了&#x27;);&#125;) 2.定位文件资源在服务器的路径，读取文件并渲染 123456789101112131415161718webServer.on(&#x27;request&#x27;,function(req,res)&#123; reqURL = req.url; //定位文件在本地服务器的路径 filePath = path.join(__dirname,&#x27;./clock/index.html&#x27;)//注意：__dirname是指当前(js)文件所在的路径 //读取文件 fs.readFile(filePath,&#x27;utf-8&#x27;,function(err,dataStr)&#123; if(err)&#123; return &#x27;404页面找不到&#x27; &#125;else&#123; //设置响应头，防止中文乱码 res.setHeader(&#x27;Content-Type&#x27;,&#x27;text/html; charset=utf8&#x27;) res.end(dataStr) &#125; &#125;)&#125;) 随后启动终端输出： 打开页面，访问localhost:90,页面渲染如下: 3.Node模块化1.模块化的基本概念1.1什么是模块化？遇到一个复杂问题时，自顶向下逐层吧系统划分成若干模块的过程。模块是可组合、分解更换的单元 把代码进行模块化拆分的好处： 提高了代码的复用性 提高了代码的可维护性 可以实现按需加载 1.2模块化规范就是一种规则，对代码进行模块化拆分与组合时，需要遵守的规则 2.Node.js中的模块化2.1Node.js中模块的分类 2.2加载模块基础语法 123456789//利用require方法//加载内置模块const fs = require(&#x27;fs&#x27;)//加载自定义模块const custom = (&#x27;./custom.js&#x27;)//加载外置模块（该模块需下载后再使用）const moment = require(&#x27;moment&#x27;) require在加载模块时，会执行被加载模块中的代码。 2.3模块的作用域只能在导入的模块内部使用，但是当你通过导入的方式加入某模块时，被导入模块内定义的变量无法再当前导入模块内使用。 比如你在c1模块内导入c2模块，c2模块中的变量在c1中是无法访问的，但是c2可以访问自身的变量。 2.4向外共享模块作用域中的成员在每个.js自定义模块中都有一个module对象，在这里面存储了和当前模块有关的信息。 利用里面的export属性来进行向外共享即可，下面介绍用法 基础语法： 1234module.exports=&#123; 属性名：属性值， ....：...&#125; 当我向M2中导入自定义(这里用M1解释)M1模块时，M2模块中得到的成员就是M1中module.exports所指向的对象。 打印查看 2.4.1共享成员的注意点 2.4.2exports对象Node提供了一种简化的module.exports对象，exports对象。默认情况下，exports和module.exports指向同一个对象。 2.4.3exports和module.exports的使用误区 require()模块时，得到的永远是module.exports所指向的对象 2.5Node.js中的模块化规范CommonJS 规范是一种JavaScript模块化编程的标准，最初为服务器端JavaScript设计，被Node.js采纳并广泛应用。它的核心特点包括： 模块定义：在CommonJS中，每个.js文件被视为一个独立的模块。这意味着文件内部定义的变量、函数等都是模块私有的，不会污染全局作用域。 模块导出：使用module.exports或exports来导出模块希望公开的接口。其他模块可以访问这些导出的接口来使用该模块的功能。module.exports是模块的默认导出对象，而exports是module.exports的一个引用，通常用于导出多个属性或方法。 模块引入：通过require函数来引入其他模块。require函数接受一个模块标识符作为参数，用于加载并返回导出的模块接口。模块标识符可以是相对路径或绝对路径，也可以是核心模块名。 加载机制：Node.js实现了懒加载（也称为延迟加载）策略，即只有当使用require函数时，模块才会被加载和执行。这样可以提高程序的运行效率，因为不立即加载所有模块，而是按需加载。 缓存机制：Node.js对加载过的模块进行缓存，任何后续对该模块的require调用都会直接从缓存中获取模块，而不是重新加载，这进一步提升了程序性能。 当使用require函数加载模块时，获取到的是module.exports最终指向的那个对象，无论这个指向是否在过程中被改变过。简而言之，尽管exports常用于方便地添加模块接口，但真正对外暴露的是通过module.exports指定的内容。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"js-node.js","slug":"js-node-js","permalink":"http://example.com/tags/js-node-js/"}]},{"title":"Git的基本使用","slug":"Git的基本使用","date":"2024-07-08T07:53:36.000Z","updated":"2024-09-14T14:08:36.359Z","comments":true,"path":"2024/07/08/Git的基本使用/","permalink":"http://example.com/2024/07/08/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"","text":"1.了解GitGit是目前最流行的版本控制系统 快照： Git的快照记录类似于备份，是在原有文件版本上重新生成一份新的文件。如果文件没有修改，Git不再重新存储该文件，而是保留一个链接指向之前存储的文件。 本地执行： Git中的三个区域 1.工作区 2.暂存区 3.Git仓库 Git中的三种状态 1.已修改(modified) 2.已暂存(staged) 3.已提交(committed) Git基本工作流程 1.在工作区中修改文件 2.将你想要下次提交的更改进行暂存 3.提交更新，找到暂存区的文件，将快照永久性存储到Git仓库 2.Git的基本操作1.获取Git仓库的两种方式 2.在现有目录中初始化Git仓库对于一个尚未进行版本控制的项目，想用Git控制他，步骤如下 （1）项目根目录中鼠标右键打开”GitBash“ （2）执行 1git init 命令将当前目录转为Git仓库 git init 命令会创建一个名字为.git的隐藏目录，这个.git目录就当前项目的Git仓库。不可删除 3.检查文件状态命令： 1234git status# 以简短的方式显示文件状态git status -s # 或git status --short 状态1：未跟踪 状态2：已跟踪{ 1.已修改 2.已暂存 3.已提交 } 4.跟踪新文件命令： 1git add + 文件名 如果文件被跟踪，可以显示绿色A标记（精简查看文件状态） 5.提交更新(本地)命令： 1git commit [-m] 比如： git commit -m ‘测试提交更新’ -m是可选项，可以说明本次提交的简短说明 基本上一套流程是把未跟踪的文件添加到暂存区(git add +文件名)然后通过git commit 往仓库提交 6.对已提交的文件进行修改如果对已经提交的文件进行修改，那么它的状态会变成已修改但未提交。简短状态是文件名前面有个红色M 命令： 1git status -s 7.暂存已修改文件如果对于已提交的文件进行了修改，若是暂存这个修改的话需要再次运行 git add 命令，该命令有如下功效： 此时查看文件状态应该是一个绿色的M 8.提交已暂存的文件再次输入命令 **git commit -m ‘提交消息’**，即可将暂存区的快照记录提交到Git仓库中 9.撤销对文件的修改概念：把工作区中对应文件的修改，还原成Git仓库中所保存的版本 命令： 1git checkout -- 文件名 本质：用Git仓库中保存的文件来覆盖工作区中指定的文件 10.向暂存区中一次性添加多个文件命令： 1git add . 11.从暂存区移除对应的文件命令： 1git reset HEAD + 文件名 移除所有暂存区文件： 1git reset HEAD . 12.跳过暂存区 1git commit -a -m &#x27;提交消息&#x27; 13.移除文件1.从工作区和Git仓库中同事移除文件 命令 1git rm -f + 文件名 2.只从Git仓库中移除文件，保留工作区对应的文件 命令 1git rm --cached + 文件名 14.Git忽略文件 .gitignore的格式规范 glob模式 举个使用例子 14.查看Git提交历史命令 1git log 具体用法和功能如下 14.回退到指定版本1234567891011#在一行上展示所有的提交历史git log --pretty=oneline#根据指定的提交ID回退到指定版本git reset --hard &lt;CommitId&gt;#在旧版本中如果还想查看完整的提交历史使用下面命令git reflog --pretty=online#再次根据最新的提交ID，跳转到最新版本git reset --hard &lt;CommitId&gt; 3.Git分支目的：防治项目干扰，提高协同开发的体验，有益于团队协作。 1.master主分支在项目根目录进行初始化操作时，git会自动帮我们创建一个分支，被称为主分支。 作用是：用来保存和记录珍项目已完成的功能代码 2.功能分支概念：从主分支上临时分叉出来的，负责一些新功能的开发，当开发完毕后，需要将该功能分支与主分支合并。 3.查看分支命令 1git branch 注：分支前面的*表示当前所在的分支 4.新建分支命令 1git branch 分支名称 新分支的代码是和主分支一样的。 5.切换分支命令： 1git checkout + 切换分支的名字 6.快速创建和切换指定分支123# -b表示创建一个新分支# checkout表示切换到工行拆新建的分支上git checkout -b 分支名称 7.合并分支12345# 切换到主分支git checkout master#在主分支上运行下列命令，将子分支的代码合并到主分支上git merge + 子分支名称 注意： 检验发现，已经合并 8.删除分支命令 1git branch -d + 分支名称 9.遇到冲突时合并分支情景：相同的文件，在不同的分支中进行了修改。 解决冲突后再次提交即可。 10.将本地分支推送到远程仓库12345678# -u 表示把本地分支和远程分支进行关联，只需要第一个推送即可git push -u 远程仓库的名字 本地分支的名称:远程分支别名#例子git push -u origin payment:pay#如果希望远程分支和本地分支名称保持一致，可以如下写法git push -u origin payment 如果远程仓库已经存在那么只需要使用 1git push origin 分支名称即可 11.查看远程仓库中所有分支列表命令 1git remote show 远程仓库名称 12.跟踪分支 13.拉取远程分支的最新代码12#拉取git pull 14.删除远程分支12345# 删除远程仓库中，指定名称的远程分支git push 远程仓库名字 --delete 远程分支名称#例子git push origin --delete register 4.关于Githubssh连接github生成密钥命令 1ssh -keygen -t rsa -b 4096 -C &#x27;注册GitHub的邮箱&#x27; 之后生成的密钥会在C:\\Users\\用户名文件夹.ssh 目录生成id_rsa和id_rsa.pub 配置ssh 上传过程 5.命令总结命令总结 12345678910111213141516171819202122232425262728293031323334353637#初始化与配置git init：在当前目录初始化一个新的Git仓库。git config：配置Git的设置，如用户名、邮箱等。#克隆与获取git clone [repository]：克隆一个远程仓库到本地。git fetch：从远程仓库下载最新的分支和标签信息，但不自动合并。git pull：从远程仓库下载并尝试自动合并到当前分支。#添加与提交git add [file]：将指定文件添加到暂存区准备提交。git add .：添加当前目录下的所有修改过的文件到暂存区。git commit -m &quot;commit message&quot;：提交暂存区的更改到本地仓库，需附带提交信息。#查看状态与历史git status：查看工作目录和暂存区的状态。git diff：显示工作目录中未暂存的更改。git log：查看提交历史，默认显示所有提交的详细信息。git log --oneline：以简洁的一行格式查看提交历史。#分支管理git branch：查看本地分支。git branch [branch-name]：创建新分支。git checkout [branch-name]：切换到指定分支。git checkout -b [branch-name]：创建并切换到新分支。git merge [branch]：合并指定分支到当前分支。git branch -d [branch-name]：删除本地分支。git push origin --delete [branch-name]：删除远程分支。#远程操作git remote add origin [url]：添加远程仓库。git remote set-url origin [new-url]：修改远程仓库地址。git remote -v：查看远程仓库信息。git push：推送本地分支到远程仓库。git push origin [branch-name]：推送特定分支到远程仓库。git pull：从远程仓库拉取并合并到当前分支。#其他常用命令git stash：保存当前的工作目录和索引状态，用于临时存储。git stash apply/pop：应用或弹出最近一次保存的stash。git reset [file]：取消暂存指定文件的更改。git reset --hard：撤销工作目录中所有未提交的更改，回到上次提交的状态。git cherry-pick [commit]：将指定提交应用于当前分支。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"git学习","slug":"git学习","permalink":"http://example.com/tags/git%E5%AD%A6%E4%B9%A0/"}]},{"title":"jQuery学习","slug":"jQuery学习","date":"2024-07-06T10:12:07.000Z","updated":"2024-09-15T03:55:32.838Z","comments":true,"path":"2024/07/06/jQuery学习/","permalink":"http://example.com/2024/07/06/jQuery%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"jQuery第一部分1.使用准备首先来对比一下jQ语法和原生Dom语法 1234567// 原生js let liArr = document.querySelectorAll(&#x27;li&#x27;) for (let i = 0; i &lt; liArr.length; i++) &#123; liArr[i].onclick = function () &#123; this.style.backgroundColor = &#x27;orange&#x27; &#125; &#125; 1234// jQuery $(&#x27;li&#x27;).click(function () &#123; $(this).css(&#x27;backgroundColor&#x27;, &#x27;orange&#x27;)&#125;) 可以发现，通过jQ语法操作样式要比原生操作Dom简单不少，那么如何使用jQ呢？下面介绍 下包:你得先把这个别人写好js文件下载到本地 导包:下载完毕之后需要导入到使用的页面中 另起一行script输出一下$,看看是否输出了下图内容: 确保上一步做完之后,我们写一段测试代码 $(&#39;body&#39;).css(&#39;backgroundColor&#39;,&#39;yellowgreen&#39;) 123456789101112 2. 可以看出，操作的元素是body标签，设置的样式是背景色，且颜色为黄绿色。jQ官方网站：https://jquery.com/## 2.选择器jQuery中如何获取需要操纵的元素?在我们学习Dom的时候，想要操作这个元素，第一步也是先获取元素，所以在jQ学习中也是一样的，下面来介绍如何通过jQ的方式来获取元素，语法很简单:```js// 基本用法$(&#x27;选择器&#x27;) 直接调用$方法即可，选择器通过字符串的方式传递进去,基本上兼容所有css的选择器，比如标签选择器，类选择器，后代选择器等。导入了jQuery之后我们通过console的方式了$这个全局变量，打印的是一个函数。既然是函数加括号就是调用他。只不过之前的函数名都不是$而已。 标签选择： 12// 标签选择器$(&#x27;p&#x27;) 类选择器(在css中选择类就是.)： 12// 类选择器$(&#x27;.p&#x27;) id选择器 12// id 选择器$(&#x27;#p&#x27;) 后代选择器(这里选择body中的所有p标签为例子)： 12// 后代选择器$(&#x27;body p&#x27;) 小结: 选择器的语法咋写来着？ ​ 调用$方法然后以字符串的方式传入css的选择器即可。 3.jQuery对象jQuery 中利用选择器获取到的并非原生的 DOM 对象，而是 jQuery 对象，我们在学习jQ选择器的时候，调用$方法获取到的返回值就是jQuery对象，jQuery提供的绝大多数方法都需要通过jQuery对象才可以访问。 12// jQuery$(&#x27;p&#x27;) 然后我们通过css方法把元素的背景色变成了粉色 12// jQuery$(&#x27;p&#x27;).css(&#x27;backgroundColor&#x27;,&#x27;pink&#x27;) 如果使用Dom对象来实现，是这样的,先获取到dom对象，然后通过点语法访问style属性，接着为backgroundColor赋值. 1document.querySelector(&#x27;p&#x27;).style.backgroundColor = &#x27;pink&#x27; 注意：两者的写法不能混淆。 除了通过选择器以外，我们还可以把dom对象直接丢到$方法中，他返回的也是一个jQ对象，就可以使用jQuery提供的那些高级方法。 12$(&#x27;选择器&#x27;)$(dom对象) 就比如 123// 4. dom对象转jQ对象，li是一个dom对象 let $li2 = $(li) $li2.css(&#x27;backgroundColor&#x27;, &#x27;skyblue&#x27;) jQuery对象 调用$方法传入选择器或dom元素获取到的是什么对象 ？ jQuery对象 jQuery对象的方法,比如css方法放在什么位置？ 原型上 4.事件绑定语法是这样的：先通过选择器找到希望绑定的元素，然后然后调用对应的事件名方法，传入回调函数，逻辑直接写在回调函数里面即可。 123$(&#x27;选择器&#x27;).事件名(function () &#123; // 逻辑....&#125;) 注意：在操作dom元素时，我们在绑定事件的时候一是要在事件名称前面加上on，二是通过赋值号=来写对应事件的回调函数(触发事件时要做的逻辑),然而jQ语法是不一样的，这要注意了。 1234567891011// 1.为 li 添加点击事件$(&#x27;li&#x27;).click(function()&#123; console.log(&#x27;这是点击事件！&#x27;); //当触发点击事件时，把背景颜色变成红色 console.log(this) //这里的this是dom对象，你可以通过以下方法实现变红 this.style.background = &#x27;red&#x27; //也可以通过jQ语法变红，但是需要进行转换 let jqObj = $(this) jqObj.css(&#x27;background&#x27;,&#x27;red&#x27;);&#125;) 从上面可以看到，当我们操作jQ对象进行操作绑定事件时，不需要在加onxxxx 和 =，方便许多，这点注意。 其他事件，比如聚焦(focus)，失焦(blur)，鼠标移入移出等等，如下所示 123456789101112131415161718192021// 2.为 .text 添加获得焦点事件 $(&#x27;.text&#x27;).focus(function () &#123; console.log(&#x27;focus&#x27;) &#125;) // 3.为 .text 添加失去焦点事件 $(&#x27;.text&#x27;).blur(function () &#123; console.log(&#x27;blur&#x27;) &#125;) // 4.为 .box 添加鼠标移入事件 $(&#x27;.box&#x27;).mouseenter(function () &#123; console.log(&#x27;mouseenter&#x27;) $(this).css(&#x27;backgroundColor&#x27;, &#x27;pink&#x27;) &#125;) // 5.为 .box 添加鼠标移出事件 $(&#x27;.box&#x27;).mouseleave(function () &#123; console.log(&#x27;mouseleave&#x27;) $(this).css(&#x27;backgroundColor&#x27;, &#x27;yellowgreen&#x27;) &#125;) jQuery中的事件绑定。 为jQuery对象绑定事件时，方法名字中有没有on？ 没有，$(‘选择器’). 传入的回调函数中，如何获取触发事件的dom元素? this,可以调用$方法将他转为jQuery对象，从而使用jQuery对象强大的方法 5.链式编程指的是通过点把多个操作（方法）连续的写下去，这样形成的结构和链子一样，所以叫做链式编程。 上一节中的对于text类的操作方法，写了两部分重复了，下面来展示链式编程的写法： 1234567$(&#x27;.text&#x27;) .focus(function () &#123; console.log(&#x27;获取焦点&#x27;) &#125;) .blur(function () &#123; console.log(&#x27;失去焦点&#x27;) &#125;) 我们在.focus方法的后面继续点.blur就可以再为他绑定失去焦点事件。形式上看去就好比下面这样： 1$(&#x27;.text&#x27;).focus(回调函数).blur(回调函数) 甚至是： 1$(&#x27;.text&#x27;).focus(回调函数).blur(回调函数).change(回调函数) 为什么可以这么写？答：因为通过jQ对象调用的大部分方法返回的还是同一个jQ对象。 链式编程 链式编程的含义是? 通过 点 把多个操作连续的写下去, 形成和 链子 一样的结构 有没有特殊情况? 有 6.内容操纵如何通过jQuery操纵元素的内容 jQuery封装了2个方法让我们对元素的文本进行设置或者,根据是否传参功能是不一样的,如何使用呢? 传递参数就是设置,不传递参数就是取值 123456// 设置$(&#x27;选择器&#x27;).html(&#x27;内容&#x27;)$(&#x27;选择器&#x27;).text(&#x27;内容&#x27;)// 取值$(&#x27;选择器&#x27;).html()$(&#x27;选择器&#x27;).text() 如果，我们要设置的内容中包含标签，那么就用.html()方法。如果要获取的内容只希望获取文本内容，不包含标签，那么推荐使用.text()方法 举例，设置普通文本： 123// 1. 设置普通文本$(&#x27;.box1&#x27;).html(&#x27;测试内容&#x27;)$(&#x27;.box2&#x27;).text(&#x27;测试内容&#x27;) 这两种方式，在页面中呈现的内容是一样的 但是如果，这时我们在带入标签进行内容的设置，代码是： 123// 2. 设置标签$(&#x27;.box1&#x27;).html(&#x27; &lt;a href=&quot;#&quot;&gt;黑马程序员&lt;/a&gt;&#x27;)$(&#x27;.box2&#x27;).text(&#x27; &lt;a href=&quot;#&quot;&gt;黑马程序员&lt;/a&gt;&#x27;) 可以清楚的发现.text方法并没有将a标签解析，而.html方法解析了 接下来测试取值。 1234567// 3. 取值 let htmlContent = $(&#x27;.box1&#x27;).html(); //包含标签 console.log(htmlContent); let textContent = $(&#x27;.box1&#x27;).text(); //包含文本 console.log(textContent); 结果 可以看到，html方法的取值可以将标签取到并输出。而text方法只能取到文本，也就是标签的内容。 下面来说一点链式编程不适用的情况。链式编程是只要你返回的对象是jQ对象，就可以继续..来执行下面的方法，我们只需要比较在赋值时，将被赋值的内容获取，在与jQ选择器获取的对象进行比较即可 123let $box1 = $(&#x27;.box1&#x27;)let $res = $box1.html(&#x27;测试内容&#x27;)console.log($box1===$res) // true 说明$box1和$res是同一个jq对象,那么进行赋值操作的时候就可以调用其他的jq方法。 哪个方法设置的标签会被正常解析？ html方法 只获取元素的文本使用哪个方法? text方法 赋值还是取值支持链式编程? ​ 赋值 案例1:计数器1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;案例计数器&lt;/title&gt;&lt;/head&gt;&lt;!-- 引入jQ --&gt;&lt;script src=&quot;../jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt;&lt;body&gt; &lt;div class=&quot;input-num&quot;&gt; &lt;!-- 减号 --&gt; &lt;button id=&quot;btn1&quot;&gt; - &lt;/button&gt; &lt;!-- 内容 --&gt; &lt;span&gt;0&lt;/span&gt; &lt;!-- 加号 --&gt; &lt;button id=&quot;btn2&quot;&gt; + &lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; let i = $(&#x27;.input-num span&#x27;).text(); console.log(i); // 分情况讨论 $(&#x27;.input-num #btn1&#x27;).click(function()&#123; let btn1Obj = $(&#x27;.input-num #btn1&#x27;) if(i !== 0)&#123; i--; $(&#x27;.input-num span&#x27;).text(i) &#125;else&#123; window.alert(&#x27;i已经是0了,不能够继续递减了!&#x27;) &#125; &#125;) $(&#x27;.input-num #btn2&#x27;).click(function()&#123; let btn2Obj = $(&#x27;.input-num #btn2&#x27;) if(i == 10)&#123; window.alert(&quot;i已经到最大值10了,不能够增加了&quot;) &#125;else&#123; i++; $(&#x27;.input-num span&#x27;).text(i) &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 针对于两个按钮，除了可以按照上面的那种方法来给它们写一个不同的id以外，还可以用伪类选择器，指的是，在一个大元素中的第一个子元素和最后一个子元素，可以用到下面这样的 last-child和first-child叫做什么选择器? 伪类选择器 写法： span里面的文本设置和取值用的是什么方法 text方法 7.过滤方法使用jQuery的过滤方法对找到的元素再次筛选 jQuery中的过滤方法,作用是对jQuery对象中的dom元素再次进行筛选,让我们更精确的定位到希望操纵的元素。 方法一共有3个,分别是first,last,和eq,其中first和last不需要传递参数,作用分别是获取到第一个和最后一个元素,eq方法需要传递索引作为参数,索引从0开始.这三个方法返回的都是jQ对象,这就意味着我们可以直接用点语法调用我们目前学过的那些方法,比如绑定事件,修改内容等等 现在针对上面的内容，对案例：计数器中的进行改写如下 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;案例计数器&lt;/title&gt;&lt;/head&gt;&lt;!-- 引入jQ --&gt;&lt;script src=&quot;../jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt;&lt;body&gt; &lt;div class=&quot;input-num&quot;&gt; &lt;!-- 减号 --&gt; &lt;button &gt; - &lt;/button&gt; &lt;!-- 内容 --&gt; &lt;span&gt;0&lt;/span&gt; &lt;!-- 加号 --&gt; &lt;button &gt; + &lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; let i = $(&#x27;.input-num span&#x27;).text(); console.log(i); // 分情况讨论 $(&#x27;.input-num button &#x27;).first().click(function()&#123; if(i != 0)&#123; i--; $(&#x27;.input-num span&#x27;).text(i) &#125;else&#123; window.alert(&#x27;i已经是0了,不能够继续递减了!&#x27;) &#125; &#125;) $(&#x27;.input-num button&#x27;).last().click(function()&#123; if(i == 10)&#123; window.alert(&quot;i已经到最大值10了,不能够增加了&quot;) &#125;else&#123; i++; $(&#x27;.input-num span&#x27;).text(i) &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 8.样式操纵基础语法： 123.css(&#x27;样式名&#x27;,&#x27;值&#x27;)//注意，驼峰命名，否则不识别.css(&#x27;backgroundColor&#x27;,&#x27;pink&#x27;) 如果要设置多个样式，可以以对象的形式进行传递 语法： 1234567.css(对象).css(&#123; backgroundColor:&#x27;pink&#x27;, color:&#x27;red&#x27;, width:&#x27;200px&#x27;, height:200&#125;) 同样，也可以获取对应样式名字的值 语法： 12.css(&#x27;样式名&#x27;).css(&#x27;width&#x27;) css方法取值时是否需要传递参数? 需要，需要告诉css方法希望获取的是什么样式 设置时数值类的样式省略单位,默认值是什么？ px css方法设置的样式在元素什么位置? 行内 9.属性操纵使用jQuery提供的方法操纵元素的属性 示例代码： 12&lt;a href=&quot;https://www.baidu.com&quot;&gt;点击跳转百度&lt;/a&gt;&lt;img src=&quot;logo.png&quot; info=&quot;测试照片&quot; /&gt; 方法有2个，分别是attr和removeAttr，其中attr方法可以用来设置或者读取属性，removeAttr的作用是删除属性 我们先来看看attr方法的用法 设置属性是通过attr方法传入两个参数，分别是属性名和设置的值 取值需传入属性名就好，和css方法是一致的。 基础语法： // 赋值 .attr(&#39;属性名&#39;,&#39;值&#39;) // 取值 .attr(&#39;属性名&#39;) 12345678removeAttr方法基础语法：```js// 删除属性.removeAttr(&#x27;属性名&#x27;) 示例代码： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;12-属性操纵&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 测试用标签 --&gt; &lt;a href=&quot;#&quot;&gt;黑马程序员&lt;/a&gt; &lt;img src=&quot;&quot; /&gt; &lt;!-- 导入 jQuery --&gt; &lt;script src=&quot;./jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 1. 赋值 $(&#x27;a&#x27;).attr(&#x27;href&#x27;, &#x27;http://www.baidu.com/&#x27;) $(&#x27;img&#x27;).attr(&#x27;src&#x27;, &#x27;http://www.baidu.com/images/logo.png&#x27;) $(&#x27;img&#x27;).attr(&#x27;info&#x27;, &#x27;测试照片&#x27;) // 2. 取值 let href = $(&#x27;a&#x27;).attr(&#x27;href&#x27;) console.log(&#x27;href:&#x27;, href) let info = $(&#x27;img&#x27;).attr(&#x27;info&#x27;) console.log(&#x27;info:&#x27;, info) // 3. 删除 $(&#x27;a&#x27;).removeAttr(&#x27;href&#x27;) $(&#x27;img&#x27;).removeAttr(&#x27;src&#x27;) $(&#x27;img&#x27;).removeAttr(&#x27;info&#x27;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; attr方法赋值操作时需要传递几个参数？ 2个，参数1是属性名，参数2是属性值 attr方法传递一个参数的作用是什么？ 取值，要获取什么属性的值，传入对应的名字就ok啦！ 删除属性的方法名叫什么？ removeAttr 案例2:图片切换完成图片切换demo 案例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;13-图片切换&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/index.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;mask&quot;&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2 class=&quot;title&quot;&gt; &lt;img src=&quot;./images/logo.png&quot; alt=&quot;&quot; /&gt; &lt;/h2&gt; &lt;!-- 图片 --&gt; &lt;img class=&quot;cover&quot; src=&quot;./images/1.png&quot; alt=&quot;&quot; /&gt; &lt;!-- 左箭头 --&gt; &lt;a href=&quot;javascript:void(0)&quot; class=&quot;left&quot;&gt; &lt;img src=&quot;./images/prev.png&quot; alt=&quot;&quot; /&gt; &lt;/a&gt; &lt;!-- 右箭头 --&gt; &lt;a href=&quot;javascript:void(0)&quot; class=&quot;right&quot;&gt; &lt;img src=&quot;./images/next.png&quot; alt=&quot;&quot; /&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;!-- 导入jQuery --&gt; &lt;script src=&quot;./jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt;&lt;script&gt;// 箭头缩放//移入$(&#x27;.center a&#x27;).mouseenter(function()&#123; console.log(&#x27;鼠标移入&#x27;); $(this).css(&#x27;transform&#x27;,&#x27;scale(1.1)&#x27;)&#125;).mouseleave(function()&#123; console.log(&#x27;鼠标移出&#x27;); $(this).css(&#x27;transform&#x27;,&#x27;scale(1)&#x27;)&#125;)// 图片切换$(&#x27;.left&#x27;).css(&#x27;display&#x27;,&#x27;none&#x27;)let index = 1$(&#x27;.left&#x27;).click(function ()&#123;index--$(&#x27;.cover&#x27;).attr(&#x27;src&#x27;,`./images/$&#123;index&#125;.png`) if(index == 1)&#123; $(&#x27;.right&#x27;).css(&#x27;display&#x27;,&#x27;&#x27;) $(this).css(&#x27;display&#x27;,&#x27;none&#x27;)&#125;&#125;)$(&#x27;.right&#x27;).click(function ()&#123; index++ console.log(index); $(&#x27;.cover&#x27;).attr(&#x27;src&#x27;,`./images/$&#123;index&#125;.png`) if(index == 5)&#123; $(this).css(&#x27;display&#x27;,&#x27;none&#x27;) $(&#x27;.left&#x27;).css(&#x27;display&#x27;,&#x27;&#x27;) &#125;&#125;)&lt;/script&gt; 为transform设置什么可以调整元素缩放? scale 使用什么方法修改元素属性？ attr方法 使用什么方法修改元素样式 css方法 10.操纵value使用jQuery提供的方法操纵表单元素的value值 jQuery中如何去操纵表单元素的value值，在网页开发中获取用户的输入。语法很简单，就是一个方法.val。 1234// 取值$(&#x27;选择器&#x27;).val()// 赋值$(&#x27;选择器&#x27;).val(&#x27;值&#x27;) val也有两种用法，取值和赋值，我们在取值的时候，不需要传递参数。 示例代码： 12345678910111213141516&lt;body&gt; &lt;!-- 测试用输入框 --&gt; &lt;input class=&quot;text&quot; type=&quot;text&quot; /&gt; &lt;!-- 引入 jQuery --&gt; &lt;script src=&quot;./jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 1. 赋值 $(&#x27;.text&#x27;).val(&#x27;测试内容！&#x27;) // 2. 取值 $(&#x27;.text&#x27;).blur(function () &#123; let value = $(this).val() console.log(&#x27;value:&#x27;, value) &#125;) &lt;/script&gt;&lt;/body&gt; 测试结果： 赋值 取值 val方法是操纵元素的什么属性? value属性 获取value是否需要传递参数 11.查找方法使用jQuery提供的查找方法对元素再次检索 jQuery提供了一些查找元素的方法，通过这些方法就可以通过元素去查找他的父元素，兄弟元素，子元素和后代元素。 方法有4个，但是非常好理解：parent方法用来获取父元素，children方法用来获取子元素，siblings用来获取兄弟元素，find用来获取后代元素，考虑到后代元素种类比较多，所以find方法必须传入选择器 这4个方法返回的都是jQ对象，之前的方法也是适用的。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;查找方法&lt;/title&gt;&lt;/head&gt;&lt;script src=&quot;./jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;h4&gt;课程列表&lt;/h4&gt; &lt;ul class=&quot;course&quot;&gt; &lt;li&gt;html&lt;/li&gt; &lt;li&gt;css&lt;/li&gt; &lt;li&gt;javascript&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;校区列表&lt;/h4&gt; &lt;ul class=&quot;campus&quot;&gt; &lt;li class=&quot;bj&quot;&gt;北京校区&lt;/li&gt; &lt;li class=&quot;sh&quot;&gt;上海校区&lt;/li&gt; &lt;li class=&quot;gz&quot;&gt;广州校区&lt;/li&gt; &lt;li class=&quot;sz&quot;&gt;深圳校区&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 获取父元素,在这个例子中父元素就是div let parentElement = $(&#x27;.course&#x27;).parent().css(&#x27;backgroundColor&#x27;, &#x27;pink&#x27;); // 获取子元素上面的两个h4标签，ul标签都是子元素 let childrenElement = $(&#x27;.container&#x27;).children().css(&#x27;backgroundColor&#x27;, &#x27;yellow&#x27;); // 获取兄弟元素 let brotherElement = $(&#x27;.course&#x27;).siblings().css(&#x27;backgroundColor&#x27;, &#x27;blue&#x27;); console.log(&#x27;这是兄弟元素&#x27;+brotherElement); // 获取后代元素 指的是li标签 let afterElement = $(&#x27;.campus&#x27;).find($(&#x27;.bj&#x27;)).css(&#x27;backgroundColor&#x27;,&#x27;red&#x27;) &lt;/script&gt;&lt;/html&gt; 图片展示： parent方法是否需要传递参数？ 不需要，父元素只有一个 获取子元素的方法是什么？ children方法 siblings方法一定要传入选择器吗？ 不一定，不传入获取所有兄弟元素，传入的话就是进行筛选啦 find方法是否可以获取到子元素? 可以，子元素也是后代元素的一种 12.操纵类名使用jQuery提供的方法操纵元素的类名 通过操纵类名达到切换样式的目的。 适用场景：样式多且杂，这时候切换类名比一个个写入方便多 基础语法： 名字非常好记，方法都是通过class结尾的，结合不同的单词产生不同的效果 addClass就是添加类名 removeClass就是移除类名 hasClass是判断类名是否存在，返回的是布尔值 toggleClass可以对类名进行切换，有就移除，没有就添加。 参数就是需要操作的类名 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;操纵类名&lt;/title&gt; &lt;style&gt; body &#123; padding: 0 30px; &#125; p &#123; color: #333; &#125; .test &#123; width: 200px; height: 100px; background-color: green; &#125; .active &#123; background-color: red; border: 5px solid skyblue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 操纵的盒子 --&gt; &lt;div class=&quot;test&quot;&gt;&lt;/div&gt; &lt;hr /&gt; &lt;!-- 测试用按钮 --&gt; &lt;button class=&quot;add&quot;&gt;添加类名&lt;/button&gt; &lt;button class=&quot;remove&quot;&gt;移除类名&lt;/button&gt; &lt;button class=&quot;has&quot;&gt;判断类名&lt;/button&gt; &lt;button class=&quot;toggle&quot;&gt;切换类名&lt;/button&gt; &lt;!-- 导入jQuery --&gt; &lt;script src=&quot;./jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 1. 添加类名 $(&#x27;.add&#x27;).click(function () &#123; $(&#x27;.test&#x27;).addClass(&#x27;active&#x27;) &#125;) // 2. 移除类名 $(&#x27;.remove&#x27;).click(function () &#123; $(&#x27;.test&#x27;).removeClass(&#x27;active&#x27;) &#125;) // 3. 判断类名 $(&#x27;.has&#x27;).click(function () &#123; let res = $(&#x27;.test&#x27;).hasClass(&#x27;active&#x27;) console.log(&#x27;res:&#x27;, res) &#125;) // 4. 切换类名 $(&#x27;.toggle&#x27;).click(function () &#123; $(&#x27;.test&#x27;).toggleClass(&#x27;active&#x27;) &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 方法是否需要传递参数? 需要，这一节学习的4个方法都需要传递类名作为参数 hasClass方法的返回值是什么？ 布尔值，hasClass方法的作用是判断类名是否存在，true就是存在，false就是不存在 addClass是添加类名，removeClass是移除类名，切换类名的方法叫做? toggleClass，类名存在就移除，不存在就添加 13.事件进阶更为强大的事件绑定,还能解绑哦 学习事件进阶需要解决两个问题： 对于没有提供的方法的事件无法绑定，比如input。 对于绑定的事件如何移除呢？ 有些更高级的需求也不好实现，比如：绑定一次性事件，就是只能触发一次的事件！ 首先是注册事件，我们可以直接使用on方法，来注册所有的事件，他是要传递两个参数，第1个是事件名，比如点击事件写click就好，第2个是回调函数 ​ 如果要删除事件呢，可以使用off这个方法，想要删除什么事件，就传入什么事件名! ​ 如果不传入事件名，会删除所有哦，是不是特别暴力啊！ ​ 最后一个是注册一次性事件，用法和on类似，方法名换成了one 基础语法： 12345678// 1. 注册事件.on(&#x27;事件名&#x27;, function()&#123;&#125;)// 2. 移除指定事件.off(&#x27;事件名&#x27;)// 3. 移除所有事件.off()// 4. 注册一次性事件.one(&#x27;事件名&#x27;, function()&#123;&#125;) 在回调函数中，this还指的是jQ对象 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;事件进阶&lt;/title&gt; &lt;style&gt; body &#123; padding: 0 30px 40px; &#125; p &#123; color: #333; &#125; button &#123; margin-top: 10px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 测试标签 --&gt; &lt;input type=&quot;text&quot; class=&quot;onoff&quot; /&gt; &lt;br /&gt; &lt;button class=&quot;one&quot;&gt;支付&lt;/button&gt; &lt;!-- 导入jQuery --&gt; &lt;script src=&quot;./jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 1. 注册事件 on $(&#x27;.onoff&#x27;).on(&#x27;focus&#x27;, function () &#123; console.log(&#x27;获取焦点&#x27;) &#125;) $(&#x27;.onoff&#x27;).on(&#x27;blur&#x27;, function () &#123; console.log(&#x27;失去焦点&#x27;) &#125;) $(&#x27;.onoff&#x27;).on(&#x27;input&#x27;, function () &#123; // console.log(&#x27;input事件触发&#x27;) // console.log(this) let value = $(this).val() console.log(&#x27;value:&#x27;, value) &#125;) //下面这种写法会报错 // $(&#x27;.onoff&#x27;).input(function () &#123; // console.log(&#x27;input事件触发&#x27;) // &#125;) // 2. 移除指定事件 off $(&#x27;.onoff&#x27;).off(&#x27;focus&#x27;) // 3. 移除所有事件 off $(&#x27;.onoff&#x27;).off() // 4. 注册一次性事件 one $(&#x27;.one&#x27;).one(&#x27;click&#x27;, function () &#123; alert(&#x27;支付成功998元&#x27;) &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 使用on方法进行事件绑定时，第一个参数是什么? 事件名 使用off方法时可以不传递参数吗？ 可以，删除所有事件，比较暴力 一次性事件通过什么方法绑定？ one 14.触发事件用代码的方式触发注册的事件 学习在jQuery中如何通过代码的方式去触发绑定的事件。 基础语法： 直接调用对应的事件方法即可，不需要传入任何参数就是触发，比如点击事件，调用click方法即可 但并不是所有事件都有对应的方法，比如input事件，这个时候就可以通过trigger的方式来触发，直接传入希望触发的事件名就好啦 trigger方法可以触发任意的事件，包括自定义的事件，什么叫做自定义事件呢？顾名思义就是事件名是咱们自己想的，写什么都可以 自定义事件必须通过on的方式来注册，把第一个参数换成自定义的事件名就好啦，同时他也只能通过代码的方式来触发 自定义事件是一种更为高阶的用法，咱们只需要了解基本的用法即可。 12345678// 1. 直接触发.事件名()// 2. trigger触发.trigger(&#x27;事件名&#x27;)// 3. 触发自定义事件.trigger(&#x27;自定义事件&#x27;)// 4. 注册自定义事件.on(&#x27;自定义事件&#x27;,function()&#123;&#125;) 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;触发事件事件处理&lt;/title&gt; &lt;style&gt; body &#123; padding: 0 30px 40px; &#125; p &#123; color: #333; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 测试用标签 --&gt; &lt;button class=&quot;btn&quot;&gt;按钮&lt;/button&gt; &lt;br /&gt; &lt;input type=&quot;text&quot; class=&quot;text&quot; /&gt; &lt;!-- 导入jQuery --&gt; &lt;script src=&quot;./jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 1. 直接触发 $(&#x27;.btn&#x27;).click(function () &#123; $(this).css(&#x27;backgroundColor&#x27;, &#x27;skyblue&#x27;) &#125;) //下面这个代码模拟了一个点击 // $(&#x27;.btn&#x27;).click() $(&#x27;.text&#x27;).on(&#x27;input&#x27;, function () &#123; console.log(&#x27;input触发啦！&#x27;) &#125;) // // 2. trigger触发，也是相当于模拟了事件要执行的行为，比如点击，输入等等 $(&#x27;.text&#x27;).trigger(&#x27;input&#x27;) $(&#x27;.btn&#x27;).trigger(&#x27;click&#x27;) // 3. 注册自定义事件 $(&#x27;.text&#x27;).on(&#x27;itheima-input&#x27;, function () &#123; console.log(&#x27;自定义事件触发！&#x27;) &#125;) // 4. 触发自定义事件 $(&#x27;.text&#x27;).trigger(&#x27;itheima-input&#x27;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; ​ trigger方法可以触发所有的事件，但是他的强大之处可不仅于此。对于自定义的事件也是可以触发。 调用click方法是否可以触发点击事件？ 可以，只要有方法的事件，都可以用这样的方式来触发 trigger方法只能用来触发原生事件？ 不对，自定义事件也是可以触发的 自定义事件，可以通过鼠标点击来触发？ 不可以，自定义事件只能通过trigger来触发 15.window事件绑定如何为window对象绑定事件呢? 用原生的方式为他绑定事件是这样的：直接为window对象对应的事件赋值即可,比如滚动，比如点击 1234// 滚动window.onscroll = function () &#123;&#125;// 点击window.onclick = function () &#123;&#125; 适用jQ来获取windows对象基础语法 1234// 滚动$(window).scroll(function () &#123;&#125;)// 点击$(window).click(function () &#123;&#125;) $方法中传入什么可以为window绑定事件? window对象，不用加引号！！！ jQuery第二部分1.元素位置jQuery中如何获取元素位置呢? position和offset都可以获取位置 返回的是一个对象 两者获取位置的参照物不同: offset始终参照的是html position参照的有定位属性的最近祖先元素 对于margin两者的处理也不相同 offset忽略 position会累加margin 如果要设置位置的话只能通过offset方法、 总结： offset方法和position方法哪个参考的是html? offset方法,position方法参考的是最近并且有定位的祖先元素 offset方法和position方法哪个可以用来设置位置? offset方法可以设置位置,但是没有动画效果 如果元素有margin哪个方法会一起计算进去呢? offset会把margin也计算进去,而position不会 2.滚动距离 jQuery中如何获取滚动距离呢? 获取元素滚动距离 1234//垂直方向移动距离$(&#x27;选择器&#x27;).scrollTop()//水平方向移动距离$(&#x27;选择器&#x27;).scrollLeft() 获取网页的滚动距离 12$(&#x27;html&#x27;).scrollTop()$(&#x27;html&#x27;).scrollLeft() 设置滚动距离 12$(&#x27;html&#x27;).scrollTop(值)$(&#x27;html&#x27;).scrollLeft(值) 小结: 对于内容可以滚动的元素可以通过scrollTop或者scrollLeft获取滚动距离,如何获取网页的滚动距离呢? 把html作为选择器即可 调用scrollTop和scrollLeft方法可以让元素滚到指定位置。 3.jQuery动画显示&amp;隐藏动画如何使用jQuery的显示隐藏动画 如何使用show方法 12//显示，参数可以传递持续时间，单位ms$(&#x27;选择器&#x27;).show() 如何使用hide方法 12//隐藏，参数可以传递持续时间，单位ms$(&#x27;选择器&#x27;).hide() 如何使用toggle方法(可以自动控制显示和隐藏) 12//显示&amp;隐藏，参数可以传递持续时间，单位ms$(&#x27;选择器&#x27;).toggle() 方法中的this 动画的持续时间 就是你要传递的参数，单位ms 动画效果 调优demo 动画 - 淡入&amp;淡出基础语法： 123456//淡入$(&#x27;选择器&#x27;).fadeIn()//淡出$(&#x27;选择器&#x27;).fadeOut()//淡入&amp;淡出，相当于在淡入淡出效果之间切换$(&#x27;选择器&#x27;).fadeToggle() 控制淡入淡出的时长，依旧可以传递时间参数，单位ms 1.淡入淡出效果是通过修改元素的哪个样式实现?opactity2.元素的尺寸是否会在淡入淡出的动画过程中一起改变?不会 动画 - 展开&amp;收起 如何使用slideDown方法 12//展开$(&#x27;选择器&#x27;).slideDown() 如何使用slideUp方法 12//收起$(&#x27;选择器&#x27;).slideUp() 如何使用slideToggle方法，就是在展开和收起直接切换 12//展开&amp;收起$(&#x27;选择器&#x27;).slideToggle() 本质是修改了哪个样式 改变垂直方向上的尺寸 方法中的this 动画的持续时间 传递参数作为持续时间，单位ms 动画效果 demo中使用淡入淡出效果 1.slideDown和slideUp哪一个用来把元素显示出来?slideDown展开2.在垂直方向上调整的样式除了高度、margin、还有?padding 动画 - 队列及停止通过jQuery为元素设置的多个动画会依次添加到动画队列中,并根据添加的顺序依次播放 基础语法： 123456//停止当前动画，继续播放后续的动画效果$(&#x27;选择器&#x27;).stop()//清空队列 在动画当前状态停止，且不再继续播放后续动画$(&#x27;选择器&#x27;).stop(true)//清空队列 直接到当前动画的结束状态$(&#x27;选择器&#x27;).stop(true,true) 动画方法和stop方法返回的是同一个jQuery对象 1.队列中动画的播放顺序和添加顺序是否有关系?有2.stop方法要清空队列需要传递什么参数?true3.传递1个true和传递2个true的区别是?1个:动画停止在执行stop方法的瞬间2个:直接到当前播放动画的结束状态 动画-自定义动画jQuery提供了animate方法来实现更为复杂的动画效果 基本语法： 1$(&#x27;选择器&#x27;).animate(动画属性，持续时间) 数值类样式支持动画,支持多个 默认单位是px 支持非样式的特殊属性 scrollLeft：水平方向滚动 scrollTop：垂直方向滚动 持续时间单位是毫秒 4.事件参数如何使用事件参数呢? 学习jQuery中的事件对象,有时候也称之为事件参数日常开发中使用的频率还行,他在触发事件时为开发者额外提供了一些信息,和功能:比如事件的触发对象,用来阻止冒泡,阻止默认行为什么的. 用法和webapi阶段基本一致 123456// 语法$(&#x27;选择器&#x27;).事件(function(event)&#123;&#125;)// 比如 点击事件$(&#x27;选择器&#x27;).click(function(event)&#123;&#125;)// 比如 键盘抬起事件$(&#x27;选择器&#x27;).keyup(function(event)&#123;&#125;) 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;事件对象&lt;/title&gt; &lt;style&gt; body &#123; padding: 0 30px; &#125; p &#123; color: #333; &#125; .box &#123; width: 200px; height: 100px; background-color: pink; padding: 20px; text-align: center; border-radius: 10px; &#125; input &#123; margin: 10px; &#125; button &#123; width: 100%; height: 30px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;事件对象&lt;/h2&gt; &lt;p&gt;事件触发时额外提供给开发者的信息,可以用来干不少事情哦&lt;/p&gt; &lt;div class=&quot;box&quot;&gt; &lt;a href=&quot;http://www.baidu.com/&quot;&gt;跳转百度&lt;/a&gt; &lt;input type=&quot;text&quot; /&gt; &lt;br /&gt; &lt;button&gt;点我&lt;/button&gt; &lt;br /&gt; &lt;/div&gt; &lt;script src=&quot;./jquery/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1.最外层盒子绑定点击事件,查看事件触发源，也就是谁触发了事件 1234$(&#x27;.box&#x27;).click(function (event) &#123; console.log(&#x27;event.target:&#x27;,event.target) console.log(&#x27;box-click&#x27;)&#125;) 2.阻止a标签的默认行为，比如a标签是跳转了，阻止跳转 123$(&#x27;a&#x27;).click(function (event) &#123; event.preventDefault()&#125;) 3.判断键盘按键 123456$(&#x27;input&#x27;).keyup(function (event) &#123; console.log(&#x27;keyCode:&#x27;,event.keyCode) if (event.keyCode === 13) &#123; console.log(&#x27;按下回车&#x27;) &#125;&#125;) 4.阻止冒泡 1234$(&#x27;button&#x27;).click(function (event) &#123; event.stopPropagation() console.log(&#x27;button-click&#x27;)&#125;) 小结一下 事件对象: 也可以叫做事件参数用法和webapi阶段学习的基本一致 在事件触发时额外传递给开发者中的信息和功能 可以通过它获取触发源,实现阻止默认行为等功能 5.动态添加html节点 - 新增在jQuery中如何新增(插入)节点 用法01-基于创建的jQuery对象进行添加 1234567891011// 基于html创建jQuery对象let $a = $(&#x27;&lt;a href=&quot;#&quot;&gt;超链接&lt;/a&gt;&#x27;)// 添加jQuery对象// 在父元素末尾添加$(&#x27;选择器&#x27;).append($a)// 在父元素开头添加$(&#x27;选择器&#x27;).prepend($a)// 在兄弟元素之前添加$(&#x27;选择器&#x27;).before($a)// 在兄弟元素之后添加$(&#x27;选择器&#x27;).after($a) 用法02-直接添加html结构 123456789// 直接添加html结构// 在父元素末尾添加$(&#x27;选择器&#x27;).append(&#x27;html结构&#x27;)// 在父元素开头添加$(&#x27;选择器&#x27;).prepend(&#x27;html结构&#x27;)// 在兄弟元素之前添加$(&#x27;选择器&#x27;).before(&#x27;html结构&#x27;)// 在兄弟元素之后添加$(&#x27;选择器&#x27;).after(&#x27;html结构&#x27;) 小结一下: append、prepend 以父元素为参考分别在结尾处和开头处添加新的元素节点 after、before 以当前元素为参考在之前或之后插入新的元素节点 append、prepend、after、before 均支持直接将 html 字符串做为节点插入 节点 - 删除在jQuery中如何删除节点呢? 不同于webapi中需要通过父元素才可以删除自己,jQuery中直接就可以把自己给删掉。 基础语法： 12// 删除自己（删掉html结构）$(&#x27;选择器&#x27;).remove(); 总结： remove 方法删除的是当前调用方法的元素节点 节点 - 克隆jQuery中如何基于现有的节点进行克隆(复制)呢? jQuery 中封装了复制（克隆）元素节点的方法，其用法如下代码所示： 123456&lt;script&gt; // 通过复制获得新的节点 拷贝事件 $(&#x27;选择器&#x27;).clone(true); // 通过复制获得新的节点 不拷贝事件 $(&#x27;选择器&#x27;).clone(false);&lt;/script&gt; 使用方式 123456789// 假设我们有一个需要复制的元素2var originalElement = $(&#x27;#someElement&#x27;);34// 通过复制获得新的节点，并保留事件处理（根据需要选择true或false）5var clonedElement = originalElement.clone(true);67// 然后你可以将这个复制的元素插入到DOM中的其他位置8// 例如，将其添加到某个元素的末尾9$(&#x27;#targetElement&#x27;).append(clonedElement); 在这个例子中： originalElement是我们想要复制的元素，通过ID选择器#someElement选取。 clonedElement变量存储了复制得到的新节点。 使用.append(clonedElement)将复制的节点添加到ID为targetElement的元素内部末尾。 总结： clone 方法复制得到的元素节点仍是 jQuery 对象 待复制的节点中如果有事件监听，需要为 clone 方法传入参数 true 6.事件委托jQuery中如何使用事件委托呢? jQuery 中封装了事件委托的支持，其用法如下代码所示： 1234// on 方法内置支持事件委托$(&#x27;祖先元素&#x27;).on(&#x27;事件名&#x27;, &#x27;后代选择器&#x27;, function () &#123; &#125;) 举个例子： 12345&lt;ul id=&quot;myList&quot;&gt; &lt;!-- 初始时可能有一些列表项，也可能没有 --&gt; &lt;li&gt;列表项 1&lt;/li&gt; &lt;li&gt;列表项 2&lt;/li&gt;&lt;/ul&gt; 12345678910111213$(document).ready(function()&#123; // 使用事件委托，为 &#x27;#myList&#x27; 下现在及将来所有的 &#x27;li&#x27; 元素绑定点击事件 $(&#x27;#myList&#x27;).on(&#x27;click&#x27;, &#x27;li&#x27;, function()&#123; alert(&#x27;你点击了: &#x27; + $(this).text()); // 这里的 &#x27;this&#x27; 指向实际触发事件的 li 元素 &#125;); // 假设后面动态添加一些 li setTimeout(function()&#123; $(&#x27;#myList&#x27;).append(&#x27;&lt;li&gt;新增列表项 3&lt;/li&gt;&#x27;); $(&#x27;#myList&#x27;).append(&#x27;&lt;li&gt;新增列表项 4&lt;/li&gt;&#x27;); &#125;, 2000); // 2秒后添加新项&#125;); 在这个例子中： &#39;#myList&#39; 是祖先元素，我们在此元素上设置监听器。 &#39;li&#39; 是后代选择器，指定了实际应该响应事件的目标元素。 当用户点击任何现有的或将来动态添加到 #myList 中的 li 元素时，都会触发这个点击事件处理器。 即使是在 setTimeout 函数中动态添加的 li，也会自动拥有点击事件处理功能，因为事件委托是基于当前的及未来的匹配元素来工作的。 总结： 事件委托需要为某个在 DOM 中已经存在的祖先元素添加事件监听 delegate 方法是 jQuery 中专门的事件委托的方法 on 方法中也内置支持事件委托，推荐使用 on 方法 jQuery第三部分1.入口函数 在jQ中的入口函数咋写呢，类似于window.onload但是不一样。 jQ中的写法 对比window.onload jQuery 中提供了更为简便的入口函数写法 在我们原生js中： window.onload的执行时机是页面资源加载完毕，包括dom元素解析完毕，外部的css，图片什么的也需要加载完毕，所以写在他内部的逻辑肯定可以获取到页面上的dom元素。 在jQ中的写法是这样的，基础语法 1$(windows).on(&#x27;load&#x27;,function()&#123;&#125;) jQ还提供了一个ready方法，完整的写法略微有点复杂,调用$方法然后把document传进去接着调用ready方法并传入回调函数,但是这里介绍较为简单的写法，两种写法的功能是一样的。 同样的功能还有一种更为简单的写法，直接在调用$方法的时候传入回调函数即可 基础语法： 1234//完整写法$(document).ready(function()&#123;&#125;)//简单写法 $(function()&#123;&#125;) 基于上面的这种写法，它能达到的功能是当dom载入完毕，即调用该函数 下面举一个例子，我们在head标签中写入一个盒子，写在这里如果修改盒子的样式，那么他是不会改变的，因为代码执行的时候dom元素还没加载呢！ 下面我们展示用window对象和jQ对象写法 12&lt;!-- 测试元素 --&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt; 12345678910111213141516171819//window对象window.onload = function () &#123; $(&#x27;.box&#x27;).css(&#x27;backgroundColor&#x27;, &#x27;orange&#x27;) &#125;//jQ的window对象写法 $(window).on(&#x27;load&#x27;, function () &#123; $(&#x27;.box&#x27;).css(&#x27;backgroundColor&#x27;, &#x27;skyblue&#x27;) &#125;)//jQ提供的ready方法 $(document).ready(function () &#123; $(&#x27;.box&#x27;).css(&#x27;backgroundColor&#x27;, &#x27;pink&#x27;) &#125;)//ready方法的简单写法 $(function () &#123; $(&#x27;.box&#x27;).css(&#x27;backgroundColor&#x27;, &#x27;deepskyblue&#x27;) &#125;) window.onload和ready哪个先执行 ready，因为ready只需要考虑dom元素加载完成，不需要考虑外部资源 window.onload和ready哪个可以获取图片尺寸 window.onload 开发中用哪个？ 看情况讨论 现在js都是在body底部载入，所以代码执行的时候dom元素都已经可以获取到了，这个时候用不用都是可以的。但是代码中如果要确保可以获取到图片的尺寸就需要用window.onload咯 2.轮播图插件–slick 轮播图作为一个非常常见的功能，有很多现成的插件，咱们来学习一下slick 轮播图插件 常用的功能封装成插件，直接使用即可 插件的含义用vscode插件讲解 jQuery插件的含义 插件使用套路 调整 配置调整 小圆点 箭头 样式调整 审查元素找到样式 直接覆盖 小结： slick是谁的插件？ jQuery，需要依赖于jQuery才可以执行 是否需要把用法和配置背下来？ 不需要，随用随查，结合翻译英文也不可怕 插件的样式可以调整吗？ 可以，直接用自己的样式覆盖默认的样式即可 那么轮播图具体要怎么写呢？ 下包：首先把需要使用的插件下载到本地 导包：jQuery的插件需要在jQ的后面导入，因为他依赖jQ，有的插件还需要用到css，根据需求导入就好！ 用包：根据文档提供的步骤使用它。 导包： 123 &lt;!-- 引入插件所需要的样式表 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/slick/slick.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/slick/slick-theme.css&quot;&gt; 建议使用插件的时候随查随用 3.懒加载插件 - lazyload这一节咱们来学习懒加载插件，名字叫做lazyload,作用是让图片的加载变的不那么迅速。从立刻加载变成看到了再去加载，这个功能在图片很多的网页用的较多，比如电商网站,像京东淘宝都有用呢。 既然是插件，那就是下包，导包，用包即可 这里示例导入包的代码 1234&lt;!-- 先导入jQueery --&gt;&lt;script src=&quot;./jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt;&lt;!-- 再导入lazyload插件 --&gt;&lt;script src=&quot;./assets/jquery.lazyload.min.js&quot;&gt;&lt;/script&gt; 用该插件的时候，有几个地方需要调整 将src换成data-original 然后通过选择器找到需要进行懒加载的图片，随后调用方法即可 12// 找到希望懒加载的图片并调用lazyload方法$(&#x27;.lazyload&#x27;).lazyload() 使用懒加载插件之后，看不到的图片会不会加载？ 不会，看到了才会加载 图片很多的网页用这个可以提升加载速度吗？ 可以，因为不会加载所有的图片，数据的传输量更小，在网速不变的情况下，加载的速度肯定会更快一些呢！ 4.fullpage插件fullpage，也是jQ的插件。他可以用来制作咱们平时在手机或者电脑上见过的那种全屏滚动的页面，这一类的页面主要的作用是营销或者推广。 同样三步走，下包，导包，用包 1234567&lt;!-- 导入 fullpage 配套样式 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;./fullpage/jquery.fullpage.css&quot; /&gt;&lt;!-- 导入 jQuery --&gt;&lt;script src=&quot;./jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt;&lt;!-- 在 jQuery 之后导入 fullpage 插件 --&gt;&lt;script src=&quot;./fullpage/jquery.fullpage.js&quot;&gt;&lt;/script&gt; 接下来是他的结构,外层的容器用个有意义的标记就好，比如id或者class都可以，内部就是每一屏的容器啦，每一屏要显示的内容放到对应的盒子里面就好，需要注意的是：每屏都必须有secion这个类名，如果有需求可以额外的添加其他的类名，但是这个必须存在哦 12345&lt;div id=&quot;fullpage&quot;&gt; &lt;div class=&quot;section&quot;&gt;第一屏&lt;/div&gt; &lt;div class=&quot;section&quot;&gt;第二屏&lt;/div&gt; &lt;div class=&quot;section&quot;&gt;第三屏&lt;/div&gt;&lt;/div&gt; 最后就是调用fullpage方法 12$(&#x27;#fullpage&#x27;).fullpage(&#123;&#125;) fullpage插件在使用的时候一定要传入配置吗？ 不一定，不传入任何的配置也有默认的功能 fullpage插件的区域容器一定要添加什么类名？ section，必须有这个类名，但是可以添加额外的类名 5.表单 - 提交事件示例表单： 12345678&lt;form&gt; &lt;input type=&quot;text&quot; placeholder=&quot;用户名&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;password&quot; placeholder=&quot;密码&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt; 绑定提交事件 12345$(&#x27;form&#x27;).submit(function (event) &#123; console.log(&#x27;submit&#x27;) event.preventDefault() return false&#125;) 使用场景：在输入完账号或者密码时进行账号密码的校验，已经提示错误等时候，需要弹出提示，这时就需要将表单提交行为的默认时间阻止了即可，然后再写需要的逻辑。 6.插件 - 日期选择器既然是插件，那就三步走，下包，导包，用包 这里示例： 123456789&lt;!-- 导入日期选择器的样式 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;./datepicker/datepicker.css&quot; /&gt;&lt;!-- 导入jQuery --&gt;&lt;script src=&quot;./jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt;&lt;!-- 导入日期选择器插件 --&gt;&lt;script src=&quot;./datepicker/datepicker.js&quot;&gt;&lt;/script&gt;&lt;!-- 导入语言包 --&gt;&lt;script src=&quot;./datepicker/i18n/datepicker.zh-CN.js&quot;&gt;&lt;/script&gt; 使用： 12345678&lt;!-- 准备html结构 --&gt;&lt;input type=&quot;text&quot; class=&quot;datapicker&quot; /&gt; // 调用插件方法 $(&#x27;.datapicker&#x27;).datepicker(&#123; //设置日期显示中文 language: &#x27;zh-CN&#x27;, &#125;) 设置选择完毕后自动关闭和自动设置 123456//传入配置项，这里传入了对象$(&#x27;.datapicker&#x27;).datepicker(&#123; language: &#x27;zh-CN&#x27;, autoPick: true, autoHide: true, &#125;) 插件默认显示的语言是中文还是英文? 英文 为了设置插件的语言为中文，需要导入什么? 中文语言包 7.插件 - 表单验证如何使用表单验证插件 业务场景：我们在注册的时候，如果用户名不填，或者密码强度不够，或者不勾选用户协议能不能注册呀？对啦，很明显是注册不了的，并且根据错误的不同会有与之对应的提示信息，这就是表单验证的功能。 既然是插件，那就三步走，下包，导包，用包 1234&lt;!-- 导入jQuery --&gt;&lt;script src=&quot;./jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt;&lt;!-- 导入validate插件 --&gt;&lt;script src=&quot;./jquery-validate/jquery-validate.js&quot;&gt;&lt;/script&gt; 123456&lt;input type=&quot;password&quot; name=&quot;password&quot; data-required data-pattern=&quot;.&#123;6,&#125;&quot;/&gt; 引入验证库：首先，确保您已经在项目中包含了所需的表单验证库或插件。这通常通过在HTML头部使用&lt;script&gt;标签或在项目依赖中导入来完成。 使用验证包：在您的JavaScript代码中，引入或创建一个实例来使用这个验证包。这是设置验证功能的基础。 选择表单元素：通过选择器（如jQuery的选择器、Vanilla JS的document.querySelector或类似的API）找到您想要进行验证的表单字段。 调用验证方法：选中表单元素后，调用验证库提供的validate方法。您可以传递多种配置选项，比如： 校验时机：指定何时触发验证（如提交时、失焦时等）。 表单提交控制：决定是否在验证失败时阻止表单提交。 回调函数：分别设置valid和invalid回调，用于处理验证成功或失败的情况。 显示错误信息：若需在页面上展示错误提示，可以通过设置表单元素的description属性或利用验证库提供的方法来实现。这部分内容会稍后详细说明。 定义验证规则： 直接在HTML的表单元素上使用自定义属性（如data-required、data-pattern）来指定验证规则。 data-required表示该字段为必填项。 data-pattern允许您通过正则表达式定义更复杂的格式要求。例如，data-pattern=&quot;.&#123;6,&#125;&quot;意味着该字段至少需要6个字符，且可包含任何字符。 表单结构：确保所有的表单元素都被正确地放置在&lt;form&gt;标签内，这是验证插件能够正常解析和工作的前提条件。 按照以上步骤操作，您就可以轻松地为网页表单添加数据验证逻辑了。记得，正则表达式的复杂度可能需要根据实际情况调整，不必一次性记住所有正则标记，可以逐步学习并应用 接下来介绍属性description data-describedby：设置的是信息显示的位置 data description：配置的是到底显示什么错误信息，需要和description中的属性对应。 除了这里需要对应，还有data-description也要对应上，比如下面 如果密码内容不填，会显示required的信息，如果填了但是不符合条件会线序pattern的信息 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;10-表单验证&lt;/title&gt; &lt;style&gt; body &#123; padding: 0 30px; &#125; p &#123; color: #333; &#125; ul &#123; padding: 0; list-style: none; &#125; li &#123; margin: 10px 0; &#125; span.error &#123; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 测试用标签 --&gt; &lt;form action=&quot;&quot;&gt; &lt;ul&gt; &lt;li&gt; 昵称: &lt;input data-required data-describedby=&quot;nickname-error&quot; data-description=&quot;nickname&quot; type=&quot;text&quot; name=&quot;nickname&quot; /&gt; &lt;span class=&quot;error&quot; id=&quot;nickname-error&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; 密码: &lt;input data-required data-pattern=&quot;.&#123;6,&#125;&quot; data-describedby=&quot;password-error&quot; data-description=&quot;password&quot; type=&quot;password&quot; name=&quot;password&quot; /&gt; &lt;span class=&quot;error&quot; id=&quot;password-error&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;label&gt; &lt;input data-required data-describedby=&quot;agree-error&quot; data-description=&quot;agree&quot; type=&quot;checkbox&quot; value=&quot;true&quot; name=&quot;agree&quot; /&gt; 同意注册协议 &lt;/label&gt; &lt;span class=&quot;error&quot; id=&quot;agree-error&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;button class=&quot;btn&quot;&gt;提交&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/form&gt; &lt;!-- 导入jQuery --&gt; &lt;script src=&quot;./jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt; &lt;!-- 导入 validate插件 --&gt; &lt;script src=&quot;./jquery-validate/jquery-validate.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&#x27;form&#x27;).validate(&#123; sendForm: false, description: &#123; password: &#123; required: &#x27;密码不能为空!&#x27;, pattern: &#x27;密码的长度必须大于等于6!&#x27; &#125;, nickname: &#123; required: &#x27;昵称不能为空!&#x27; &#125;, agree: &#123; required: &#x27;必须同意用户协议!&#x27; &#125; &#125;, valid () &#123; console.log(&#x27;验证成功&#x27;) &#125;, invalid () &#123; console.log(&#x27;验证失败&#x27;) &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 8.克隆学习jQuery中的克隆方法，他可以直接把一个jQuery对象拷贝一份，用法非常简单，直接调用clone方法即可，不需要传递任何参数就可以拷贝，如果希望连事件一起拷贝可以传入参数true. 返回的依旧是jQ对象 基本语法： 12//如果希望克隆时能够连带被克隆对象的事件。这里传入true参数，反正不需要克隆事件，则不传递参数即可$(&#x27;选择器(要克隆的对象)&#x27;).clone(); 克隆方法得到的是什么对象？ jQuery对象 希望事件一起克隆需要传递什么参数? true 9.获取dom对象jQ提供了很多便捷的方法，但是有些方法只有dom对象才有，如何将jQ对象转为dom对象呢？ 调用get方法传入索引。 二种是通过中括号的方式传入索引，索引是从0开始，获取到的都是dom对象，可以直接使用dom对象的那些方法 语法： 1234// get方法获取.get(索引)// 中括号获取[索引] 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;12-获取dom对象&lt;/title&gt; &lt;style&gt; p &#123; color: #333; &#125; video &#123; margin: 10px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 测试标签 播放器 --&gt; &lt;button class=&quot;play&quot;&gt;播放&lt;/button&gt; &lt;button class=&quot;pause&quot;&gt;暂停&lt;/button&gt; &lt;br /&gt; &lt;video src=&quot;./video/video.mp4&quot;&gt;&lt;/video&gt; &lt;!-- 测试标签 form --&gt; &lt;form action=&quot;&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;password&quot; placeholder=&quot;请输入密码&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;button&quot; class=&quot;reset&quot; value=&quot;重置&quot; /&gt; &lt;/form&gt; &lt;!-- 导入jQuery --&gt; &lt;script src=&quot;./jquery/jquery-3.5.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 1.get方法获取dom对象 let $btn = $(&#x27;button&#x27;) console.log(&#x27;$btn:&#x27;, $btn) let pauseBtn = $btn.get(1) console.log(&#x27;pauseBtn:&#x27;, pauseBtn) // 2. 中括号获取dom对象 let playBtn = $btn[0] console.log(&#x27;playBtn:&#x27;, playBtn) // 3. 播放视频 $(&#x27;.play&#x27;).click(function () &#123; //方式1 $(&#x27;video&#x27;).trigger(&#x27;play&#x27;) //方式1 let video = $(&#x27;video&#x27;)[0] console.log(&#x27;video:&#x27;, video) video.play() &#125;) // 4. 暂停视频 $(&#x27;.pause&#x27;).click(function () &#123; //方式1 $(&#x27;video&#x27;).trigger(&#x27;pause&#x27;) //方式2 let video = $(&#x27;video&#x27;)[0] console.log(&#x27;video:&#x27;, video) video.pause() &#125;) // 5. 重置表单 $(&#x27;.reset&#x27;).click(function () &#123; //方式1 $(&#x27;form&#x27;).trigger(&#x27;reset&#x27;) //方式2 let form = $(&#x27;form&#x27;)[0] console.log(&#x27;form:&#x27;, form) form.reset() &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 可以使用 [] 还有一个什么方法来获取dom对象？ get方法 索引从几开始? 从0开始 10.表单 - 序列化(快速获取form表单元素的value值)方法的名字叫做serialize，首先获取到form标签，然后就可以调用啦，他是一个jQ的方法，为了能够正常获取数据需要为表单元素设置name属性，否则可是拿不到的哦。 ​ 获取到的是一个字符串，格式很有规律 name1&#x3D;value1&amp;name2&#x3D;value2 基础语法： 12345678&lt;script&gt; $(&#x27;form&#x27;).submit(function () &#123; //基础用法 let data = $(this).serialize() console.log(&#x27;data:&#x27;, data) return false &#125;)&lt;/script&gt; serialize方法要能够获取到value值，表单元素要有什么属性? name属性 获取到的数据是什么格式?(对象，字符串) 字符串，key&#x3D;value&amp;key2&#x3D;value的格式，目前掌握语法即可，在之后的课程中会用到这个方法呢 11.工具方法$.each遍历数组，第一个参数传入数组，然后传入回调函数，数组有几项回调函数就会执行几次，每次遍历的时候会把数组的内容传递给回调函数，回调函数的第一个参数是数组的每一项，第二个参数是下标，我们就可以在回调函数里面获取并使用这些数据啦。 ​ 还可以通过$.map来基于现有数组生成新的数组，用法和each类似，但是在回调函数里面可以返回一个值，每次执行返回的结果最终会被放到一个新增数组中。 123456// 遍历数组$.each(数组, function (item, index) &#123;&#125;)// 遍历并返回新数组$.map(数组,function(item,index)&#123; // 返回新的值&#125;) 了解即可。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://example.com/tags/jQuery/"}]},{"title":"Vue3.js(组合式API)","slug":"Vue3","date":"2024-06-30T02:25:55.000Z","updated":"2024-09-12T11:12:13.947Z","comments":true,"path":"2024/06/30/Vue3/","permalink":"http://example.com/2024/06/30/Vue3/","excerpt":"","text":"vue脚手架 @vue&#x2F;cil是vue官方提供的一个全局模块包(得到vue命令)，此包用来创建vue脚手架项目 脚手架目录和代码分析 vue安装全局包全局安装@vue&#x2F;cil模块包 1yarn global add @vue/cli 查看是否安装成功 @vue&#x2F;cli创建项目1.创建项目 12# 创建项目vue create vuecli-demo 注意：项目名字中不能有大写字母。中文和特殊符号 2.开始创建，成功如下 3.进入项目文件输入yarn serve启动项目，浏览器输出如下代表成功 项目结构 创建一个 Vue3应用API——setup函数setup是Vue3中的一个新的配置项，值是一个函数，他是组合式API”表演的舞台”，组件中所用到所有数据，方法、计算属性、监视….等等，均配置在setup中 基本使用setup() 钩子是在组件中使用组合式 API 的入口，通常只在以下情况下使用： 需要在非单文件组件中使用组合式 API 时。 需要在基于选项式 API 的组件中集成基于组合式 API 的代码时。 注意 对于结合单文件组件使用的组合式 API，推荐通过 &#96;&#96; 以获得更加简洁及符合人体工程学的语法。 我们可以使用响应式 API 来声明响应式的状态，在 setup() 函数中返回的对象会暴露给模板和组件实例。其他的选项也可以通过组件实例来获取 setup() 暴露的属性： 12345678910111213141516171819202122&lt;script&gt;import &#123; ref &#125; from &#x27;vue&#x27;export default &#123; setup() &#123; const count = ref(0) // 返回值会暴露给模板和其他的选项式 API 钩子 return &#123; count &#125; &#125;, mounted() &#123; console.log(this.count) // 0 &#125;&#125;&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;count++&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt; setup() 自身并不含对组件实例的访问权，即在 setup() 中访问 this 会是 undefined。你可以在选项式 API 中访问组合式 API 暴露的值，但反过来则不行。 setup语法糖对于setup函数，我们最基本的用法是 12345678setup()&#123; //定义变量 let a =ref(10) //返回(暴露变量)return &#123; a &#125;&#125; 现在我引入setup语法糖，写法变得很简洁简单 12345&lt;script setup&gt; let a = ref(10) //写入一些函数...等等内容 .....&lt;/script&gt; 那么上面这种写法，就相当于最基本使用的写法，可以看到简洁了不少 应用实例每个 Vue 应用都是通过 createApp 函数创建一个新的 应用实例： 12345import &#123; createApp &#125; from &#x27;vue&#x27;const app = createApp(&#123; /* 根组件选项 */&#125;) 根组件我们传入 createApp 的对象实际上是一个组件，每个应用都需要一个“根组件”，其他组件将作为其子组件。 如果你使用的是单文件组件，我们可以直接从另一个文件中导入根组件。 12345import &#123; createApp &#125; from &#x27;vue&#x27;// 从一个单文件组件中导入根组件import App from &#x27;./App.vue&#x27;const app = createApp(App) 挂载应用应用实例必须在调用了 .mount() 方法后才会渲染出来。该方法接收一个“容器”参数，可以是一个实际的 DOM 元素或是一个 CSS 选择器字符串： 1&lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 1app.mount(&#x27;#app&#x27;) 应用根组件的内容将会被渲染在容器元素里面。容器元素自己将不会被视为应用的一部分 .mount() 方法应该始终在整个应用配置和资源注册完成后被调用。同时请注意，不同于其他资源注册方法，它的返回值是根组件实例而非应用实例。 模板语法Vue 使用一种基于 HTML 的模板语法，使我们能够声明式地将其组件实例的数据绑定到呈现的 DOM 上。所有的 Vue 模板都是语法层面合法的 HTML，可以被符合规范的浏览器和 HTML 解析器解析。 在底层机制中，Vue 会将模板编译成高度优化的 JavaScript 代码。结合响应式系统，当应用状态变更时，Vue 能够智能地推导出需要重新渲染的组件的最少数量，并应用最少的 DOM 操作。 如果你对虚拟 DOM 的概念比较熟悉，并且偏好直接使用 JavaScript，你也可以结合可选的 JSX 支持直接手写渲染函数而不采用模板。但请注意，这将不会享受到和模板同等级别的编译时优化。 文本插值最基本的数据绑定形式是文本插值，它使用的是“Mustache”语法 (即双大括号)： template 1&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; 双大括号标签会被替换为相应组件实例中 msg 属性的值。同时每次 msg 属性更改时它也会同步更新。 原始 HTML双大括号会将数据解释为纯文本，而不是 HTML。若想插入 HTML，你需要使用 v-html 指令： 12345&lt;script setup&gt; let rawHtml = &#x27;&lt;span style=&quot;color: red&quot;&gt;This should be red.&lt;/span&gt;&#x27;&lt;/script&gt;&lt;p&gt;Using text interpolation: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;&lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt; 1234//而使用vue中的&#123;&#123;&#125;&#125;不会渲染html，所以会显示纯文本Using text interpolation: &lt;span style=&quot;color: red&quot;&gt;This should be red.&lt;/span&gt;使用v-html会解析span标签，所以下面的会被渲染成红色Using v-html directive: This should be red. 这里我们遇到了一个新的概念。这里看到的 v-html attribute 被称为一个指令。指令由 v- 作为前缀，表明它们是一些由 Vue 提供的特殊 attribute，你可能已经猜到了，它们将为渲染的 DOM 应用特殊的响应式行为。这里我们做的事情简单来说就是：在当前组件实例上，将此元素的 innerHTML 与 rawHtml 属性保持同步。 span 的内容将会被替换为 rawHtml 属性的值，插值为纯 HTML——数据绑定将会被忽略。注意，你不能使用 v-html 来拼接组合模板，因为 Vue 不是一个基于字符串的模板引擎。在使用 Vue 时，应当使用组件作为 UI 重用和组合的基本单元。 Attribute 绑定双大括号不能在 HTML attributes 中使用。想要响应式地绑定一个 attribute，应该使用 v-bind 指令： 1&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt; v-bind 指令指示 Vue 将元素的 id attribute 与组件的 dynamicId 属性保持一致。如果绑定的值是 null 或者 undefined，那么该 attribute 将会从渲染的元素上移除。 简写因为 v-bind 非常常用，我们提供了特定的简写语法： 1&lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt; 开头为 : 的 attribute 可能和一般的 HTML attribute 看起来不太一样，但它的确是合法的 attribute 名称字符，并且所有支持 Vue 的浏览器都能正确解析它。此外，他们不会出现在最终渲染的 DOM 中。简写语法是可选的，但相信在你了解了它更多的用处后，你应该会更喜欢它。 同名简写 (要求vue版本为3.4+)如果 attribute 的名称与绑定的 JavaScript 值的名称相同，那么可以进一步简化语法，省略 attribute 值： 12345&lt;!-- 与 :id=&quot;id&quot; 相同 --&gt;&lt;div :id&gt;&lt;/div&gt;&lt;!-- 这也同样有效 --&gt;&lt;div v-bind:id&gt;&lt;/div&gt; 这与在 JavaScript 中声明对象时使用的属性简写语法类似。请注意，这是一个只在 Vue 3.4 及以上版本中可用的特性。 布尔型 Attribute布尔型 attribute 依据 true &#x2F; false 值来决定 attribute 是否应该存在于该元素上。disabled 就是最常见的例子之一。 v-bind 在这种场景下的行为略有不同： 1&lt;button :disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt; 当 isButtonDisabled 为真值或一个空字符串 (即 &lt;button disabled=&quot;&quot;&gt;) 时，元素会包含这个 disabled attribute。而当其为其他假值时 attribute 将被忽略。 动态绑定多个值如果你有像这样的一个包含多个 attribute 的 JavaScript 对象： 1const objectOfAttrs = &#123; id: &#x27;container&#x27;, class: &#x27;wrapper&#x27; &#125; 通过不带参数的 v-bind，你可以将它们绑定到单个元素上： 1&lt;div v-bind=&quot;objectOfAttrs&quot;&gt;&lt;/div&gt; 使用 JavaScript 表达式至此，我们仅在模板中绑定了一些简单的属性名。但是 Vue 实际上在所有的数据绑定中都支持完整的 JavaScript 表达式： 1234567&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;div :id=&quot;`list-$&#123;id&#125;`&quot;&gt;&lt;/div&gt; 这些表达式都会被作为 JavaScript ，以当前组件实例为作用域解析执行。 在 Vue 模板内，JavaScript 表达式可以被使用在如下场景上： 在文本插值中 (双大括号) 在任何 Vue 指令 (以 v- 开头的特殊 attribute) attribute 的值中 仅支持表达式每个绑定仅支持单一表达式，也就是一段能够被求值的 JavaScript 代码。一个简单的判断方法是是否可以合法地写在 return 后面。 12345&lt;!-- 这是一个语句，而非表达式 --&gt;&#123;&#123; var a = 1 &#125;&#125;&lt;!-- 条件控制也不支持，请使用三元表达式 --&gt;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125; 调用函数可以在绑定的表达式中使用一个组件暴露的方法： 123&lt;time :title=&quot;toTitleDate(date)&quot; :datetime=&quot;date&quot;&gt; &#123;&#123; formatDate(date) &#125;&#125;&lt;/time&gt; 指令 Directives指令是带有 v- 前缀的特殊 attribute。Vue 提供了许多内置指令，包括上面我们所介绍的 v-bind 和 v-html。 指令 attribute 的期望值为一个 JavaScript 表达式 (除了少数几个例外，即之后要讨论到的 v-for、v-on 和 v-slot)。一个指令的任务是在其表达式的值变化时响应式地更新 DOM。以 v-if 为例： 1&lt;p v-if=&quot;seen&quot;&gt;Now you see me&lt;/p&gt; 这里，v-if 指令会基于表达式 seen 的值的真假来移除&#x2F;插入该 &lt;p&gt; 元素。 参数 Arguments某些指令会需要一个“参数”，在指令名后通过一个冒号隔开做标识。例如用 v-bind 指令来响应式地更新一个 HTML attribute： 1234&lt;a v-bind:href=&quot;url&quot;&gt; ... &lt;/a&gt;&lt;!-- 简写 --&gt;&lt;a :href=&quot;url&quot;&gt; ... &lt;/a&gt; 这里 href 就是一个参数，它告诉 v-bind 指令将表达式 url 的值绑定到元素的 href attribute 上。在简写中，参数前的一切 (例如 v-bind:) 都会被缩略为一个 : 字符。 另一个例子是 v-on 指令，它将监听 DOM 事件： 1234&lt;a v-on:click=&quot;doSomething&quot;&gt; ... &lt;/a&gt;&lt;!-- 简写 --&gt;&lt;a @click=&quot;doSomething&quot;&gt; ... &lt;/a&gt; 这里的参数是要监听的事件名称：click。v-on 有一个相应的缩写，即 @ 字符。我们之后也会讨论关于事件处理的更多细节。 动态参数同样在指令参数上也可以使用一个 JavaScript 表达式，需要包含在一对方括号内： 12345678&lt;!--注意，参数表达式有一些约束，参见下面“动态参数值的限制”与“动态参数语法的限制”章节的解释--&gt;&lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;&lt;!-- 简写 --&gt;&lt;a :[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt; 这里的 attributeName 会作为一个 JavaScript 表达式被动态执行，计算得到的值会被用作最终的参数。举例来说，如果你的组件实例有一个数据属性 attributeName，其值为 &quot;href&quot;，那么这个绑定就等价于 v-bind:href。 相似地，你还可以将一个函数绑定到动态的事件名称上： 1234&lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;&lt;!-- 简写 --&gt;&lt;a @[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt; 在此示例中，当 eventName 的值是 &quot;focus&quot; 时，v-on:[eventName] 就等价于 v-on:focus。 1234&lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;&lt;!-- 简写 --&gt;&lt;a @[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt; 在此示例中，当 eventName 的值是 &quot;focus&quot; 时，v-on:[eventName] 就等价于 v-on:focus。 动态参数值的限制动态参数中表达式的值应当是一个字符串，或者是 null。特殊值 null 意为显式移除该绑定。其他非字符串的值会触发警告。 动态参数语法的限制动态参数表达式因为某些字符的缘故有一些语法限制，比如空格和引号，在 HTML attribute 名称中都是不合法的。例如下面的示例： 12&lt;!-- 这会触发一个编译器警告 --&gt;&lt;a :[&#x27;foo&#x27; + bar]=&quot;value&quot;&gt; ... &lt;/a&gt; 如果你需要传入一个复杂的动态参数，我们推荐使用计算属性替换复杂的表达式，也是 Vue 最基础的概念之一，我们很快就会讲到。 当使用 DOM 内嵌模板 (直接写在 HTML 文件里的模板) 时，我们需要避免在名称中使用大写字母，因为浏览器会强制将其转换为小写： 1&lt;a :[someAttr]=&quot;value&quot;&gt; ... &lt;/a&gt; 上面的例子将会在 DOM 内嵌模板中被转换为 :[someattr]。如果你的组件拥有 “someAttr” 属性而非 “someattr”，这段代码将不会工作。单文件组件内的模板不受此限制。 修饰符 Modifiers修饰符是以点开头的特殊后缀，表明指令需要以一些特殊的方式被绑定。例如 .prevent 修饰符会告知 v-on 指令对触发的事件调用 event.preventDefault()来阻止默认行为： 1&lt;form @submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt; 之后在讲到 v-on 和 v-model 的功能时，你将会看到其他修饰符的例子。 最后，在这里你可以直观地看到完整的指令语法： 响应式基础声明响应式状态ref()在组合式 API 中，推荐使用 ref() 函数来声明响应式状态： 语法：let xxx &#x3D; ref(初始值) 1234//引入ref函数import &#123; ref &#125; from &#x27;vue&#x27;const count = ref(0) ref() 接收参数，并将其包裹在一个带有 .value 属性的 ref 对象中返回： 1234567const count = ref(0)console.log(count) // &#123; value: 0 &#125;console.log(count.value) // 0count.value++console.log(count.value) // 1 要在组件模板中访问 ref，请从组件的 setup() 函数中声明并返回它们： 12345678910111213import &#123; ref &#125; from &#x27;vue&#x27;export default &#123; // `setup` 是一个特殊的钩子，专门用于组合式 API。 setup() &#123; const count = ref(0) // 将 ref 暴露给模板 return &#123; count &#125; &#125;&#125; 1&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; 注意： 在模板中使用 ref 时，我们不需要附加 .value。为了方便起见，当在模板中使用时，ref 会自动解包 在JS中操作模板中的数据时，需要xxx.value,而模板直接使用即可 比如对于 let name &#x3D; ref(‘张三’)来说,name 不是响应式的,name.value 是响应式的。 ref定义的是基本类型数据，也可以定义数据类型 reactive()特别强调：reactive()只能定义对象类型响应式数据 还有另一种声明响应式状态的方式，即使用 reactive() API。与将内部值包装在特殊对象中的 ref 不同，reactive() 将使对象本身具有响应性： 1234567891011&lt;script setup&gt; //定义对象类型响应式数据 let car = reactive(&#123; brand:&#x27;奔驰&#x27;, price:100 &#125;) function changePrice()&#123; car.price+=10 &#125;&lt;/script&gt; 在模板中使用： 1234&lt;div class=&quot;test&quot;&gt; 车的型号是：&#123;&#123; car.brand &#125;&#125;,车的价格是:&#123;&#123; car.price &#125;&#125;万 &lt;button @click=&quot;changePrice&quot;&gt;改变车的价格&lt;/button&gt;&lt;/div&gt; ref()对比reactive() reactive() 的局限性reactive() API 有一些局限性： 有限的值类型：它只能用于对象类型 (对象、数组和如 Map、Set 这样的集合类型)。它不能持有如 string、number 或 boolean 这样的原始类型。 不能替换整个对象：由于 Vue 的响应式跟踪是通过属性访问实现的，因此我们必须始终保持对响应式对象的相同引用。这意味着我们不能轻易地“替换”响应式对象，因为这样的话与第一个引用的响应性连接将丢失 对解构操作不友好：当我们将响应式对象的原始类型属性解构为本地变量时，或者将该属性传递给函数时，我们将丢失响应性连接 由于这些限制，我们建议使用 ref() 作为声明响应式状态的主要 API。 toRefs和toReftoRefs可以把一个由reactive代理的响应式对象里面的每一个Key-value变成由ref代理的响应式数据 图解： 声明方法要为组件添加方法，我们需要用到 methods 选项。它应该是一个包含所有方法的对象： 12345678910111213141516export default &#123; data() &#123; return &#123; count: 0 &#125; &#125;, methods: &#123; increment() &#123; this.count++ &#125; &#125;, mounted() &#123; // 在其他方法或是生命周期中也可以调用方法 this.increment() &#125;&#125; Vue 自动为 methods 中的方法绑定了永远指向组件实例的 this。这确保了方法在作为事件监听器或回调函数时始终保持正确的 this。你不应该在定义 methods 时使用箭头函数，因为箭头函数没有自己的 this 上下文。 1234567export default &#123; methods: &#123; increment: () =&gt; &#123; // 反例：无法访问此处的 `this`! &#125; &#125;&#125; 和组件实例上的其他属性一样，方法也可以在模板上被访问。在模板中它们常常被用作事件监听器： 1&lt;button @click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt; 在上面的例子中，increment 方法会在 &lt;button&gt; 被点击时调用。 深层响应性在 Vue 中，默认情况下，状态是深度响应的。这意味着当改变嵌套对象或数组时，这些变化也会被检测到： 1234567891011121314151617export default &#123; data() &#123; return &#123; obj: &#123; nested: &#123; count: 0 &#125;, arr: [&#x27;foo&#x27;, &#x27;bar&#x27;] &#125; &#125; &#125;, methods: &#123; mutateDeeply() &#123; // 以下都会按照期望工作 this.obj.nested.count++ this.obj.arr.push(&#x27;baz&#x27;) &#125; &#125;&#125; DOM 更新时机当你修改了响应式状态时，DOM 会被自动更新。但是需要注意的是，DOM 更新不是同步的。Vue 会在“next tick”更新周期中缓冲所有状态的修改，以确保不管你进行了多少次状态修改，每个组件都只会被更新一次。 要等待 DOM 更新完成后再执行额外的代码，可以使用 nextTick() 全局 API： 1234567891011import &#123; nextTick &#125; from &#x27;vue&#x27;export default &#123; methods: &#123; async increment() &#123; this.count++ await nextTick() // 现在 DOM 已经更新了 &#125; &#125;&#125; 有状态方法在某些情况下，我们可能需要动态地创建一个方法函数，比如创建一个预置防抖的事件处理器： 12345678910import &#123; debounce &#125; from &#x27;lodash-es&#x27;export default &#123; methods: &#123; // 使用 Lodash 的防抖函数 click: debounce(function () &#123; // ... 对点击的响应 ... &#125;, 500) &#125;&#125; 不过这种方法对于被重用的组件来说是有问题的，因为这个预置防抖的函数是有状态的：它在运行时维护着一个内部状态。如果多个组件实例都共享这同一个预置防抖的函数，那么它们之间将会互相影响。 要保持每个组件实例的防抖函数都彼此独立，我们可以改为在 created 生命周期钩子中创建这个预置防抖的函数： 12345678910111213141516export default &#123; created() &#123; // 每个实例都有了自己的预置防抖的处理函数 this.debouncedClick = _.debounce(this.click, 500) &#125;, unmounted() &#123; // 最好是在组件卸载时 // 清除掉防抖计时器 this.debouncedClick.cancel() &#125;, methods: &#123; click() &#123; // ... 对点击的响应 ... &#125; &#125;&#125; 计算属性基础示例模板中的表达式虽然方便，但也只能用来做简单的操作。如果在模板中写太多逻辑，会让模板变得臃肿，难以维护。比如说，我们有这样一个包含嵌套数组的对象： 12345678const author = reactive(&#123; name: &#x27;John Doe&#x27;, books: [ &#x27;Vue 2 - Advanced Guide&#x27;, &#x27;Vue 3 - Basic Guide&#x27;, &#x27;Vue 4 - The Mystery&#x27; ]&#125;) 我们想根据 author 是否已有一些书籍来展示不同的信息： 12&lt;p&gt;Has published books:&lt;/p&gt;&lt;span&gt;&#123;&#123; author.books.length &gt; 0 ? &#x27;Yes&#x27; : &#x27;No&#x27; &#125;&#125;&lt;/span&gt; 这里的模板看起来有些复杂。我们必须认真看好一会儿才能明白它的计算依赖于 author.books。更重要的是，如果在模板中需要不止一次这样的计算，我们可不想将这样的代码在模板里重复好多遍。 因此我们推荐使用计算属性来描述依赖响应式状态的复杂逻辑。这是重构后的示例： 12345678910111213141516171819202122&lt;script setup&gt;import &#123; reactive, computed &#125; from &#x27;vue&#x27;const author = reactive(&#123; name: &#x27;John Doe&#x27;, books: [ &#x27;Vue 2 - Advanced Guide&#x27;, &#x27;Vue 3 - Basic Guide&#x27;, &#x27;Vue 4 - The Mystery&#x27; ]&#125;)// 一个计算属性 refconst publishedBooksMessage = computed(() =&gt; &#123; return author.books.length &gt; 0 ? &#x27;Yes&#x27; : &#x27;No&#x27;&#125;)&lt;/script&gt;&lt;template&gt; &lt;p&gt;Has published books:&lt;/p&gt; &lt;span&gt;&#123;&#123; publishedBooksMessage &#125;&#125;&lt;/span&gt;&lt;/template&gt; 123&lt;p&gt;Has published books:&lt;/p&gt;&lt;!--我们的计算属性publishedBooksMessage()返回了臃肿的表达式，而我们在使用时直接使用计算属性的名称即可--&gt;&lt;span&gt;&#123;&#123; publishedBooksMessage &#125;&#125;&lt;/span&gt; 我们在这里定义了一个计算属性 publishedBooksMessage。 更改此应用的 data 中 books 数组的值后，可以看到 publishedBooksMessage 也会随之改变。 在模板中使用计算属性的方式和一般的属性并无二致。Vue 会检测到 this.publishedBooksMessage 依赖于 this.author.books，所以当 this.author.books 改变时，任何依赖于 this.publishedBooksMessage 的绑定都将同时更新。 计算属性缓存 vs 方法你可能注意到我们在表达式中像这样调用一个函数也会获得和计算属性相同的结果： 1&lt;p&gt;&#123;&#123; calculateBooksMessage() &#125;&#125;&lt;/p&gt; 1234// 组件中function calculateBooksMessage() &#123; return author.books.length &gt; 0 ? &#x27;Yes&#x27; : &#x27;No&#x27;&#125; 若我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的，然而，不同之处在于计算属性值会基于其响应式依赖被缓存。一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要 author.books 不改变，无论多少次访问 publishedBooksMessage 都会立即返回先前的计算结果，而不用重复执行 getter 函数。 这也解释了为什么下面的计算属性永远不会更新，因为 Date.now() 并不是一个响应式依赖： js 1const now = computed(() =&gt; Date.now()) Class 与 Style 绑定数据绑定的一个常见需求场景是操纵元素的 CSS class 列表和内联样式。因为 class 和 style 都是 attribute，我们可以和其他 attribute 一样使用 v-bind 将它们和动态的字符串绑定。但是，在处理比较复杂的绑定时，通过拼接生成字符串是麻烦且易出错的。因此，Vue 专门为 class 和 style 的 v-bind 用法提供了特殊的功能增强。除了字符串外，表达式的值也可以是对象或数组。 绑定 HTML class绑定对象我们可以给 :class (v-bind:class 的缩写) 传递一个对象来动态切换 class： 1&lt;div :class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt; 上面的语法表示 active 是否存在取决于数据属性 isActive 的真假值。 你可以在对象中写多个字段来操作多个 class。此外，:class 指令也可以和一般的 class attribute 共存。举例来说，下面这样的状态： 12const isActive = ref(true)const hasError = ref(false) 1234&lt;div class=&quot;static&quot; :class=&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;&gt;&lt;/div&gt; 这将渲染： 1&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt; 当 isActive 或者 hasError 改变时，class 列表会随之更新。举例来说，如果 hasError 变为 true，class 列表也会变成 &quot;static active text-danger&quot;。 还可以写成下面这样 123456const classObject = reactive(&#123; active: true, &#x27;text-danger&#x27;: false&#125;)//模板中写&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt; 这将渲染： 1&lt;div class=&quot;active&quot;&gt;&lt;/div&gt; 我们也可以绑定一个返回对象的计算属性。这是一个常见且很有用的技巧： 1234567891011121314data() &#123; return &#123; isActive: true, error: null &#125;&#125;,computed: &#123; classObject() &#123; return &#123; active: this.isActive &amp;&amp; !this.error, &#x27;text-danger&#x27;: this.error &amp;&amp; this.error.type === &#x27;fatal&#x27; &#125; &#125;&#125; 1&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt; 绑定数组我们可以给 :class 绑定一个数组来渲染多个 CSS class： 123456data() &#123; return &#123; activeClass: &#x27;active&#x27;, errorClass: &#x27;text-danger&#x27; &#125;&#125; 1&lt;div :class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt; 渲染的结果是： 1&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt; 如果你也想在数组中有条件地渲染某个 class，你可以使用三元表达式： 1&lt;div :class=&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;&gt;&lt;/div&gt; errorClass 会一直存在，但 activeClass 只会在 isActive 为真时才存在。 然而，这可能在有多个依赖条件的 class 时会有些冗长。因此也可以在数组中嵌套对象： 1&lt;div :class=&quot;[&#123; activeClass: isActive &#125;, errorClass]&quot;&gt;&lt;/div&gt; 在组件上使用对于只有一个根元素的组件，当你使用了 class attribute 时，这些 class 会被添加到根元素上并与该元素上已有的 class 合并。 举例来说，如果你声明了一个组件名叫 MyComponent，模板如下： 12&lt;!-- 子组件模板 --&gt;&lt;p class=&quot;foo bar&quot;&gt;Hi!&lt;/p&gt; 在使用时添加一些 class： 12&lt;!-- 在使用组件时 --&gt;&lt;MyComponent class=&quot;baz boo&quot; /&gt; 渲染出的 HTML 为： 1&lt;p class=&quot;foo bar baz boo&quot;&gt;Hi!&lt;/p&gt; Class 的绑定也是同样的： 1&lt;MyComponent :class=&quot;&#123; active: isActive &#125;&quot; /&gt; 当 isActive 为真时，被渲染的 HTML 会是： 1&lt;p class=&quot;foo bar active&quot;&gt;Hi!&lt;/p&gt; 如果你的组件有多个根元素，你将需要指定哪个根元素来接收这个 class。你可以通过组件的 $attrs 属性来指定接收的元素： 123&lt;!-- MyComponent 模板使用 $attrs 时 --&gt;&lt;p :class=&quot;$attrs.class&quot;&gt;Hi!&lt;/p&gt;&lt;span&gt;This is a child component&lt;/span&gt; 1&lt;MyComponent class=&quot;baz&quot; /&gt; 这将被渲染为： 12&lt;p class=&quot;baz&quot;&gt;Hi!&lt;/p&gt;&lt;span&gt;This is a child component&lt;/span&gt; 绑定内联样式绑定对象:style 支持绑定 JavaScript 对象值，对应的是 HTML 元素的 style 属性： 123456data() &#123; return &#123; activeColor: &#x27;red&#x27;, fontSize: 30 &#125;&#125; 1&lt;div :style=&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt; 直接绑定一个样式对象通常是一个好主意，这样可以使模板更加简洁： 12345678data() &#123; return &#123; styleObject: &#123; color: &#x27;red&#x27;, fontSize: &#x27;13px&#x27; &#125; &#125;&#125; 同样的，如果样式对象需要更复杂的逻辑，也可以使用返回样式对象的计算属性。 绑定数组我们还可以给 :style 绑定一个包含多个样式对象的数组。这些对象会被合并后渲染到同一元素上： 12&lt;!-- 测试绑定数组 --&gt;&lt;p :style=&quot;[arrStyle,arrStyle1]&quot;&gt;测试绑定数组&lt;/p&gt; 123456789101112data()&#123; return &#123; //arrStyle arrStyle:&#123; color:&#x27;blue&#x27;, fontSize:&#x27;60px&#x27; &#125;, arrStyle1:&#123; backgroundColor:&#x27;red&#x27; &#125; &#125;&#125; 自动前缀当你在 :style 中使用了需要浏览器特殊前缀的 CSS 属性时，Vue 会自动为他们加上相应的前缀。Vue 是在运行时检查该属性是否支持在当前浏览器中使用。如果浏览器不支持某个属性，那么将尝试加上各个浏览器特殊前缀，以找到哪一个是被支持的。 样式多值1&lt;div :style=&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;&gt;&lt;/div&gt; 数组仅会渲染浏览器支持的最后一个值。在这个示例中，在支持不需要特别前缀的浏览器中都会渲染为 display: flex。 条件渲染v-ifv-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回真值时才被渲染。 v-else你也可以使用 v-else 为 v-if 添加一个“else 区块”。 1234567891011121314151617&lt;script&gt;export default &#123; data() &#123; return &#123; awesome: true &#125; &#125;&#125;&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;awesome = !awesome&quot;&gt;切换awesome真假值&lt;/button&gt; &lt;!-- 如果真，则显示下面的内容 --&gt; &lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt; &lt;!-- 否则，显示下面的内容 --&gt; &lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;&lt;/template&gt; 注意：一个 v-else 元素必须跟在一个 v-if 或者 v-else-if 元素后面，否则它将不会被识别。 v-else-if顾名思义，v-else-if 提供的是相应于 v-if 的“else if 区块”。它可以连续多次重复使用： 123456789101112&lt;div v-if=&quot;type === &#x27;A&#x27;&quot;&gt; A&lt;/div&gt;&lt;div v-else-if=&quot;type === &#x27;B&#x27;&quot;&gt; B&lt;/div&gt;&lt;div v-else-if=&quot;type === &#x27;C&#x27;&quot;&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; 和 v-else 类似，一个使用 v-else-if 的元素必须紧跟在一个 v-if 或一个 v-else-if 元素后面。 &lt;template&gt; 上的 v-if12345&lt;template v-if=&quot;ok&quot;&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt; 1234567891011121314151617181920212223242526&lt;script&gt;export default &#123; data() &#123; return &#123; type:true &#125; &#125;, methods:&#123; changeTypeValue()&#123; this.type = !this.type &#125; &#125;&#125;&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;changeTypeValue&quot;&gt; 切换模板显示/隐藏&lt;/button&gt;&lt;template v-if=&quot;type == true&quot;&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt; v-else 和 v-else-if 也可以在 &lt;template&gt; 上使用。 v-show另一个可以用来按条件显示一个元素的指令是 v-show。其用法基本一样： 1&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt; 不同之处在于 v-show 会在 DOM 渲染中保留该元素；v-show 仅切换了该元素上名为 display 的 CSS 属性。 v-show 不支持在 &lt;template&gt; 元素上使用，也不能和 v-else 搭配使用。 v-if 对比 v-showv-if 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。 v-if 也是惰性的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。 相比之下，v-show 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS display 属性会被切换。 总的来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 v-show 较好；如果在运行时绑定条件很少改变，则 v-if 会更合适。 v-if 和 v-for当 v-if 和 v-for 同时存在于一个元素上的时候，v-if 会首先被执行。提醒：不推荐同时使用v-if 和 v-for二者优先级不同 列表渲染v-for我们可以使用 v-for 指令基于一个数组来渲染一个列表。v-for 指令的值需要使用 item in items 形式的特殊语法，其中 items 是要渲染的数组，而 item 是迭代项的别名： 12345data() &#123; return &#123; items: [&#123; message: &#x27;Foo&#x27; &#125;, &#123; message: &#x27;Bar&#x27; &#125;] &#125;&#125; 123&lt;li v-for=&quot;item in items&quot;&gt; &#123;&#123; item.message &#125;&#125;&lt;/li&gt; 完整代码 12345678910111213141516&lt;script&gt;export default &#123; data() &#123; return &#123; parentMessage: &#x27;Parent&#x27;, items: [&#123; message: &#x27;Foo&#x27; &#125;, &#123; message: &#x27;Bar&#x27; &#125;] &#125; &#125;&#125;&lt;/script&gt;&lt;template&gt; &lt;li v-for=&quot;(item, index) in items&quot;&gt; &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/template&gt; v-for 变量的作用域和下面的 JavaScript 代码很类似： 12345678910const parentMessage = &#x27;Parent&#x27;const items = [ /* ... */]items.forEach((item, index) =&gt; &#123; // 可以访问外层的 `parentMessage` // 而 `item` 和 `index` 只在这个作用域可用 console.log(parentMessage, item.message, index)&#125;) 上面说明：V-for这个指令中的变量只能在该指令内使用。 注意 v-for 是如何对应 forEach 回调的函数签名的。实际上，你也可以在定义 v-for 的变量别名时使用解构，和解构函数参数类似： 12345678&lt;li v-for=&quot;&#123; message &#125; in items&quot;&gt; &#123;&#123; message &#125;&#125;&lt;/li&gt;&lt;!-- 有 index 索引时 --&gt;&lt;li v-for=&quot;(&#123; message &#125;, index) in items&quot;&gt; &#123;&#123; message &#125;&#125; &#123;&#123; index &#125;&#125;&lt;/li&gt; 对于多层嵌套的 v-for，作用域的工作方式和函数的作用域很类似。每个 v-for 作用域都可以访问到父级作用域： 12345&lt;li v-for=&quot;item in items&quot;&gt; &lt;span v-for=&quot;childItem in item.children&quot;&gt; &#123;&#123; item.message &#125;&#125; &#123;&#123; childItem &#125;&#125; &lt;/span&gt;&lt;/li&gt; span标签的v-for是li标签v-for的儿子，所以span中可以访问到li标签中的item 你也可以使用 of 作为分隔符来替代 in，这更接近 JavaScript 的迭代器语法： 1&lt;div v-for=&quot;item of items&quot;&gt;&lt;/div&gt; v-for 与对象你也可以使用 v-for 来遍历一个对象的所有属性。遍历的顺序会基于对该对象调用 Object.keys() 的返回值来决定。 123456789data() &#123; return &#123; myObject: &#123; title: &#x27;How to do lists in Vue&#x27;, author: &#x27;Jane Doe&#x27;, publishedAt: &#x27;2016-04-10&#x27; &#125; &#125;&#125; 12345&lt;ul&gt; &lt;li v-for=&quot;value in myObject&quot;&gt; &#123;&#123; value &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 看下效果 可以通过提供第二个参数表示属性名 (例如 key)： 123&lt;li v-for=&quot;(value, key) in myObject&quot;&gt; &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/li&gt; 看下效果 第三个参数表示位置索引： 123&lt;li v-for=&quot;(value, key, index) in myObject&quot;&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/li&gt; 看下效果 在 v-for 里使用范围值v-for 可以直接接受一个整数值。在这种用例中，会将该模板基于 1...n 的取值范围重复多次。 1&lt;span v-for=&quot;n in 102&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/span&gt; 注意此处 n 的初值是从 1 开始而非 0。 &lt;template&gt; 上的 v-for与模板上的 v-if 类似，你也可以在 &lt;template&gt; 标签上使用 v-for 来渲染一个包含多个元素的块。例如： 1234567891011121314151617181920&lt;script&gt;export default &#123; data() &#123; return &#123; items:[&#123; msg:&#x27;你好&#x27;, &#125;] &#125; &#125;&#125;&lt;/script&gt;&lt;template&gt;&lt;ul&gt; &lt;template v-for=&quot;item in items&quot;&gt; &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;li class=&quot;divider&quot; role=&quot;presentation&quot;&gt;&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt;&lt;/template&gt; v-for 与 v-if当它们同时存在于一个节点上时，v-if 比 v-for 的优先级更高。这意味着 v-if 的条件将无法访问到 v-for 作用域内定义的变量别名： 1234567&lt;!-- 这会抛出一个错误，因为属性 todo 此时 没有在该实例上定义--&gt;&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt; &#123;&#123; todo.name &#125;&#125;&lt;/li&gt; 在外先包装一层 &lt;template&gt; 再在其上使用 v-for 可以解决这个问题 (这也更加明显易读)： 12345&lt;template v-for=&quot;todo in todos&quot;&gt; &lt;li v-if=&quot;!todo.isComplete&quot;&gt; &#123;&#123; todo.name &#125;&#125; &lt;/li&gt;&lt;/template&gt; 通过 key 管理状态Vue 默认按照“就地更新”的策略来更新通过 v-for 渲染的元素列表。当数据项的顺序改变时，Vue 不会随之移动 DOM 元素的顺序，而是就地更新每个元素，确保它们在原本指定的索引位置上渲染。 默认模式是高效的，但只适用于列表渲染输出的结果不依赖子组件状态或者临时 DOM 状态 (例如表单输入值) 的情况。 为了给 Vue 一个提示，以便它可以跟踪每个节点的标识，从而重用和重新排序现有的元素，你需要为每个元素对应的块提供一个唯一的 key 属性： 123&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt; &lt;!-- 内容 --&gt;&lt;/div&gt; 当你使用 &lt;template v-for&gt; 时，key 应该被放置在这个 &lt;template&gt; 容器上： 123&lt;template v-for=&quot;todo in todos&quot; :key=&quot;todo.name&quot;&gt; &lt;li&gt;&#123;&#123; todo.name &#125;&#125;&lt;/li&gt;&lt;/template&gt; 推荐在任何可行的时候为 v-for 提供一个 key attribute，除非所迭代的 DOM 内容非常简单 (例如：不包含组件或有状态的 DOM 元素)，或者你想有意采用默认行为来提高性能。 key 绑定的值期望是一个基础类型的值，例如字符串或 number 类型。不要用对象作为 v-for 的 key。 组件上使用 v-for我们可以直接在组件上使用 v-for，和在一般的元素上使用没有区别 (别忘记提供一个 key)： 1&lt;MyComponent v-for=&quot;item in items&quot; :key=&quot;item.id&quot; /&gt; 但是，这不会自动将任何数据传递给组件，因为组件有自己独立的作用域。为了将迭代后的数据传递到组件中，我们还需要传递 props： 123456&lt;todo-item v-for=&quot;(todo, index) in todos&quot; :key=&quot;todo.id&quot; :title=&quot;todo.title&quot; @remove=&quot;todos.splice(index, 1)&quot;&gt;&lt;/todo-item&gt; 在TodoItem组件中使用props来接收titile并渲染 123456789101112131415&lt;script&gt;export default &#123; //接收title属性 props: [&#x27;title&#x27;], emits: [&#x27;remove&#x27;]&#125;&lt;/script&gt;&lt;template&gt; &lt;li&gt; //渲染 &#123;&#123; title &#125;&#125; &lt;button @click=&quot;$emit(&#x27;remove&#x27;)&quot;&gt;Remove&lt;/button&gt; &lt;/li&gt;&lt;/template&gt; 数组变化侦测操作数组的方法Vue 能够侦听响应式数组的变更方法，并在它们被调用时触发相关的更新。这些变更方法包括： push()：向数组的末尾添加一个或多个元素，并返回新的长度。 pop()：删除数组中的最后一个元素，并返回该元素的值。 shift()：删除数组中的第一个元素，并返回该元素的值。 unshift()：在数组的开头添加一个或多个元素，并返回新的长度。 splice()：这个方法可以用于删除、插入或替换数组中的元素。它接受至少两个参数：第一个参数是要操作的起始位置的索引，第二个参数是要删除的元素数量。可选的第三个参数及以后是你要插入到指定位置的新元素。 sort()：对数组的元素进行排序，默认情况下按照字符串的Unicode码点顺序排序。如果你想自定义排序逻辑，可以传入一个比较函数作为参数。 这里说明比较函数通常是下面这种写法 12345678//升序(a,b)=&gt;&#123; return a-b&#125;//降序(a,b)=&gt;&#123; return b-a&#125; reverse()：反转数组中元素的顺序，第一个元素变成最后一个，最后一个变成第一个。 替换一个数组变更方法，顾名思义，就是会对调用它们的原数组进行变更。相对地，也有一些不可变 (immutable) 方法，例如 filter()，concat() 和 slice()，这些都不会更改原数组，而总是返回一个新数组。当遇到的是非变更方法时，我们需要将旧的数组替换为新的： filter() 方法创建一个新的数组，其包含通过所提供函数实现的测试的所有元素。 123const numbers = [1, 2, 3, 4, 5, 6];2const evenNumbers = numbers.filter(n =&gt; n % 2 === 0);3console.log(evenNumbers); // 输出: [2, 4, 6] concat() 方法用于合并两个或多个数组。此方法不会更改现有的数组，而是返回一个新的数组。 1234const array1 = [&#x27;a&#x27;, &#x27;b&#x27;];2const array2 = [&#x27;c&#x27;, &#x27;d&#x27;];3const combinedArray = array1.concat(array2);4console.log(combinedArray); // 输出: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] slice() 方法返回一个新的数组对象，它是原数组的一部分。你可以指定开始和结束的位置来截取数组的一部分，不会改变原数组。 123const array = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;];2const partOfArray = array.slice(1, 4);3console.log(partOfArray); // 输出: [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] 展示过滤或排序后的结果有时，我们希望显示数组经过过滤或排序后的内容，而不实际变更或重置原始数据。在这种情况下，你可以创建返回已过滤或已排序数组的计算属性。 12345678910data() &#123; return &#123; numbers: [1, 2, 3, 4, 5] &#125;&#125;,computed: &#123; evenNumbers() &#123; return this.numbers.filter(n =&gt; n % 2 === 0) &#125;&#125; 1&lt;li v-for=&quot;n in evenNumbers&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt; 在计算属性不可行的情况下 (例如在多层嵌套的 v-for 循环中)，你可以使用以下方法： 12345678910data() &#123; return &#123; sets: [[ 1, 2, 3, 4, 5 ], [6, 7, 8, 9, 10]] &#125;&#125;,methods: &#123; even(numbers) &#123; return numbers.filter(number =&gt; number % 2 === 0) &#125;&#125; 123&lt;ul v-for=&quot;numbers in sets&quot;&gt; &lt;li v-for=&quot;n in even(numbers)&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;&lt;/ul&gt; 在计算属性中使用 reverse() 和 sort() 的时候务必小心！这两个方法将变更原始数组，计算函数中不应该这么做。请在调用这些方法之前创建一个原数组的副本： 12- return numbers.reverse()+ return [...numbers].reverse() 事件处理监听事件我们可以使用 v-on 指令 (简写为 @) 来监听 DOM 事件，并在事件触发时执行对应的 JavaScript。用法：v-on:click=&quot;handler&quot; 或 @click=&quot;handler&quot;。 事件处理器 (handler) 的值可以是： 内联事件处理器：事件被触发时执行的内联 JavaScript 语句 (与 onclick 类似)。 方法事件处理器：一个指向组件上定义的方法的属性名或是路径。 内联事件处理器把逻辑写在标签中，称为内联 内联事件处理器通常用于简单场景，例如： 12345678&lt;script setup&gt; let counter = ref(0)&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;counter++&quot;&gt;Add 1&lt;/button&gt; &lt;p&gt;The button above has been clicked &#123;&#123; counter &#125;&#125; times.&lt;/p&gt;&lt;/template&gt; 方法事件处理器随着事件处理器的逻辑变得愈发复杂，内联代码方式变得不够灵活。因此 v-on 也可以接受一个方法名或对某个方法的调用。 12345678910111213141516&lt;script setup&gt; let name = ref(&#x27;vue.js&#x27;) function greet(event) &#123; // `this` inside methods points to the current active instance alert(`Hello $&#123;name&#125;!`) // `event` is the native DOM event if (event) &#123; alert(event.target.tagName) &#125; &#125;&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;greet&quot;&gt;Greet&lt;/button&gt;&lt;/template&gt; 方法事件处理器会自动接收原生 DOM 事件并触发执行。在上面的例子中，我们能够通过被触发事件的 event.target 访问到该 DOM 元素。 方法与内联事件判断模板编译器会通过检查 v-on 的值是否是合法的 JavaScript 标识符或属性访问路径来断定是何种形式的事件处理器。举例来说，foo、foo.bar 和 foo[&#39;bar&#39;] 会被视为方法事件处理器，而 foo() 和 count++ 会被视为内联事件处理器。 在内联处理器中调用方法除了直接绑定方法名，你还可以在内联事件处理器中调用方法。这允许我们向方法传入自定义参数以代替原生事件： 123456789101112131415&lt;script&gt;export default &#123; methods: &#123; say(message) &#123; alert(message) &#125; &#125;&#125;&lt;/script&gt;&lt;template&gt; &lt;!--内联写法--&gt; &lt;button @click=&quot;say(&#x27;hi&#x27;)&quot;&gt;Say hi&lt;/button&gt; &lt;button @click=&quot;say(&#x27;what&#x27;)&quot;&gt;Say what&lt;/button&gt;&lt;/template&gt; 在内联事件处理器中访问事件参数123456789&lt;!-- 使用特殊的 $event 变量 --&gt;&lt;button @click=&quot;warn(&#x27;Form cannot be submitted yet.&#x27;, $event)&quot;&gt; Submit&lt;/button&gt;&lt;!-- 使用内联箭头函数 --&gt;&lt;button @click=&quot;(event) =&gt; warn(&#x27;Form cannot be submitted yet.&#x27;, event)&quot;&gt; Submit&lt;/button&gt; 123456789methods: &#123; warn(message, event) &#123; // 这里可以访问 DOM 原生事件 if (event) &#123; event.preventDefault() &#125; alert(message) &#125;&#125; 事件修饰符在处理事件时调用 event.preventDefault() 或 event.stopPropagation() 是很常见的。尽管我们可以直接在方法内调用，但如果方法能更专注于数据逻辑而不用去处理 DOM 事件的细节会更好。 为解决这一问题，Vue 为 v-on 提供了事件修饰符。修饰符是用 . 表示的指令后缀，包含以下这些： .stop .prevent .self .capture .once .passive 123456789101112131415&lt;!-- 单击事件将停止传递 --&gt;&lt;a @click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;&lt;!-- 提交事件将不再重新加载页面 --&gt;&lt;form @submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;!-- 修饰语可以使用链式书写 --&gt;&lt;a @click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;&lt;!-- 也可以只有修饰符 --&gt;&lt;form @submit.prevent&gt;&lt;/form&gt;&lt;!-- 仅当 event.target 是元素本身时才会触发事件处理器 --&gt;&lt;!-- 例如：事件处理器不来自子元素 --&gt;&lt;div @click.self=&quot;doThat&quot;&gt;...&lt;/div&gt; 注意： 使用修饰符时需要注意调用顺序，因为相关代码是以相同的顺序生成的。因此使用 @click.prevent.self 会阻止元素及其子元素的所有点击事件的默认行为，而 @click.self.prevent 则只会阻止对元素本身的点击事件的默认行为。 .capture、.once 和 .passive 修饰符与原生 addEventListener 事件相对应： 12345678910&lt;!-- 添加事件监听器时，使用 `capture` 捕获模式 --&gt;&lt;!-- 例如：指向内部元素的事件，在被内部元素处理前，先被外部处理 --&gt;&lt;div @click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;&lt;!-- 点击事件最多被触发一次 --&gt;&lt;a @click.once=&quot;doThis&quot;&gt;&lt;/a&gt;&lt;!-- 滚动事件的默认行为 (scrolling) 将立即发生而非等待 `onScroll` 完成 --&gt;&lt;!-- 以防其中包含 `event.preventDefault()` --&gt;&lt;div @scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt; .passive 修饰符一般用于触摸事件的监听器，可以用来改善移动端设备的滚屏性能。 注意： 请勿同时使用 .passive 和 .prevent，因为 .passive 已经向浏览器表明了你不想阻止事件的默认行为。如果你这么做了，则 .prevent 会被忽略，并且浏览器会抛出警告。 按键修饰符在监听键盘事件时，我们经常需要检查特定的按键。Vue 允许在 v-on 或 @ 监听按键事件时添加按键修饰符。 123&lt;!-- 仅在 `key` 为 `Enter` 时调用 `submit` --&gt;&lt;!--监听键盘按键抬起(keyup)的事件--&gt;&lt;input @keyup.enter=&quot;submit&quot; /&gt; 你可以直接使用 KeyboardEvent.key 暴露的按键名称作为修饰符，但需要转为 kebab-case 形式。 12&lt;!--@keyup时键盘抬起事件，&quot;page-down&quot;指的是键盘上的pageDown按键,意味着按下pageDown触发事件，抬起时触发事件onPageDown--&gt;&lt;input @keyup.page-down=&quot;onPageDown&quot; /&gt; 在上面的例子中，仅会在 $event.key(指按键) 为 &#39;PageDown&#39; 时调用事件处理。 按键别名 .enter：回车 .tab：Tab键 .delete (捕获“Delete”和“Backspace”两个按键) .esc：ESC按键 .space：空格 .up：上箭头 .down：下箭头 .left：左箭头 .right：右箭头 系统按键修饰符你可以使用以下系统按键修饰符来触发鼠标或键盘事件监听器，只有当按键被按下时才会触发。 .ctrl .alt .shift .meta 注意： 在 Mac 键盘上，meta 是 Command 键 (⌘)。在 Windows 键盘上，meta 键是 Windows 键 (⊞)。在 Sun 微机系统键盘上，meta 是钻石键 (◆)。在某些键盘上，特别是 MIT 和 Lisp 机器的键盘及其后代版本的键盘，如 Knight 键盘，space-cadet 键盘，meta 都被标记为“META”。在 Symbolics 键盘上，meta 也被标识为“META”或“Meta”。 举例来说： 12345&lt;!-- Alt + Enter --&gt;&lt;input @keyup.alt.enter=&quot;clear&quot; /&gt;&lt;!-- Ctrl + 点击 --&gt;&lt;div @click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt; 注意： 请注意，系统按键修饰符和常规按键不同。与 keyup 事件一起使用时，该按键必须在事件发出时处于按下状态。换句话说，keyup.ctrl 只会在你仍然按住 ctrl 但松开了另一个键时被触发。若你单独松开 ctrl 键将不会触发。 比如我们的ctrl c，ctrl v相信这么一说就都明白了。 通过@keyup.ctrl.c和@keyup.ctrl.v来绑定 .exact 修饰符.exact 修饰符允许精确控制触发事件所需的系统修饰符的组合。 123456789101112131415161718192021222324252627&lt;script&gt;export default &#123; methods: &#123; onclick() &#123; alert(&#x27;你好，你刚刚出发了ctrl事件！&#x27;) &#125;, onclick1() &#123; alert(&#x27;你好，你刚刚出发了ctrl事件！&#x27;) &#125;, onclick2() &#123; alert(&#x27;你好，你刚刚出发了ctrl事件！&#x27;) &#125; &#125;&#125;&lt;/script&gt;&lt;template&gt; &lt;!-- 按住ctrl，即使在按住别的按键，也可以触发该事件 --&gt;&lt;button @click.ctrl=&quot;onclick&quot;&gt;触发事件&lt;/button&gt; &lt;br/&gt;&lt;br/&gt;&lt;!-- 按住ctrl，但是这次如果同时按住了别的按键，该事件不会触发 --&gt;&lt;button @click.ctrl.exact=&quot;onclick1&quot;&gt;触发事件1&lt;/button&gt;&lt;br/&gt;&lt;br/&gt;&lt;!-- 点击就会触发，意味着不需要按任何按键即可触发 --&gt;&lt;button @click.exact=&quot;onclick2&quot;&gt;触发事件2&lt;/button&gt;&lt;/template&gt; 鼠标按键修饰符 .left：默认情况下，如果不使用任何修饰符，Vue.js的鼠标事件监听器会响应所有的鼠标按钮。但是，.left修饰符确保只有在左键被按下或释放时才触发事件处理函数。 .right：使用.right修饰符，事件处理函数仅在右键被按下或释放时触发。这对于创建上下文菜单或其他依赖右键操作的交互特别有用。 .middle：.middle修饰符则确保只有在鼠标中键（通常是滚轮按钮）被按下或释放时才触发事件处理函数。这在需要监听滚轮点击的场景中很有用。 这些修饰符将处理程序限定为由特定鼠标按键触发的事件。 比如下面这样： 1234567891011121314&lt;script&gt;export default &#123; methods: &#123; handleLeftClick(event) &#123; console.log(&#x27;左键点击事件:&#x27;, event); // 在这里处理左键点击的逻辑 &#125; &#125;&#125;&lt;/script&gt;&lt;template&gt;&lt;div @click.left=&quot;handleLeftClick&quot;&gt;点击我&lt;/div&gt;&lt;/template&gt; 表单输入绑定在前端处理表单时，我们常常需要将表单输入框的内容同步给 JavaScript 中相应的变量。手动连接值绑定和更改事件监听器可能会很麻烦： 123&lt;input :value=&quot;text&quot; @input=&quot;event =&gt; text = event.target.value&quot;&gt; v-model 指令帮我们简化了这一步骤： 1&lt;input v-model=&quot;text&quot;&gt; 另外，v-model 还可以用于各种不同类型的输入，&lt;textarea&gt;、&lt;select&gt; 元素。它会根据所使用的元素自动使用对应的 DOM 属性和事件组合： 文本类型的 &lt;input&gt; 和 &lt;textarea&gt; 元素会绑定 value property 并侦听 input 事件； &lt;input type=&quot;checkbox&quot;&gt;(复选框) 和 &lt;input type=&quot;radio&quot;&gt;(单选框) 会绑定 checked property 并侦听 change 事件； &lt;select&gt; 会绑定 value property 并侦听 change 事件。 注意： v-model 会忽略任何表单元素上初始的 value、checked 或 selected attribute。它将始终将当前绑定的 JavaScript 状态视为数据的正确来源。你应该在 JavaScript 中使用data 选项来声明该初始值。 也就是说，使用v-model绑定某个值时，该值必须在data函数中声明并返回给vue模板 基本用法来看下面这段代码 123456789101112131415&lt;script&gt;export default &#123; data()&#123; return &#123; //初始化message message: &#x27;&#x27; &#125; &#125;&#125;&lt;/script&gt;&lt;template&gt;&lt;p&gt;消息是：&#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;input v-model=&quot;message&quot; placeholder=&quot;请输入你要打印的消息&quot; type=&quot;text&quot;&gt;&lt;/template&gt; 效果 多行文本同样的道理，来看下面这段代码 123&lt;span&gt;Multiline message is:&lt;/span&gt;&lt;p style=&quot;white-space: pre-line;&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;textarea v-model=&quot;message&quot; placeholder=&quot;add multiple lines&quot;&gt;&lt;/textarea&gt; 效果和上面的是一样的 注意： &lt;textarea&gt; 中是不支持插值表达式的。请使用 v-model 来替代： 12345&lt;!-- 错误 --&gt;&lt;textarea&gt;&#123;&#123; text &#125;&#125;&lt;/textarea&gt;&lt;!-- 正确 --&gt;&lt;textarea v-model=&quot;text&quot;&gt;&lt;/textarea&gt; 复选框单一的复选框，绑定布尔类型值： 12345678&lt;script setup&gt; let message = ref(&#x27;&#x27;)&lt;/script&gt;&lt;template&gt;&lt;input v-model=&quot;message&quot; type=&quot;checkbox&quot; id=&quot;checkbox&quot; &gt;&lt;label for=&quot;checkbox&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/label&gt;&lt;/template&gt; 我们也可以将多个复选框绑定到同一个数组或集合的值： 123&lt;script setup&gt; let checkedNames = ref([])&lt;/script&gt; 123456789101112&lt;template&gt;&lt;div&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/div&gt;&lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot; /&gt;&lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot; /&gt;&lt;label for=&quot;john&quot;&gt;John&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot; /&gt;&lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt;&lt;/template&gt; 页面效果 在这个例子中，checkedNames 数组将始终包含所有当前被选中的框的value属性对应的值。关于value绑定，请详见值绑定小结 单选按钮12345678910111213&lt;script setup&gt; let picked = ref([])&lt;/script&gt;&lt;template&gt;&lt;div&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/div&gt;&lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot; /&gt;&lt;label for=&quot;one&quot;&gt;One&lt;/label&gt;&lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot; /&gt;&lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt;&lt;/template&gt; 上面这段代码同样，效果也一样 选择器单个选择器的示例如下： 12345678&lt;div&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/div&gt;&lt;select v-model=&quot;selected&quot;&gt; &lt;option disabled value=&quot;&quot;&gt;Please select one&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt;&lt;/select&gt; 页面效果 注意 如果 v-model 表达式的初始值不匹配任何一个选择项，&lt;select&gt; 元素会渲染成一个“未选择”的状态。在 iOS 上，这将导致用户无法选择第一项，因为 iOS 在这种情况下不会触发一个 change 事件。因此，我们建议提供一个空值的禁用选项，如上面的例子所示。 多选 (值绑定到一个数组)： 只是比单选多个一个multiple属性 1234567&lt;div&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/div&gt;&lt;select v-model=&quot;selected&quot; multiple&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt;&lt;/select&gt; 选择器的选项可以使用 v-for 动态渲染： 123456789101112export default &#123; data() &#123; return &#123; selected: &#x27;A&#x27;, options: [ &#123; text: &#x27;One&#x27;, value: &#x27;A&#x27; &#125;, &#123; text: &#x27;Two&#x27;, value: &#x27;B&#x27; &#125;, &#123; text: &#x27;Three&#x27;, value: &#x27;C&#x27; &#125; ] &#125; &#125;&#125; 1234567&lt;select v-model=&quot;selected&quot;&gt; &lt;option v-for=&quot;option in options&quot; :value=&quot;option.value&quot;&gt; &#123;&#123; option.text &#125;&#125; &lt;/option&gt;&lt;/select&gt;&lt;div&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/div&gt; 页面效果 值绑定对于单选按钮，复选框和选择器选项，v-model 绑定的值通常是静态的字符串 (或者对复选框是布尔值)： 12345678910&lt;!-- `picked` 在被选择时是字符串 &quot;a&quot; --&gt;&lt;input type=&quot;radio&quot; v-model=&quot;picked&quot; value=&quot;a&quot; /&gt;&lt;!-- `toggle` 只会为 true 或 false --&gt;&lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot; /&gt;&lt;!-- `selected` 在第一项被选中时为字符串 &quot;abc&quot; --&gt;&lt;select v-model=&quot;selected&quot;&gt; &lt;option value=&quot;abc&quot;&gt;ABC&lt;/option&gt;&lt;/select&gt; 但有时我们可能希望将该值绑定到当前组件实例上的动态数据。这可以通过使用 v-bind 来实现。此外，使用 v-bind 还使我们可以将选项值绑定为非字符串的数据类型。 复选框12345&lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot; true-value=&quot;yes&quot; false-value=&quot;no&quot; /&gt; true-value 和 false-value 是 Vue 特有的 attributes，仅支持和 v-model 配套使用。这里 toggle 属性的值会在选中时被设为 &#39;yes&#39;，取消选择时设为 &#39;no&#39;。你同样可以通过 v-bind 将其绑定为其他动态值： 12345&lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot; :true-value=&quot;dynamicTrueValue&quot; :false-value=&quot;dynamicFalseValue&quot; /&gt; 注意： true-value 和 false-value attributes 不会影响 value attribute，因为浏览器在表单提交时，并不会包含未选择的复选框。为了保证这两个值 (例如：“yes”和“no”) 的其中之一被表单提交，请使用单选按钮作为替代。 单选按钮12&lt;input type=&quot;radio&quot; v-model=&quot;pick&quot; :value=&quot;first&quot; /&gt;&lt;input type=&quot;radio&quot; v-model=&quot;pick&quot; :value=&quot;second&quot; /&gt; pick 会在第一个按钮选中时被设为 first，在第二个按钮选中时被设为 second。效果 选择器选项1234&lt;select v-model=&quot;selected&quot;&gt; &lt;!-- 内联对象字面量 --&gt; &lt;option :value=&quot;&#123; number: 123 &#125;&quot;&gt;123&lt;/option&gt;&lt;/select&gt; v-model 同样也支持非字符串类型的值绑定！在上面这个例子中，当某个选项被选中，selected 会被设为该对象字面量值 &#123; number: 123 &#125;。 修饰符.lazy默认情况下，v-model 会在每次 input 事件后更新数据 (IME 拼字阶段的状态例外)。你可以添加 lazy 修饰符来改为在每次 change 事件后更新数据： 12&lt;!-- 在 &quot;change&quot; 事件后同步更新而不是 &quot;input&quot; --&gt;&lt;input v-model.lazy=&quot;msg&quot; /&gt; .number如果你想让用户输入自动转换为数字，你可以在 v-model 后添加 .number 修饰符来管理输入： 1&lt;input v-model.number=&quot;age&quot; /&gt; 如果该值无法被 parseFloat() 处理，那么将返回原始值。 number 修饰符会在输入框有 type=&quot;number&quot; 时自动启用。也就是说效果等同于下面这么写 1&lt;input v-model=&quot;age&quot; type=&quot;number&quot;/&gt; parseFloat()，用于解析一个字符串并返回一个浮点数。如果字符串的开始部分不是一个有效的浮点数表示，则返回 NaN（Not-a-Number）。 下面是一组数据，能够更直观的感受该函数的用法 123456console.log(parseFloat(&quot;123.45&quot;)); // 输出：123.45console.log(parseFloat(&quot; 67.89&quot;)); // 输出：67.89console.log(parseFloat(&quot;100 apples&quot;)); // 输出：100console.log(parseFloat(&quot;3.14e2&quot;)); // 输出：314console.log(parseFloat(&quot;abc123&quot;)); // 输出：NaNconsole.log(parseFloat(&quot;123abc&quot;)); // 输出：123 .trim如果你想要默认自动去除用户输入内容中两端的空格，你可以在 v-model 后添加 .trim 修饰符： 1&lt;input v-model.trim=&quot;msg&quot; /&gt; 生命周期钩子每个 Vue 组件实例在创建时都需要经历一系列的初始化步骤，比如设置好数据侦听，编译模板，挂载实例到 DOM，以及在数据改变时更新 DOM。在此过程中，它也会运行被称为生命周期钩子的函数，让开发者有机会在特定阶段运行自己的代码。 注册周期钩子举例来说，mounted 钩子可以用来在组件完成初始渲染并创建 DOM 节点后运行代码： 12345export default &#123; mounted() &#123; console.log(`the component is now mounted.`) &#125;&#125; 还有其他一些钩子，会在实例生命周期的不同阶段被调用，最常用的是 mounted、updated 和 unmounted。 所有生命周期钩子函数的 this 上下文都会自动指向当前调用它的组件实例。注意：避免用箭头函数来定义生命周期钩子，因为如果这样的话你将无法在函数中通过 this 获取组件实例。 生命周期图示下面是实例生命周期的图表。你现在并不需要完全理解图中的所有内容，但以后它将是一个有用的参考。 生命周期选项注意：使用生命周期钩子时，要手动引入对应的钩子，然后将回调函数当成参数写在钩子里面 onBeforeMount()注册一个钩子，在组件被挂载之前被调用。 详细信息 当这个钩子被调用时，组件已经完成了其响应式状态的设置，但还没有创建 DOM 节点。它即将首次执行 DOM 渲染过程。 这个钩子在服务端渲染时不会被调用。 1234import &#123;onBeforeMount&#125; from &#x27;vue&#x27;onBeforeMount(()=&gt;&#123; &#125;) onMounted在组件被挂载之后调用。 ​ 详细信息 组件在以下情况下被视为已挂载： 所有同步子组件都已经被挂载。(不包含异步组件或 &lt;Suspense&gt; 树内的组件) 其自身的 DOM 树已经创建完成并插入了父容器中。注意仅当根容器在文档中时，才可以保证组件 DOM 树也在文档中。 这个钩子通常用于执行需要访问组件所渲染的 DOM 树相关的副作用，或是在服务端渲染应用中用于确保 DOM 相关代码仅在客户端被调用。 这个钩子在服务端渲染时不会被调用。 1234import &#123;onMounted&#125; from &#x27;vue&#x27;onMounted(()=&gt;&#123; //处理的逻辑&#125;) onBeforeUpdate在组件即将因为一个响应式状态变更而更新其 DOM 树之前调用。 详细信息 这个钩子可以用来在 Vue 更新 DOM 之前访问 DOM 状态。在这个钩子中更改状态也是安全的。 这个钩子在服务端渲染时不会被调用。 1234import &#123;onBeforeUpdate&#125; from &#x27;vue&#x27;onBeforeUpdate(()=&gt;&#123; //逻辑&#125;) onUpdated注册一个回调函数，在组件因为响应式状态变更而更新其 DOM 树之后调用。 详细信息 父组件的更新钩子将在其子组件的更新钩子之后调用。 这个钩子会在组件的任意 DOM 更新后被调用，这些更新可能是由不同的状态变更导致的。如果你需要在某个特定的状态更改后访问更新后的 DOM，请使用 nextTick() 作为替代。 这个钩子在服务端渲染时不会被调用。 警告： 不要在 updated 钩子中更改组件的状态，这可能会导致无限的更新循环！ 1234import &#123;onUpdated&#125; from &#x27;vue&#x27;onUpdated(()=&gt;&#123; //逻辑&#125;) onBeforeUnmount在一个组件实例被卸载之前调用。 详细信息 当这个钩子被调用时，组件实例依然还保有全部的功能。 这个钩子在服务端渲染时不会被调用。 1234import &#123;onBeforeUnmount&#125; from &#x27;vue&#x27;onBeforeUnmount(()=&gt;&#123; //逻辑&#125;) onUnmounted在一个组件实例被卸载之后调用。 详细信息 一个组件在以下情况下被视为已卸载： 其所有子组件都已经被卸载。 所有相关的响应式作用 (渲染作用以及 setup() 时创建的计算属性和侦听器) 都已经停止。 可以在这个钩子中手动清理一些副作用，例如计时器、DOM 事件监听器或者与服务器的连接。 这个钩子在服务端渲染时不会被调用。 1234import &#123;onUnmounted&#125; from &#x27;vue&#x27;onUnmounted(()=&gt;&#123; //逻辑&#125;) 侦听器(watch)基本示例计算属性允许我们声明性地计算衍生值。然而在有些情况下，我们需要在状态变化时执行一些“副作用”：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态。 在组合式 API 中，我们可以使用 watch 函数在每次响应式状态发生变化时触发回调函数： 下面示例一段代码，来展示watch的用法 12345678910111213141516171819202122232425262728293031&lt;script setup&gt;import &#123; ref, watch &#125; from &#x27;vue&#x27;const question = ref(&#x27;&#x27;)const answer = ref(&#x27;Questions usually contain a question mark. ;-)&#x27;)const loading = ref(false)// 可以直接侦听一个 refwatch(question, async (newQuestion, oldQuestion) =&gt; &#123; if (newQuestion.includes(&#x27;?&#x27;)) &#123; loading.value = true answer.value = &#x27;Thinking...&#x27; try &#123; const res = await fetch(&#x27;https://yesno.wtf/api&#x27;) answer.value = (await res.json()).answer &#125; catch (error) &#123; answer.value = &#x27;Error! Could not reach the API. &#x27; + error &#125; finally &#123; loading.value = false &#125; &#125;&#125;)&lt;/script&gt;&lt;template&gt; &lt;p&gt; Ask a yes/no question: &lt;input v-model=&quot;question&quot; :disabled=&quot;loading&quot; /&gt; &lt;/p&gt; &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt;&lt;/template&gt; 侦听数据源类型watch 的第一个参数可以是不同形式的“数据源”：它可以是一个 ref (包括计算属性)、一个响应式对象(reactive定义的响应式对象)、一个 getter 函数、或多个数据源组成的数组，说白了就是下面这四种情况： 监听ref定义的基本数据类型1234567891011121314151617181920212223&lt;script setup&gt;import &#123; ref, watch &#125; from &#x27;vue&#x27;//定义数据let sum = ref(0)//方法function changSum()&#123; sum.value+=1&#125;//监视器(watch的返回值实际上是一个停止该监视器的函数)const stopWatch =watch( //监视的数据源 sum, //回调函数 (newValue,oldValue)=&gt;&#123; console.log(&#x27;sum变化了&#x27;); console.log(&#x27;新的值：&#x27;+newValue,&#x27;旧的值：&#x27;+ oldValue); if(newValue &gt; 10)&#123; stopWatch() &#125; &#125;,)&lt;/script&gt; 监视ref定义的对象类型数据12345678910111213141516171819202122232425262728293031&lt;script setup&gt;let person = ref(&#123; name:&#x27;张三&#x27;, age:18&#125;)//定义方法function changeName()&#123; person.value.name = &#x27;小四&#x27;&#125;function changeAge()&#123; person.value.age=45&#125;function changePerson()&#123; person.value=&#123;name:&#x27;小五&#x27;,age:99&#125;&#125;//监视器watch( //监视的是ref定义对象类型数据的地址值，如果想要监视对象内的属性， //需要开启深度监视 person, (newValue,oldValue)=&gt;&#123; //针对于nV和oV讲讲：当你仅仅是对对象内的属性值做出了修改时，通过监听获得nV和oV这两个值是相同的，当你完全改变了这个对象包括对象的名字和属性时，这时监听所获得的nV和oV是不同的，即新值和旧值 console.log(newValue,oldValue); &#125;, &#123;deep:true&#125;)&lt;/script&gt; 注意： 针对于nV和oV讲讲：当你仅仅是对对象内的属性值做出了修改时，通过监听获得nV和oV这两个值是相同的，当你完全改变了这个对象包括对象的名字和属性时，这时监听所获得的nV和oV是不同的，即新值和旧值，本质是因为当你仅仅改变对象内的属性值时，还是同一个对象，对象存储的地址没有发生改变。 监视reactive定义的对象类型数据使用reactive定义的对象，是默认开启深度监视的，所以直接监视即可。 12345678910111213141516171819202122232425262728&lt;script setup&gt;let person = reactive(&#123; name:&#x27;张三&#x27;, age:18&#125;)//定义方法function changeName()&#123; person.name = &#x27;小四&#x27;&#125;function changeAge()&#123; person.age=45&#125;function changePerson()&#123; Object.assign(person,&#123;name:&#x27;刘小&#x27;,age:65&#125;)&#125;//监视器watch( //使用reactive定义的对象，是默认开启深度监视的，所以直接监视即可。 person, (newValue,oldValue)=&gt;&#123; console.log(newValue,oldValue); &#125;,)&lt;/script&gt; 监听reactive或ref中的对象类型的属性值注意，你不能直接侦听响应式对象的属性值，例如: 123456const obj = reactive(&#123; count: 0 &#125;)// 错误，因为 watch() 得到的参数是一个 numberwatch(obj.count, (count) =&gt; &#123; console.log(`Count is: $&#123;count&#125;`)&#125;) 如果想监听响应式对象的属性值，需要用一个返回该属性值的getter函数，getter简单来说就是一个函数，返回一个值 1234567// 提供一个 getter 函数watch( () =&gt; &#123;return obj.count&#125;, (count) =&gt; &#123; console.log(`Count is: $&#123;count&#125;`) &#125;) 深层侦听器直接给 watch() 传入一个响应式对象，会隐式地创建一个深层侦听器——该回调函数在所有嵌套的变更时都会被触发： 来看代码 123456789const obj = reactive(&#123; count: 0 &#125;)watch(obj, (newValue, oldValue) =&gt; &#123; // 在嵌套的属性变更时触发 // 注意：`newValue` 此处和 `oldValue` 是相等的 // 因为它们是同一个对象！&#125;)obj.count++ 相比之下，一个返回响应式对象的 getter 函数，只有在返回不同的对象时，才会触发回调： 123456watch( () =&gt; state.someObject, () =&gt; &#123; // 仅当 state.someObject 被替换时触发 &#125;) 你也可以给上面这个例子显式地加上 deep 选项，强制转成深层侦听器： 12345678watch( () =&gt; state.someObject, () =&gt; &#123; // 仅当 state.someObject 被替换时触发 &#125; &#123;deep:true&#125;) 提醒深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，开销很大。因此请只在必要时才使用它，并且要留意性能。 即时回调的侦听器watch 默认是懒执行的：仅当数据源变化时，才会执行回调。但在某些场景中，我们希望在创建侦听器时，立即执行一遍回调。举例来说，我们想请求一些初始数据，然后在相关状态更改时重新请求数据。 我们可以用一个对象来声明侦听器，给其添加immediate: true 选项，这样便能强制回调函数立即执行： 来看代码 123456watch( dataSource, (newVaule,oldValue)=&gt;&#123;&#125; //使得监视器马上生效 &#123;immedite:true&#125;) 一次性侦听器(vue版本3.4+)每当被侦听源发生变化时，侦听器的回调就会执行。如果希望回调只在源变化时触发一次，请使用 once: true 选项。 123456watch( dataSource, (newValue,oldValue)=&gt;&#123;&#125; //开启下面这个选项使得监视器只执行一次回调 &#123;once:true&#125;) watchEffect()立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。 123456watchEffect(async () =&gt; &#123; const response = await fetch( `https://jsonplaceholder.typicode.com/todos/$&#123;todoId.value&#125;` ) data.value = await response.json()&#125;) 这个例子中，回调会立即执行，不需要指定 immediate: true。在执行期间，它会自动追踪 todoId.value 作为依赖（和计算属性类似）。每当 todoId.value 变化时，回调会再次执行。有了 watchEffect()，我们不再需要明确传递 todoId 作为源值。 watch vs. watchEffect watch 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。watch 会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。 watchEffect，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。 回调的触发时机当你更改了响应式状态，它可能会同时触发 Vue 组件更新和侦听器回调。 类似于组件更新，用户创建的侦听器回调函数也会被批量处理以避免重复调用。例如，如果我们同步将一千个项目推入被侦听的数组中，我们可能不希望侦听器触发一千次。 默认情况下，侦听器回调会在父组件更新 (如有) 之后、所属组件的 DOM 更新之前被调用。这意味着如果你尝试在侦听器回调中访问所属组件的 DOM，那么 DOM 将处于更新前的状态。 Post Watchers如果想在侦听器回调中能访问被 Vue 更新之后的所属组件的 DOM，你需要指明 flush: &#39;post&#39; 选项： 1234567watch(source, callback, &#123; flush: &#x27;post&#x27;&#125;)watchEffect(callback, &#123; flush: &#x27;post&#x27;&#125;) 同步侦听器你还可以创建一个同步触发的侦听器，它会在 Vue 进行任何更新之前触发：设置属性flush:&#39;sync&#39; 1234567watch(source, callback, &#123; flush: &#x27;sync&#x27;&#125;)watchEffect(callback, &#123; flush: &#x27;sync&#x27;&#125;) 停止侦听器在 setup() 或 &lt;script setup&gt; 中用同步语句创建的侦听器，会自动绑定到宿主组件实例上，并且会在宿主组件卸载时自动停止。因此，在大多数情况下，你无需关心怎么停止一个侦听器 一个关键点是，侦听器必须用同步语句创建：如果用异步回调创建一个侦听器，那么它不会绑定到当前组件上，你必须手动停止它，以防内存泄漏。如下方这个例子： 1234567891011&lt;script setup&gt;import &#123; watchEffect &#125; from &#x27;vue&#x27;// 它会自动停止watchEffect(() =&gt; &#123;&#125;)// ...这个则不会！setTimeout(() =&gt; &#123; watchEffect(() =&gt; &#123;&#125;)&#125;, 100)&lt;/script&gt; 要手动停止一个侦听器，请调用 watch 或 watchEffect 返回的函数： 1234const unwatch = watchEffect(() =&gt; &#123;&#125;)// ...当该侦听器不再需要时unwatch() 模板引用虽然 Vue 的声明性渲染模型为你抽象了大部分对 DOM 的直接操作，但在某些情况下，我们仍然需要直接访问底层 DOM 元素。要实现这一点，我们可以使用特殊的 ref attribute： 1&lt;input ref=&#x27;input&#x27;/&gt; ref 是一个特殊的 属性，和 v-for 章节中提到的 key 类似。它允许我们在一个特定的 DOM 元素或子组件实例被挂载后，获得对它的直接引用。这可能很有用，比如说在组件挂载时将焦点设置到一个 input 元素上，或在一个元素上初始化一个第三方库。 访问模板引用123456789101112131415&lt;script setup&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;// 声明一个 ref 来存放该元素的引用// 必须和模板里的 ref 同名const input = ref(null)onMounted(() =&gt; &#123; input.value.focus()&#125;)&lt;/script&gt;&lt;template&gt; &lt;input ref=&quot;input&quot; /&gt;&lt;/template&gt; 注意，你只可以在组件挂载后才能访问模板引用。如果你想在模板中的表达式上访问 $refs.input，在初次渲染时会是 undefined。这是因为在初次渲染前这个元素还不存在呢！ v-for 中的模板引用需要 v3.2.25 及以上版本 当在 v-for 中使用模板引用时，对应的 ref 中包含的值是一个数组，它将在元素被挂载后包含对应整个列表的所有元素 12345678910111213141516171819&lt;script setup&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;const list = ref([ /* ... */])const itemRefs = ref([])onMounted(() =&gt; console.log(itemRefs.value))&lt;/script&gt;&lt;template&gt; &lt;ul&gt; &lt;li v-for=&quot;item in list&quot; ref=&quot;itemRefs&quot;&gt; &#123;&#123; item &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt; 应该注意的是，ref 数组并不保证与源数组相同的顺序。 函数模板引用除了使用字符串值作名字，ref attribute 还可以绑定为一个函数，会在每次组件更新时都被调用。该函数会收到元素引用作为其第一个参数： 1&lt;input :ref=&quot;(el) =&gt; &#123; /* 将 el 赋值给一个数据属性或 ref 变量 */ &#125;&quot;&gt; 注意我们这里需要使用动态的 :ref 绑定才能够传入一个函数。当绑定的元素被卸载时，函数也会被调用一次，此时的 el 参数会是 null。你当然也可以绑定一个组件方法而不是内联函数。 组件基础组件允许我们将 UI 划分为独立的、可重用的部分，并且可以对每个部分进行单独的思考。在实际应用中，组件常常被组织成层层嵌套的树状结构： 这和我们嵌套 HTML 元素的方式类似，Vue 实现了自己的组件模型，使我们可以在每个组件内封装自定义内容与逻辑。 定义一个组件当使用构建步骤时，我们一般会将 Vue 组件定义在一个单独的 .vue 文件中，这被叫做单文件组件 (简称 SFC)： 123456789&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const count = ref(0)&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&lt;/template&gt; 当不使用构建步骤时，一个 Vue 组件以一个包含 Vue 特定选项的 JavaScript 对象来定义： 1234567891011121314import &#123; ref &#125; from &#x27;vue&#x27;export default &#123; setup() &#123; const count = ref(0) return &#123; count &#125; &#125;, template: ` &lt;button @click=&quot;count++&quot;&gt; You clicked me &#123;&#123; count &#125;&#125; times. &lt;/button&gt;` // 也可以针对一个 DOM 内联模板： // template: &#x27;#my-template-element&#x27;&#125; 这里的模板是一个内联的 JavaScript 字符串，Vue 将会在运行时编译它。你也可以使用 ID 选择器来指向一个元素 (通常是原生的 &lt;template&gt; 元素)，Vue 将会使用其内容作为模板来源。 上面的例子中定义了一个组件，并在一个 .js 文件里默认导出了它自己，但你也可以通过具名导出在一个文件中导出多个组件。 使用组件要使用一个子组件，我们需要在父组件中导入它。假设我们把计数器组件放在了一个叫做 ButtonCounter.vue 的文件中，这个组件将会以默认导出的形式(使用export deafult{})被暴露给外部。 12345678&lt;script setup&gt;import ButtonCounter from &#x27;./ButtonCounter.vue&#x27;&lt;/script&gt;&lt;template&gt; &lt;h1&gt;Here is a child component!&lt;/h1&gt; &lt;ButtonCounter /&gt;&lt;/template&gt; 通过 &lt;script setup&gt;，导入的组件都在模板中直接可用。需要在 components 选项上注册它。这个组件将会以其注册时的名字作为模板中的标签名。 当然，你也可以全局地注册一个组件，使得它在当前应用中的任何组件上都可以使用，而不需要额外再导入。关于组件的全局注册和局部注册两种方式的利弊，我们放在了组件注册这一章节中专门讨论。 组件可以被重用任意多次： 1234&lt;h1&gt;Here is a child component!&lt;/h1&gt;&lt;ButtonCounter /&gt;&lt;ButtonCounter /&gt;&lt;ButtonCounter /&gt; 组件通信通过props来传递数据这里假设我有两个组件，一个称为父组件，另一个是子组件 Props 是一种特别的 属性，你可以在组件上声明注册。这里要用到 props 选项： 父组件向子组件传递信息12345678&lt;script setup&gt; //子组件中利用defineProps来接收父组件传递来的数据defineProps([&#x27;title&#x27;])&lt;/script&gt;&lt;template&gt; &lt;h4&gt;&#123;&#123; title &#125;&#125;&lt;/h4&gt;&lt;/template&gt; 在父组件中，需这样书写。 123&lt;BlogPost title=&quot;My journey with Vue&quot; /&gt;&lt;BlogPost title=&quot;Blogging with Vue&quot; /&gt;&lt;BlogPost title=&quot;Why Vue is so fun&quot; /&gt; 也可以通过动态绑定的形式，传递数据。一般来说，我们在子组件中声明接收某个变量时，那么就在父组件中可以动态绑定该变量即可 子组件向父组件传递数据原理：本质上还是父传子，只不过这时父组件需要给子组件传递一个函数，在子组件中调用父组件传递过来的函数并传入参数(子向父传递的数据)，相当于回调 通过自定义事件(子传父)来传递数据自定义事件是我们自己来编写的，不同于点击，鼠标移入移出等事件，对于这个应用场景，下面来这样解释 首先在父组件中编写自定义事件 子组件中通过函数defineEmits来声明在父组件中的自定义事件 触发事件 const emit = defineEmits([&#39;CustomEvent&#39;]) 使用emit来触发事件，语法是emit(&#39;要触发的事件名称&#39;) 图解： 使用mitt进行组件通信安装mitt1yarn add mitt 编辑mitt123456//引入mittimport mitt from &quot;mitt&quot;;//实例化mitt,可以使用emitter来绑定事件const emitter = mitt()//暴露出去export default emitter 使用mitt mitt(): 这个构造函数返回一个新的事件发射器实例。 on(eventName, handler): 订阅特定事件。当事件触发时，对应的处理器（handler）将被调用。eventName 可以是任何字符串，handler 应该是一个函数。 emit(eventName, ...args): 触发一个事件。这会调用所有已注册到该事件的处理器。eventName 是事件的名称，...args 是传递给处理器的任意参数。 off(eventName, handler): 取消订阅特定事件的处理器。如果没有提供处理器，则会取消订阅所有该事件的处理器。 all: 这是一个特殊属性，允许你订阅所有事件。当你订阅 all 时，提供的处理器会接收到所有触发的事件以及它们的名称。 once(eventName, handler):订阅一次性的事件。处理器会在事件第一次触发时调用，然后自动取消订阅。 案例： 使用v-model进行组件传值(v-model双向绑定实现的原理)v-model用在html标签上 通过v-model实现数据与视图的双向绑定 &lt;input type=&quot;text&quot; v-model=&quot;username&quot;/&gt; 12345672. 通过v-model的底层原理实现双向绑定 1. ```html &lt;input :value=&quot;username&quot; @input=&quot;username = &lt;HTMLInputElement&gt;($event.target).value&quot; /&gt; :value实现数据到视图的绑定，而 @input=&quot;username = $event.target.value&quot;实现视图到数据的绑定，实际上是通过$event事件对象来拿到更改输入框中的值，将其赋值给username v-model用在组件标签上业务场景：封装一个组件，实现双向绑定的功能 上面展示的就是v-model的底层原理，一般图片右边的工作是UI组件库所要做的，类似于我们直接调用UI组件库，在组件上使用属性v-model来实现的数据绑定，实际上就是我们自定义这样来实现的。 上面图片中的事件名称格式是：@update:xxxx。 对于上面的形式，我们在自定义组件实现双向绑定功能时，左边图片就可以简写成v-model=username，而右边是我们真正需要手动实现的内容，来实现双向绑定，我想要说的是，v-model=username就帮助我们实现了左边组件的写法了，我们只需要实现右边的就可以了。 实际上v-model还可以起名字，写法v-model:xxx，如果写成这样的话，那么 在拓展一下$event什么时候有.target 绑定在html标签上的事件，有 绑定在自定义组件上的事件，没有，并且$event就相当于传递的数据 使用$attrs来传递数据适用场景： 当我们要实现从A中向C中传递数据时，使用$attrs，实现当前组件的父组件(A组件)，给当前组件的子组件(C组件)传递数据 实现：在B组件中，给C组件绑定一个属性v-bind=&#39;$attrs&#39;即可 该三个组件属于内嵌关系，A组件中使用了B组件，B组件中使用了C组件 数据的流向实际上是：A组件(父组件中定义的数据)—-&gt;B组件—–&gt;B组件通过在C组件上绑定v-bind=$attrs——&gt;孙组件(C组件)收到了来自A组件的数据。这样实际上是爷——&gt;孙组件之间的通信。 爷组件中定义函数，孙组件中调用函数，作为一种回调的形式，实现孙—–&gt;爷的数据传递 $ref和$parent $ref用于父传子 $parent用与子传父 属性 说明， $ref 值是对象，包含所有被ref属性表示的DOM元素或组件实例。 $parent 值为对象，当前组件的父组件实例对象。 注意：在必要时，使用宏函数defineExpose(&#123;&#125;)把要暴露出的东西作为对象。用来解决数据没有拿到的问题 使用provide和inject实现组件通信提供数据的组件使用provide来提供数据 语法： 1234567import &#123;provide, ref&#125; from &#x27;vue&#x27;let username = ref(&#x27;zhangsan&#x27;)function updateFname()&#123; username.value = &#x27;李四&#x27;&#125;//使用provide来提供数据provide(&#x27;nameContext&#x27;,&#123;username,updateFname&#125;) 接收数据的组件通过inject来注入数据 语法： 1234567891011121314&lt;template&gt; &lt;div class=&quot;child&quot;&gt; 父组件传来的数据，父亲的名字是：&#123;&#123; FatherName &#125;&#125; &lt;button @click=&quot;updateFname&quot;&gt;修改父亲的名字&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123;inject, ref&#125; from &#x27;vue&#x27;let FatherName = ref(&#x27;&#x27;)//解构赋值 通过inject并指定key值接收const &#123;username,updateFname&#125; = inject(&#x27;nameContext&#x27;)FatherName = username&lt;/script&gt; 这样就完成了双方的通信。 组件通信总结 监听事件在父组件中，我们可以添加一个 postFontSize ref 来实现这个效果： 12345const posts = ref([ /* ... */])const postFontSize = ref(1) 在模板中用它来控制所有博客文章的字体大小： 1234567&lt;div :style=&quot;&#123; fontSize: postFontSize + &#x27;em&#x27; &#125;&quot;&gt; &lt;BlogPost v-for=&quot;post in posts&quot; :key=&quot;post.id&quot; :title=&quot;post.title&quot; /&gt;&lt;/div&gt; 然后，给 &lt;BlogPost&gt; 组件添加一个按钮： 1234567&lt;!-- BlogPost.vue, 省略了 &lt;script&gt; --&gt;&lt;template&gt; &lt;div class=&quot;blog-post&quot;&gt; &lt;h4&gt;&#123;&#123; title &#125;&#125;&lt;/h4&gt; &lt;button&gt;Enlarge text&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 父组件可以通过 v-on 或 @ 来自定义一个事件 1234&lt;BlogPost ... @enlarge-text=&quot;postFontSize += 0.1&quot; /&gt; 子组件可以通过调用内置的 $emit 方法，通过传入事件名称来抛出一个事件： 1234567&lt;!-- BlogPost.vue, 省略了 &lt;script&gt; --&gt;&lt;template&gt; &lt;div class=&quot;blog-post&quot;&gt; &lt;h4&gt;&#123;&#123; title &#125;&#125;&lt;/h4&gt; &lt;button @click=&quot;$emit(&#x27;enlarge-text&#x27;)&quot;&gt;Enlarge text&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 通过插槽来分配内容一些情况下我们会希望能和 HTML 元素一样向组件中传递内容： 这可以通过 Vue 的自定义 &lt;slot&gt; 元素来实现： 我们使用 &lt;slot&gt; 作为一个占位符，父组件传递进来的内容就会渲染在这里 123456789101112131415&lt;!-- AlertBox.vue --&gt;&lt;template&gt; &lt;div class=&quot;alert-box&quot;&gt; &lt;strong&gt;This is an Error for Demo Purposes&lt;/strong&gt; &lt;!--用于渲染父组件传递来的内容--&gt; &lt;slot /&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.alert-box &#123; /* ... */&#125;&lt;/style&gt; 动态组件有些场景会需要在两个组件间来回切换，比如 Tab 界面： 上面的例子是通过 Vue 的 &lt;component&gt; 元素和特殊的 is attribute 实现的： 12&lt;!-- currentTab 改变时组件也改变 --&gt;&lt;component :is=&quot;tabs[currentTab]&quot;&gt;&lt;/component&gt; 在上面的例子中，被传给 :is 的值可以是以下几种： 被注册的组件名 导入的组件对象 你也可以使用 is 属性 来创建一般的 HTML 元素。 当使用 &lt;component :is=&quot;...&quot;&gt; 来在多个组件间作切换时，被切换掉的组件会被卸载。我们可以通过 &#96;&#96; 组件强制被切换掉的组件仍然保持“存活”的状态。 Vue路由—基础Vue Router 是 Vue 官方的客户端路由解决方案。 客户端路由的作用是在单页应用 (SPA) 中将浏览器的 URL 和用户看到的内容绑定起来。当用户在应用中浏览不同页面时，URL 会随之更新，但页面不需要从服务器重新加载。 Vue Router 基于 Vue 的组件系统构建，你可以通过配置路由来告诉 Vue Router 为每个 URL 路径显示哪些组件。 创建路由器实例路由器实例是通过调用 createRouter() 函数创建的: 1234567891011121314151617181920212223242526import &#123; createRouter,createMemoryHistory &#125; from &#x27;vue-router&#x27;//导入路由组件import HomeView from &#x27;@/components/HomeView.vue&#x27;import AboutView from &#x27;@/components/AboutView.vue&#x27;//编写一组路由规则const routes = [ &#123; path: &#x27;/&#x27;, component: HomeView, &#125;, &#123; path: &#x27;/aboutVue&#x27;, component:AboutView &#125;]//注册路由实例const router = new createRouter(&#123; //这是路由器的工作模式 history: createMemoryHistory(), routes&#125;)//暴露路由export deafult = router 这里的 routes 选项定义了一组路由，把 URL 路径映射到组件。其中，由 component 参数指定的组件就是先前在 App.vue 中被 &lt;RouterView&gt; 渲染的组件。这些路由组件通常被称为视图，但本质上它们只是普通的 Vue 组件。 工作模式这里的 history 选项控制了路由器的工作模式，下面详细解释一下路由器的工作模式： 注册路由器插件一旦创建了我们的路由器实例，我们就需要将其注册为插件，这一步骤可以通过调用 use() 来完成。 123const app = createApp(App)app.use(router)app.mount(&#x27;#app&#x27;) 和大多数的 Vue 插件一样，use() 需要在 mount() 之前调用。 如果你好奇这个插件做了什么，它的职责包括： 全局注册 RouterView 和 RouterLink 组件。 添加全局 $router 和 $route 属性。 启用 useRouter() 和 useRoute() 组合式函数。 触发路由器解析初始路由。 访问路由器和当前路由如果你是从 ES 模块导出路由器实例的，你可以将路由器实例直接导入到你需要它的地方。在一些情况下这是最好的方法。 在组件模板中，路由器实例将被暴露为 $router。这与同样被暴露的 $route 一样，但注意前者最后有一个额外的 r。 1234567891011121314151617&lt;script setup&gt;import &#123; computed &#125; from &#x27;vue&#x27;import &#123; useRoute, useRouter &#125; from &#x27;vue-router&#x27; //通过这种方法获取路由器实例和当前路由const router = useRouter()const route = useRoute()const search = computed(&#123; get() &#123; return route.query.search ?? &#x27;&#x27; &#125;, set(search) &#123; router.replace(&#123; query: &#123; search &#125; &#125;) &#125;&#125;)&lt;/script&gt; 你现在不一定要完全理解这段代码，关键是要知道可以通过 useRouter() 和 useRoute() 来访问路由器实例和当前路由。 router 和 route常常以 router 作为路由器实例提及。即由 createRouter() 返回的对象。在应用中，访问该对象的方式取决于上下文。在选项式 API 中，它可以通过 this.$router 来访问。 RouterView 和 RouterLink在模板中，组件的名字可以是 PascalCase 风格或 kebab-case 风格的。Vue 的模板编译器支持两种格式，因此 &lt;RouterView&gt; 和 &lt;router-view&gt; 通常是等效的。此时应该遵循你自己项目中使用的约定。 如果使用 DOM 内模板，那么需要注意：组件名字必须使用 kebab-case 风格且不支持自闭合标签。因此你不能直接写 &lt;RouterView /&gt;，而需要使用 &lt;router-view&gt;&lt;/router-view&gt;。 Vue路由—路由参数query参数两种传递方式: 1.直接拼接参数在路径中 1&lt;routerLink to=&#x27;/user/details?name=jack&amp;age=20&#x27;&gt;&lt;/routerLink&gt; 2.写成对象形式 1234567&lt;routerLink :to=&#x27;&#123; path:&#x27;/user/details&#x27;, query:&#123; name:&#x27;jack&#x27;, age;20 &#125; &#125;&#x27;&gt;&lt;/routerLink&gt; params参数当我们使用params参数时，有两个注意点： 1.定义路由规则时，需要指定占位参数 1234567891011121314151617const router = createRouter(&#123; routes:[ &#123; path:&#x27;/user&#x27;, name:&#x27;routeOne&#x27;, //组件 componet:News children:&#123; //设置路由跳转时用到的属性name name:&#x27;routeTwo&#x27; //在这里需要使用占位参数来指定接收某个参数 path:&#x27;details/:name/:age&#x27;, componet:details, &#125; &#125; ]&#125;) 2.设置跳转时，只能用name，不能用path 123456789&lt;routerLink :to=&#x27;&#123; //这里只能用name，不能用path name:&#x27;routeTwo&#x27;, //传递的参数 params:&#123; name:&#x27;jack&#x27;, age:20 &#125; &#125;&#x27;&gt;&lt;/routerLink&gt; Vue路由—路由属性props属性props写法——布尔模式下面这种实例中的写法，有这多层级的调用 1234567&lt;!-- User.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;!--三层调用--&gt; User &#123;&#123; $route.params.id &#125;&#125; &lt;/div&gt;&lt;/template&gt; 们可以通过 props 配置来解除这种行为：在路由规则当中，设置属性props为true时，如下 123456const routes = [ &#123; path: &#x27;/user/:id&#x27;, component: User, props: true &#125;] 此时，我们就可以在对应路由组件中定义defaultProps函数来接收该属性。因为props属性已经将params参数作为props传递给了User路由组件，所以此时就会变成下面这种写法： 12345678910&lt;script setup&gt; defaultProps([&#x27;id&#x27;])&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;!--这里就可以直接渲染id而不必去写多余的访问层级--&gt; User &#123;&#123; id &#125;&#125; &lt;/div&gt;&lt;/template&gt; props写法——函数写法该写法可以自己决定将什么作为props传递给路由组件，注意return出去(query参数适用) 123456789const routes = [ &#123; path: &#x27;/user/:id&#x27;, component: User, props(route)&#123; //可以选择打印route，结果是当前路由，所以可以读取到query属性 return route.query &#125; &#125;] 12345678910&lt;script setup&gt; defaultProps([&#x27;id&#x27;])&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;!--这里就可以直接渲染id而不必去写多余的访问层级--&gt; User &#123;&#123; id &#125;&#125; &lt;/div&gt;&lt;/template&gt; props写法——对象写法可以自己决定将什么作为props传递给路由组件。 12345678910const routes = [ &#123; path: &#x27;/user/:id&#x27;, component: User, props:&#123; a:100, b:200, c:90 &#125; &#125;] replace属性在提及replace时，我们先说一个属性push，因为该属性是默认值。 1.属性位置：写在路由的routerLink标签中,因其是默认值所以可以不写 1&lt;routerLink push&gt;&lt;/routerLink&gt; 2.功能：可以让我们返回上一个访问的页面。 3.工作方式：类似于栈的先进，就是最先访问的页面会被放在最里面。 4.图解： replace属性，不是这样的，它不会让我们返回上一次访问的页面 1.属性位置：写在路由的routerLink标签中 1&lt;routerLink replace&gt;&lt;/routerLink&gt; 2.功能：不能让我们返回上一个访问的页面。 3.工作方式：最先访问的页面会被后面访问的页面替换掉 4.图解： Vue路由—编程式导航除了使用 &lt;router-link&gt; 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。 1.拿到路由器对象实例 123impotr &#123; useRouter &#125; from &#x27;vue-router&#x27;//拿到路由器对象const router = useRouter() 2.借助对象中的.push方法完成跳转 12router.push()//push方法可以传递字符串也可以传递对象，类似与routerLink中的to的用法 Vue路由—重定向给路由添加redirect属性，下面例子是从 /home 重定向到 /： 1const routes = [&#123; path: &#x27;/home&#x27;, redirect: &#x27;/&#x27; &#125;] 重定向的目标也可以是一个命名的路由： 1const routes = [&#123; path: &#x27;/home&#x27;, redirect: &#123; name: &#x27;homepage&#x27; &#125; &#125;] 甚至是一个方法，动态返回重定向目标： 123456789101112131415const routes = [ &#123; // /search/screens -&gt; /search?q=screens path: &#x27;/search/:searchText&#x27;, redirect: to =&gt; &#123; // 方法接收目标路由作为参数 // return 重定向的字符串路径/路径对象 return &#123; path: &#x27;/search&#x27;, query: &#123; q: to.params.searchText &#125; &#125; &#125;, &#125;, &#123; path: &#x27;/search&#x27;, // ... &#125;,] 插槽默认插槽通过slot标签，来对要渲染的内容进行占位 把内容写在双标签内，通过slot对组件标签里的内容要进行占位，那么只要在双标签内写内容，该内容就会渲染到slot指定的位置 具名插槽就是带有name标签属性的插槽，作用还是用来占位置，只是在向插槽添加内容时，有不同与默认插槽的写法 语法： 1&lt;slot name=&#x27;s1&#x27;&gt;&lt;/slot&gt; 写法： 使用template标签，并使用v-slot:xxx来指定插槽名称，xxx指的是名称,当然了我们也可以简写v-slot:xxx为#xxx 作用域插槽适用场景：数据在子组件中，但根据数据生成的结构，由父组件决定 为何称为”作用域”？，因为数据时维护在子组件中的，父组件想要使用数据，那么这时候就产生了作用域问题，因为父组件访问不到子组件的数据 语法： 在插槽上通过props来传递数据即可，子组件中有如下写法： 123456789101112131415161718192021&lt;template&gt; &lt;div class=&quot;child&quot;&gt; &lt;h2&gt;射击游戏&lt;/h2&gt; &lt;slot :game=&quot;shotGame&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; reactive &#125; from &#x27;vue&#x27;;let shotGame = reactive([ &#123; id: 1, name: &#x27;战地五&#x27; &#125;, &#123; id: 2, name: &#x27;csol&#x27; &#125;, &#123; id: 3, name: &#x27;战地1&#x27; &#125;,])&lt;/script&gt; 在父组件中，不需要使用宏函数defineProps来进行接收，只需要在使用的模板上指定v-slot=&#39;xxx&#39;，这样，子组件上绑定的名为game数据就以一个对象的形式传到了父组件中 查看参数： 这时，通过params.game就能够访问到子组件中的数据，这就是作用域插槽的使用。 其他API：shallowRef()ref() 的浅层作用形式。 和 ref() 不同，浅层 ref 只会让第一层级的数据是响应式的，只有对 .value 的访问是响应式的。 示例 1234567const state = shallowRef(&#123; count: 1 &#125;)// 不会触发更改state.value.count = 2// 会触发更改state.value = &#123; count: 2 &#125; 作用：shallowRef() 常常用于对大型数据结构的性能优化或是与外部的状态管理系统集成。 shallowReactive()reactive() 的浅层作用形式。 和 reactive() 不同，这里没有深层级的转换：一个浅层响应式对象里只有根级别的属性是响应式的。属性的值会被原样存储和暴露，这也意味着值为 ref 的属性不会被自动解包了。 123456789101112131415const state = shallowReactive(&#123; foo: 1, nested: &#123; bar: 2 &#125;&#125;)// 更改状态自身的属性是响应式的state.foo++// ...但下层嵌套对象不会被转为响应式isReactive(state.nested) // false// 不是响应式的state.nested.bar++ readonly()接受一个对象 (不论是响应式还是普通的) 或是一个 ref，返回一个原值的只读代理。 只读代理是深层的：对任何嵌套属性的访问都将是只读的。它的 ref 解包行为与 reactive() 相同，但解包得到的值是只读的。 1234567891011121314const original = reactive(&#123; count: 0 &#125;)const copy = readonly(original)watchEffect(() =&gt; &#123; // 用来做响应性追踪 console.log(copy.count)&#125;)// 更改源属性会触发其依赖的侦听器original.count++// 更改该只读副本将会失败，并会得到一个警告copy.count++ // warning! 例子很明显，如果直接更改原属性，那么只读属性的copy也会跟着变化并触发侦听器，当我们直接更改只读属性时，这时由于属性是只读的，那么我们就会得到一个警告：该属性是只读属性！ shallowReadonly()readonly() 的浅层作用形式 和 readonly() 不同，这里没有深层级的转换：只有根层级的属性变为了只读。属性的值都会被原样存储和暴露，这也意味着值为 ref 的属性不会被自动解包了。 123456789101112131415const state = shallowReadonly(&#123; foo: 1, nested: &#123; bar: 2 &#125;&#125;)// 更改状态自身的属性会失败state.foo++// ...但可以更改下层嵌套对象isReadonly(state.nested) // false// 这是可以通过的state.nested.bar++ toRaw()根据一个 Vue 创建的代理返回其原始对象。 详细信息 toRaw() 可以返回由 reactive()、readonly()、shallowReactive() 或者 shallowReadonly() 创建的代理对应的原始对象。 123456789101112&lt;script setup&gt;import &#123;reactive,toRaw&#125; from &#x27;vue&#x27; let person = reactive(&#123; name:&#x27;tony&#x27;, age:18 &#125;) //通过toRaw返回原始对象 let person2 = toRaw(person) console.log(&#x27;响应式数据&#x27;,person) //修改person2不会触发视图更新 console.log(&#x27;原始对象&#x27;,person2)&lt;/script&gt; 控制台输出： markRaw()将一个对象标记，并且该对象永远不能转为响应式对象。返回该对象本身。 1234//markRaw()let car = markRaw(&#123;brand:&#x27;奔驰&#x27;，price:100&#125;)let car2 = reactive(car)//这里创建响应式对象car2会失败，因为car已经被markRaw标记了 customRef()customRef() 预期接收一个工厂函数作为参数，这个工厂函数接受 track 和 trigger 两个函数作为参数，并返回一个带有 get 和 set 方法的对象。 示例 创建一个防抖 ref，即只在最近一次 set 调用后的1秒后再调用： 12345678910111213141516171819202122232425262728&lt;script setup&gt;import &#123; customRef &#125; from &#x27;vue&#x27;;let initMsg=&#x27;你好&#x27;let timeOut//customRef的用法let msg = customRef((track,trigger)=&gt;&#123; return &#123; //当有人访问msg时，调用get get()&#123; //跟踪 track() //--------通过track()函数告诉vue，数据msg很重要，需要让vue保持跟踪状态 console.log(&#x27;有人访问了msg&#x27;); return initMsg &#125;, //当有人修改msg时，调用set,这里的value是修改后的新值 set(value)&#123; clearTimeout(timeOut) setTimeout(() =&gt; &#123; console.log(&#x27;有人修改了msg&#x27;); initMsg = value //触发 trigger() //------------通过trigger()函数告诉vue，数据已经更改了 &#125;, 1000); &#125; &#125;&#125;)&lt;/script&gt; 但是在真实的业务场景中，我们一般将其封装为一个hooks。 新建useMsg.js文件 代码如下： 123456789101112131415161718192021222324252627282930import &#123; customRef &#125; from &#x27;vue&#x27;;export default function(initMsg,delay)&#123;let timeOut//customRef的用法let msg = customRef((track,trigger)=&gt;&#123; return &#123; //当有人访问msg时，调用get get()&#123; //跟踪 track() //--------通过track()函数告诉vue，数据msg很重要，需要让vue保持跟踪状态 console.log(&#x27;有人访问了msg&#x27;); return initMsg &#125;, //当有人修改msg时，调用set,这里的value是修改后的新值 set(value)&#123; //清除定时器 clearTimeout(timeOut) timeOut = setTimeout(() =&gt; &#123; console.log(&#x27;有人修改了msg&#x27;); initMsg = value //触发 trigger() //------------通过trigger()函数告诉vue，数据已经更改了 &#125;, delay); &#125; &#125;&#125;)return msg&#125; 使用： 1234567&lt;script setup&gt;import useMsg from &#x27;@/hooks/useMsg&#x27;;let msg =useMsg(&#x27;你好&#x27;,3000)console.log(msg);&lt;/script&gt; 查看控制台输出 内置组件Teleport&lt;Teleport&gt; 是一个内置组件，它可以将一个组件内部的一部分模板“传送”到该组件的 DOM 结构外层的位置去。 基本用法应用场景 一个组件模板的一部分在逻辑上从属于该组件，但从整个应用视图的角度来看，它在 DOM 中应该被渲染在整个 Vue 应用外部的其他地方。 这类场景最常见的例子就是全屏的模态框。(提示框) 1234567891011&lt;template&gt;&lt;div class=&quot;outer&quot;&gt; &lt;h3&gt;Tooltips with Vue 3 Teleport&lt;/h3&gt; &lt;div&gt; &lt;MyModal /&gt; &lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import MyModal from &#x27;@/Teleport/MyModal.vue&#x27;&lt;/script&gt; 12345678910111213141516171819202122232425&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const open = ref(false)&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;open = true&quot;&gt;Open Modal&lt;/button&gt; &lt;div v-if=&quot;open&quot; class=&quot;modal&quot;&gt; &lt;p&gt;Hello from the modal!&lt;/p&gt; &lt;button @click=&quot;open = false&quot;&gt;Close&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.modal &#123; position: fixed; z-index: 999; top: 20%; left: 50%; width: 300px; margin-left: -150px;&#125;&lt;/style&gt; 当在初始 HTML 结构中使用这个组件时，会有一些潜在的问题： position: fixed 能够相对于浏览器窗口放置有一个条件，那就是不能有任何祖先元素设置了 transform、perspective 或者 filter 样式属性。也就是说如果我们想要用 CSS transform 为祖先节点 &lt;div class=&quot;outer&quot;&gt; 设置动画，就会不小心破坏模态框的布局！ 这个模态框的 z-index 受限于它的容器元素。如果有其他元素与 &lt;div class=&quot;outer&quot;&gt; 重叠并有更高的 z-index，则它会覆盖住我们的模态框。 为了解决上述问题，Teleport组件提供了简单方法来实现。 12345678&lt;button @click=&quot;open = true&quot;&gt;Open Modal&lt;/button&gt;&lt;Teleport to=&quot;body&quot;&gt; &lt;div v-if=&quot;open&quot; class=&quot;modal&quot;&gt; &lt;p&gt;Hello from the modal!&lt;/p&gt; &lt;button @click=&quot;open = false&quot;&gt;Close&lt;/button&gt; &lt;/div&gt;&lt;/Teleport&gt; 这段代码中，使用了Teleport组件，to=&#39;body&#39;用来指定一个传送的目标（意思是把Teleport内的代码渲染在什么地方），to的值可以是一个CSS选择器，也可以是一个DOM元素对象。上面的代码的作用就是告诉 Vue“把以下模板片段传送到 body 标签下”。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://example.com/tags/vue-js/"}]},{"title":"Nginx网关","slug":"Nginx网关","date":"2024-06-10T08:54:18.000Z","updated":"2024-07-09T03:57:26.728Z","comments":true,"path":"2024/06/10/Nginx网关/","permalink":"http://example.com/2024/06/10/Nginx%E7%BD%91%E5%85%B3/","excerpt":"","text":"1. Nginx安装目录(对于源码安装): 当使用源代码编译安装 Nginx 时，整个 Nginx 的安装树可能位于此目录下。这包括可执行文件、配置文件、文档和模块文件等。 内部可能包含以下子目录： client_body_temp: 用于存储上传的大文件的临时目录。 conf: 包含所有的配置文件，如 nginx.conf，以及其他的配置片段或模块配置。 html: 这是 Nginx 的默认网站根目录，通常包含默认的 HTML 页面。 logs: 类似于 /var/log/nginx，用于存储日志文件。 mime.types: 包含 MIME 类型的定义，用于识别和处理不同的文件类型。 modules: 可能包含 Nginx 的模块文件，用于扩展 Nginx 的功能。 sbin: 包含 Nginx 的二进制可执行文件。 2. Nginx多线程请求模型和基本请求流程 Nginx 的设计并不基于传统的多线程模型来处理请求，而是采用了异步非阻塞的事件驱动模型。Nginx 使用了多进程（多worker进程）模型来提高并发性能和稳定性，每个worker进程内处理请求时则利用了高效的事件处理机制。 2.1 Nginx 的多进程模型Nginx 的工作模型包括一个master进程和多个worker进程。master进程主要负责读取和验证配置文件，生成worker进程，并监听和响应来自worker进程和外部的信号，如重启、停止等操作。worker进程则负责处理所有来自客户端的网络请求。 2.2 Nginx 的事件驱动模型每个worker进程都有自己的事件循环，可以同时处理多个连接。Nginx 使用了高效的事件处理模块，比如epoll（Linux）、kqueue（BSD系统）等，这些模块允许Nginx在一个进程内处理成千上万的并发连接，而无需为每一个连接创建一个新的线程。 2.3 Nginx 的基本请求处理流程当一个HTTP请求到达Nginx时，它遵循以下基本流程： 接受连接：Nginx监听在配置的端口上，当请求到达时，master进程通过套接字接受连接，然后将连接分配给一个空闲的worker进程。 读取请求：worker进程读取客户端的HTTP请求，包括请求行、请求头和可能的请求体。 解析请求：解析请求的URL、HTTP方法、协议版本等信息。 处理请求：根据配置文件中的规则和指令，Nginx决定如何处理请求，这可能包括： 路由到正确的站点或服务器块。 提供静态文件服务。 执行重定向。 执行反向代理，将请求转发到后端服务器。 执行负载均衡，选择后端服务器池中的一个服务器。 执行缓存策略，检查是否有缓存的数据可以提供。 生成响应：一旦请求被处理，Nginx会生成响应，这可能包括从文件系统读取数据、从后端服务器获取数据或从缓存中获取数据。 发送响应：将响应发送回客户端，包括HTTP状态行、响应头和响应体。 记录日志：Nginx会记录请求和响应的信息到日志文件，通常包括访问日志和错误日志。 关闭连接：根据HTTP协议版本和配置，Nginx可能会保持连接打开一段时间（持久连接）或立即关闭连接。 这种模型允许Nginx高效地处理大量的并发连接，同时也保持了较低的内存消耗和CPU占用率。由于每个worker进程独立处理请求，即使一个请求处理失败，也不会影响其他worker进程的正常工作。 3. Nginx配置文件nginx.conf详解Nginx的配置文件nginx.conf是其核心配置所在，用于定义Nginx的行为和服务设置。以下是您提到的一些关键配置项的详细解释： 3.1 worker_connections属性worker_connections是events块中的一个配置项，用来指定每个worker进程能够同时打开的最大连接数。这是Nginx并发能力的关键设置。例如： Nginx 1231events &#123;2 worker_connections 1024;3&#125; 默认情况下，这个值通常是系统限制的最大文件描述符数量。增加这个值可以提高Nginx处理并发连接的能力，但也要考虑到系统的实际硬件资源，如内存。 3.2 http属性http块包含了全局的HTTP设置和虚拟服务器定义。在这个块中，你可以定义各种与HTTP相关的设置，比如MIME类型、日志格式、gzip压缩、缓存、SSL证书等。例如： Nginx 123456789101http &#123;2 include mime.types;3 default_type application/octet-stream;45 sendfile on;6 tcp_nopush on;7 tcp_nodelay on;89 keepalive_timeout 65;10&#125; 3.3 sendfile属性sendfile是一个与文件传输相关的指令，控制Nginx是否使用高效的操作系统级别的文件传输方式。默认情况下，它是开启的(on)。使用sendfile可以避免用户空间和内核空间之间的数据复制，从而提高文件传输效率。例如： Nginx 11 sendfile on; 3.4keepalive_timeout属性keepalive_timeout用于设置HTTP持久连接（keep-alive）的超时时间。这是客户端和服务器之间保持连接打开的时间长度，直到超时或被关闭。例如： Nginx 11 keepalive_timeout 65; 这个设置对于减少网络延迟和提高性能非常重要，因为它允许客户端和服务器在多个请求间重用同一个TCP连接，而不需要每次请求都重新建立和关闭连接。 3.5 server属性server块用于定义一个虚拟服务器，可以绑定到特定的IP地址和端口，或者监听所有的可用接口。每个server块都可以有自己独立的设置，包括监听的端口、主机名、请求处理逻辑等。例如： Nginx 123456781server &#123; //监听端口号2 listen 80; //主机名称3 server_name localhost;45 # 配置请求路由、错误页面、日志等6&#125; 每个server块都可以包含多个location块，用于更细粒度的请求路由和处理。通过不同的server块，Nginx可以同时为多个不同的域名或服务提供服务。 正确配置这些选项对于优化Nginx的性能、安全性和功能性至关重要。 3.5.1 Server Blockserver 是 Nginx 中用于定义一个虚拟服务器的配置块，可以理解为一个独立的“网站”配置。每个 server 块可以绑定到一个或多个 IP 地址和端口，也可以监听特定的域名。server 块内的设置定义了该虚拟服务器的行为，包括但不限于： listen: 指定要监听的端口和地址，例如 listen 80; 表示监听 80 端口。 server_name: 设置虚拟服务器的域名，例如 server_name example.com;。 3.5.2 Location Blocklocation 块是 server 块内的子配置块，用于更精细地控制请求的处理方式。它基于 URL 的路径模式来匹配请求，并应用相应的配置。例如： 精确匹配: location = /index.html &#123; ... &#125; 前缀匹配: location /images/ &#123; ... &#125; 正则表达式匹配: location ~* \\.(jpg|jpeg|gif|png)$ &#123; ... &#125; location 块内的配置可以包括静态文件服务、反向代理设置、重写规则、错误页定制、访问控制等。 3.5.3 Error_page Directiveerror_page 指令用于定义特定错误代码的自定义错误页面。它可以将一组错误代码映射到一个特定的 URI，当发生这些错误时，Nginx 将重定向到该 URI。例如： Nginx 11error_page 404 /404.html; 这表示当 Nginx 遇到 404 错误时，会显示 /404.html 文件作为错误页面。error_page 可以在 http、server 或 location 块中定义。 4. Nginx 反向代理和负载均衡4.1 Nginx 反向代理Nginx作为反向代理服务器时，其主要工作原理是位于网络服务器群前端，接受来自客户端（如浏览器）的请求，但客户端并不直接知道实际提供服务的服务器位置。Nginx根据预设的规则将请求转发至后端服务器之一，并将该服务器的响应再转发回客户端。这一过程对客户端是透明的，即客户端只知道Nginx的地址，而不知道实际提供服务的服务器地址。 优点： 安全：隐藏后端服务器的真实IP，增强安全防护。 性能优化：可以通过缓存、压缩等技术减少后端服务器的负担。 负载均衡：通过分配请求到不同的后端服务器，实现资源的有效利用，提高系统整体性能。 4.2 负载均衡负载均衡是指将大量并发访问或数据流量合理地分配到多台服务器上，以达到最优资源利用，最大化处理能力，最小化响应时间，同时避免任何单一服务器过载。Nginx作为一个优秀的负载均衡器，它提供了多种算法来决定如何将请求分发到后端服务器，包括但不限于轮询（Round Robin）、最少连接数（Least Connections）、IP哈希（IP Hash）等。 轮询：按照顺序将请求分发给后端服务器。 最少连接数：将新请求分发给当前连接数最少的服务器。 IP哈希：根据客户端的IP地址进行哈希运算，将同一客户端的请求尽量分发到同一服务器上，以保持会话的一致性。 4.3 正向代理正向代理与反向代理的工作方式相反。正向代理位于客户端一侧，它的主要作用是代表客户端去获取互联网上的资源，而不是像反向代理那样代表服务器接收请求。当客户端配置了正向代理后，所有对外的请求都会先经过这个代理，由代理服务器代替客户端去访问目标服务器，获取资源后再返回给客户端。 用途： 匿名访问：通过代理服务器隐藏客户端的真实IP，保护隐私。 内容过滤：企业或学校网络中常见的场景，用于过滤不适宜的网站或内容。 缓存加速：对于重复的请求，代理服务器可以缓存资源，提高访问速度。 正向代理和反向代理虽然在工作方向上有本质的区别，但在实际应用中，它们都可以起到优化网络性能、提高安全性和控制网络流量的作用。Nginx本身既可以配置为反向代理，也可以配置为正向代理，不过在实践中更多被用作反向代理和负载均衡器。","categories":[],"tags":[{"name":"nginx学习","slug":"nginx学习","permalink":"http://example.com/tags/nginx%E5%AD%A6%E4%B9%A0/"}]},{"title":"JavaWeb开发学习","slug":"JavaWeb开发学习","date":"2024-05-02T09:41:21.000Z","updated":"2024-07-21T12:19:01.127Z","comments":true,"path":"2024/05/02/JavaWeb开发学习/","permalink":"http://example.com/2024/05/02/JavaWeb%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Maven Maven是apache旗下的一个开源项目，是一款用于管理和构建java项目的工具。 maven的作用： 仓库:用于存储资源，管理各种jar包。 本地仓库:自己计算机上的一个目录。 中央仓库:由Maven团队维护的全球唯一的。仓库地址:https://repo1.maven.qrg/maven2/ 远程仓库(私服):一般由公司团队搭建的私有仓库。 maven中的坐标： maven中的坐标是资源的唯一标识，通过该坐标可以唯一定位资源位置。 使用坐标来定义项目或引入项目中需要的依赖。 Maven 坐标主要组成： groupld:定义当前Maven项目隶属组织名称(通常是域名反写，例如:com.itheima)。 artifactld:定义当前Maven项目名称(通常是模块名称，例如 order-service、goods-service)。 version:定义当前项目版本号 依赖传递 依赖具有传递性 直接依赖:在当前项目中通过依赖配置建立的依赖关系。 间接依赖:被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源 排除依赖： 排除依赖指主动断开依赖的资源，被排除的资源无需指定版本。 上面通过标签来排除。 依赖范围：依赖的jar包在默认情况下可以再任何地方使用。但是我们通过标签可以指定它的作用范围。 主程序范围有效。(main文件夹范围内) 测试程序范围有效。(test文件夹范围内) 是否参与打包运行。(package指令范围内) maven的生命周期： clean：清理。 compile：编译 test：测试 package：打包 install：安装(将打好的jar包安装到本地仓库) 官网：https://spring.io Spring形成一种开发生态圈，Spring提供了若干个子项目，每个项目用于完成特定功能。 ServletServlet简介 Servlet就是sun公司开发动态web的一门技术 Sun在这些API中提供了一个接口叫做 ：Servlet，如果你想开发一个Servlet程序，只需要完成两个步骤： 编写一个类实现Servlet接口 把开发好的Java类部署到web服务器中 把实现了Servlet接口的java程序叫做Servlet HelloServletServlet接口有两个默认的实现类：HttpServlet，GenericServlet 1.构建一个Maven项目，删掉里面的src目录，以后就可以在这个项目里面建立多个Moduel(模块)，这个空的就是主工程 子工程的项目结构 2.关于Maven父子工程的理解 父项目中会有一个 123&lt;modules&gt; &lt;module&gt;Servlet-01&lt;/module&gt;&lt;/modules&gt; 子项目中会有 1234&lt;groupId&gt;org.example&lt;/groupId&gt;&lt;artifactId&gt;JavaWeb-02-Servlet&lt;/artifactId&gt;&lt;packaging&gt;pom&lt;/packaging&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; 4.编写一个Servlet程序 ​ 1.编写一个普通类 ​ 2.实现Servlet接口，这里我们直接继承HttpServlet 12345678910111213141516171819202122package com.li;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class HelloServlet extends HttpServlet &#123; //由于Get或者post只是请求实现方式不同，可以相互调用，业务逻辑一样 @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; PrintWriter writer = resp.getWriter(); //响应流 writer.print(&quot;Hello Servlet&quot;); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 5.编写Servlet的映射 ​ 为什么要映射：我们写Java程序，但是要通过浏览器访问，而浏览器需要连接Web服务器，所以我们需要在Web服务中注册我们写的Servlet。还需要给他浏览器能够访问的路径。 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt;&lt;!-- 注册Servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;com.li.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt;&lt;!-- Servlet请求路径--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 6.配置Tomcat ​ 注意 ：配置项目发布的路径 在第二步中，要注意下面问题 启动运行即可 Servlet原理 Mapping映射问题1、一个Servlet可以指定一个映射路径 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 2、一个Servlet可以指定多个映射路径 123456789101112131415161718192021222324&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello2&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello3&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello4&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello5&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 3、一个Servlet可以指定通用映射路径 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 4、默认请求路径 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 5、指定一些后缀或者前缀等等… 12345&lt;!-- 注意，*前面不能加项目映射的路径--&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;*.demo&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 6、优先级问题指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求； 12345678910&lt;!--404--&gt;&lt;servlet&gt; &lt;servlet-name&gt;error&lt;/servlet-name&gt; &lt;servlet-class&gt;com.kuang.servlet.ErrorServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;error&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; ServletContextweb容器在启动时候，它会为每个web程序都穿件一个对应的ServletContext对象，它代表了当前web应用； 1、共享数据 我们在一个servlet中放入数据，可以在另一个Servlet中拿到这个数据 public class HelloServlet extends HttpServlet &#123; //放入数据 @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;hello&quot;); ServletContext servletContext = this.getServletContext();// Servlet上下文 String name = &quot;小李&quot;; servletContext.setAttribute(&quot;username&quot;,name); //将一个数据保存在了Servlet中，名字为username，值是name &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125; &#125; 1234567891011121314151617181920* ```java public class GetServlet extends HttpServlet &#123; //拿到数据 @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //this.getServletContext();拿到的servletContext是和前一个类一样的容器 ServletContext servletContext = this.getServletContext(); String username =(String)servletContext.getAttribute(&quot;username&quot;); resp.setContentType(&quot;text/html&quot;); resp.setCharacterEncoding(&quot;UTF-8&quot;); resp.getWriter().print(&quot;名字是：&quot;+username); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125; &#125; 测试结果： 2、获取初始化参数12345&lt;!--配置一些web应用初始化参数--&gt;`&lt;context-param&gt;` &lt;param-name&gt;application-name&lt;/param-name&gt;` &lt;param-value&gt;学习Servlet&lt;/param-value&gt;`context-param&gt;` 1234567891011121314public class ServletDemo03 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletContext servletContext = this.getServletContext(); //调用方法，但是注意要在web.xml注册。 String url = servletContext.getInitParameter(&quot;url&quot;); resp.getWriter().print(url); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 3、进行请求转发123456789101112131415public class ServletDemo04 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletContext servletContext = this.getServletContext(); //参数是要转发的地址 RequestDispatcher requestDispatcher = servletContext.getRequestDispatcher(&quot;/hello&quot;); //转发的请求路径 requestDispatcher.forward(req,resp); //调用forward进行请求转发 &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 4、读取资源文件需要一个文件流 12345678910@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获得文件流的方法getResourceAsStream() InputStream is = this.getServletContext().getResourceAsStream(&quot;/WEB-INF/db.properties&quot;); Properties prop = new Properties(); prop.load(is); String user = prop.getProperty(&quot;username&quot;); String pwd = prop.getProperty(&quot;password&quot;); resp.getWriter().print(user+&quot;:&quot;+pwd);&#125; HttpServletRequest(6.21学到了狂神的servlet的这个地方)HttpServletResponseweb服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象，代表响应的一个HttpServletResponse； 获取客户端请求过来的参数：HttpServletRequest 响应客户端响应一些信息：HttpServletResponse SpringBoot入门 编写一个入门程序，浏览器访问url输出Hello，Spring！字样 项目结构： 第一步，在java包下的com下新建controller包下创建HelloTestController类中添加如下内容： 123456789101112131415package com.xiaoli.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController//该注解相当于@Controller + @ResponseBody@RequestMapping(&quot;/hello&quot;)public class HelloSpringController &#123; @GetMapping(&quot;/test&quot;) public void testSpring()&#123; System.out.println(&quot;Hello,Spring,你好，Spring&quot;); &#125;&#125; 启动类下启动SpringBoot项目，访问&#x2F;hello&#x2F;test查看页控制台输出 浏览器输出： 概念:Hyper Text Transfer Protocol，超文本传输协议，规定了浏览器和服务器之间数据传输的规则。 特点: 基于TCP协议:面向连接，安全 基于请求-响应模型的:一次请求对应一次响应 HTTP协议是无状态的协议:对于事务处理没有记忆能力。每次请求-响应都是独立的。 缺点:多次请求间不能共享数据。 优点:速度快 4.HTTP默认端口：80 5.HTTPS默认端口：443 HTTP 1.0: HTTP&#x2F;1.0:客户端可以与Web服务器连接，只能获得一个web资源，断开连接。 HTTP&#x2F;1.1：客户端可以与Web服务器连接，可以获得多个web资源 HTTP——请求数据格式客户端——发请求(Request)——服务器 请求行：请求数据的第一行(请求方式、资源路径、协议) 请求头：第二行开始，key：value格式 请求体：(post请求独有)，存放请求的参数 拿下面这一段代码举例： 我们来看下，他的各个部分代表着什么含义： HTTP——响应格式服务器——响应——客户端 响应行：响应数据的第一行(协议、状态码、描述) 状态码 ： 常见的响应状态码： 响应状态码 200:请求响应成功 200 3xx:请求重定向 重定向:你重新到我给你新位置去; 4xx:找不到资源 404资源不存在 5xx:服务器代码错误 500502:网关错误 常见面试题： ​ 当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么? 响应头：第二行开始，格式key：value 常见的响应头： 响应体：最后一部分，存放响应数据。 Web服务器——Tomcat 是一个开源免费的轻量级Web服务器，支持Servlet&#x2F;JSP少量JavaEE规范。 Tomcat也称为Web容器、Servlet容器。Servlet程序需要依赖于Tomcat才能运行。 Tomcat官网：https://tomcat.apache.org/ Tomcat目录说明 请求和响应概述（1）BS架构和CS架构 （2）接口测试的工具postman，apifox等等都可以 （3） 简单参数 原始方式 在原始Web程序中，获取求情参数，需要通过HttpServletRequest对象手动获取 实现代码： //请求地址 @RequestMapping(&quot;/simpleParam&quot;) public String simpleParam(HttpServletRequest request)&#123; //获取参数名称为name的值，赋值给变量name String name = request.getParameter(&quot;name&quot;); //获取参数名称为age的值，赋值给变量ageStr String ageStr = request.getParameter(&quot;age&quot;); //把ageStr转成int类型，赋值给age变量 int age = Integer.paseInt(ageStr); System.out.println(name+&quot;:&quot;+age); return &quot;ok;&quot; &#125; 123456789101112* SpringBoot方法： * 实现代码： ```java //请求地址 @RequestMapping(&quot;/simpleParam&quot;) public String simpleParam(String name,Integer age)&#123; System.out.println(name+&quot;:&quot;+age); return &quot;ok;&quot; &#125; 在SpringBoot方法中，如果你请求的参数名称和方法中定义的形参名称不一致，可以使用注解**@RequestParam完成映射。比如我形参为username，但是我请求的参数是name，那么这时候就需要这样改写(如下图形式)。如果说该参数不需要传，那么可以在@RequestParam注解中设置属性required &#x3D; false** 123456//请求地址@RequestMapping(&quot;/simpleParam&quot;)public String simpleParam(@RequestParam(name = &quot;name&quot;,required = false)String username,Integer age)&#123;System.out.println(username+&quot;:&quot;+age);return &quot;ok;&quot;&#125; （4）实体参数 简单实体对象：请求参数名与形参对象属性名相同，定义POJO接收即可。(query参数) 结果： 复杂实体对象：请求参数名与形参对象属性名相同，按照对象层次结构关系即可接受嵌套POJO属性参数。 （5）数组集合参数 数组参数：请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可接收参数。 结果： 集合参数 ：请求参数名称与形参集合名称相同且请求参数为多个时，@RequesParam绑定参数关系。 结果： （6）日期参数 日期参数：使用@DataTimeFormat注解完成日期参数格式转换。 结果： （7）Json参数 JSON参数：JSON数据键名与形参对象属性名相同，定义POJO类型形参即可接收参数，需要使用@RequestBody标识 （8）路径参数 通过URL直接传递参数，使用{….}来标识该路径参数，需要使用**@PathVariable**获取路径参数。 说明： 举例： 123456//接收来自前端的proId@RequestMapping(&quot;/pathParam/&#123;proId&#125;&quot;)public String pathParam(@PathVariable Long proId) &#123; //调用某个方法传入proId实现某种功能等等 return &quot;OK&quot;;&#125; 响应数据(介绍注解**@ResponseBody**)来看一图： 这里介绍注解**@ResponseBody** 类型：方法注解，类注解 位置：Controller方法上&#x2F;类上 作用：将方法返回值直接响应，如果返回值类型是实体对象&#x2F;集合，将会转换为JSON格式响应 说明：**@RestController &#x3D; @Controller + @ResponseBody** 为了统一并且方便管理，这里提供一个统一响应类Result类 三层架构 controller:控制层，接收前端发送的请求，对请求进行处理，并响应数据。 service:业务逻辑层，处理具体的业务逻辑。 dao:数据访问层(Data Access Object)(持久层)，负责数据访问操作，包括数据的增、删、改、查 （2）分层解耦 内聚:软件中各个功能模块内部的功能联系。 耦合:衡量软件中各个层&#x2F;模块之间的依赖、关联的程度。 如何解决耦合过高呢？下面提供解决方法 由图可以看出，我们需要提供一个容器，从而舍弃在controller层中去操作对象这一步。接下来，就介绍控制反转和依赖注入这两个概念。 控制反转: Inversion Of Control，简称IOC。对象的创建控制权由程序自身转移到外部(容器)，这种思想称为控制反转 依赖注入: Dependency Injection，简称DI。容器为应用程序提供运行时，所依赖的资源，称之为依赖注入。 Bean对象:IOC容器中创建、管理的对象，称之为bean。 （3）IOC&amp;DI入门步骤如下： 1.利用@Componet注解，将实现类交给IOC容器管理 注入依赖对象(注入Bean)，只需要在需要注入的对象上面添加注解@AutoWired注解即可完成 （4）IOC详解(控制反转) 对于Bean对象**(IOC容器中创建、管理的对象，称之为bean**)，如若要把某个对象交给IOC容器管理，需要在对应类上加上如下注解： Bean组件扫描 前面声明Bean的四大注解，想要生效，还需要被组件扫描注解**@ComponetScan**扫描。 @ComponetScan注解虽然没有显示配置，但是实际上已经包含在了启动类注解**@SpringBootApplication中，默认扫描范围是启动类所在的包及其子包。** （5）DI详解(依赖注入) Bean注入： 解决方法： 使用@Primary注解，想使用谁就在谁上添加该注解，在进行程序运行时就会使用带有@Primary注解的Bean对象 @AutoWried注解搭配@Qualifier注解： @Resource注解(由JDK提供)：注入哪一个Bean就使用@Resource(name &#x3D; “要注入Bean对象的名字”) 穿插一道面试题： @AutoWried与@Resource注解的区别 ： @Autowired 是spring框架提供的注解。而@Resource是JDK提供的注解。 @Autowired 默认是按照类型注入，而@Resource默认是按照名称注入。 Mysql——查询（1）Mysql——基本查询语法： 123456789# 查询多个字段Select 字段1,字段2,字段3 from 表名；# 查询所有字段(通配符)Selcet * from 表名;# 设置别名(as关键字可以省略)select 字段1 [as &#x27;别名1&#x27;],字段2 [as &#x27;别名2&#x27; ] from 表名;# 去除重复记录select DISTINCT 字段1,字段2 from 表名; （2）Mysql——条件查询 语法： 1select 要查询的字段 from 表名 where 条件 （3）Mysql——聚合函数 语法： 1234567891011121314select 字段列表from 表名列表where 条件列表group by 分组字段列表having 分组后条件列表order by 排序字段列表limit 分页参数 聚合函数： count：统计数量(*是通配符) max：取最大值 min：取最小值 avg：取平均值 sum：求和 语法： 1select 聚合函数(字段名) from 表名 （4）Mysql——分组查询 语法：group by 关键字 1select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后的过滤条件] （5）Mysql——排序查询 关键字：order by 语法： 1select 字段列表 from 表名 [where 条件] group by 分组字段名 order by 字段1 排序方式1,字段2,排序方式2,....; 排序方式： ASC：升序(默认值) DESC：降序 （6）Mysql——分页查询 关键字：limit 语法： select 字段列表 from 表名 limit 起始索引,查询记录数; 123456789101112131415161718192021222324252627282930313233343536373839* 起始索引从0开始。起始索引 = (页码－1) * 5* 注意事项： ![image-20240521202744500](../images/JavaWeb开发学习/image-20240521202744500.png)## Mysql——多表设计#### （1）一对多* 实现：在数据库表中多的一方，添加字段，来关联一的一方的主键* 实现关联可以通过添加外键约束： * 外键语法： * ![image-20240521204007417](../images/JavaWeb开发学习/image-20240521204007417.png)#### （2）一对一* 案例：用户与身份证的关系* 关系：一对一关系，用于单表拆分，将一张表的基础字段放在一张表中，其他字段放在另一张表中，以此来提升操作效率。* 图例：![image-20240525190504774](../images/JavaWeb开发学习/image-20240525190504774.png)#### （3）多对多* 案例：学生和课程之间的关系* 关系：一门课程可以有多个学生选修，而一个学生也可以选修多门课程* 实现：建立一张第三表(中间表)，**中间表至少包含两个外键**，**分别关联两边的主键**。 * 示例：![image-20240525190728405](../images/JavaWeb开发学习/image-20240525190728405.png)## Mysql——多表查询* 概念：从多张表中查询数据。* 笛卡尔积：笛卡尔积是指在数学中，两个集合(两张表)的所有组合情况，而多表查询的结果符合笛卡尔积。 * 语法： ```sql Select * from 表名1,表名2 where 表1.字段名 = 表2.字段名。 这里要注意的是：where后的条件是指表1表2中都有的字段。 分类： 连接查询 内连接：相当于查询A，B交集部分数据 外连接： 左外连接：查询左表所有数据(包括两张表交集部分数据) 右外连接 ：查询有表所有数据(包括两张表交集部分) 图示： 内连接： 隐式内连接：Select 字段列表 from 表1，表2 where 条件…； 显示内连接：Select 字段列表 from [inner] join 表2 on 连接条件.. 外连接 ： 左外连接(会把在左表中而不在右表中的数据查出)：Select 字段列表 from 表1 left [outer] join 表2 on 连接条件….； 右外连接(会把在右表中而不在左表中的数据查出)：select 字段列表 from 表1 left [outer] join 表2 on 连接条件… （1）子查询 介绍：sql语句中嵌套select查询，称为嵌套查询，又称子查询。 形式 ：select * from 表1 where 字段1 &#x3D;(select 字段1 from 表2)； 子查询外部的语句可以是insert &#x2F; update &#x2F; delete &#x2F; select 的任何一个。最常见的是select。 分类 ： 标量子查询:子查询返回的结果为单个值 列子查询:子查询返回的结果为一列 行子查询:子查询返回的结果为一行 表子查询:子查询返回的结果为多行多列 （1）标量子查询 子查询返回的结果是单个值(数字、字符串、日期等)，最简单 的形式。 常用的操作符: &#x3D; &lt;&gt; &gt; &gt;&#x3D; &lt; &lt;&#x3D; （2）列子查询 子查询返回的结果是一列(可以是多行)。 常用操作符：in、not in 等 （3）行子查询 子查询返回的结果是一行(可以是多列) 常用操作符：&#x3D; 、 &lt;&gt; 、 in 、 not in。 示例： 这里需要注意的是，当返回多个字段，(多列)时，可以使用括号，将要返回的字段括起来，并用逗号隔开，里面字段顺序和子查询中的字段顺序一致。 （4）表子查询 子查询返回的结果是多行多列，把它作为临时表来使用。 常用操作符：in Mysql——事务概念： 事务 是一组操作的集合，它是一个不可分割的工作单位。事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作 要么同时成功，要么同时失败。 事务控制： 开启事务：start transaction; &#x2F; begin ; 提交事务：commit; 回滚事务：rollback; 示例：依次运行。 事务的四大特性(ACID)： 原子性：事务是不可分割的最小单元，要么全部成功，要么全部失败 一致性：事务完成时，必须使所有的数据都保持一致状态 隔离性：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行 持久性：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的 （1）Mysql——索引(对数据库查询效率进行优化的手段 )索引的概念：是帮助数据库高效获取数据的数据结构(构建红黑二叉树)。 当一张表没有建立索引的时候，默认查找方法是进行全表扫描，数据量越大，性能越低。 索引的示例： 索引的优缺点： 优点： 缺点： 索引结构： MySQL数据库支持的索引结构有很多，如:Hash索引、B+Tree索引、Full-Text索引等。我们平常所说的索引，如果没有特别指明，都是指默认的 B+Tree 结构组织的索引。 拓展：请求方法以及含义1. GET 意义：GET方法用于从服务器请求信息。它是最常见的HTTP请求类型，主要用于获取资源。当使用GET方法时，请求的参数会被附加在URL后面，以问号分隔。 特点： 安全性：理论上不应该有副作用，不应修改数据或状态。 可缓存：结果可以被缓存。 可收藏：即请求可以被保存、书签化或分享给他人。 参数长度限制：由于参数是URL的一部分，因此可能受到URL长度的限制（尽管现代浏览器和服务器通常可以处理非常长的URL）。 2. POST 意义：POST方法用于向服务器发送数据，通常用于创建新的资源或者更新现有资源的部分内容。POST请求的数据体通常包含在HTTP请求的消息体中。 特点： 不安全：可能会改变服务器上的数据或状态。 不可缓存：结果不应被缓存。 不可收藏：请求不能被保存或分享。 数据大小无限制：理论上没有数据大小的限制。 3. PUT 意义：PUT方法用于替换指定的资源。与POST不同，PUT通常用于更新一个已存在的资源，而不是创建一个新的资源。PUT请求的数据体包含要更新的资源的新状态。 特点： 安全性：理论上不应有副作用，但会修改数据或状态。 可幂等：多次相同的请求应该产生相同的结果。 数据大小无限制：理论上没有数据大小的限制。 4.其他HTTP请求方法除了GET、POST和PUT，HTTP还定义了其他一些请求方法： HEAD：类似于GET，但服务器只会返回响应头部，而不返回响应体。这可以用来检查资源的状态和元数据，而不需要传输整个资源。 DELETE：用于删除指定的资源。 PATCH：用于对资源进行部分更新。与PUT不同，PATCH只更新指定的部分，而不是替换整个资源。 OPTIONS：用于查询服务器支持的通信选项，如HTTP方法和服务器支持的媒体类型。 CONNECT：用于建立与代理服务器的TCP连接，主要在HTTP代理隧道中使用。 每种请求方法都有其特定的用途和适用场景，在开发Web应用时，合理选择和使用这些方法对于构建高效、安全和符合标准的应用程序至关重要。 MyBatis——入门编写一个入门程序(基于注解的方式) 准备实体类User 12345678910111213141516171819202122232425262728293031323334353637383940package com.xiaoli.springbootmybatis.domain;public class User &#123; private int user_id; private String user_name; private int phone_number; public int getUser_id() &#123; return user_id; &#125; public void setUser_id(int user_id) &#123; this.user_id = user_id; &#125; public String getUser_name() &#123; return user_name; &#125; public void setUser_name(String user_name) &#123; this.user_name = user_name; &#125; public int getPhone_number() &#123; return phone_number; &#125; public void setPhone_number(int phone_number) &#123; this.phone_number = phone_number; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;user_id=&quot; + user_id + &quot;, user_name=&#x27;&quot; + user_name + &#x27;\\&#x27;&#x27; + &quot;, phone_number=&quot; + phone_number + &#x27;&#125;&#x27;; &#125;&#125; 引入MyBatis相关依赖。配置MyBatis（数据库连接信息） 123456789#配置数据库的连接信息 - 四要素#驱动类名称spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver#数据库连接的urlspring.datasource.url=jdbc://localhost:3306/springboot#连接数据库的用户名spring.datasource.username=root#连接数据库的密码spring.datasource.password=123456 mapper接口文件中的代码 12345678910111213141516package com.xiaoli.springbootmybatis.mapper;import com.xiaoli.springbootmybatis.domain.User;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;import java.util.List;@Mapper //在运行时 ，会自动生成该接口的实现类对象（代理对象），并将该对象交给IOC容器管理public interface UserMapper &#123; @Select(&quot;select * from user&quot;) public List&lt;User&gt; selectList();&#125; 在测试类中 有如下代码 1234567891011121314151617181920212223package com.xiaoli.springbootmybatis;import com.xiaoli.springbootmybatis.mapper.UserMapper;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTest //springboot整合单元测试的注解class SpringBootMyBatisApplicationTests &#123; //注入IOC容器中的bean @Autowired UserMapper userMapper; @Test public void allUsers()&#123; usersList.stream().forEach(item -&gt;&#123; System.out.println(item); &#125;); &#125;&#125; 输出如下 如果字段没有和数据对应，不会报错，但是数据会出现问题 ​ 1.JDBC介绍 JDBC:(Java DataBase Connectivity)，就是使用Java语言操作关系型数据库的一套API。 2.数据库连接池 数据库连接池是个容器，负责分配、管理数据库连接(Connection) 它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个 释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏 优点： 资源重用 提升系统响应速度 避免数据库连接遗漏 实现数据库连接池 标准接口：DataSource 官方(sun)提供的数据库连接池接口，由第三方组织实现此接口 功能:获取连接 代码：Connection getConnection() throws SOLException; 连接池常见产品： Druid(德鲁伊) Druid连接池是阿里巴巴开源的数据库连接池项目 功能强大，性能优秀，是ava语言最好的数据库连接池之一 切换数据库连接池：比如切换到德鲁伊连接池，在pom中引入启动依赖即可 3.LomBok Lombok是一个实用的]ava类库，能通过注解的形式自动生成构造器、getter&#x2F;setter、equals、hashcode、tostring等方法，并可以自动化生成日志变量，简化java开发、提高效率。如要使用LomBok需要引入依赖 MyBatis——基础操作准备项目，来看下项目结构 1.删除操作在Mapper包下创建对应的接口 @Mapper注解是在SpringBoot项目启动时候，动态的将bean注入容器中，注意，动态传参的参数名称应该和形参名称一致。#{}被称为参数占位符 注意事项如果mapper接口方法形参只有一个普通类型的参数，#{}里面的属性名可以随便写，如:#{id}、#{value}。 编写测试方法 如果想在控制台看到日志信息可以在application.properties中，打开mybatis的日志，并指定输出到控制台 12#指定mybatis输出日志的位置,输出控制台mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutlmpl 在输出的日志中，我们动态传入的参数会被?代替，这其实是Mysql的预编译SQL 对于预编译SQL他的： 优势：性能更高，更安全。（可以防止SQL注入） 使用Java在执行SQL语句的过程 参数占位符 2.新增员工 采用@Insert注解来进行插入操作，现在来看在mapper接口里面的方法。这里的对应指的是#{}中参数名称要和java实体类的属性名对应 新增(主键返回) 描述:在数据添加成功后，需要获取插入数据库数据的主键。如:添加套餐数据时，还需要维护套餐菜品关系表数据。 3.更新操作 在Mapper接口中写入更新的方法 采用@Update注解 执行更新操作，在测试类中操作bean对象调用上面定义的update方法。 4 .查询操作 由于在进行查询操作时候，通过某个条件查询出来我们想要的数据，那这时候就要选择封装该数据的方法，有很多，下面展示将返回来的某一个员工信息封装在对象中 方法： 在Test类中调用方法getByid，动态的传入值如下 下面来介绍一下再MyBatis中的数据封装 实体类属性名 和 数据库表查询返回(注意是返回来的数据)的字段名一致，mybatis会自动封装。 如果实体类属性名 和 数据库表查询返回的字段名不一致，不能自动封装 解决方法如下： 方案三：MyBatis的驼峰命名自动映射开关 比如数据库字段为a_Cloumn 会被解析为 aCloumn 开启方式：在配置文件中添加如下代码： mybatis.configuration.map-underscore-to-camel-case=true 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495### 5.查询操作(条件查询)即SQL语法中where关键字后面的内容，这里举例子如下* 当然，在进行查询的时候难免会遇到下面这种情况* ![image-20240612204731922](../images/JavaWeb开发学习/image-20240612204731922.png)* concat方法：该方法会把里面包括的字符串拼接成一个字符串，那么就可解决上面的办法啦，如下，?即是我们的#&#123;name&#125;占位符、* ![image-20240612205413989](../images/JavaWeb开发学习/image-20240612205413989.png)* 正确的代码是这样的：![image-20240612205517715](../images/JavaWeb开发学习/image-20240612205517715.png)#### 参数名说明![image-20240612205655793](../images/JavaWeb开发学习/image-20240612205655793.png)## MyBait——XML映射文件* 规范： * XML映射文件的名称与Mapper接口名称一致，并且将XML映射文件和Mapper接口放置在相同包下(**同包同名**) * XML映射文件的namespace属性为Mapper接口全限定名一致。 * XML映射文件中sql语句的id与Mapper接口中的方法名一致，并保持返回类型一致。 * ![image-20240612205928624](../images/JavaWeb开发学习/image-20240612205928624.png) * 返回类型我们用ResultType属性来指定，注意，resultType指的是单条记录所封装的类型## MyBatis——动态SQL***动态SQL标签以及关键属性的概述：**** 随着用户输入或外部条件的变化而变化的SQL语句，我们称为动态SQL。动态SQL在MyBatis中是一组非常强大的功能，允许你根据运行时的条件动态地构建SQL语句。以下是MyBatis中动态SQL标签及其关键属性的概述：1. **`&lt;if&gt;`** - **`test`**：表达式，用于测试条件。如果表达式计算为true，则执行if体内的SQL语句。2. **`&lt;choose&gt;`**, **`&lt;when&gt;`**, **`&lt;otherwise&gt;`** - **`choose`**：类似于Java中的switch语句，用于多个条件的选择。 - **`when`**：每个`&lt;when&gt;`元素都包含一个`test`属性，当测试条件满足时，执行其中的SQL语句。 - **`otherwise`**：当所有的`&lt;when&gt;`条件都不满足时，执行`&lt;otherwise&gt;`中的SQL语句。3. **`&lt;where&gt;`** - 自动在前面添加“WHERE”关键字，如果已经有“WHERE”关键字，则不会重复添加。还会移除前导的AND或OR关键字。4. **`&lt;set&gt;`** - 用于UPDATE语句中，只会在有至少一个字段需要更新的情况下添加“SET”关键字，并移除尾部的逗号。5. **`&lt;foreach&gt;`** - **`collection`**：指定要遍历的集合或数组的名称。 - **`item`**：当前元素的变量名。 - **`index`**：可选，表示当前元素的索引。 - **`open`**：开始符号，如左括号。 - **`close`**：结束符号，如右括号。 - **`separator`**：元素间的分隔符。6. **`&lt;trim&gt;`** - **`prefix`**：添加到内部SQL语句的开头的前缀。 - **`suffix`**：添加到内部SQL语句的结尾的后缀。 - **`prefixOverrides`**：从内部SQL语句开头移除的字符串。 - **`suffixOverrides`**：从内部SQL语句结尾移除的字符串。7. **`&lt;bind&gt;`** - **`name`**：定义的变量名。 - **`value`**：变量的值，可以是一个表达式。8. **`&lt;sql&gt;`** 和 **`&lt;include&gt;`** - **`&lt;sql&gt;`**：用于定义可重用的SQL片段。 - **`&lt;include&gt;`**：用于包含由`&lt;sql&gt;`定义的SQL片段。 - **`refid`**：在`&lt;include&gt;`标签中引用`&lt;sql&gt;`片段的ID。9. **`&lt;when&gt;`** 和 **`&lt;otherwise&gt;`** 在 **`&lt;choose&gt;`** 内部使用，已经提到过。每个标签都有自己的用途和特定的属性，这些属性帮助你控制SQL语句的动态生成过程。在实际应用中，这些标签通常会被组合使用，以生成复杂和灵活的SQL查询。例如，`&lt;if&gt;`标签可以嵌套在`&lt;foreach&gt;`标签中，或者`&lt;where&gt;`和`&lt;set&gt;`标签可以包含`&lt;if&gt;`或`&lt;choose&gt;`结构来进一步定制输出的SQL语句。### 1.`foreach` 标签的关键属性- **`collection`**：指定要迭代的集合或数组的名称。如果你传递的是一个单一的List或数组参数，`collection`属性可以省略，MyBatis会自动识别。对于Map类型的参数，需要明确指定Map中的键名作为`collection`属性的值。- **`item`**：表示每次迭代中当前元素的变量名。- **`index`**：表示当前元素在集合中的索引位置的变量名，这个属性是可选的。- **`open`** 和 **`close`**：分别指定开始和结束符号，常用于构建SQL语句的括号。- **`separator`**：指定迭代元素之间的分隔符，如逗号。#### 示例假设你有一个方法，接受一个整数列表，并且你想根据这些ID查询数据库中的记录：#### Java接口定义```javapublic interface UserMapper &#123; List&lt;User&gt; findUsersByIds(@Param(&quot;ids&quot;) List&lt;Integer&gt; ids);&#125; 映射文件中的SQL语句123456&lt;select id=&quot;findUsersByIds&quot; resultType=&quot;User&quot;&gt; SELECT * FROM user WHERE id IN &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt;&lt;/select&gt; 在这个例子中： collection=&quot;ids&quot; 表示传入的参数是名为ids的列表。 item=&quot;id&quot; 表示每次迭代的元素被称为id。 open=&quot;(&quot; 和 close=&quot;)&quot; 创建了一个包含所有ID的列表，它们被包裹在圆括号内。 separator=&quot;,&quot; 在每个ID之间插入一个逗号。 当调用findUsersByIds方法并传入一个ID列表时，MyBatis会生成一个SQL语句，其中包含一个适合的IN子句，以匹配提供的ID列表。 在MyBatis中，动态SQL主要通过使用&lt;if&gt;、&lt;choose&gt;、&lt;when&gt;、&lt;otherwise&gt;、&lt;where&gt;、&lt;set&gt;、&lt;foreach&gt;等标签来实现。下面分别介绍&lt;update&gt;和&lt;insert&gt;标签的动态写法： 2. &lt;update&gt;标签动态写法假设我们有一个用户表users，字段包括id、name、email和status。我们想要更新用户的name和email，但是只有当它们不为null时才进行更新。 123456789101112&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.example.User&quot;&gt; UPDATE users &lt;set&gt; &lt;if test=&quot;name != null&quot;&gt; name = #&#123;name&#125;, &lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt; email = #&#123;email&#125;, &lt;/if&gt; &lt;/set&gt; WHERE id = #&#123;id&#125;&lt;/update&gt; 这里使用了&lt;set&gt;标签来包含可能更新的字段，每个字段都用&lt;if&gt;标签包裹，通过test属性判断参数是否非空。 3. &lt;insert&gt;标签动态写法同样以users表为例，我们想要插入一条新记录，但是某些字段可能为空或未提供值，我们可以根据提供的值动态生成插入语句。 1234567891011121314151617181920212223242526&lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.example.User&quot;&gt; INSERT INTO users &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;name != null&quot;&gt; name, &lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt; email, &lt;/if&gt; &lt;if test=&quot;status != null&quot;&gt; status, &lt;/if&gt; &lt;/trim&gt; VALUES &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;name != null&quot;&gt; #&#123;name&#125;, &lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt; #&#123;email&#125;, &lt;/if&gt; &lt;if test=&quot;status != null&quot;&gt; #&#123;status&#125;, &lt;/if&gt; &lt;/trim&gt;&lt;/insert&gt; 这里使用了&lt;trim&gt;标签来帮助处理括号和逗号的添加和去除，使得SQL语句格式正确。每个字段同样使用&lt;if&gt;标签进行条件判断。 这些动态SQL技巧可以大大提高代码的灵活性和可维护性。 4.trim标签&lt;trim&gt;标签是MyBatis框架中一个非常有用的元素，主要用于处理动态SQL中常见的问题，如多余的前缀、后缀或分隔符（如逗号、AND等）。它允许你在生成SQL语句时自动添加或移除特定的字符串，从而确保SQL语句的正确性和效率。下面是&lt;trim&gt;标签的一些关键特性和属性： 基本属性 prefix：指定要添加到&lt;trim&gt;元素内部SQL语句开始处的前缀。 suffix：指定要添加到&lt;trim&gt;元素内部SQL语句结束处的后缀。 prefixOverrides：指定要从&lt;trim&gt;元素内部SQL语句开始处移除的字符串。这通常用于移除多余的逗号、AND或OR关键字。 suffixOverrides：指定要从&lt;trim&gt;元素内部SQL语句结束处移除的字符串。 使用场景 WHERE子句的动态构建：当你需要根据传入的参数动态构建WHERE子句时，&lt;trim&gt;标签可以自动添加”WHERE”关键字，并且确保不会出现多余的AND关键字。 1234&lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND&quot;&gt; &lt;if test=&quot;id != null&quot;&gt; AND id = #&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;name != null&quot;&gt; AND name = #&#123;name&#125; &lt;/if&gt;&lt;/trim&gt; SET子句的动态构建：在UPDATE语句中，&lt;trim&gt;标签可以用来构建动态的SET子句，确保不会有额外的逗号。 1234&lt;trim prefix=&quot;SET&quot;&gt; &lt;if test=&quot;name != null&quot;&gt; name = #&#123;name&#125;, &lt;/if&gt; &lt;if test=&quot;age != null&quot;&gt; age = #&#123;age&#125;, &lt;/if&gt;&lt;/trim&gt; VALUES子句的动态构建：在INSERT语句中，&lt;trim&gt;可以帮助构建动态的列名和值列表。 123456789&lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;name != null&quot;&gt; name, &lt;/if&gt; &lt;if test=&quot;age != null&quot;&gt; age, &lt;/if&gt;&lt;/trim&gt;VALUES&lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;name != null&quot;&gt; #&#123;name&#125;, &lt;/if&gt; &lt;if test=&quot;age != null&quot;&gt; #&#123;age&#125;, &lt;/if&gt;&lt;/trim&gt; 示例假设我们有以下需求：构建一个动态的SQL查询，如果userId和username都有值，则需要包含这两个字段的查询条件；如果没有值，则不包含。 1234567&lt;select id=&quot;selectUsersByCriteria&quot; resultType=&quot;User&quot;&gt; SELECT * FROM users &lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND&quot;&gt; &lt;if test=&quot;userId != null&quot;&gt; AND id = #&#123;userId&#125; &lt;/if&gt; &lt;if test=&quot;username != null&quot;&gt; AND username = #&#123;username&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; 这样，即使某些条件未被满足，SQL语句也不会出错，因为&lt;trim&gt;标签会确保正确的语法。 5.补充说明：MyBatis动态SQL——更多细节与高级用法1. &lt;choose&gt;, &lt;when&gt;, &lt;otherwise&gt;标签这些标签组合起来类似于Java中的switch-case结构，用于在多个条件中选择一个执行。这在构建复杂查询条件时特别有用，例如根据不同的业务逻辑分支生成不同的SQL片段。 1234567891011&lt;choose&gt; &lt;when test=&quot;type == &#x27;active&#x27;&quot;&gt; AND status = &#x27;active&#x27; &lt;/when&gt; &lt;when test=&quot;type == &#x27;inactive&#x27;&quot;&gt; AND status = &#x27;inactive&#x27; &lt;/when&gt; &lt;otherwise&gt; -- 如果没有匹配的条件，则不做任何操作 &lt;/otherwise&gt;&lt;/choose&gt; 2. &lt;bind&gt;标签&lt;bind&gt;标签用于定义局部变量，可以在后续的SQL片段中重用。这对于减少代码重复和提高代码可读性很有帮助。 1234&lt;select id=&quot;findUsersByName&quot;&gt; &lt;bind name=&quot;escapedName&quot; value=&quot;&#x27;%&#x27;+name+&#x27;%&#x27;&quot;/&gt; SELECT * FROM users WHERE name LIKE #&#123;escapedName&#125;&lt;/select&gt; 在这个例子中，&lt;bind&gt;标签创建了一个名为escapedName的变量，其值为%加上传入的名字再加上%，这样就可以在LIKE子句中使用这个变量，而无需直接在SQL语句中拼接字符串，提高了安全性。 3. &lt;foreach&gt;标签的高级用法除了基本的使用外，&lt;foreach&gt;标签还支持闭合表达式（closing expression），这允许在循环结束时添加额外的代码片段。 1234567&lt;select id=&quot;findUsersByIds&quot; resultType=&quot;User&quot;&gt; SELECT * FROM users WHERE id IN &lt;foreach collection=&quot;list&quot; item=&quot;item&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; #&#123;item&#125; &lt;/foreach&gt; ORDER BY id DESC&lt;/select&gt; 在这个例子中，ORDER BY id DESC是循环结束后添加的SQL片段，确保了查询结果按ID降序排列。 4. &lt;sql&gt;标签&lt;sql&gt;标签用于定义可复用的SQL片段。这有助于保持代码的DRY（Don’t Repeat Yourself）原则。 1234567&lt;sql id=&quot;commonFields&quot;&gt;id, name, email, status&lt;/sql&gt;&lt;select id=&quot;findUsers&quot; resultType=&quot;User&quot;&gt; SELECT &lt;include refid=&quot;commonFields&quot;/&gt; FROM users&lt;/select&gt; 这里，&lt;sql&gt;标签定义了一个包含常用字段的SQL片段，然后在&lt;select&gt;语句中通过&lt;include&gt;标签引用它。 5. &lt;isNotEmpty&gt;和&lt;isNotNUll&gt;标签虽然这些不是MyBatis的标准标签，但许多MyBatis插件提供了这样的功能，用于检查变量是否非空或非NULL。这在处理动态SQL时可以提供更简洁的语法。 123&lt;isNotEmpty property=&quot;name&quot;&gt; AND name = #&#123;name&#125;&lt;/isNotEmpty&gt; 这些标签可以简化条件判断，使SQL映射文件更加清晰和易于维护。 通过以上补充，我们看到了MyBatis动态SQL的更多细节和高级用法，这将帮助开发者更高效地处理复杂的数据库查询需求。 开发规范——Restful REST(REpresentational State Transfer)，表述性状态转换，它是一种软件架构风格 注意事项 REST是风格，是约定方式，约定不是规定，可以打破。 描述模块的功能通常使用复数，也就是加s的格式来描述，表示此类资源，而非单个资源。如:users、emps、books。 开发规范——统一响应结果 前后端交互统一响应结果Result类 开发流程","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"}]},{"title":"Java学习笔记","slug":"Java学习笔记","date":"2024-04-08T06:56:32.000Z","updated":"2024-09-13T01:53:14.441Z","comments":true,"path":"2024/04/08/Java学习笔记/","permalink":"http://example.com/2024/04/08/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1、如何拿到用户的输入有时候的一些业务是需要用户和系统互动的，这时，我们就需要来接收用户的互动，在java中，通常这么做 1234//新建一个扫描器对象scScanner sc = new Scanner(System.in);//定义一个变量来接收用户输入，类型要看你接受的是字符串还是数据而变动数据类型 变量 = sc.nextInt(); 举个例子，比如我下面这段代码 1234Scanner sc = new Scanner(System.in);System.out.println(&quot;请您输出查询的id&quot;);int id = sc.nextInt();operator.searchMovieById(id); 很好理解，接收用户输入的数字id然后把他传给operator.searchMovieById(id);方法完成代码逻辑。 this关键字在java中this关键字的作用是: this就是一个变量，可以用在方法中，用来拿到当前对象；哪个对象调用方法，this就指向那个对象，也就是拿到那个对象 用来解决对象的成员变量与方法内部变量的名称一样时，导致访问冲突问题的 123private Movie[] movies;public MovieOperator(Movie[] movies)&#123; this.movies = movies; 如果写成movies = movies 这时就会报错，让idea觉得你这是在该函数内部自己赋值给自己，显然不成立，如果加上this就会被识别为是Movie[ ] 的对象movies。 字符串类型 方式一: 123String name = &quot;小黑&quot;String schoolName = &quot;黑马程序员&quot; 方式二：调用String类的构造器初始化字符串对象 1234567public String() //创建一个空白字符串对象，不含有任何内容public String(String original) // 根据传入的字符串内容，来创建字符串对象public String(char[] chars)// 根据字符数组的内容，来创建字符串对象public String(byte[] bytes) //根据字节数组的内容，来创建字符串对象 (2)有关字符串的一些方法 1234567891011121314151617181920212223242526272829//查询字符串长度(字符个数)public int length()//获取某个索引位置处的字符返回public char charAt(int index) //将当前字符串转换成字符数组返回public char[] toCharArray()://判断当前字符串与另一个字符串的内容一样，一样返回truepublic boolean equals(object anobject) //判断当前字符串与另一个字符串的内容是否一样(忽略大小写)public boolean equalsIgnoreCase(String anotherString) //根据开始和结束索引进行截取，得到新的字符串(包前不包后)public String substring(int beginIndex, int endIndex) //从传入的索引处截取，截取到末尾，得到新的字符串返回public String substring(int beginIndex)//使用新值，将字符串中的旧值替换，得到新的字符串public String replace(CharSequence target,CharSequence replacement) ////判断字符串中是否包含了某个字符串public boolean contains(Charsequence s)//判断字符串是否以某个字符串内容开头，开头返回true，反之返回falsepublic boolean startsWith(String prefix)//判断字符串是否以某个字符串内容结尾，结尾返回true，反之返回falsepublic boolean endWith(String prefix)//把字符串按照某个字符串内容分割，并返回字符串数组回来public String[] split(String regex)//indexOf用于获取数据在字符串中第一次出现的位置String s = &quot;world hello hello world hello&quot;s.indexOf(&quot;world&quot;);//lastIndexOf用于获取数据在字符串中最后一次出现的位置s.lastIndexOf(&quot;hello&quot;); （3）字符串进行比较有哪些需要注意的？ 1、字符串的比较使用==比较好吗?为什么?什么时候使用==? 不好，对于字符串对象的比较，&#x3D;&#x3D;比较的是地址，容易出业务bug 基本数据类型的变量或者值应该使用&#x3D;&#x3D;比较。 2、开发中比较字符串推荐使用什么方式比较?使用String提供的equals方法，它只关心字符串内容一样就返回true， 123方法名public boolean equals(object anobject)public boolean equalsIgnoreCase(String anotherstring) (4)随机产生验证码(使用字符串方式) 12345678910111213141516171819202122232425package com.itheima.StringController;import java.util.Random;//随机产生验证码public class StringDemo2 &#123; public static void main(String[] args) &#123; System.out.println(randomCode(4)); System.out.println(randomCode(5)); System.out.println(randomCode(6)); &#125; public static String randomCode(int tempCode)&#123; Random r = new Random(); String code = &quot;&quot;; String data =&quot;abcdefghijklmnopqrstuVWXyZABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;; //我们需要5位验证码调用for循环 for (int i = 0; i &lt; tempCode; i++) &#123; int j = r.nextInt(data.length()); //将字符交给code code += data.charAt(j); &#125; return code; &#125;&#125; (5)两种方式的区别 双引号给出的字符串对象，存在于堆内存中的常量池中，相同内容只会存储一份。 new 字符串对象，每new一次都会在堆内存中产生一个字符串对象。 字符串大小写转换12345String s =&quot;Hello,World&quot;//字符串变小写s.toLowerCase()//字符串变大写s.toUpperCase() StringBuilder方法java提供的一种对字符串进行拼接，反转的快捷类 使用实例： 1234567891011StringBuilder s = new StringBuilder();//拼接字符串for (int i = 0; i &lt; 10; i++) &#123; s.append(i); &#125;System.out.println(s);//反转字符串s.reverse();//在字符串指定位置插入s.insert(1,&quot;abc&quot;);System.out.println(s.toString()); ArrayList集合类型1.怎么学？ arrayList会提供创建容器对象的方式 会提供相应方法对容器进行操作 增 删 改 查 创建对象 &#x3D;&#x3D;&#x3D;&#x3D;&gt; 添加增删改查方法 &#x3D;&#x3D;&#x3D;&#x3D;&gt; 了解集合特点 2.ArrayList常用方法 构造器 ArrayList是用的最多、最常见的一种集合。 1234567//创建一个空的集合对象public ArrayList() //存储任意数据类型 ArrayList list = new ArrayList(); /** 也可以这么写 */ Array&lt;Object&gt; list = new ArrayList(); 常用方法名 1234567891011121314//将指定的元素添加到此集合的末尾public boolean add(E e) //在此集合中的指定位置插入指定的元素public void add(int index,E element) //返回指定索引处的元素public E get(int index) //返回集合中的元素的个数public int size() //删除指定索引处的元素，返回被删除的元素public E remove(int index) //删除指定的元素，返回删除是否成功public boolean remove(Object o) //修改指定索引处的元素，返回被修改的元素public E set(int index,E element) 3.从集合中遍历元素，并筛选出元素删除它，应该如何操作才能不出bug?方式一:每次删除一个数据后，索引-1。 方式二:从集合后面遍历然后删除，可以避免漏掉元素。 集合中常用的接口1.Collection接口(面对单一的数据处理) 常用子接口：List，Set，Queue List：按照 插入顺序保存数据，数据可以重复 具体实现类：ArrayList，LinkedList Set：集，无序保存，数据不能重复 具体实现类：HashSet(面对K-V键值对的数据处理) Queue：队列 具体实现类：ArrayBlockingQueue 1.Map接口 具体实现类：hashMap，HashTable ArrayList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.itheima.List;import java.util.ArrayList;public class TestList &#123; public static void main(String[] args) &#123; //ArrayList:Array + List // TODO List:列表，清单 // 按照数据插入顺序进行存储 ArrayList list = new ArrayList(); ArrayList list1 = new ArrayList(); list1.add(&quot;1&quot;); list1.add(&quot;2&quot;); list1.add(&quot;3&quot;); //创建集合对象 //1.不需要传入参数，底层数组为空数组 //2.构造参数需要传递一个int类型的值，设置底层数组的长度 //3.构造参数需要传递一个Collection集合类型的值，用于将其他集合中的数据放置在当前集合中 // TODO 增加数据 // add方法添加数据时，只要将数据作为参数传递到add方法即可 // 添加数据时，如果集合中没有任何的数据，那么底层就会创建长度为10的数组 // add方法也可以传入两个参数，第一个是索引,第二个是添加数据的值 list.add(&quot;zhangsan&quot;); list.add(&quot;wangwu&quot;); list.add(&quot;xiaoli&quot;); list.add(1,&quot;zhaoliu&quot;); //在该集合中传入其他集合 list.addAll(list1); // 获取集合中的数据条数 System.out.println(list.size());//3 //获取指定位置的数据，传入的是索引 System.out.println(list.get(1));//wangwu //遍历集合中的数据 for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; //如果循环数据不关心数据的位置，采用特殊的for循环 for (Object obj : list)&#123; System.out.println(&quot;集合中的数据：&quot;+obj); &#125; // todo 修改数据 //将指定位置的数据进行修改set()注意，传递两个参数，第一个参数表示数据的位置，第二个表示修改后的值 Object oldVal = list.set(1, &quot;lisi&quot;); System.out.println(&quot;修改前的值：&quot;+oldVal); // todo 删除数据 //将指定位置的数据进行修改remove()注意，传递1个参数，一个参数表示数据的位置。 Object remove = list.remove(1); System.out.println(&quot;删除的值&quot;+remove); //清空集合的数据// list.clear(); //删除指定集合中的数据(比如上面新添加的list1)// list.removeAll(list1); //判断集合中是否存在某条数据,包含返回true不包含返回false System.out.println(list.contains(&quot;lisi&quot;)); //获取数据在索引中第一个的位置，数据不存在返回-1，存在返回数据所在位置的索引值 System.out.println(list.indexOf(&quot;lisi&quot;)); //获取最后出现的位置的索引值(集合中有多个zhangsan，但是返回的是最后一个zhangsan的索引值) list.lastIndexOf(&quot;lisi&quot;); //复制一个集合 Object clone = list.clone(); ArrayList list2 = (ArrayList)clone; //该集合和被复制的list集合额内容一致 System.out.println(list2); // TODO 打印集合对象 System.out.println(list); &#125;&#125; LinkedListLinkedList &#x3D; Linked(链接) + List 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.itheima.List;import java.util.LinkedList;public class LinkedListTest &#123; public static void main(String[] args) &#123; //todo 集合--- Collection // LinkedList //构建集合对象 LinkedList linkedList = new LinkedList(); LinkedList linkedList1=new LinkedList(); //增加第一个数据 linkedList.add(&quot;zhangsan&quot;); linkedList.add(&quot;lisi&quot;); linkedList.add(&quot;wangwu&quot;); linkedList1.add(&quot;1&quot;); linkedList1.add(&quot;2&quot;); linkedList1.add(&quot;3&quot;); //添加一个集合 linkedList.addAll(linkedList1); //链表前面增加// linkedList.addFirst(&quot;lisi&quot;); //链表后面增加// linkedList.add(1,&quot;wangwu&quot;); //获取数据 //拿到第一个数据(开头数据) System.out.println(linkedList.getFirst()); //拿到第二个数据(结尾数据) System.out.println(linkedList.getLast()); //根据索引拿数据 System.out.println(linkedList.get(1));//lisi // todo 遍历数据 for (int i = 0; i &lt; linkedList.size(); i++) &#123; System.out.println(linkedList.get(i)); &#125; //todo 遍历数据(第二种) for (Object obj:linkedList)&#123; System.out.println(obj); &#125; //删除数据 linkedList.remove(&quot;lisi&quot;); //表示删除第一个 linkedList.remove(1); linkedList.remove(); //删除链表第一个元素 linkedList.removeFirst(); //删除链表最后一个元素 linkedList.removeLast(); //push相当于addFirst方法 linkedList.push(&quot;123&quot;); //pop()弹出元素 System.out.println(linkedList.poll()); //todo 打印集合的数据 System.out.println(linkedList); &#125;&#125; 泛型12345678910111213141516171819202122232425package com.itheima.List;import java.util.ArrayList;public class ListQuestion &#123; //todo 集合 public static void main(String[] args) &#123; //todo 泛型语法&lt;&gt;中放你要在集合中存储的数据类型 User user = new User(); //如果没有尖括号里面的内容，表示我在这个容器中可以存储任何类型的数据 MyContainer&lt;User&gt; myContainer = new MyContainer(); //会报错，因为我已经用尖括号限定了容器类类型// MyContainer.data = new Object(); &#125;&#125;// todo 容器类class MyContainer&lt;C&gt;&#123; public C data;&#125;class User&#123;&#125; 比较器1234567891011121314151617181920212223242526272829303132package com.itheima.List;import java.util.ArrayList;import java.util.Comparator;public class ListSort &#123; public static void main(String[] args) &#123; ArrayList list = new ArrayList(); list.add(1); list.add(2); list.add(3); //new一个比较类的对象 NumberComparator comparator = new NumberComparator(); //todo 集合中的数据进行比较 list.sort(comparator); System.out.println(list); &#125;&#125;//创建一个比较类，实现Comparator接口class NumberComparator implements Comparator&lt;Integer&gt;&#123; @Override public int compare(Integer o1, Integer o2) &#123; //todo 如果第一个数大于第二个数，返回结果为正数，表示升序排序// return o1 - o2; //todo 如果第一个数小于第二个数，返回结果为负数，表示升序降序 return o2 - o1; //todo 如果第一个数等于第二个数，返回结果为0。// return 0; &#125;&#125; HashSet12345678910111213141516171819202122232425262728package com.itheima.List;import java.util.HashSet;public class HashSetTest &#123; public static void main(String[] args) &#123; //HashSet:Hash + Set //Hash：哈希算法，散列(无序) //ArrayList：数组 //LinkedList： HashSet hashSet = new HashSet(); //todo 增加数据 hashSet.add(&quot;lisi&quot;); hashSet.add(&quot;zhangsan&quot;); hashSet.add(&quot;wangwu&quot;); // todo 修改数据(先删除，在增加) hashSet.remove(&quot;zhangsan&quot;); hashSet.add(&quot;xiaoli&quot;); //todo 遍历数据 for (Object obj : hashSet)&#123; System.out.println(obj); &#125; // todo 转换成数组 Object[] objects = hashSet.toArray(); System.out.println(hashSet); &#125;&#125; HashSet处理重复数据重写equals和hashcode方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.itheima.List;import java.util.HashSet;public class HashSetTestForNum &#123; public static void main(String[] args) &#123; //HashSet的底层是：数组 + 链表 结构 HashSet hashSet = new HashSet(); User1 user1 = new User1(); User1 user2 = new User1(); User1 user3 = new User1(); user1.id=1001; user1.name=&quot;zhangsan&quot;; user2.id=1001; user2.name=&quot;zhangsan&quot;; user3.id=1002; user3.name=&quot;lisi&quot;; hashSet.add(user1); hashSet.add(user2); hashSet.add(user3); System.out.println(hashSet); &#125;&#125;class User1&#123; public String name; public int id; //重写hashcode方法和equals //类似于内存地址 @Override public int hashCode() &#123; return id; &#125; @Override public boolean equals(Object obj) &#123; if(obj instanceof User1)&#123; User1 testObj = (User1) obj; if(testObj.id == this.id)&#123; if(testObj.name.equals(this.name))&#123; return true; &#125; &#125; return false; &#125;else&#123; return false; &#125; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&#x27;&quot; + id + &#x27;\\&#x27;&#x27; + &quot;, name=&quot; + name + &#x27;&#125;&#x27;; &#125;&#125; Queue接口12345678910111213141516171819202122232425262728293031323334353637383940package com.itheima.Queue;import java.util.concurrent.ArrayBlockingQueue;public class TestQueue &#123; public static void main(String[] args) throws Exception&#123; //todo 了解我们的Queue // ArrayBlockingQueue = Array(数组) + Blocking(阻塞，等待) // 所以queue底层还是数组 ArrayBlockingQueue queue = new ArrayBlockingQueue(3); //添加数据 queue.add(&quot;zhangsan&quot;); queue.add(&quot;lisi&quot;); queue.add(&quot;wangwu&quot;); //由于我长度只给了3，所以只能存三个数据，下面这个数据无法存储,报错 Queue full，代表queue存满了// queue.add(&quot;xiaoli&quot;); //添加数据(put)方法，该方法能够体现出阻塞这一概念，当我添加的数据大于长度时，程序会继续运行，不会停止// queue.put(&quot;zhangsan&quot;);// queue.put(&quot;lisi&quot;);// queue.put(&quot;wangwu&quot;); //添加数据offer方法，该方法会返回一个布尔类型的值，添加成功返回true，添加失败(超出queue存储长度)返回false// boolean zhangsan = queue.offer(&quot;zhangsan&quot;);// boolean lisi = queue.offer(&quot;lisi&quot;);// boolean wangwu = queue.offer(&quot;wangwu&quot;);// System.out.println(zhangsan);// System.out.println(lisi);// System.out.println(wangwu); //拿取数据(poll方法)// System.out.println(queue.poll());// System.out.println(queue.poll());// System.out.println(queue.poll()); //拿取数据(take方法),当我去一个不存在的数据时，不会报错，程序不会结束，体现了一个等待，阻塞的过程 System.out.println(queue.take()); System.out.println(queue.take()); System.out.println(queue.take()); System.out.println(queue); &#125;&#125; HashMap(处理键值对数据(K,V))数据存储无序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.itheima.HashMap;import java.util.*;public class TestHashMap &#123; public static void main(String[] args) &#123; //HashMap = Hash + Map //todo 处理键值对&#123;K=V&#125; //创建HashMap对象 HashMap&lt;String,String&gt; map = new HashMap(); //添加数据put方法,当put传入的键相同时，相当于修改操作，返回被修改的值 map.put(&quot;zhangsan&quot;,&quot;1&quot;); System.out.println(map.put(&quot;zhangsan&quot;, &quot;2&quot;));//返回1，并且zhangsan键对应的value值被改为了2 map.put(&quot;lisi&quot;,&quot;2&quot;); map.put(&quot;wangwu&quot;,&quot;3&quot;); System.out.println(map); //todo 查询数据(返回被删除的键对应的value值) System.out.println(map.get(&quot;zhangsan&quot;)); //todo 删除数据 map.remove(&quot;zhangsan&quot;); //todo 添加数据putIfAbsent方法，这个方法会检查该map里面有没有这个键值，如果有，则不做任何操作，如果没有则插入数据 map.putIfAbsent(&quot;Xiaoli&quot;,&quot;4&quot;); map.putIfAbsent(&quot;lisi&quot;,&quot;2&quot;); //todo 修改数据replace方法 map.replace(&quot;Xiaoli&quot;,&quot;8&quot;); //todo 清空// map.clear(); //todo 获取map集合中所有的key Set setKey = map.keySet();// for(Object i : setKey)&#123;// System.out.println(map.get(i));// &#125; //todo 获取所有的值 Collection value = map.values(); System.out.println(value); //判断集合中包含某个指定的value值 System.out.println(map.containsValue(&quot;1&quot;)); System.out.println(map); //todo 获取键值对对象 Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet(); for (Map.Entry&lt;String, String&gt; entry : entries) &#123; System.out.println(entry.getKey()+&quot;=&quot;+ entry.getValue()); &#125; &#125;&#125; HashTable1234567891011package com.itheima.HashTable;public class TestHashTable &#123; public static void main(String[] args) &#123; //todo HashTable // HashTable底层容量默认11 // HashTable的K,V不可以为null值 // HashTable使用的是HashCode //基本操作和HashMap一致(第(8)小节内容) &#125;&#125; 迭代器12345678910111213141516171819202122232425262728293031package com.itheima.HashTable;import java.util.HashMap;import java.util.HashSet;import java.util.Iterator;import java.util.Set;public class DieDaiQi &#123; public static void main(String[] args) &#123; HashMap&lt;String, Integer&gt; map = new HashMap&lt;String,Integer&gt;(); map.put(&quot;a&quot;,1); map.put(&quot;b&quot;,2); map.put(&quot;c&quot;,3); //todo 获取map集合当中的key值，返回key值的集合 Set&lt;String&gt; setKeys = map.keySet(); //TODO 使用迭代器对集合map进行处理 //todo 创建迭代器对象(iterator) Iterator&lt;String&gt; iterator = setKeys.iterator(); //hasNext用于判断是否存在下一条数据 while (iterator.hasNext())&#123; //获取下一条数据 String key = iterator.next(); if(&quot;b&quot;.equals(key))&#123; iterator.remove(); &#125; System.out.println(map); &#125; System.out.println(map); &#125;&#125; 工具类第二章标识符的命名规则123456789101112131415161718192021222324252627282930313233/ /T0D0标识符得命名规则//1．英文拉丁字母/ / wx , qqString username = &quot;zhangsan&quot;;String xingming = &quot;lisi&quot;;// 2．符号//@，#，%，$//3.标识符只能采用下划线和美元$符号，其他符号不能使用，称之为特殊符号//4.空格属于特殊符号，所以也不能作为标识符使用String _name = &quot;wangwu&quot;;String $name = &quot;wangwu&quot; ;String $na_me = &quot;wangwu&quot;;system.out.println(_name);system.out.println($name);system.out.println($na_me);//5.阿拉伯数据0到9可以作为标识符使用，但是不能开头 //数字如果在标识符得开头位置，那么会被识别为数字，而不是标识符，所以会发生错误//String 1name = &quot;zhangsan&quot;;String name1 = &quot;zhangsan&quot;;//6.标识符区分大小写String Public = &quot;zhaoliu&quot;;//7.驼峰命名法String userName = &quot;小李&quot;; 数据存储单位1.比特(bit位)：数据运算的最小存储单位。 2.字节(byte)：数据的最小存储单位。 字节和比特之间可以互相转换的，关系如下 ​ 1byte = 8bit 数据类型基础数据类型一共4类8种，分别如下 整数数据类型:byte，short，int，long分别是8位，16位，32位，64位，整型常量类型默认为int类型 浮点类型：含有小数点的数据类型；float（单精度浮点类型），double（双精度浮点类型）。，浮点型常量默认为double类型 注意：如果float定义时，没有加f则会被认为在定义double类型，从而出现类型转换的错误。 123//单精度浮点类型，我们需要用F(f)来结尾如float f = 2.0f;double d = 12.3; 字符类型:char类型代表一个单一的字符,进行运算时会被转为ACSII码进行运算，用单引号定义。 1char c = &#x27;@&#x27;; 布尔类型：boolean类型：判断条件是否成立，成立取值true，不成立取值false，该类型不能做运算，可以与字符串类型进行拼接。 1boolean bln = true; 引用数据类型引用数据类型：类 数组 接口 枚举 注解 就比如最常用的String类型就是引用类型。String可以用来声明包含0个，1个，等多个字符的字符串； 自动类型提升规则：当容量小的变量与容量大的变量做运算时，结果自动转换为容量大的数据类型。(这里的容量指表示数据的范围。) 下面这条线，从左到右是自动类型提升，从右往左是强制类型转换。 byte、short、char ——&gt; int ——-&gt; long ——&gt; float ——-&gt;double 特别的：byte、short、char类型的变量直接做运算，结果为int类型。 强制数据类型转换在java中范围小的数据可以直接转换为范围大的数据，但是范围大的数据不能转换成范围小的数据，如果非要大类型转小类型，那么我们应该使用小括号进行强制类型转换 1234byte b =10;int i = s;//在()中指明要转换的类型。byte i1 =(byte)i; 运算符就是参与数据运算的符号，Java定义，无法自行定义 算数运算符 二元运算符：两个元素参与运算的运算符 1 + 2 算术表达式 &#x3D; 元素1 二元运算符 元素2 (表达式是有结果的，就需要有类型，这里的类型是元素种类类型最大的那一种，最小使用的类型为int类型) 123456System.out.println(1 + 2) //3System.out.println(2 - 2) //0System.out.println(1 * 2) //2System.out.println(4 / 2) //2 (int,int) ==&gt;int结果类型取决于类型大的那个System.out.println(1.0 / 2) //0.5 (double,int) ==&gt;double,结果类型取决于类型大的那个System.out.println(5 % 2) //1(取余数，模运算) 一元运算符：一个元素参与的运算符(++，--) ++:本质是加1操作的简化版本，也成为自增运算符,注意，++i，表示i先自加1随后在进入下面的运算，而i++表示i先参加运算后再加1 --:本质是减1操作的简化版本，也成为自减运算符,注意，–i，表示i先自减少1随后在进入下面的运算，而i–表示i先参加运算后再减1 赋值运算符123456789101112131415161718192021public class OperatorDemo3 &#123; public static void main(String[] args) &#123; // TODO 赋值运算符 //等号就是赋值运算符，将右边表达式的结果赋值给等号左边变量 //赋值运算符要考虑类型的关系 String name = &quot;zhangsan&quot;; //TODO 复合赋值运算符：+= // 如果元素进行运算后重新赋值给自己，那么可以将运算和赋值的符号进行简化 // 复合赋值运算符进行运算时，数据类型不会发生变化 int i =0; i+=1;//相当于i = i+1 System.out.println(i); byte num1 = 10; //下面这种写法由于二元运算符最小类型为int会导致报错 //num1 = num1 + 20; //使用复合运算符就不会报错了，因为复合赋值运算符进行运算时，数据类型不会发生变化 num1 +=20; System.out.println(num1); &#125;&#125; 逻辑运算符和位运算符逻辑运算符用于组合条件表达式，并基于这些条件表达式的真假值来决定最终的结果。 &amp;&amp; (逻辑与) - “且”的关系 描述: 当两个操作数都为 true 时，结果才为 true。该运算符表达”且”的关系、 特点： 短路行为: 如果第一个操作数为 false，则不会评估第二个操作数。 示例: 123boolean a = true;boolean b = false;boolean result = a &amp;&amp; b; // 结果为 false &amp;(按位与) - “且”的关系 描述：按位与 (&amp;) 用于整数类型（如 byte、short、int 和 long），它按位进行操作。对于两个整数，按位与运算符会比较它们每一位上的二进制位，如果两个位都为 1，那么结果位也为 1；否则结果位为 0。 特点 当两个对应位都是 1 时，结果位为 1；否则结果位为 0。 没有短路行为。 示例: 123int a = 5; // 二进制表示: 0101int b = 3; // 二进制表示: 0011int result = a &amp; b; // 结果为 1 (二进制: 0001) || (逻辑或) - “或”的关系 描述: 逻辑或 (||) 用于连接两个布尔表达式，并且只要这两个表达式中有任何一个为 true，整个表达式的结果就为 true。 特点：|| 具有短路行为，这意味着如果第一个表达式为 true，那么第二个表达式将不会被计算。 示例: 123boolean a = true;boolean b = false;boolean result = a || b; // 结果为 true |(按位或) - “或”的关系 描述：按位或 (|) 用于整数类型（如 byte、short、int 和 long），它按位进行操作。对于两个整数，按位或运算符会比较它们每一位上的二进制位，如果两个位中至少有一个为 1，那么结果位也为 1；否则结果位为 0。 特点: 当两个对应位中至少有一个为 1 时，结果位为 1；否则结果位为 0。 没有短路行为。 示例 123int a = 5; // 二进制表示: 0101int b = 3; // 二进制表示: 0011int result = a | b; // 结果为 7 (二进制: 0111) ! (逻辑非) 描述: 对操作数的布尔值取反。 示例: 12boolean a = true;boolean result = !a; // 结果为 false 位运算符位运算符在Java中用于按位操作整数类型的数据（如 byte、short、int 和 long）。位运算符允许你直接对这些数据类型的二进制位进行操作。 1. &amp; (按位与) 当两个对应位都是 1 时，结果位才是 1；否则结果位为 0。 2. | (按位或) 当两个对应位中至少有一个是 1 时，结果位为 1；否则结果位为 0。 3. ^ (按位异或) 当两个对应位不同时，结果位为 1；相同则结果位为 0。 4. ~ (按位取反) 对每个位进行取反操作，1 变为 0，0 变为 1。 5. &lt;&lt; (左移) 将二进制位向左移动指定的位置数，高位丢失，低位补零。 6. &gt;&gt; (带符号右移) 将二进制位向右移动指定的位置数，高位补符号位（如果是负数，则补 1；如果是正数，则补 0）。 7. &gt;&gt;&gt; (无符号右移) 将二进制位向右移动指定的位置数，高位补 0。 三元运算符 - 条件运算符语法： 变量 &#x3D; （条件表达式）？（任意表达式1）：（任意表达式2） 1234567891011public class OperatorDemo6 &#123; public static void main(String[] args) &#123; // TODO 运算符 - 三元运算符 // 指三个元素参与运算的运算符 //基本语法结构：变量 = （条件表达式）？（任意表达式1）：（任意表达式2） // 当条件表达式的结果为ture则执行表达式1，反之执行表达式2 int i = 10 ; int k =(i == 5)? (i+10):(i+1); System.out.println(k); &#125;&#125; 流程控制顺序执行 按照代码顺序从前往后执行 分支执行 if……else…… if……elif……….elif……..else…….. switch(变量){ case1: ……. ; case2: ……… ;default: ………..;},switch分支判断也叫等值分支判断。 其中在switch分支中如果想要跳出某个case并结束分支执行，就在那个case块的内容最后加上break用来跳出 重复执行（循环）在Java中，循环结构允许你重复执行一段代码直到满足某个特定条件。Java提供了几种不同类型的循环结构，包括for循环、while循环和do-while循环。下面是每种循环的基本语法和示例。 for 循环for循环是最常用的循环结构之一，特别适合已知循环次数的情况。 语法123for (初始化; 终止条件; 更新表达式) &#123; // 循环体&#125; 例子： 123for (int i = 1; i &lt;= 5; i++) &#123; System.out.println(i);&#125; 这段代码将会输出数字1到5。 while 循环while循环会在每次迭代前检查条件是否为真。只有当条件为真时，循环体才会被执行。 语法123while (条件) &#123; // 循环体&#125; 例子： 12345int i = 1;while (i &lt;= 5) &#123; System.out.println(i); i++;&#125; 这段代码同样会输出数字1到5。 do-while 循环do-while循环至少会执行一次循环体，然后在每次迭代后检查条件是否为真。 语法123do &#123; // 循环体&#125; while (条件); 例子： 12345int i = 1;do &#123; System.out.println(i); i++;&#125; while (i &lt;= 5); 这段代码同样会输出数字1到5。 控制语句在循环内部，你可以使用控制语句来改变循环的执行流程： break: 用于立即退出循环。 continue: 用于跳过当前迭代，直接进入下一次迭代。 return: 用于从方法中返回并退出循环。 例子： 123456789for (int i = 1; i &lt;= 10; i++) &#123; if (i == 5) &#123; continue; // 跳过数字5 &#125; if (i == 8) &#123; break; // 在数字8时退出循环 &#125; System.out.println(i);&#125; 这段代码将输出1到4和6到7。 嵌套循环循环还可以嵌套在一起，即在一个循环内包含另一个循环。 示例： 12345for (int i = 1; i &lt;= 3; i++) &#123; for (int j = 1; j &lt;= 3; j++) &#123; System.out.println(&quot;i: &quot; + i + &quot;, j: &quot; + j); &#125;&#125; 这段代码会输出一个3x3的矩阵，每个元素都表示两个循环变量的值。 小练习:九层妖塔 请在控制台输出打印如下 代码如下: 1234567891011for(int i = 0;i&lt;9;i++)&#123;//完成打印但是打印出来的是全部对齐的，并未达到要求 //下面打印空格因为最后一行不用输出空格所以我们只打印8层就可以，按照规律每层打印的空格数=8-层号for(int j=0;j&lt;8-i;j++)&#123;System.out.print(&quot; &quot;);&#125; for(int j=0;j&lt;i*2+1;j++)&#123; System.out.print(&quot;*&quot;); &#125; System.out.println(&quot; &quot;);&#125; switch-case在Java中，switch 语句是一种选择结构，用于基于不同的条件来执行不同的代码块。它提供了一个更简洁的方式来编写多分支的 if-else 结构。 基本语法1234567891011switch (expression) &#123; case constant1: // 执行相应的代码块 break; case constant2: // 执行相应的代码块 break; // 其他 case 分支 default: // 如果没有匹配到任何 case，则执行此代码块&#125; 注意： 表达式 (expression) 必须是一个整数、字符、枚举或字符串。 常量 (constant) 必须是字面量或者常量表达式（不能是变量）。 break 语句用来结束当前的 case 并跳出整个 switch 语句。如果省略 break，程序会继续执行下一个 case，这就是所谓的“穿透”行为。 default 子句是可选的，当 expression 的值与所有 case 常量都不匹配时，会执行 default 中的代码。default 可以放在 switch 语句的任何位置，但是通常放在最后。 示例假设我们有一个变量 day，表示一周中的某一天，我们可以使用 switch 语句来输出这一天的名称： 1234567891011121314151617181920212223242526int day = 4; // 假设今天是星期三switch (day) &#123; case 1: System.out.println(&quot;Monday&quot;); break; case 2: System.out.println(&quot;Tuesday&quot;); break; case 3: System.out.println(&quot;Wednesday&quot;); break; case 4: System.out.println(&quot;Thursday&quot;); break; case 5: System.out.println(&quot;Friday&quot;); break; case 6: System.out.println(&quot;Saturday&quot;); break; case 7: System.out.println(&quot;Sunday&quot;); break; default: System.out.println(&quot;Invalid day&quot;);&#125; Java 7 和以后版本的新特性从Java 7开始，switch 表达式可以接受 String 类型。此外，从Java 12开始，switch 语句支持新的箭头语法，使得代码更加简洁。 Java 12+ 的增强版 switch 表达式1234567String fruit = &quot;apple&quot;;var result = switch (fruit) &#123; case &quot;apple&quot; -&gt; &quot;You chose an apple!&quot;; case &quot;banana&quot; -&gt; &quot;You chose a banana!&quot;; default -&gt; &quot;Unknown fruit&quot;;&#125;;System.out.println(result); 这种形式允许你将 switch 语句当作一个表达式来使用，并且不需要 break 语句。 转义字符在Java中，转义字符是一种特殊的字符序列，用于表示一些不可见或者特殊含义的字符。这些字符通常以反斜杠（\\）开始。下面是一些常用的Java转义字符及其含义： \\n - 新行（换行符） \\t - 水平制表符（Tab键） \\b - 退格（Backspace） \\f - 换页符 \\r - 回车（将光标移至行首） \\&#39; - 单引号 \\&quot; - 双引号 \\\\ - 反斜杠 \\xxx - 八进制转义序列，其中xxx是1到3位的八进制数，代表对应的ASCII字符。 \\uxxxx - Unicode转义序列，其中xxxx是四位的十六进制数，代表对应的Unicode字符。 例如，你可以使用这些转义字符来构造字符串： 1String example = &quot;Hello,\\n\\tWorld!&quot;; // Hello,后面是一个新行，然后是制表符，接着是World! 在这个例子中，\\n 代表一个新行，\\t 代表一个水平制表符。 你还可以使用这些转义字符来创建包含特殊字符的字符串，比如： 1String withQuote = &quot;He said, \\&quot;Hello, World!\\&quot;&quot;; // 字符串中含有双引号 在这个例子中，\\&quot; 用来表示字符串中的双引号。 第三章 面向对象什么是面向对象？所谓面向对象，其实就是分析问题时，以问题所涉及的是或者物为中心的分析方式 类和对象类 and 对象(先有类，再有对象)类表示归纳和整理；对象表示具体的事务。 在Java中我们用class表示类，通常类名首写字母大写。 基本语法结构： 1234567class 类名&#123;特征(属性)功能(方法)&#125; 创建对象的语法结构对象：类的实例化(具象化) 12new 类名();//小括号不能丢//new是关键字，表示创建一个具体的对象，使用一次，创建一次，每次都是全新的对象。 对象是将内存地址赋值给了变量，所以变量其实引用了内存中的对象，所以称之为引用变量，而变量的类型称之为引用数据类型。 特殊的对象：空对象(null)，没有引用的对象，称之为空对象，关键字对象，所有引用对象的类型默认取值为null 属性所谓属性，就是类的对象的相同特征 声明：属性类型 属性名称 &#x3D; 属性值 如果在声明属性的同时进行了初始化赋值，那么所有对象的属性就完全相同。如果希望每个对象的属性不一致，那么我们可以只声明即可，那么属性会在构造对象的时候默认初始化，而默认初始化的值取决于属性的类型 byte，short，int，long &#x3D;&#x3D;&gt; 0 float,double &#x3D;&#x3D;&gt; 0.0 boolean flg &#x3D;&#x3D;&gt; false char &#x3D;&#x3D;&gt;空字符 引用数据类型 &#x3D;&#x3D;&gt; null 1234//初始化并赋值zhansanString name = &quot;zhansan&quot;;//只声明String name; 静态(static)针对于具体对象的属性称之为对象属性，成员属性，实例属性 针对于具体对象的方法称之为对象方法，成员方法，实例方法 把和对象无关，只和类相关的称之为静态， 和类相关的方法称为静态方法 和类相关的属性称为静态属性 静态语法：就是在属性和方法前面增加static关键字 在Java语法中： 成员方法可以访问静态属性和静态方法 静态方法不可以访问成员属性和静态方法 在访问静态类的属性时，可以用静态类名.属性名直接访问。 静态代码块当类的信息加载完成后，会自动调用静态代码块，可以完成静态属性的初始化功能 123static&#123; //代码块内容&#125; 在我们构建对象时，代码块会进行初始化，但不是静态的 1234&#123;//代码块内容&#125; 方法方法的声明：1【方法返回值类型】【void】 方法名(参数)&#123;功能代码&#125; 方法中void是空的意思，意味着没有结果。如果在方法中的结果需要返回，则确定返回值的类型利用return关键字来返回结果。没有返回值就用void 123456//返回的结果是布尔类型的所以用Booleanboolean register()&#123;System.out.println(&quot;注册成功&quot;) //返回结果return true;&#125; 方法传参(方法参数)1.语法:方法名(参数类型 参数名称) 方法名(参数类型1 参数名称1,参数类型2 参数名称2,参数类型3 参数名称3) { }进行多个参数的传递。 2.传参注意事项： 参数个数要匹配 参数类型要匹配 参数顺序要匹配 当参数个数不确定时，我们可以使用特殊语法来声明：可变参数 12参数类型... 参数名称方法名(String ... name)&#123; &#125; 当参数列表中还有别的参数时，我们需要将可变参数声明在参数列表最后。 基本数据类型:传数值 引用数据类型:传引用地址 1234567891011121314//main方法中User user = new User();String name =&quot;zhangsan&quot;； //传递参数user.sayHello(name);class User&#123;void sayHello(String name)&#123; //使用参数System.out.println(&quot;hello&quot;+ name); &#125;&#125; 小插曲Java中的三块内存区域 栈：存放的是(方法，变量) 堆：存放(对象) 元空间：存放类的信息，也称之为方法区 包包中容纳类 语法：package 包完整路径; 包完整路径用·隔开 包名一般全是小写字母 包的导入:我们用import语法来导入包。 import使用在package后class前 12345package xxx.xxx.Xxxx;import xxxxxx;public class xxxx&#123;&#125; 面向对象——构建对象——构造方法12//创建了一个User类的对象userUser user = new User(); 上面这个过程实际上使用了构造方法来构建的对象下面来介绍一个构造方法 构造方法：专门用于构建对象 如果类中没有任何构造方法，那么**JVM(java虚拟机)**会自动添加一个公共的无参的构造方法。基本语法如下 123类名 ()&#123;&#125; 注意点: 构造方法也是方法，但是没有void关键字 方法名和类名完全相同 如果类中没有构造方法&#x3D;&#x3D;&#x3D;&gt;JVM会提供默认构造方法 如果类中有构造方法&#x3D;&#x3D;&#x3D;&gt;JVM不会提供默认构造方法 构造方法也是方法，可以传递参数，但是一般传递参数的目的是用于对象属性的赋值 面向对象——继承关键字：Extends 基本语法： 1class 子类 extends 父类 &#123; &#125; 类存在父子关系：子类可以直接获取到父类的成员属性和成员方法 类的继承只能是单继承，一个类只能有一个父类，不能存在多个父类 在继承中，如果父类和子类含有相同的属性，那么可以采用特殊的关键字进行区分:super &amp; this. super：表示上一级 this：表示当前 继承中的方法问题构造方法(完成内存控件属性的初始化操作): 父类对象是在子类对象前创建完成的，创建子类对象前，会先创建父类对象 如果父类提供了有参构造方法，那么JVM就不会提供默认的构造方法，那么子类应该调用super方法(带入参数)构建父类对象。 面向对象——多态所谓多态，其实就是一个对象在不同场景下表现出来的不同状态和形态。 多态语法其实就是对对象的使用场景进行了约束。 以父类声明的子类对象，只能使用父类中的方法，如果子类对象想使用子类方法，需要用子类来声明子类对象 面向对象——方法重载相同的方法：在一个类中，相同方法是指方法名，参数列表相同，和返回值类型无关的方法。 方法重载： 在Java中，如果方法名称相同，但是参数列表(个数，顺序，类型)不相同，会认为是不同的方法，只是名称一样，我们称之为方法的重载。 在构造方法中，想要调用其他构造方法，那么需要使用关键字:this 123456789101112131415161718192021222324package com.itheima.面相对象综合实例;public class ClassObject2 &#123; public static void main(String[] args) &#123; //我们只需要调用无参构造方法即可 //创建对象时会调用构造函数 User user = new User(); &#125;&#125;class User&#123; User()&#123; //使用this关键字传入参数调用下面构造方法 this(&quot;zhansan&quot;); &#125; User(String name)&#123; //接收name并用this关键字调用下面方法 this(&quot;zhangsan&quot;,&quot;男&quot;); &#125; User(String name, String sex)&#123; System.out.println(&quot;名字是:&quot;+name+&quot;,&quot;+sex); &#125;&#125; 打印如下: 1名字是:zhangsan,男 结论基本数据类型： 基本数据类型匹配方法时，可以在数值不变的情况下扩大数据的精度。 byte数据类型无法和char类型做转换，char没有负数，而byte存在着负数 引用数据类型： 引用数据类型无法扩大数据精度，但是引用数据类型匹配方法时，会往object类去找。 比如A类是B类的父类，那么当调用的方法在B类中不符合时，就去A类中寻找，如果A类中没有就去A类的父类object中寻找 面向对象——方法重写定义：在父类中的方法其实主要体现通用性(可以被多个子类继承，可以被多个子类使用自身方法)，无法在某一个特定情况去使用这个方法。如果子类对象需要再某个特定业务逻辑中使用该父类的方法，那么就需要对父类中的方法进行重写，这个操作成为重写。 请注意： 子类中的方法不会覆盖父类的方法，只是父类当前方法不适用这个场景 如果想在当前类调用父类方法可以使用super关键字进行调用 当子类的方法中的返回值类型，参数列表，方法名称都和父类相同时才可以进行重写 1234567891011121314151617181920212223package com.itheima.面相对象综合实例;public class RewriteMethods &#123; public static void main(String[] args) &#123; Child child = new Child(); Parent parent =new Parent(); System.out.println(child.sum());//40 System.out.println(parent.sum());//20 &#125;&#125; class Parent&#123; int i = 10; int sum()&#123; return i+10; &#125;&#125;class Child extends Parent&#123; int i =20; int sum()&#123; return i+20; &#125;&#125; 通过以上例子，总结四点： 一个对象能使用什么方法，取决于引用变量的类型 一个对象能使用什么属性，取决于引用变量的类型 一个对象的方法具体使用(这个方法怎么去执行，逻辑是什么，直接使用还是间接使用)，需要看具体对象 一个对象的属性具体的使用是不需要看具体的对象的，属性在哪里声明就在哪里使用 面向对象——递归定义：方法调用自身，成为递归方法 递归最经典的案例——求n以内的奇数和 123456789101112131415161718package com.itheima.面相对象综合实例;public class RewriteMethods &#123; public static void main(String[] args) &#123; int result = getSum(20); System.out.println(result); &#125; static int getSum(int n) &#123;//三元运算符，当n是偶数时会执行(n－1)，当n是奇数时直接用n n = n % 2 == 0 ? n - 1 : n; if (n == 1) &#123; return 1; &#125; else &#123; return n + getSum(n - 2); &#125; &#125;&#125; 递归——阶乘 一个大于1的数的阶乘就是这个数乘以这个数减一的阶乘 123456789101112131415package com.itheima.面相对象综合实例;public class RewriteMethods &#123; public static void main(String[] args) &#123; int result1 = jieCheng(5); System.out.println(result1); &#125; //求n以内的数的阶乘 public static int jieCheng(int n)&#123; if(n&lt;= 1)&#123; return 1; &#125;else &#123; return n * jieCheng(n-1); &#125; &#125;&#125; 注意： 递归应该有跳出的逻辑 调用自身时，传入的参数应该是有规律的 面向对象——访问权限 public：公共的，访问权限修饰符 ​ 在Java中，公共类只有一个，且名称和源码文件相同 ​ main方法：main方法是有JVM调用的，JVM可以任意调用，可以忽略权限问题 Java中的访问权限有四种： private：私有的，同一个类中可以使用，别的类，其他地方无法使用 (default)：默认权限，当不设定任何权限时，JVM会默认提供权限，包(路径)权限 protected：受保护的权限，子类可以访问 public：公共的，任意使用。 面向对象——内部类——外部类外部类：在源码中直接声明的类 内部类：类中声明的类 内部类在进行定义的时候，可以当成外部类的属性使用即可，但是在使用的时候，因为内部类被看做了外部类的属性，所以需要定义外部类对象进行使用。 1234//内部类定义class InnerClass&#123;&#125; 举个例子： 1234567891011121314151617181920212223242526package com.itheima.面相对象综合实例;public class InerClass &#123; public static void main(String[] args) &#123; //创建外部类对象 OuterClass outerClass = new OuterClass(); //通过外部类对象来创建内部类对象 OuterClass.InnerClass1 innerClass1 = outerClass.new InnerClass1(); //调用各自的方法 outerClass.printSome(); innerClass1.printSome(); &#125;&#125;class OuterClass&#123; public void printSome()&#123; System.out.println(&quot;我是外部类方法&quot;); &#125; class InnerClass1 &#123; public void printSome()&#123; System.out.println(&quot;我是内部类方法&quot;); &#125; &#125;&#125; 面向对象——final关键字 final可以修饰变量：变量的值一旦初始化不允许被修改 final可以修饰属性：但是JVM不会对自动对属性进行初始化，需要手动初始化，并且属性值不可以修改 final可以修饰方法：final修饰的方法不可以被子类重写 final可以修饰类：当final修饰一个类时，被修饰的类不可以有子类 final不可以修饰构造方法。 final可以修饰方法参数：一旦修饰，该参数无法修改。 一般将final修饰的变量称之为常量，或者叫不可变量。 面向对象——抽象—Abstract 抽象类：不完整的类就是抽象类，抽象类不能够构造对象 1234//语法abstract class 类名&#123;&#125; 抽象方法：只有声明方法，而不去写方法里面的逻辑。 12//语法abstract 返回值类型 方法名(参数); 在一个类中，有抽象方法就是抽象类，反之，如果有抽象类，他的方法不一定是抽象方法。 抽象类无法直接构造对象，但是可以通过子类间接构造对象。 如果抽象类中含有抽象方法，那么子类继承抽象类，需要重写抽象方法，将方法补充完整。 abstract关键字不能和final关键字一起使用 面向对象——接口(interface)接口：可以简单理解为规则。 基本语法： 12//接口语法interface 接口名称&#123; 接口属性，接口规则&#125; 接口其实是抽象的 规则的属性必须为固定值，而且不能修改。 属性和行为的访问权限是公共的。 属性是静态的。 行为是抽象的。 接口可以继承其他接口 类的对象需要遵循接口，在Java中其实就是实现(implements)接口。而且类可以实现多个接口 接口的一段演示代码 12345678910111213141516171819202122232425262728293031323334353637383940public class InterfaceTest &#123; public static void main(String[] args) &#123; Computer c = new Computer(); Light light = new Light(); //相当于把电灯插到usb1口上 c.usb1 = light; //把电灯插到usb2口上 c.usb2 = light; //电脑给上面两个供电(调用givePower方法) c.givePower(); &#125;&#125;interface rule &#123; &#125;interface PowerOut extends rule&#123; public void givePower();&#125;interface PowerIn extends rule&#123; public void receivePower();&#125;class Computer implements PowerOut&#123; public PowerIn usb1; public PowerIn usb2; public void givePower()&#123; System.out.println(&quot;电脑提供电源&quot;); usb1.receivePower(); usb2.receivePower(); &#125;&#125;class Light implements PowerIn&#123; public void receivePower()&#123; System.out.println(&quot;电灯接受电源&quot;); &#125;&#125; 面向对象——枚举(Enum)定义：枚举是一个特殊的类，其中包含了一组特定的对象，一般使用大写的的字母，这些对象不会发生改变。 123enum City&#123; BEIJING,SHANGHAI&#125; 枚举使用enum关键字使用。 枚举类的对象一般放在前面，如果还要写入别的语法那么应该用分号与后面的语法隔开。 枚举类不能创建对象，只能在内部使用 举个例子 1234567891011121314151617181920public class EnumTest &#123; public static void main(String[] args) &#123; System.out.print(City.SHANGHAI.name); System.out.println(City.SHANGHAI.code); System.out.print(City.BEIJING.name); System.out.println(City.BEIJING.code); &#125;&#125;enum City&#123; //相当于new一个对象,JVM完成 BEIJING(&quot;北京&quot;,1001),SHANGHAI(&quot;上海&quot;,1002); City(String name, int code)&#123; this.name = name; this.code = code; &#125; public String name; public int code;&#125; 面向对象——匿名类在某些场合下，类的名字不重要了，我们只是想使用类中的方法或功能，那么这个时候就需要用到特殊的语法：匿名类。 定义：没有名字的类，被称为匿名类 举个例子 1234567891011121314151617181920212223242526272829public class NoNameClass &#123; public static void main(String[] args) &#123; //创建了一个SayHello的对象me SayHello me = new SayHello(); //下面这种写法不需要再额外创建张三和李四的类，也就是我们创建了一个没有名字的类new person()&#123;&#125; me.sayHelloToPeople(new Person() &#123; //重写抽象方法具体化 public String name()&#123; return &quot;张三&quot;; &#125; &#125;); me.sayHelloToPeople(new Person() &#123; public String name()&#123; return &quot;李四&quot;; &#125; &#125;); &#125;&#125;abstract class Person&#123; //有抽象方法所以是抽象类 public abstract String name();&#125;class SayHello &#123; public void sayHelloToPeople(Person person) &#123; System.out.println(&quot;hello&quot; + person.name()); &#125;&#125; 接口也可以 12345678910111213//只关心你是怎么飞的，并没有考虑你是什么类，所以这里用匿名类。 new Fly() &#123; public void fly() &#123; System.out.println(&quot;使用飞行器飞行&quot;); &#125; &#125;.fly(); &#125;&#125;//接口是抽象的interface Fly&#123; public void fly();&#125; 面向对象——Bean规范 类要求必须含有无参的，公共的构造方法 属性必须私有化，然后提供公共的get，set方法 例子 1234567891011121314151617181920212223242526272829public class Movie &#123; private int id; private String name; private double price; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; &#125; 面向对象——作用域例子 12345678910111213141516171819202122package com.itheima.面相对象综合实例;public class ZuoYongYu &#123; public static void main(String[] args) &#123; User2 user2 = new User2(); user2.test(); &#125;&#125;class Person2&#123; &#125;class User2 extends Person2&#123; String name = &quot;lisi&quot;; public void test()&#123; //如果属性和(局部)变量名称相同，访问时不加修饰符，那么优先访问变量 String name = &quot;wangwu&quot;;//启动打印的是wangwu，如果注释掉这一行，那么打印的将会是lisi System.out.println(name); &#125;&#125; 第四章 常见类和对象常见类和对象——ObjectObject类的包路径：java.lang.Object Object对象的常用方法： 1234567891011121314151617181920212223242526272829303132333435package com.itheima.常见类和对象;public class ObjectClass &#123; public static void main(String[] args) &#123; Object obj = new Person(); //object对象的常用方法 // TODO toString()，将对象转换成字符串 String s = obj.toString(); System.out.println(s); // TODO 获取对象的内存地址 int i = obj.hashCode(); System.out.println(i); // TODO 判断两个对象是否相等，如果相等返回true，不相等返回flase // equals方法比较对象时，默认比较的是内存地址 Person person = new Person(); boolean equals1 = obj.equals(person); boolean equals2 = obj.equals(obj); System.out.println(equals1);//false System.out.println(equals2);//true //TODO getClass获取对象的类型信息 Class&lt;?&gt; currentClassName = obj.getClass(); System.out.println(currentClassName.getSimpleName()); &#125;&#125;class Person&#123;&#125;class user extends Person&#123;&#125; 常见类和对象——数组语法 声明一个数组：数据类型[] 数组名; 初始化一个数组： 静态初始化：静态初始化:数组变量的声明和数组元素的赋值同时进行 1234//声明一个数组 : 数据类型[] 数组名;int[] nums;//也可以下面这种方式,也表示数组的长度为5 - 静态初始化:数组变量的声明和数组元素的赋值同时进行nums = new int[]&#123;1,2,3,4,5&#125;; 动态初始化：动态初始化：数组变量的声明和数组元素的赋值分开进行 123int[] num1;//初始化一个数组:表示创建一个长度为5的数组 - 动态初始化：数组变量的声明和数组元素的赋值分开进行num1 = new int[5]; 数组的访问：通过数组名[下标(索引)]来访问 数组的修改：数组名[索引] &#x3D; 新值 数组的特点数组的特点：(学习时注意与JS中的数组进行区分。) 数组中的元素在内存中是依次紧密排列的，有序的。 数组是引用数据类型的变量。数组的元素，既可以是基本数据类型，也可以是引用数据类型。 数组一旦初始化完成，其长度就确定了，并且长度不可更改(重点) 创建数组对象会在内存中开辟一块”连续的空间”。占据空间的大小，取决于数组的长度和数组中元素的类型。 数组的默认值在 Java 中，当你创建一个数组但没有给每个元素赋初值时，Java 会自动为数组的每个元素分配一个默认值。这个默认值取决于数组元素的数据类型。下面是各种基本数据类型数组的默认值： 整型 (int[], short[], byte[]): 默认值为 0. 长整型 (long[]): 默认值为 0L. 浮点型 (float[]): 默认值为 0.0f. 双精度浮点型 (double[]): 默认值为 0.0d. 字符型 (char[]): 默认值为 \\u0000 (即 ASCII 的 NUL 字符).或0 布尔型 (boolean[]): 默认值为 false. 例如： 123456int[] intArray = new int[10]; // 每个元素都是 0long[] longArray = new long[5]; // 每个元素都是 0Lfloat[] floatArray = new float[3]; // 每个元素都是 0.0fdouble[] doubleArray = new double[7]; // 每个元素都是 0.0dchar[] charArray = new char[4]; // 每个元素都是 &#x27;\\u0000&#x27;boolean[] booleanArray = new boolean[2]; // 每个元素都是 false 引用数据类型的数组，默认值是 null。例如： 12String[] stringArray = new String[5]; // 每个元素都是 nullObject[] objectArray = new Object[10]; // 每个元素都是 null 请注意，这些默认值只适用于使用 new 关键字创建的数组。如果你声明一个数组但没有用 new 显式地分配内存，则不能访问这些默认值，因为这样的数组实际上并未创建。 一维数组内存解析 该图传达的意思有： 数组在内存中时，栈中存放的是数组的首元素的地址。 new出来的内容是在堆中的，通过赋值操作把响应的地址赋值给变量。 通过new关键字出来的会新开辟一块内存空间(重要) 第二张图： 这张图传达的意思： 如果我们直接进行赋值，那么就是将数组的内存地址赋值给新的变量，进而两个变量指向同一个数组。 在该图中我们没有使用new关键字进行定义新变量，所以没有开辟新的内存空间 常见类和对象——二维数组二维数组的定义 123456789//二维数组(可以简单理解为3X3的表格)String[][] names = new String[3][3];//二维数组的遍历for(int row= 0 ;row&lt;3;i++)&#123; for(int col =0; col &lt; 3; j++)&#123; System.out.print(names[row][col]); &#125; System.out.println(&quot; &quot;);&#125; 数组——应用冒泡排序1234567891011121314151617181920212223package com.itheima.常见类和对象;public class MaoPaoPaiXu &#123; // TODO 将一个数组的最大的数放在数组最后面 public static void main(String[] args) &#123; int[] nums = &#123;1,4,3,5，2&#125;; //注意不能索引到最后一个数，因为最后一个数的下一位没有数据 //左边和右边比较，我们先找出最大的数，让他放在数组最后一个元素位置 for(int i = 0;i&lt; nums.length-1;i++)&#123; int num1 =nums[i]; int num2 =nums[i+1]; if(num1&gt;num2)&#123; nums[i] = num2; nums[i+1] = num1; &#125; &#125; for (int num : nums) &#123; //打印结果为1,3,2,4,5 System.out.println(num); &#125; &#125; &#125; 上面这个只是找出了我们的最大的数放到了数组最后面，那么我们的冒泡排序的结果应该1,2,3,4,5所以稍加改动如下: 解析：那么在上面的基础上，我们每次把最大数放在后面不就可以了吗？也就是说第一次比较5个数，那么5最大放在后面，第二次比较4个数一定是4最大，我们把四放在四个数的最后面。依次类推，不就完成了吗？ 123456789101112131415161718192021222324252627//代码逻辑(冒泡排序)package com.itheima.常见类和对象;public class ErWeiShuZu &#123; // TODO 将一个数组的最大的数放在数组最后面 public static void main(String[] args) &#123; int[] nums = &#123;1,4,3,5，2&#125;; //注意不能索引到最后一个数，因为最后一个数的下一位没有数据 //左边和右边比较，我们先找出最大的数，让他放在数组最后一个元素位置 for (int i = 0; i &lt; nums.length; i++) &#123; //当i=0时，我们下面的循环就找5个数的大小，等于1就找4个数的大小..... for (int j = 0; j &lt; nums.length - i - 1; j++) &#123; int num1 = nums[j]; int num2 = nums[j + 1]; if (num1 &gt; num2) &#123; nums[j] = num2; nums[j + 1] = num1; &#125; &#125; &#125; for (int num : nums) &#123; System.out.println(num); &#125; &#125;&#125; 思路图解冒泡排序 选择排序12345678910111213141516171819202122232425 //选择排序int[] nums = &#123;1,4,3,5，2&#125;;//第一步：找到最大值的索引 for (int j = 0; j &lt; nums.length; j++) &#123; //将最大值索引定为0，因为0已经被用了所以下面的循环从1开始 int maxIndex = 0; for (int i = 1; i &lt; nums.length-j; i++) &#123; int num1 = nums[i];//4 3 2 5 int num2 =nums[maxIndex];//1 4 4 4 if (num1&gt;num2)&#123; //循环完成后我们的最大值索引就被找到了 maxIndex = i; &#125; &#125; //把最后一个数和我们的最大值索引对应的数进行交换就完成了将最大的数放在数组最后面 int num3 = nums[nums.length-j-1]; int num4 = nums[maxIndex]; nums[nums.length-j-1] = num4; nums[maxIndex] = num3; &#125;for (int num : nums) &#123; //打印的结果为1，2，3，4，5 System.out.println(num); &#125; 二分查找法* 前提：数据有序。 解释：二分查找法，又称折半查找（Binary Search），是一种在有序数组中高效查找特定元素的算法。其核心思想是通过将待查找区间反复减半来逼近目标值，直至找到目标或者确定目标不存在于数组中。以下是二分查找的基本步骤： 初始化: 确定查找区间的初始边界，通常是整个数组的开始索引（设为left）和结束索引（设为right），或者说是数组的第一个元素和最后一个元素的索引。 计算中间索引: 在每一轮查找中，计算当前查找区间中间元素的索引 mid = (left + right) / 2（实际应用中为防止整数溢出，通常写作 mid = left + (right - left) / 2）。 比较与分支: 如果数组中间元素array[mid]正好等于目标值，查找成功，返回中间元素的索引mid。 如果array[mid]小于目标值，则说明目标值位于中间元素右侧的子区间，因此更新查找区间为left = mid + 1。 如果array[mid]大于目标值，则目标值位于中间元素左侧的子区间，更新查找区间为right = mid - 1。 重复步骤2和3，直到left &gt; right，此时说明目标值不在数组中，查找失败。 二分查找的时间复杂度为O(log n)，其中n是数组中的元素数量。这是因为每次操作都将查找范围减半，因此大大减少了需要检查的元素数量，尤其是在处理大数据集时，这种算法的效率优势更为明显。但需要注意的是，二分查找的前提是数组必须是有序的，且通常适用于静态数据结构，因为对数组的插入和删除操作可能会破坏其有序性，从而增加维护成本。 1234567891011121314151617181920212223242526272829package com.itheima.常见类和对象;//演示的是二分法查找，前提是必须数组有序public class SelectPaiXu &#123; public static void main(String[] args) &#123; int nums[]=&#123;1,2,3,4,5,6,7&#125;; //定义查找的目标数 int targetNumber = 5; //定义开始的索引 int startIndex = 0; //定义中间值索引 int middle = 0; //定义结束索引 int endIndex = nums.length - 1; //查找中间值索引 while (startIndex &lt;=endIndex )&#123; middle= (startIndex+endIndex) / 2; if(nums[middle] &gt; targetNumber)&#123; endIndex = middle -1; &#125;else if(nums[middle]&lt;targetNumber)&#123; startIndex= middle+1; &#125;else &#123; break; &#125; &#125; //打印中间值索引 System.out.println(&quot;数据的位置是：&quot;+middle); &#125;&#125; 常见类和对象——包装类在Java中，基本数据类型如 int, char, boolean 等都有对应的引用类型，也称为包装类。这些包装类提供了对基本数据类型的一些额外功能，比如自动装箱&#x2F;拆箱、比较、序列化等。以下是Java中所有基本数据类型的包装类： 基本数据类型 包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 包装类的特点 实例化：包装类是对象，因此需要通过 new 关键字实例化。 不可变性：所有的包装类都是不可变的（immutable），这意味着一旦创建了包装类的对象，就不能更改其值。 方法：包装类提供了许多有用的方法，例如转换、比较、解析等。 装箱与拆箱：从Java 5开始，Java支持自动装箱（将基本类型自动转换为包装类）和自动拆箱（将包装类自动转换为基本类型）。 示例下面是一些使用包装类的例子： 创建包装类对象12345678910Integer myInt = new Integer(10); // 明确地创建对象Integer myAutoBoxedInt = 20; // 自动装箱// 拆箱int primitiveInt = myInt; // 自动拆箱// 创建其他包装类对象Double myDouble = new Double(10.5);Character myChar = new Character(&#x27;A&#x27;);Boolean myBool = new Boolean(true); 使用包装类的方法1234567891011121314// 解析字符串为整数Integer parsedInt = Integer.parseInt(&quot;123&quot;);// 获取最大值int maxValue = Integer.MAX_VALUE;// 比较两个整数boolean isEqual = Integer.compare(10, 10) == 0;// 将整数转换为字符串String intAsString = Integer.toString(10);// 获取一个整数的二进制表示String binaryString = Integer.toBinaryString(10); 使用包装类的静态方法123456789// 比较两个整数int compareResult = Integer.compare(10, 20);// 检查一个整数是否为偶数boolean isEven = (10 &amp; 1) == 0;// 最大值和最小值int max = Math.max(10, 20);int min = Math.min(10, 20); 特殊情况对于 Integer 类，Java 为了节省内存，对于 -128 到 127 之间的整数，会缓存这些值的对象。这意味着在这个范围内使用自动装箱时，实际上使用的是同一个对象。 123Integer a = 127;Integer b = 127;System.out.println(a == b); // 输出 true，因为a和b指向同一个对象 但是，超出这个范围时，对象不再是同一个： 123Integer a = 128;Integer b = 128;System.out.println(a == b); // 输出 false，因为a和b是不同的对象 将基本数据类型转换为包装类12345678910111213141516package com.itheima.常见类和对象;public class BaoZhuangLei &#123; public static void main(String[] args) &#123; int i =1; //将基本数据类型转换为包装类型 Integer i1 = Integer.valueOf(i); //也可以写成,这个过程称为自动装箱 Integer i2 =i; //自动拆箱 int j = i1.intValue(); //也可以写成 int j1 = i1; &#125;&#125; 5）常见类和对象——日期和日历日期类: 1234567891011121314151617181920212223242526272829package com.itheima.常见类和对象;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class DateTest &#123; public static void main(String[] args) throws ParseException &#123; //Date :日期类 //Calendar :日历类 Date d = new Date(); System.out.println(d);// Java格式化日期格式: //y(Y)-&gt;年-&gt; yyyy //m(M)-&gt;MM:月份，mm:分钟 //d(D)-&gt;dd :一个月中的日期，D:一年中的日期 //h(H)-&gt;h:12进制，HH:24进制 //s(S)-&gt;s :秒,S:亳秘 //Date转换为String SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); String dateFormatString =sdf.format(d); System.out.println(dateFormatString); //string转换为Date String dateString=&quot;2022-06-01&quot;; Date parseDate = sdf.parse(dateString); System.out.println(parseDate); &#125;&#125; 日历类： 123456789//拿到日历的对象Calendar instance =Calendar.getInstance();//打印日历中的各种属性System.out.println(instance.get(Calendar.YEAR)); System.out.println(instance.get(Calendar.MONTH));System.out.println(instance.get(Calendar.DATE));//在日历中找到当前时间instance.setTime(new Date());instance.add(Calendar.YEAR,1); 6）常见类和对象——工具类 工具类不应该创建对象才能使用，也就意味着，可以直接使用类中的属性和方法，一般都声明为静态的。 工具类对外提供的属性和方法都应该是公共的。 为了使开发者方便，应该尽量提供丰富的方法和属性。 第五章 异常Java中的异常分为两大类： 可以通过代码恢复正常逻辑执行的异常，称之为运行期异常：RuntimeException 不可以通过代码恢复正常执行逻辑的异常，称之为编译异常： Exception 异常处理的语法： try：尝试(放的是可能会出现问题的代码) catch：捕捉，捕捉多个异常时，优先选择小的异常，然后将其抛出 finally：最终 12345678910try&#123; //可能会出现异常的代码 //如果出现异常那么JVM会将异常进行封装，形成一个具体的异常类然后将这个异常抛出&#125;catch(抛出的异常对象 对象引用)&#123; //异常的解决方案&#125;catch()&#123;&#125;finally()&#123; //最 终要执行的逻辑(不论异常处没处理)&#125; 异常的常见类型： 1234567891011121314151617// TODO 异常//1.除数为0的算术异常:java.lang.ArithmeticException//运行期异常int i = 0;if(i!=0)&#123; int j= 10 /i;&#125;//2:空指针异常:java.lang.NullPointerException，调用了一个成员对象或成员方法为空(null)对象的属性或方法时，就会发生异常User3 user = null;System.out.println(user.tostring());//3:索引越界，针对数组，字符串索引越界，针对字符串class User3 &#123; &#125; 如果方法中可能会出现问题，那么需要提前声明，告诉其他人，我的方法可能会出现问题。这时，我们需要使用throws关键字 12345678910111213public static void main(String args[]) throws ArithmeticException&#123; User user = new User(); int i =10; int j =0; user.test(i,j);&#125;class User8public void test(int i,int j) throws ArithmeticException &#123;System.out.println(i/j); &#125; 那么在运行期的异常，他不会抱任何问题，因为只要你的逻辑对了，代码就能继续运行，那么我们该如何让他出现提示，需要解决异常呢？下面这种方法，我们手动抛出异常对象，但是使用的是throw关键字，然后new出异常对象 12345678910111213141516public static void main(String args[]) throws Exception&#123; User user = new User(); int i =10; int j =0; user.test(i,j);&#125;class User8&#123; public void test(int i,int j) throws Exception &#123; try&#123; System.out.println(i/j); &#125;catch(ArithmeticException e) //这里演示手动抛出异常 throw new Exception(); &#125;&#125; （1）自定义异常看代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.itheima.Exception;public class ZiDingYiException &#123; public static void main(String[] args) throws Exception &#123; String username = &quot;admin&quot;; String password =&quot;admin&quot;; //对异常进行处理 try &#123; //可能出现异常的代码 loginSystem(username,password); &#125;catch (AccountException e)&#123; System.out.println(&quot;账号输入有误，请重新输入&quot;); &#125;catch (PasswordException e)&#123; System.out.println(&quot;密码输入有误，请重新输入&quot;); &#125; &#125; //如果下面是运行期异常(RuntimeException)这里可以不用抛出异常 //如果下面是编译期异常(Exception)，则需抛出异常 public static void loginSystem(String username,String password) throws AccountException,PasswordException&#123; if(!&quot;admin&quot;.equals(username))&#123; //创建异常对象 throw new AccountException(&quot;用户名不正确&quot;); &#125; if(!&quot;admin&quot;.equals(password))&#123; throw new PasswordException(&quot;密码不正确&quot;); &#125; System.out.println(&quot;登录成功&quot;); &#125;&#125;//账户异常class AccountException extends loginException&#123; public AccountException(String message) &#123; // 调用父类里面的方法，传入message参数，详细可以在代码中ctrl+左键点击查看 super(message); &#125;&#125;//密码异常class PasswordException extends loginException&#123; public PasswordException(String message)&#123; super(message); &#125;&#125;//自定义异常，如果这里继承运行期异常(RuntimeException)，那么上面就不需要抛出，如果是编译期异常(Exception),责需要抛出异常class loginException extends RuntimeException&#123; public loginException(String message)&#123; super(message); &#125;&#125; 第六章 Java中遇到的各种问题(1)Mybatis与java​ 在Mybatis和java联合编写xml文件时，有关Mapper.xml（编写SQL的）文件中，增删改查标签中，使用parameterType属性指定传递参数类，resultType属性指定返回结果类型，resultMap标签完成当数据库表字段和Java实体类属性名或类型不一致时的手动映射，另外，SQL文中，where条件中只有一个参数时，推荐使用基本类型（int，short，char，byte，float，double，long，boolean）+String，当有多个参数时，使用Java实体类，接下来，我们来讲讲具体的用法。来看示例： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--上面是文件头，下面是这个xml文件对应的mapper文件的路径--&gt;&lt;mapper namespace=&quot;com.ruoyi.publicController.mapper.proDetailMapper&quot;&gt; &lt;resultMap id=&quot;proDetailsResult&quot; type=&quot;proSelectDetails&quot;&gt; &lt;result property=&quot;proName&quot; column=&quot;pro_name&quot;/&gt; &lt;result property=&quot;profounder&quot; column=&quot;user_name&quot;/&gt; &lt;result property=&quot;proTrack&quot; column=&quot;pro_track&quot;/&gt; &lt;result property=&quot;proScore&quot; column=&quot;pro_score&quot;/&gt; &lt;/resultMap&gt; &lt;resultMap id=&quot;countResult&quot; type=&quot;proSelectDetails&quot;&gt; &lt;result property=&quot;countOne&quot; column=&quot;countOne&quot;/&gt; &lt;result property=&quot;countTwo&quot; column=&quot;countTwo&quot;/&gt; &lt;/resultMap&gt; &lt;!--查询总表所有项目信息--&gt; &lt;select id=&quot;selectAllInfo&quot; resultMap=&quot;proDetailsResult&quot; resultType=&quot;proSelectDetails&quot;&gt; &lt;include refid=&quot;selectProDetailsVo&quot;/&gt; &lt;/select&gt; &lt;sql id=&quot;selectProDetailsVo&quot;&gt; SELECT DISTINCT pro_details3.pro_id, pro_name, pro_details3.pro_score, user_name, pro_track FROM pro_details3 INNER JOIN judges_score ON judges_score.pro_id = pro_details3.pro_id INNER JOIN pro_coreteam ON pro_details3.pro_id = pro_coreteam.pro_id INNER JOIN sys_user ON sys_user.user_id = pro_coreteam.student_id &lt;/sql&gt;&lt;!--根据项目赛道查询项目信息--&gt;&lt;select id=&quot;selectProDetailsByProTrack&quot; resultMap=&quot;proDetailsResult&quot; resultType=&quot;proSelectDetails&quot;&gt; &lt;include refid=&quot;selectProDetailsVo&quot;/&gt; where pro_track = #&#123;proTrack&#125;&lt;/select&gt; 1.parameterType定义在增删改查标签中的属性，指定SQL文中where条件的参数类型，可以是基本数据类型（8个）或String或者对象类型例如，根据id查询name，如果数据库中定义的字段id是int类型，就可以指定parameterType的属性值是int，可以参看下边的代码。 1&lt; select id=&quot;queryPersonNameById&quot; parameterType=&quot;int&quot; resultType=&quot;String&quot;&gt;&lt;/select&gt; 2.resultType也是定义在增删改查标签中的属性，用于指定查询结果或增删改执行结果的类型，同样可以是基本数据类型+String+对象类型，这里需要注意的是，当查询结果是多条时，无需写List，MyBatis底层会自动为我们生成List&lt;数据类型&gt;，我们只需指定类型即可。同样是上边的例子，根据id查询name，name在数据库中是varchar类型，resultType就指定成String类型，类型不区分大小写，尽量保持和Java一致，使用大写。 1&lt; select id=&quot;queryPersonNameById&quot; parameterType=&quot;int&quot; resultType=&quot;String&quot;&gt;&lt;/select&gt; 3.resultMap当实体类的属性名和数据库表字段名或类型不一致时使用例如，Person表中，定义的字段是id和nameJava实体类中，定义的是pid和pname，这种情况下，使用resultMap手动完成数据库和Java实体类属性的映射。它是单独的&lt; resultMap&gt;标签，定义id(该属性是下面要用到的resultMap标签对应的值)，type（该属性指定了结果应该映射到的Java类的完全限定名或别名。）通常使用在查询标签中例如下边的代码id标签完成数据库主键的映射result标签完成数据库非主键字段的映射property属性指定java实体类中的属性名，column是数据库字段名 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;xxx.xxx.mapper.PersonMapper&quot;&gt; &lt;resultMap type=&quot;person&quot; id=&quot;personMapping&quot;&gt; &lt;id property=&quot;pid&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;pname&quot; column=&quot;name&quot;/&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;queryAllPersonUseResultMap&quot; resultMap=&quot;personMapping&quot;&gt; select * from person &lt;/select&gt;&lt;/mapper&gt; (2)增强for循环123for (元素类型 参数 : 集合名称) &#123; // 使用element(参数)&#125; 通常适配类型：它通常用于遍历数组或实现了Iterable接口的集合类（如ArrayList、HashSet等）。 增强for循环的优点： 使用增强型for循环的优点 简洁易读: 代码更简洁，不需要显式地处理索引。 减少错误: 避免了手动操作索引可能带来的错误，例如越界访问。 使用增强型for循环的限制 只读访问: 增强型for循环适用于只读访问集合中的元素，如果需要修改元素或需要索引值，则需要使用传统的for循环。 无法跳跃访问: 不能实现按特定步长跳跃访问元素，只能顺序遍历。","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://example.com/tags/Java%E5%AD%A6%E4%B9%A0/"}]},{"title":"开发(基于ruoyiui)笔记","slug":"开发-基于ruoyiui-笔记","date":"2024-03-21T07:30:34.000Z","updated":"2024-09-04T00:31:29.996Z","comments":true,"path":"2024/03/21/开发-基于ruoyiui-笔记/","permalink":"http://example.com/2024/03/21/%E5%BC%80%E5%8F%91-%E5%9F%BA%E4%BA%8Eruoyiui-%E7%AC%94%E8%AE%B0/","excerpt":"","text":"问题（一）在查询时参数没有带入1234567891011121314151617181920212223242526272829*&lt;el-form-item label=&quot;项目赛道&quot; prop=&quot;proTrack&quot;&gt;*​ *&lt;el-select*​ *v-model=&quot;queryParams.proTrack&quot;*​ *placeholder=&quot;请选择项目赛道&quot;*​ *clearable*​ *@keyup.enter.native=&quot;handleQuery&quot;*​ *\\&gt;*​ *&lt;el-option v-for=&quot;item in proTrackList&quot;*​ *:key=&quot;item.key&quot;*​ *:label=&quot;item.proTrack&quot;*​ *:value=&quot;item.proTrack&quot;*​ *\\&gt;*​ *&lt;/el-option&gt;*​ *&lt;/el-select&gt;* *&lt;/el-form-item&gt;* 这是一段vue代码,我出现的问题是再前端页面查询的时候无法带入proTrack这个参数。 解决方法:因为我们proTrackList中没有value这个字段，导致我再绑定的时候:value&#x3D;”item.value”绑定出错，将value更换为proTrack成功在查询时候带入了参数proTrack 还有一种没有带入参数的情况就是，有些需要参数的函数，你可能没有传入函数或者定义接受函数的变量。那这时候我们就需要去定义这个函数对于变量的传与接。下面来举一个我的错误例子 先来看我原本的写法 123456789101112131415161718192021222324252627 //查询小组列表 selectGroup()&#123; this.loading=true; selectGroupList(this.queryParams).then(response =&gt;&#123;​ this.tableList = response.rows;​ this.total = response.total;​ this.loading=false; &#125;) &#125;, //赛道改变清空组列表 selectOnChangeTrack()&#123; this.tableList = []; this.selectGroup(this.Track); &#125;, 可以看selectOnChangeTrack这个函数里，我在调用 this.selectGroup(this.Track);时，我传入了参数this.Track，this.Track是选择框的数据，proTrack是查询参数。而我在上面的函数时，却没有接收传过来的参数this.Track ,在vue中，通常定义一个形参，在作为传来参数的载体，然后再将这个形参的值赋值给查询变量，这样就能完成参数的传递，改动如下 12345678910111213141516171819//查询小组列表selectGroup(tempdata)&#123; //将形参tempdata赋值给查询参数proTrack，这样在查询时就会携带proTrack这个参数. this.queryParams.proTrack = tempdata this.loading=true; selectGroupList(this.queryParams).then(response =&gt;&#123; this.tableList = response.rows; this.total = response.total; this.loading=false; &#125;)&#125;, 以上即是改正后的。改正后可以带入要传的参数了。 问题（二）数据库字段名称与后端java应该对应这是一段ruoyi对应的后端代码 123456789101112&lt;select id=&quot;selectRecommendationList&quot; parameterType=&quot;Recommendation&quot; resultMap=&quot;RecommendationResult&quot;&gt; &lt;include refid=&quot;selectRecommendationVo&quot;/&gt; &lt;where&gt; &lt;if test=&quot;time != null &quot;&gt; and pro_details3.time = #&#123;time&#125;&lt;/if&gt; &lt;if test=&quot;proName != null and proName != &#x27;&#x27;&quot;&gt; and pro_name like concat(&#x27;%&#x27;, #&#123;proName&#125;, &#x27;%&#x27;)&lt;/if&gt; &lt;if test=&quot;proScore != null &quot;&gt; and pro_score = #&#123;proScore&#125;&lt;/if&gt; &lt;if test=&quot;proGroup != null and proGroup != &#x27;&#x27;&quot;&gt; and pro_group = #&#123;proGroup&#125;&lt;/if&gt; &lt;if test=&quot;userName != null and userName != &#x27;&#x27;&quot;&gt; and user_name = #&#123;userName&#125;&lt;/if&gt; &lt;if test=&quot;deptName != null and deptName != &#x27;&#x27;&quot;&gt; and dept_name = #&#123;deptName&#125;&lt;/if&gt; &lt;if test=&quot;proTrack !=null and proTrack != &#x27;&#x27;&quot;&gt; and pro_track=#&#123;proTrack&#125;&lt;/if&gt; &lt;/where&gt;&lt;/select&gt; mybaits中数据查询mapper文件中，值得注意的是在and后的字段名称**(比如uesr_name,dept_name,pro_track,pro_group等等)**要和数据库中的字段对应而前面的proGroup是实体类中我们自己定义的属性。 不对应，就会报错 以下这段代码是同样的道理，请注意数据字段是column后面的而实体类是property后面的，数据库字段要和自己的数据库中的字段一致(完全一致) 123456789101112&lt;resultMap type=&quot;Recommendation&quot; id=&quot;RecommendationResult&quot;&gt; &lt;result property=&quot;proId&quot; column=&quot;pro_id&quot; /&gt; &lt;result property=&quot;proName&quot; column=&quot;pro_name&quot; /&gt; &lt;result property=&quot;proScore&quot; column=&quot;pro_score&quot; /&gt; &lt;result property=&quot;proGroup&quot; column=&quot;pro_group&quot; /&gt; &lt;result property=&quot;userName&quot; column=&quot;user_name&quot; /&gt; &lt;result property=&quot;deptName&quot; column=&quot;dept_name&quot; /&gt; &lt;result property=&quot;proTrack&quot; column=&quot;pro_track&quot;/&gt; &lt;result property=&quot;proGroupId&quot; column=&quot;pro_group_Id&quot;/&gt; &lt;result property=&quot;proGroupName&quot; column=&quot;pro_group_name&quot;/&gt; &lt;result property=&quot;time&quot; column=&quot;time&quot;/&gt;&lt;/resultMap&gt; 问题(三)对vue中v-for的理解在Vue的v-for循环中，:key、:label和:value是用于绑定循环中每个元素的属性的特殊语法。 :key用于指定循环中每个元素的唯一标识符。它是必需的，用于帮助Vue跟踪每个元素的身份，以便在更新DOM时进行高效的重用和重新排序。通常，你可以使用一个唯一的属性或索引作为key，确保在循环中的元素之间具有唯一性。 :label用于指定循环中每个选项的显示文本。它绑定了每个选项的显示值，这将在选择框中显示给用户。 :value&#96;用于指定循环中每个选项的实际值。它绑定了每个选项的实际值，当用户选择某个选项时，该值将被传递给绑定的数据模型。 这些特殊语法（:key、:label和:value）是Vue中用于在循环中绑定属性的常见约定，但你也可以根据需要选择其他属性名称。重要的是确保在循环中的每个元素都有唯一的标识符作为key，以及适当的属性用于label和value。这样可以确保循环中的每个元素都能正确地显示和处理。 问题（四）理解一段代码的含义(以获取学院名称列表为例)12345678910111213141516171819/**获取学院名称函数 */ getDeptNameList()&#123; this.loading = true; listRecommendation(this.queryParams).then(response =&gt; &#123;​ this.deptNameList = response.rows;​ console.log(this.deptNameList)​ this.total = response.total;​ this.loading = false;​ &#125;) &#125;, 下面对这段代码剖析： 1234567891011121314getDeptNameList() &#123; this.loading = true; *// 设置 loading 状态为 true，表示正在加载数据* *// 调用 listRecommendation 函数，并传递 this.queryParams 参数* listRecommendation(this.queryParams).then(response =&gt; &#123; this.deptNameList = response.rows; *// 将返回的学院名称列表赋值给 this.deptNameList* console.log(this.deptNameList); *// 打印学院名称列表到控制台* this.total = response.total; *// 设置总数为返回结果的总数* this.loading = false; *// 设置 loading 状态为 false，表示加载数据完成* &#125;); &#125;, 帮助理解 思路（一）选择框一限定选择框二的内容如果想实现两个选择框第一个选择框里面的所选择的内容可以改变第二个选择框里面的数据（比如选择了第一个框里面的2021年，那第二个选择框就会显示在2021里面有什么内容) 可以考虑使用@change&#x3D;””来绑定一个变化，只要第一个选择框里面的内容变了，那么就会执行@change绑定的事件比如 12345678910111213141516171819202122232425262728 //选择框一&lt;el-form-item label=&quot;选择赛事:&quot; prop=&quot;time&quot;&gt;​ &lt;el-select​ v-model=&quot;queryParams.time&quot;​ placeholder=&quot;请选择参赛时间&quot;​ clearable //表示是否可以清除选择框内容​ @change=&quot;handleSelectionChange1&quot;​ \\&gt;​ &lt;el-option v-for=&quot;dict in dict.type.events_year&quot; ​ :key=&quot;dict.key&quot; ​ :label=&quot;dict.value&quot; ​ :value=&quot;dict.value&quot;&gt;​ &lt;/el-option&gt;​ &lt;/el-select&gt; &lt;/el-form-item&gt; 123456789101112131415161718192021222324252627282930//选择框二el-form-item label=&quot;&quot; prop=&quot;selectCompetition&quot;&gt;​ &lt;el-select​ class=&quot;custom-select&quot;​ v-model=&quot;queryParams.selectCompetition&quot;​ placeholder=&quot;请选择赛事&quot;​ clearable​ @keyup.enter.native=&quot;handleQuery&quot; //回车​ \\&gt;​ &lt;el-option v-for=&quot; item in competitionList&quot; ​ :key=&quot;item.key&quot;​ :label=&quot;item.eventName&quot;​ :value=&quot;item.value&quot;&gt;​ &lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; 123456789101112//@change的所绑定事件的功能 handleSelectionChange1() &#123; this.queryParams.startTime = this.queryParams.time; // Update the query parameter this.queryParams.selectCompetition = null; // Clear the competition dropdown this.competitionList = []; // Clear the competition list this.getEventsList(); // Call the function to fetch the updated competition list&#125;, 问题（五）:在今天编写代码时候遇到了这么一个问题，就是关于添加数据前端页面他不给我显示。 查看发现是getfilename函数作怪，因为我的这个函数是要获取路径去分割，然而我并没有在数据库给出路径，所以这两个数据显示不出来，更改函数后成功显示，函数更改如下 12345678910111213 getfileName(path)&#123; if(path)&#123;​ return path.split(&#x27;/&#x27;).pop(); &#125;else&#123;​ return &quot;暂无资料&quot;; &#125; &#125;, 方法1:在数据库中呢，我删除一个数据，由于这个数据关联很多表，那就需要一同删除，这可以利用触发器，以下是我在该项目中写道的触发器123BEGIN DELETE FROM pro_coreteam WHERE pro_id = OLD.pro_id;END 该触发器是当我们根据项目id（pro_id）删除数据时，他会带着通过项目id关联的id里面的内容一同删除,删除的表名称、是pro_coreteam 4.2新添加了一个触发器代码如下 1234567891011DELIMITER //CREATE TRIGGER update_group_idAFTER INSERT ON pro_mapping_groupFOR EACH ROWBEGIN UPDATE pro_details3 SET pro_group_id = NEW.group_id WHERE pro_id = NEW.pro_id;END;//DELIMITER ; 解释 在这个触发器中，当在 pro_mapping_group 表中插入新的记录时，将会更新 pro_details3 表中对应 pro_id 的 pro_group_id 字段。这里假设 pro_mapping_group 表和 pro_details3 表通过 pro_id 字段关联。如果你的实际情况不同，请根据实际情况修改 WHERE 子句。 请注意，这个触发器只在插入新的记录时触发，如果你更新 pro_mapping_group 表中的 group_id 字段，这个触发器不会触发。如果你希望在更新 group_id 时也触发，你需要创建一个额外的 AFTER UPDATE 触发器 方法2:如何写一个对话框即点击按钮弹出对话框？1234567891011121314151617181920212223242526&lt;template&gt; &lt;!-- ... --&gt; &lt;el-button type=&quot;success&quot; @click=&quot;showDialog&quot;&gt;导入互联网+大赛官网（大创网）项目资料&lt;/el-button&gt; &lt;el-dialog title=&quot;导入互联网+大赛官网（大创网）项目资料&quot; :visible.sync=&quot;dialogVisible&quot; width=&quot;800px&quot; top=&quot;5vh&quot; append-to-body&gt; &lt;!-- 对话框内容 --&gt; &lt;!-- ... --&gt; &lt;/el-dialog&gt;&lt;/template&gt;&lt;script&gt;export default &#123; // ... data() &#123; return &#123; dialogVisible: false, // 对话框可见性 &#125;; &#125;, methods: &#123; showDialog() &#123; this.dialogVisible = true; // 点击按钮时显示对话框 &#125;, // 其他方法 // ... &#125;,&#125;;&lt;/script&gt; 方法3:如何在插入数据时携带其他参数新建你要插入的属性比如我下面的 12345@Excel(name = &quot;学生账号&quot;)private Long StuNumber;/** 学生id*/private Long userId; 在服务层写好定义的方法 1public int insertCore(ProCoreteam proCoreteam); 实现类中实现方法 12345@Overridepublic int insertCore(ProCoreteam proCoreteam)&#123; return proManagerMapper.insertCore(proCoreteam);&#125; 在mapper中定义方法 1public int insertCore(ProCoreteam proCoreteam); 在xml文件中使用方法 1234&lt;insert id=&quot;insertCore&quot; parameterType=&quot;ProCoreteam&quot; &gt; insert into pro_coreteam (pro_id,student_id) value (#&#123;proId&#125;,#&#123;studentId&#125;)&lt;/insert&gt; 同理按照以上步骤创建stuNumber的方法 123&lt;select id=&quot;selectstuIdBystuNumber&quot; parameterType=&quot;long&quot; resultMap=&quot;ProManagerResult&quot;&gt; select user_id from sys_user where phonenumber = #&#123;stuNumber&#125;&lt;/select&gt; 关键点在下面，我们要先获取插入完成以后的proid 1234567-- &lt;insert&gt;//获取插入完以后的proid &lt;selectKey resultType=&quot;Long&quot; keyProperty=&quot;proId&quot; order=&quot;AFTER&quot;&gt; select LAST_INSERT_ID() &lt;/selectKey&gt; &lt;/insert&gt; 1.最外层的&lt;insert&gt;&lt;/insert&gt;没有返回属性（resultType），但是里面的&lt;selectKey&gt;&lt;/selectKey&gt;是有返回值类型的。 2.order=&quot;AFTER&quot;表示先执行插入，之后才执行selectkey语句的。 3.select @@identity和select LAST_INSERT_ID()都表示选出刚刚插入的最后一条数据的id。 4.实体类中id属性字段一定需要set以及get方法 5.此时，接口中仍不需要有返回值，框架会自动将值注入到我们insert的那个对象中，我们可以直接使用就可以了。 其实，我们的接口中可以有返回值，但是这个返回值不是id,而是表示插入后影响的行数，此时sql中仍和上面一样，不需要写返回值。 1234567&lt;insert id=&quot;insertStudentCacheId&quot; parameterType=&quot;Student&quot;&gt; insert into student(name,age,score) values(#&#123;name&#125;,#&#123;age&#125;,#&#123;score&#125;) &lt;!-- 指定结果类型resultType，keyProperty是属性，自动返回到属性id中，order是次序，after是指获取id是在于插入后 --&gt; &lt;selectKey resultType=&quot;int&quot; keyProperty=&quot;id&quot; order=&quot;AFTER&quot;&gt; select @@identity &lt;/selectKey&gt;&lt;/insert&gt; 最最最核心的一步 12345678//执行完以后主键自增，获取到自增的proId所以要先执行proManagerMapper.insertProManager(proManager);//创建实体类ProManager的对象S存储通过学生账号获得stuidProManager S = proManagerMapper.selectstuIdBystuNumber(proManager.getStuNumber());//带参数的构建对象方法,上面已经获取到了proId和studentId所以下面创建ProCoreteam的对象p_core存储这两个idProCoreteam p_core=new ProCoreteam(proManager.getProId(),S.getUserId());//调用插入方法插入id，由于是个导入过程所以会在导入过程中执行以上内容自动插入，这样就携带了其他参数proManagerMapper.insertCore(p_core); 问题（六）基于ruoyiUI新建对话框的一些属性问题我们首先新建一个对话框，代码如下(我这个时ruoyiUI的对话框建法) 1&lt;el-dialog :title=&quot;title&quot; :visible.sync=&quot;open&quot; width=&quot;1500px&quot; append-to-body&gt; &lt;/el-dialog&gt; :title=&quot;title&quot;：此属性设置对话框的标题。title 应该是你的 Vue 实例的 data 属性之一，用来存放对话框的标题。: 前缀表示这是一个动态属性，它的值会被解析为 JavaScript 表达式。 :visible.sync=&quot;open&quot;：此属性控制对话框的可见性。如果 open 是 true，对话框就会显示；如果 open 是 false，对话框就会隐藏。.sync 修饰符表示这个属性是双向绑定的：当对话框的可见性改变时，open 的值也会相应地改变（对话框自带的×）。 width=&quot;1500px&quot;：此属性设置对话框的宽度。在这个例子中，对话框的宽度被设置为 1500 像素。 append-to-body：此属性表示对话框将被附加到 body 元素。这可以防止对话框被其他 CSS 影响，确保它能正确地显示在其他元素之上。这是一个布尔属性，如果存在，其值就是 true。 方法4: 如何获取当前行id？面对这个问题我只想说，这可真是让我想的酣畅淋漓的一次啊，为什么这么说？先来看看我犯了什么错误把首先，我当时一心只想着获取当前行id，但是却忽视了原表格是一个静态表格这个前提。所以我花了快一个小时，唉还好脑子转得快(快什么，要是快的话早想到了)突然意识到了，这是一个静态表格，我去哪里动态获取当前行？ 其次，因为脑子当时很热，一点思路也没有，所以就乱撞，白白荒废了时间。 接下来，让我来整理获取当前行id的一个思路 首先想，你要在哪一行操作，好的定位到这一行，要用&lt;template&gt;&lt;/template&gt;标签，具体写法如下: 1234567891011121314151617&lt;el-table-column prop=&quot;selectPro&quot; label=&quot;查看项目&quot; width=&quot;208&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button class=&quot;ebtn1&quot; style=&quot;color: white;&quot; @click=&quot;getAllocationList(scope.row.groupId)&quot; \\&gt;查看&lt;/el-button&gt; &lt;/template&gt;&lt;/el-table-column&gt; 比如我就是这一行要注意了，绑定点击事件的时候，必须加scope.row.xxxx其中的xxxx是你要获取的什么什么id，那么这样你就可以获取到当前行的id了 12345678910111213141516getAllocationList(groupId)&#123; console.log(groupId) this.loading = true; alreadyAllocation(groupId).then(response =&gt;&#123; this.alAllocationList = response.rows; this.total = response.total; this.loading=false; &#125;) &#125; 可以在你所用的时间console.log(groupId)你获取的id然后查看控制台有没有对应的id输出，然后传递参数就可以了。 你甚至还可以这么写 1234567891011121314151617getAllocationList(groupId)&#123; // 输出传入的 groupId console.log(groupId) // 创建一个新对象，包含 groupId const params = &#123;groupId&#125; this.loading = true; //传递参数 alreadyAllocation(params).then(response =&gt;&#123; this.alAllocationList = response.rows; this.total = response.total; this.loading=false; &#125;) &#125; 也是可以的，ok今天就写这么多0.0 问题7:在传入参数时的错误报错是这样对的 Error: nested exception is org.apache.ibatis.binding.BindingException: Parameter &#39;groupId&#39; not found. Available parameters are [arg1, arg0, param1, param2] 翻译一下就是 错误：嵌套异常是 org.apache.ibatis.binding.BindingException：找不到参数“groupId”。可用参数为 [arg1， arg0， param1， param2] 这是我传入参数的函数 12345678910111213141516171819202122232425262728getAllocationList(row)&#123; const proTrack = this.Track; const groupId=row.groupId; const groupName=row.groupName; this.loading = true; alreadyAllocation(groupId,proTrack).then(response =&gt;&#123;​ this.alAllocationList = response.data;​ // console.log(this.alAllocationList)​ this.sendArrayToParent(this.alAllocationList);​ this.sendArrayToParent2(groupName);​ // console.log(tableList);​ this.total = response.total;​ this.loading=false; &#125;) &#125; 这是js里面对应的接口 1234567891011export function alreadyAllocation(groupId,proTrack)&#123; return request(&#123;​ url: &#x27;/project/csxmfp/group/&#x27; + groupId +&#x27;/&#x27;+ proTrack,​ method: &#x27;get&#x27; &#125;)&#125; 报错问题是gruopId找不到，可用参数给出了[arg1, arg0, param1, param2] 这四个参数，这时我就在想，那是不是传入的参数得用这四个中的几个呢？于是我检查了后端，在处理器(proAllocationController)中打印了我从前端带过来的两个参数 123456789101112 /** * 通过赛道名称和小组获取参赛项目分配详细信息 */ @PreAuthorize(&quot;@ss.hasPermi(&#x27;project:csxmfp:querybygroupId&#x27;)&quot;) @GetMapping(value = &quot;group/&#123;groupId&#125;/&#123;trackName&#125;&quot;) public AjaxResult getInfoByGroupId(@PathVariable(&quot;groupId&quot;) Long groupId,@PathVariable(&quot;trackName&quot;) String trackName) &#123; System.out.println(groupId); System.out.println(&quot;aaaa&quot;+trackName); return success(proAllocationService.selectGroupProjectByGroupId(groupId,trackName)); &#125;&#125; 控制台输出 可以看到控制台是有groupId的输出1这就是说拿到了前端数据那为什么后端确说我没有定义呢？检查xml文件 12345678910111213141516171819&lt;select id=&quot;selectGroupProjectByGroupId&quot; parameterType=&quot;GroupProject&quot; resultMap=&quot;GroupProjectresultMap&quot;&gt; SELECT pro_details3.pro_id, pro_details3.pro_name, pro_details3.pro_logo, pro_details3.pro_track, pro_details3.pro_group_id FROM pro_details3 INNER JOIN pro_mapping_group ON pro_details3.pro_id = pro_mapping_group.pro_id &lt;where&gt; pro_mapping_group.group_id = #&#123;group_id&#125; &lt;if test=&quot;proTrack != &#x27;null&#x27; and proTrack != &#x27;&#x27; and arg1!= null&quot;&gt; and pro_details3.pro_track = #&#123;proTrack&#125;&lt;/if&gt; &lt;/where&gt; ORDER BY pro_details3.pro_id;&lt;/select&gt; 于是就想到会不会是参数的传递问题呢？于是我就尝试用arg0代替groupId，用age1代替了proTrack,下面是更新完xml文件 12345678910111213141516171819&lt;select id=&quot;selectGroupProjectByGroupId&quot; parameterType=&quot;GroupProject&quot; resultMap=&quot;GroupProjectresultMap&quot;&gt; SELECT pro_details3.pro_id, pro_details3.pro_name, pro_details3.pro_logo, pro_details3.pro_track, pro_details3.pro_group_id FROM pro_details3 INNER JOIN pro_mapping_group ON pro_details3.pro_id = pro_mapping_group.pro_id &lt;where&gt; pro_mapping_group.group_id = #&#123;arg0&#125; &lt;if test=&quot;arg1 != &#x27;null&#x27; and arg1 != &#x27;&#x27; and arg1!= null&quot;&gt; and pro_details3.pro_track = #&#123;arg1&#125;&lt;/if&gt; &lt;/where&gt; ORDER BY pro_details3.pro_id;&lt;/select&gt; 运行代码，成功传递了数据，问题解决了。你要是问我为什么这样做，其实我也不清楚，但是通过报错信息给出了可用的四个参数，所以说有错误还是要从报错信息入手啊 问题8：vue+ruoyi前端内网在线预览ppt在内网在线预览ppt时，我踩了很多坑，这里记录一下我都翻过什么错误。 错误一：在给数据模型里面的数据赋值时，没有搞清楚层级，来看代码这里，我定义了一个prevForm对象，里面有prev和url两个数据。然而在我进行赋值操作时错写成了this.prev &#x3D; xxxx，this.url&#x3D;xxxx，看似没错，但是实际上已经少写了一层了那就是丢了一个最大的对象prevForm正确写法是这样的 错误二：没有搞清楚&#x3D;，&#x3D;&#x3D;，&#x3D;&#x3D;&#x3D;这三个符号的意思，&#x3D;：意味着赋值操作，左边的值赋值给右边的，&#x3D;&#x3D;是比较运算符，当左右两边相等时返回true，不相等时返回false，而&#x3D;&#x3D;&#x3D;在前端中表示全等，意味着完全相等，意思就是在做运算判断时，等式两边的数值以及数据类型都必须相同。 在线预览ppt： 我完成这次任务主要使用了vue-office，官网：vue-office: 支持word(.docx)、excel(.xlsx)、pdf等各类型office文件预览的vue组件集合，提供一站式office文件预览方案，支持vue2和3 (gitee.com) 思路是，我在a标签中写了一个函数whatType用来判断这是一个以什么结尾的文件，这里用到了方法pop()取最后一个元素 来说一下在线预览ppt的模板： 第一步，确定你要在线预览文件的类型： 12345678//docx文档预览组件npm install @vue-office/docx vue-demi//excel文档预览组件npm install @vue-office/excel vue-demi//pdf文档预览组件npm install @vue-office/pdf vue-demi vue模板 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;vue-office-docx :src=&quot;docx&quot; @rendered=&quot;rendered&quot;/&gt; &lt;vue-office-excel :src=&quot;excel&quot; @rendered=&quot;rendered&quot;/&gt; &lt;vue-office-pdf :src=&quot;pdf&quot; @rendered=&quot;rendered&quot;/&gt;&lt;/template&gt;&lt;script&gt;//引入VueOfficeDocx组件import VueOfficeDocx from &#x27;@vue-office/docx&#x27;//引入VueOfficeExcel组件import VueOfficeExcel from &#x27;@vue-office/excel&#x27;//引入VueOfficePdf组件import VueOfficePdf from &#x27;@vue-office/pdf&#x27;//引入相关样式import &#x27;@vue-office/docx/lib/index.css&#x27;export default &#123; components:&#123; VueOfficeDocx &#125;, data()&#123; return &#123; docx: &#x27;http://static.shanhuxueyuan.com/test6.docx&#x27; //设置文档网络地址，可以是相对地址 excel： pdf: &#125; &#125;, methods:&#123; rendered()&#123; console.log(&quot;渲染完成&quot;) &#125; &#125;&#125;&lt;/script&gt; 一次性引入了三个，这样会渲染三个 最后，展示一下我写的点击弹出弹窗，来展示对应的内容，代码如下(只展示核心部分，多余代码省略)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;template&gt;......... &lt;el-table-column label=&quot;项目计划书&quot; align=&quot;center&quot; prop=&quot;proPlan&quot; &gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;a @click=&quot;whatType(scope.row.proPlan)&quot; v-if=&quot;getfileName(scope.row.proPt) !== &#x27;暂无资料&#x27;&quot;&gt; &#123;&#123; getfileName(scope.row.proPlan) &#125;&#125; &lt;/a&gt; &lt;a v-else&gt; &#123;&#123; getfileName(scope.row.proPlan) &#125;&#125; &lt;/a&gt; &lt;/template&gt;.......&lt;!--弹出各种文件预览弹窗--&gt;&lt;el-dialog :visible.sync=&quot;dialogPrevVisible&quot; title=&quot;文件预览&quot; width=&quot;90%&quot; &gt; &lt;el-form style=&quot;margin-top: 10px;&quot; :model=&quot;prevForm&quot;&gt; &lt;template v-if=&quot;prevForm.prev == &#x27;docx&#x27;&quot;&gt; &lt;vue-office-docx style=&quot;height: 90%&quot; :src=&quot;prevForm.url&quot; @rendered=&quot;rendered&quot;/&gt; &lt;/template&gt; &lt;template v-if=&quot;prevForm.prev == &#x27;xlsx&#x27;&quot;&gt; &lt;vue-office-excel style=&quot;height: 90%&quot; :src=&quot;prevForm.url&quot; @rendered=&quot;rendered&quot; /&gt; &lt;/template&gt; &lt;template v-if=&quot;prevForm.prev == &#x27;pdf&#x27;&quot;&gt; &lt;vue-office-pdf style=&quot;height: 90%&quot; :src=&quot;prevForm.url&quot; @rendered=&quot;rendered&quot;/&gt; &lt;/template&gt; &lt;/el-form&gt; &lt;/el-dialog&gt;......&lt;/template&gt;&lt;script&gt;//引入VueOfficeDocx组件import VueOfficeDocx from &#x27;@vue-office/docx&#x27;;import VueOfficeExcel from &#x27;@vue-office/excel&#x27;;import VueOfficePdf from &#x27;@vue-office/pdf&#x27;;//引入相关样式import &#x27;@vue-office/docx/lib/index.css&#x27;;data() &#123; return &#123; //设置弹窗初始状态 dialogPrevVisible:false, prevForm:&#123; prev:&#x27;&#x27;, url:&#x27;&#x27; &#125;,.....&#125;methods: &#123; //判断路径的类型 whatType(path)&#123; //获取文件拓展名并改为小写 var tempPath = path; console.log(tempPath); //pop函数取最后一个元素，然后在转成小写。 var fileType = path.split(&#x27;.&#x27;).pop().toLowerCase(); console.log(fileType); if(fileType == &#x27;docx&#x27;)&#123; this.prevForm.prev = &#x27;docx&#x27;, this.prevForm.url=&#x27;http://192.168.1.104/dev-api&#x27;+ tempPath this.dialogPrevVisible = true; &#125;else if(fileType == &#x27;excel&#x27;)&#123; this.prevForm.prev = &#x27;excel&#x27;, this.prevForm.url=&#x27;http://192.168.1.104/dev-api&#x27;+ tempPath this.dialogPrevVisible = true; &#125;else if(fileType ==&#x27;pdf&#x27;)&#123; this.prevForm.prev = &#x27;pdf&#x27;, this.prevForm.url=&#x27;http://192.168.1.104/dev-api&#x27;+ tempPath this.dialogPrevVisible = true; &#125;else&#123; window.alert(&quot;不支持查看该文件格式&quot;) &#125; &#125;, rendered()&#123; console.log(&quot;渲染完成&quot;) &#125;, &#125;&lt;/script&gt; Vue中v-model数据绑定问题(绑定对象) 在vue中，选择框中如果需要传递多个值到后端进行带参数的查询，这时，我们就应该将这两个值，绑定在一个对象上，那么关于如何绑定到对象以及进行参数的传递，下面是我的理解： 示例代码： &lt;el-form :model=&quot;queryParams&quot;&gt; &lt;el-form-item label=&quot;请选择赛事：&quot; prop=&quot;proGameId&quot;&gt; &lt;el-select v-model=&quot;this.selectedOption&quot; placeholder=&quot;请选择下拉选择&quot; clearable :style=&quot;&#123;width: &#39;100%&#39;&#125;&quot; @change=&quot;getList2&quot;&gt; &lt;el-option v-for=&quot;(item, index) in EventList&quot; :key=&quot;index&quot; :label=&quot;`$&#123;item.proGame&#125;——$&#123;item.groupName&#125;`&quot; :value=&quot;&#123; proGameId: item.proGameId, groupId: item.groupId &#125;&quot; :disabled=&quot;item.disabled&quot;&gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; 解释：**:label&#x3D;”$&#123;item.proGame&#125;——$&#123;item.groupName&#125;“**绑定成这样的label，在我们的选择框中就会是下面的样式 **:value&#x3D;”{ proGameId: item.proGameId, groupId: item.groupId }”**通过这样的绑定，想要将proGameId和groupId同时绑定到该选择框中，那么首先v-model的绑定应该是一个对象 并且在对象中，还必须包含你所绑定的这两个属性值，初始化为null。(初始化为空的原因是对象初始化就是空对象)，如下图 这样，就完成了数据在选择框层面的绑定。那么如何传递这两个数据呢？比如我今天就遇到这样的问题，从后端查询到这两个的值，同时也需要把查询到的值 ，再绑定到选择框中，当选择框的内的选项一改变就会传递这两个对象的值到后端再进行一次查询。 首先要做的就是绑定@change事件，比如我上面代码中的 然后 这样就成功把值带到查询参数里面，就可以在次传递给后端进行查询啦。 最后，如果在调用函数getList2的时候我并没有指定参数，那么在方法中的getList2(value)中，这个value就指的是:value所绑定的内容。也就是用户选择的值","categories":[{"name":"开发总结","slug":"开发总结","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"java和vue开发中遇到的错误以及如何改正和对他们的理解整理(参加的项目)","slug":"java和vue开发中遇到的错误以及如何改正和对他们的理解整理-参加的项目","permalink":"http://example.com/tags/java%E5%92%8Cvue%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E6%94%B9%E6%AD%A3%E5%92%8C%E5%AF%B9%E4%BB%96%E4%BB%AC%E7%9A%84%E7%90%86%E8%A7%A3%E6%95%B4%E7%90%86-%E5%8F%82%E5%8A%A0%E7%9A%84%E9%A1%B9%E7%9B%AE/"}]},{"title":"后端获取图片数据的开发文档","slug":"基于ruoyi框架的开发笔记","date":"2023-12-06T13:42:11.048Z","updated":"2024-09-04T00:33:14.333Z","comments":true,"path":"2023/12/06/基于ruoyi框架的开发笔记/","permalink":"http://example.com/2023/12/06/%E5%9F%BA%E4%BA%8Eruoyi%E6%A1%86%E6%9E%B6%E7%9A%84%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/","excerpt":"","text":"后端获取图片数据的开发文档1.后端获取图片数据的基本需求（文件）在com&#x2F;ruoyi&#x2F;system&#x2F;domain&#x2F;目录下创建SysPicture.java 在该类中编写你在图片数据库中定义的属性:以下拿我的举例子 1234567891011121314151617181920212223242526272829/** * 图片表 data_entires * * */public class SysPicture extends BaseEntity&#123; private static final long serialVersionUID = 1L; /** 图片序号 */ @Excel(name = &quot;图片序号&quot;, cellType = Excel.ColumnType.NUMERIC) private Long pictureId; /** 图片编码 */ @Excel(name = &quot;图片编码&quot;) private String pictureCode; /** 图片名称 */ @Excel(name = &quot;图片名称&quot;) private String pictureName; /** 图片排序 */ @Excel(name = &quot;图片排序&quot;) private Integer pictureSort; /** 状态（0正常 1停用） */ @Excel(name = &quot;状态&quot;, readConverterExp = &quot;0=正常,1=停用&quot;) private String status; 添加Set,Get方法 123456789101112131415161718192021222324252627282930313233343536373839public Long getPictureId() &#123; return pictureId;&#125;public void setPictureId(Long pictureId) &#123; this.pictureId = pictureId;&#125;public String getPictureCode() &#123; return pictureCode;&#125;public void setPictureCode(String pictureCode) &#123; this.pictureCode = pictureCode;&#125;public String getPictureName() &#123; return pictureName;&#125;public void setPictureName(String pictureName) &#123; this.pictureName = pictureName;&#125;public Integer getPictureSort() &#123; return pictureSort;&#125;public void setPictureSort(Integer pictureSort) &#123; this.pictureSort = pictureSort;&#125;public String getStatus() &#123; return status;&#125;public void setStatus(String status) &#123; this.status = status;&#125; 添加toString()方法 1234567891011121314@Overridepublic String toString() &#123; return new ToStringBuilder(this, ToStringStyle.MULTI_LINE_STYLE) .append(&quot;pictureId&quot;, getPictureId()) .append(&quot;postCode&quot;, getPictureCode()) .append(&quot;postName&quot;, getPictureName()) .append(&quot;postSort&quot;, getPictureSort()) .append(&quot;status&quot;, getStatus()) .append(&quot;createBy&quot;, getCreateBy()) .append(&quot;createTime&quot;, getCreateTime()) .append(&quot;updateBy&quot;, getUpdateBy()) .append(&quot;updateTime&quot;, getUpdateTime()) .append(&quot;remark&quot;, getRemark()) .toString(); 可以参考其他的domian类文件。 在com&#x2F;ruoyi&#x2F;web&#x2F;controller&#x2F;system&#x2F;目录下创建SysPictureController.java 控制层中我们主要添加 1234567891011121314151617181920@RestController@RequestMapping(&quot;/system/picture&quot;)public class SysPictureController extends BaseController&#123; //创建并注入服务处的对象 @Autowired private ISysPictureService pictureService; /** * 获取图片 */ @PreAuthorize(&quot;@ss.hasPermi(&#x27;system:picture:list&#x27;)&quot;) @GetMapping(&quot;/list&quot;) public TableDataInfo list(SysPicture picture) &#123; startPage(); List&lt;SysPicture&gt; list = pictureService.selectPictureList(picture); return getDataTable(list); &#125;&#125; 在com&#x2F;ruoyi&#x2F;system&#x2F;service&#x2F;目录下创建服务层的类ISysPictureService.java 在该类中添加如下代码 123456789public interface ISysPictureService &#123; /** * 查询图片信息集合 * * @param picture 图片信息 * @return 图片列表 */ public List&lt;SysPicture&gt; selectPictureList(SysPicture picture);&#125; 在com&#x2F;ruoyi&#x2F;system&#x2F;service&#x2F;impl&#x2F;目录下编写SysPictureServiceImpl.java类并添加如下代码: 1234567891011@Servicepublic class SysPictureServiceImpl implements ISysPictureService &#123; @Autowired private SysPictureMapper pictureMapper; @Override public List&lt;SysPicture&gt; selectPictureList(SysPicture picture) &#123; return pictureMapper.selectPictureList(picture); &#125;&#125; 在com&#x2F;ruoyi&#x2F;system&#x2F;mapper&#x2F;目录下编写SysPictureMapper.java类 在该类中添加 123456789101112131415/** *图片信息 数据层 */@Repositorypublic interface SysPictureMapper &#123; /** * 查询图片数据集合 * * @param picture 图片信息 * @return 图片数据集合 */ public List&lt;SysPicture&gt; selectPictureList(SysPicture picture);&#125; 在mapper&#x2F;system&#x2F;目录下添加SysPictureMapper.xml文件 内容如下 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; 以上部分为文件头，可复制直接使用 &lt;mapper namespace=&quot;com.ruoyi.system.mapper.SysPictureMapper&quot;&gt;//该位置必须要找到Mapper文件所在位置 &lt;resultMap type=&quot;SysPicture&quot; id=&quot;SysPictureResult&quot;&gt; &lt;id property=&quot;pictureId&quot; column=&quot;picture_id&quot; /&gt; &lt;result property=&quot;pictureCode&quot; column=&quot;picture_code&quot; /&gt; &lt;result property=&quot;pictureName&quot; column=&quot;picture_name&quot; /&gt; &lt;result property=&quot;pictureSort&quot; column=&quot;picture_sort&quot; /&gt; &lt;result property=&quot;status&quot; column=&quot;status&quot; /&gt; &lt;result property=&quot;createBy&quot; column=&quot;create_By&quot; /&gt; &lt;result property=&quot;createTime&quot; column=&quot;create_time&quot; /&gt; &lt;result property=&quot;updateBy&quot; column=&quot;update_by&quot; /&gt; &lt;result property=&quot;updateTime&quot; column=&quot;update_time&quot; /&gt; &lt;result property=&quot;remark&quot; column=&quot;remark&quot; /&gt; &lt;/resultMap&gt; &lt;sql id=&quot;selectPictureVo&quot;&gt; select picture_id, picture_code, picture_name, picture_sort, status, create_by, create_time, remark from data_entires &lt;/sql&gt; &lt;select id=&quot;selectPictureList&quot; parameterType=&quot;SysPost&quot; resultMap=&quot;SysPictureResult&quot;&gt; &lt;include refid=&quot;selectPictureVo&quot;/&gt; &lt;where&gt; &lt;if test=&quot;pictureCode != null and pictureCode != &#x27;&#x27;&quot;&gt; AND picture_code like concat(&#x27;%&#x27;, #&#123;pictureCode&#125;, &#x27;%&#x27;) &lt;/if&gt; &lt;if test=&quot;status != null and status != &#x27;&#x27;&quot;&gt; AND status = #&#123;status&#125; &lt;/if&gt; &lt;if test=&quot;pictureName != null and pictureName != &#x27;&#x27;&quot;&gt; AND picture_name like concat(&#x27;%&#x27;, #&#123;pictureName&#125;, &#x27;%&#x27;) &lt;/if&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; 以上的大部分代码，均参考ruoyi官方编写的其他内容改编 由于ruoyi设置了查询权限，我们在运行项目进行数据查询时会提示权限不足,这时候我们需要带着两个请求头去查询 Cookie Authorization","categories":[{"name":"开发总结","slug":"开发总结","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"}],"tags":[]}],"categories":[{"name":"开发总结","slug":"开发总结","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"},{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"开发总结","slug":"开发总结","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"},{"name":"手机，移动端，less","slug":"手机，移动端，less","permalink":"http://example.com/tags/%E6%89%8B%E6%9C%BA%EF%BC%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%8Cless/"},{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"},{"name":"uni-app框架","slug":"uni-app框架","permalink":"http://example.com/tags/uni-app%E6%A1%86%E6%9E%B6/"},{"name":"状态管理工具(vue3.js)","slug":"状态管理工具-vue3-js","permalink":"http://example.com/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-vue3-js/"},{"name":"HTML,CSS","slug":"HTML-CSS","permalink":"http://example.com/tags/HTML-CSS/"},{"name":"状态管理工具(vue2.js)","slug":"状态管理工具-vue2-js","permalink":"http://example.com/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-vue2-js/"},{"name":"打包工具，模块","slug":"打包工具，模块","permalink":"http://example.com/tags/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%EF%BC%8C%E6%A8%A1%E5%9D%97/"},{"name":"vue.js前置知识","slug":"vue-js前置知识","permalink":"http://example.com/tags/vue-js%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"},{"name":"jwt,身份认证,cookie","slug":"jwt-身份认证-cookie","permalink":"http://example.com/tags/jwt-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81-cookie/"},{"name":"前端,web,框架","slug":"前端-web-框架","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF-web-%E6%A1%86%E6%9E%B6/"},{"name":"npm,yarn","slug":"npm-yarn","permalink":"http://example.com/tags/npm-yarn/"},{"name":"js-node.js","slug":"js-node-js","permalink":"http://example.com/tags/js-node-js/"},{"name":"git学习","slug":"git学习","permalink":"http://example.com/tags/git%E5%AD%A6%E4%B9%A0/"},{"name":"jQuery","slug":"jQuery","permalink":"http://example.com/tags/jQuery/"},{"name":"vue.js","slug":"vue-js","permalink":"http://example.com/tags/vue-js/"},{"name":"nginx学习","slug":"nginx学习","permalink":"http://example.com/tags/nginx%E5%AD%A6%E4%B9%A0/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/tags/JavaWeb/"},{"name":"Java学习","slug":"Java学习","permalink":"http://example.com/tags/Java%E5%AD%A6%E4%B9%A0/"},{"name":"java和vue开发中遇到的错误以及如何改正和对他们的理解整理(参加的项目)","slug":"java和vue开发中遇到的错误以及如何改正和对他们的理解整理-参加的项目","permalink":"http://example.com/tags/java%E5%92%8Cvue%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E6%94%B9%E6%AD%A3%E5%92%8C%E5%AF%B9%E4%BB%96%E4%BB%AC%E7%9A%84%E7%90%86%E8%A7%A3%E6%95%B4%E7%90%86-%E5%8F%82%E5%8A%A0%E7%9A%84%E9%A1%B9%E7%9B%AE/"}]}
{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Java练习题","slug":"Java练习题","date":"2024-04-25T04:48:53.000Z","updated":"2024-04-25T04:51:07.319Z","comments":true,"path":"2024/04/25/Java练习题/","permalink":"http://example.com/2024/04/25/Java%E7%BB%83%E4%B9%A0%E9%A2%98/","excerpt":"","text":"题(1)：最简单的四舍五入1234567891011import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); double d= scanner.nextDouble(); //write your code here...... int i = (int)(d+0.5); System.out.println(i); &#125;&#125;","categories":[],"tags":[{"name":"练习题，面试题","slug":"练习题，面试题","permalink":"http://example.com/tags/%E7%BB%83%E4%B9%A0%E9%A2%98%EF%BC%8C%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"Java学习笔记","slug":"Java学习笔记","date":"2024-04-08T06:56:32.000Z","updated":"2024-04-28T11:08:11.731Z","comments":true,"path":"2024/04/08/Java学习笔记/","permalink":"http://example.com/2024/04/08/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1、如何拿到用户的输入有时候的一些业务是需要用户和系统互动的，这时，我们就需要来接收用户的互动，在java中，通常这么做 1234//新建一个扫描器对象scScanner sc = new Scanner(System.in);//定义一个变量来接收用户输入，类型要看你接受的是字符串还是数据而变动数据类型 变量 = sc.nextInt(); 举个例子，比如我下面这段代码 1234Scanner sc = new Scanner(System.in);System.out.println(&quot;请您输出查询的id&quot;);int id = sc.nextInt();operator.searchMovieById(id); 很好理解，接收用户输入的数字id然后把他传给operator.searchMovieById(id);方法完成代码逻辑。 2、this关键字在java中this关键字的作用是: this就是一个变量，可以用在方法中，用来拿到当前对象；哪个对象调用方法，this就指向那个对象，也就是拿到那个对象 用来解决对象的成员变量与方法内部变量的名称一样时，导致访问冲突问题的 123private Movie[] movies;public MovieOperator(Movie[] movies)&#123; this.movies = movies; 如果写成movies = movies 这时就会报错，让idea觉得你这是在该函数内部自己赋值给自己，显然不成立，如果加上this就会被识别为是Movie[ ] 的对象movies。 3、常用API(应用程序编程接口)(1)、String创建对象封装字符串数据的方式* 方式一: 123String name = &quot;小黑&quot;String schoolName = &quot;黑马程序员&quot; 方式二：调用String类的构造器初始化字符串对象 1234567public String() //创建一个空白字符串对象，不含有任何内容public String(String original) // 根据传入的字符串内容，来创建字符串对象public String(char[] chars)// 根据字符数组的内容，来创建字符串对象public String(byte[] bytes) //根据字节数组的内容，来创建字符串对象 (2)有关字符串的一些方法 1234567891011121314151617181920212223242526272829//查询字符串长度(字符个数)public int length()//获取某个索引位置处的字符返回public char charAt(int index) //将当前字符串转换成字符数组返回public char[] toCharArray()://判断当前字符串与另一个字符串的内容一样，一样返回truepublic boolean equals(object anobject) //判断当前字符串与另一个字符串的内容是否一样(忽略大小写)public boolean equalsIgnoreCase(String anotherString) //根据开始和结束索引进行截取，得到新的字符串(包前不包后)public String substring(int beginIndex, int endIndex) //从传入的索引处截取，截取到末尾，得到新的字符串返回public String substring(int beginIndex)//使用新值，将字符串中的旧值替换，得到新的字符串public String replace(CharSequence target,CharSequence replacement) ////判断字符串中是否包含了某个字符串public boolean contains(Charsequence s)//判断字符串是否以某个字符串内容开头，开头返回true，反之返回falsepublic boolean startsWith(String prefix)//判断字符串是否以某个字符串内容结尾，结尾返回true，反之返回falsepublic boolean startsWith(String prefix)//把字符串按照某个字符串内容分割，并返回字符串数组回来public String[] split(String regex)//indexOf用于获取数据在字符串中第一次出现的位置String s = &quot;world hello hello world hello&quot;s.indexOf(&quot;world&quot;);//lastIndexOf用于获取数据在字符串中最后一次出现的位置s.lastIndexOf(&quot;hello&quot;); （3）字符串进行比较有哪些需要注意的？ 1、字符串的比较使用==比较好吗?为什么?什么时候使用==? 不好，对于字符串对象的比较，&#x3D;&#x3D;比较的是地址，容易出业务bug 基本数据类型的变量或者值应该使用&#x3D;&#x3D;比较。 2、开发中比较字符串推荐使用什么方式比较?使用String提供的equals方法，它只关心字符串内容一样就返回true， 123方法名public boolean equals(object anobject)public boolean equalsIgnoreCase(String anotherstring) (4)随机产生验证码(使用字符串方式) 12345678910111213141516171819202122232425package com.itheima.StringController;import java.util.Random;//随机产生验证码public class StringDemo2 &#123; public static void main(String[] args) &#123; System.out.println(randomCode(4)); System.out.println(randomCode(5)); System.out.println(randomCode(6)); &#125; public static String randomCode(int tempCode)&#123; Random r = new Random(); String code = &quot;&quot;; String data =&quot;abcdefghijklmnopqrstuVWXyZABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;; //我们需要5位验证码调用for循环 for (int i = 0; i &lt; tempCode; i++) &#123; int j = r.nextInt(data.length()); //将字符交给code code += data.charAt(j); &#125; return code; &#125;&#125; (5)两种方式的区别 双引号给出的字符串对象，存在于堆内存中的常量池中，相同内容只会存储一份。 new 字符串对象，每new一次都会在堆内存中产生一个字符串对象。 2）字符串大小写转换12345String s =&quot;Hello,World&quot;//字符串变小写s.toLowerCase()//字符串变大写s.toUpperCase() 3）StringBuilder方法java提供的一种对字符串进行拼接，反转的快捷类 使用实例： 1234567891011StringBuilder s = new StringBuilder();//拼接字符串for (int i = 0; i &lt; 10; i++) &#123; s.append(i); &#125;System.out.println(s);//反转字符串s.reverse();//在字符串指定位置插入s.insert(1,&quot;abc&quot;);System.out.println(s.toString()); 2、ArrayList集合概述1.怎么学？ arrayList会提供创建容器对象的方式 会提供相应方法对容器进行操作 增 删 改 查 创建对象 &#x3D;&#x3D;&#x3D;&#x3D;&gt; 添加增删改查方法 &#x3D;&#x3D;&#x3D;&#x3D;&gt; 了解集合特点 2.ArrayList常用方法 构造器 ArrayList是用的最多、最常见的一种集合。 1234567//创建一个空的集合对象public ArrayList() //存储任意数据类型 ArrayList list = new ArrayList(); /** 也可以这么写 */ Array&lt;Object&gt; list = new ArrayList(); 常用方法名 1234567891011121314//将指定的元素添加到此集合的末尾public boolean add(E e) //在此集合中的指定位置插入指定的元素public void add(int index,E element) //返回指定索引处的元素public E get(int index) //返回集合中的元素的个数public int size() //删除指定索引处的元素，返回被删除的元素public E remove(int index) //删除指定的元素，返回删除是否成功public boolean remove(Object o) //修改指定索引处的元素，返回被修改的元素public E set(int index,E element) 3.从集合中遍历元素，并筛选出元素删除它，应该如何操作才能不出bug?方式一:每次删除一个数据后，索引-1。 方式二:从集合后面遍历然后删除，可以避免漏掉元素。 (1) 集合中常用的接口1.Collection接口(面对单一的数据处理) 常用子接口：List，Set，Queue List：按照 插入顺序保存数据，数据可以重复 具体实现类：ArrayList，LinkedList Set：集，无序保存，数据不能重复 具体实现类：HashSet(面对K-V键值对的数据处理) Queue：队列 具体实现类：ArrayBlockingQueue 1.Map接口 具体实现类：hashMap，HashTable （2）ArrayList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.itheima.List;import java.util.ArrayList;public class TestList &#123; public static void main(String[] args) &#123; //ArrayList:Array + List // TODO List:列表，清单 // 按照数据插入顺序进行存储 ArrayList list = new ArrayList(); ArrayList list1 = new ArrayList(); list1.add(&quot;1&quot;); list1.add(&quot;2&quot;); list1.add(&quot;3&quot;); //创建集合对象 //1.不需要传入参数，底层数组为空数组 //2.构造参数需要传递一个int类型的值，设置底层数组的长度 //3.构造参数需要传递一个Collection集合类型的值，用于将其他集合中的数据放置在当前集合中 // TODO 增加数据 // add方法添加数据时，只要将数据作为参数传递到add方法即可 // 添加数据时，如果集合中没有任何的数据，那么底层就会创建长度为10的数组 // add方法也可以传入两个参数，第一个是索引,第二个是添加数据的值 list.add(&quot;zhangsan&quot;); list.add(&quot;wangwu&quot;); list.add(&quot;xiaoli&quot;); list.add(1,&quot;zhaoliu&quot;); //在该集合中传入其他集合 list.addAll(list1); // 获取集合中的数据条数 System.out.println(list.size());//3 //获取指定位置的数据，传入的是索引 System.out.println(list.get(1));//wangwu //遍历集合中的数据 for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; //如果循环数据不关心数据的位置，采用特殊的for循环 for (Object obj : list)&#123; System.out.println(&quot;集合中的数据：&quot;+obj); &#125; // todo 修改数据 //将指定位置的数据进行修改set()注意，传递两个参数，第一个参数表示数据的位置，第二个表示修改后的值 Object oldVal = list.set(1, &quot;lisi&quot;); System.out.println(&quot;修改前的值：&quot;+oldVal); // todo 删除数据 //将指定位置的数据进行修改remove()注意，传递1个参数，一个参数表示数据的位置。 Object remove = list.remove(1); System.out.println(&quot;删除的值&quot;+remove); //清空集合的数据// list.clear(); //删除指定集合中的数据(比如上面新添加的list1)// list.removeAll(list1); //判断集合中是否存在某条数据,包含返回true不包含返回false System.out.println(list.contains(&quot;lisi&quot;)); //获取数据在索引中第一个的位置，数据不存在返回-1，存在返回数据所在位置的索引值 System.out.println(list.indexOf(&quot;lisi&quot;)); //获取最后出现的位置的索引值(集合中有多个zhangsan，但是返回的是最后一个zhangsan的索引值) list.lastIndexOf(&quot;lisi&quot;); //复制一个集合 Object clone = list.clone(); ArrayList list2 = (ArrayList)clone; //该集合和被复制的list集合额内容一致 System.out.println(list2); // TODO 打印集合对象 System.out.println(list); &#125;&#125; （3）LinkedListLinkedList &#x3D; Linked(链接) + List 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.itheima.List;import java.util.LinkedList;public class LinkedListTest &#123; public static void main(String[] args) &#123; //todo 集合--- Collection // LinkedList //构建集合对象 LinkedList linkedList = new LinkedList(); LinkedList linkedList1=new LinkedList(); //增加第一个数据 linkedList.add(&quot;zhangsan&quot;); linkedList.add(&quot;lisi&quot;); linkedList.add(&quot;wangwu&quot;); linkedList1.add(&quot;1&quot;); linkedList1.add(&quot;2&quot;); linkedList1.add(&quot;3&quot;); //添加一个集合 linkedList.addAll(linkedList1); //链表前面增加// linkedList.addFirst(&quot;lisi&quot;); //链表后面增加// linkedList.add(1,&quot;wangwu&quot;); //获取数据 //拿到第一个数据(开头数据) System.out.println(linkedList.getFirst()); //拿到第二个数据(结尾数据) System.out.println(linkedList.getLast()); //根据索引拿数据 System.out.println(linkedList.get(1));//lisi // todo 遍历数据 for (int i = 0; i &lt; linkedList.size(); i++) &#123; System.out.println(linkedList.get(i)); &#125; //todo 遍历数据(第二种) for (Object obj:linkedList)&#123; System.out.println(obj); &#125; //删除数据 linkedList.remove(&quot;lisi&quot;); //表示删除第一个 linkedList.remove(1); linkedList.remove(); //删除链表第一个元素 linkedList.removeFirst(); //删除链表最后一个元素 linkedList.removeLast(); //push相当于addFirst方法 linkedList.push(&quot;123&quot;); //pop()弹出元素 System.out.println(linkedList.poll()); //todo 打印集合的数据 System.out.println(linkedList); &#125;&#125; （4）泛型12345678910111213141516171819202122232425package com.itheima.List;import java.util.ArrayList;public class ListQuestion &#123; //todo 集合 public static void main(String[] args) &#123; //todo 泛型语法&lt;&gt;中放你要在集合中存储的数据类型 User user = new User(); //如果没有尖括号里面的内容，表示我在这个容器中可以存储任何类型的数据 MyContainer&lt;User&gt; myContainer = new MyContainer(); //会报错，因为我已经用尖括号限定了容器类类型// MyContainer.data = new Object(); &#125;&#125;// todo 容器类class MyContainer&lt;C&gt;&#123; public C data;&#125;class User&#123;&#125; （5）比较器1234567891011121314151617181920212223242526272829303132package com.itheima.List;import java.util.ArrayList;import java.util.Comparator;public class ListSort &#123; public static void main(String[] args) &#123; ArrayList list = new ArrayList(); list.add(1); list.add(2); list.add(3); //new一个比较类的对象 NumberComparator comparator = new NumberComparator(); //todo 集合中的数据进行比较 list.sort(comparator); System.out.println(list); &#125;&#125;//创建一个比较类，实现Comparator接口class NumberComparator implements Comparator&lt;Integer&gt;&#123; @Override public int compare(Integer o1, Integer o2) &#123; //todo 如果第一个数大于第二个数，返回结果为正数，表示升序排序// return o1 - o2; //todo 如果第一个数小于第二个数，返回结果为负数，表示升序降序 return o2 - o1; //todo 如果第一个数等于第二个数，返回结果为0。// return 0; &#125;&#125; （6）HashSet12345678910111213141516171819202122232425262728package com.itheima.List;import java.util.HashSet;public class HashSetTest &#123; public static void main(String[] args) &#123; //HashSet:Hash + Set //Hash：哈希算法，散列(无序) //ArrayList：数组 //LinkedList： HashSet hashSet = new HashSet(); //todo 增加数据 hashSet.add(&quot;lisi&quot;); hashSet.add(&quot;zhangsan&quot;); hashSet.add(&quot;wangwu&quot;); // todo 修改数据(先删除，在增加) hashSet.remove(&quot;zhangsan&quot;); hashSet.add(&quot;xiaoli&quot;); //todo 遍历数据 for (Object obj : hashSet)&#123; System.out.println(obj); &#125; // todo 转换成数组 Object[] objects = hashSet.toArray(); System.out.println(hashSet); &#125;&#125; 第二章1、标识符的命名规则123456789101112131415161718192021222324252627282930313233/ /T0D0标识符得命名规则//1．英文拉丁字母/ / wx , qqString username = &quot;zhangsan&quot;;String xingming = &quot;lisi&quot;;// 2．符号//@，#，%，$//3.标识符只能采用下划线和美元$符号，其他符号不能使用，称之为特殊符号//4.空格属于特殊符号，所以也不能作为标识符使用String _name = &quot;wangwu&quot;;String $name = &quot;wangwu&quot; ;String $na_me = &quot;wangwu&quot;;system.out.println(_name);system.out.println($name);system.out.println($na_me);//5.阿拉伯数据0到9可以作为标识符使用，但是不能开头 //数字如果在标识符得开头位置，那么会被识别为数字，而不是标识符，所以会发生错误//String 1name = &quot;zhangsan&quot;;String name1 = &quot;zhangsan&quot;;//6.标识符区分大小写String Public = &quot;zhaoliu&quot;;//7.驼峰命名法String userName = &quot;小李&quot;; 2、数据存储单位1.比特(bit位)：数据运算的最小存储单位。 2.字节(byte)：数据的最小存储单位。 字节和比特之间可以互相转换的，关系如下 ​ 1byte = 8bit 3、基础数据类型1.整数数据类型:byte，short，int，long分别是8位，16位，32位，64位 2.浮点类型：含有小数点的数据类型；float（单精度浮点类型），double（双进度浮点类型）。 单精度浮点类型，我们需要用F(f)来结尾如 1float f = 2.0f; 3.字符类型:使用符号标识文字内容 1char c = &quot;@&quot; 4.布尔类型：判断条件是否成立，成立取值true，不成立取值false 1boolean bln = true; 4、数据类型转换在java中范围小的数据可以直接转换为范围大的数据，但是范围大的数据不能转换成范围小的数据，如果非要大类型转小类型，那么我们应该使用小括号进行强制类型转换 123byte b =10;int i = s;byte i1 =(byte)i; 5、引用数据类型类、String、接口、数组、枚举、特殊类型值:null 6、运算符、表达式、算数运算符1.运算符就是参与数据运算的符号，Java定义，无法自行定义2.表达式就是采用运算符和数据连接在一起形成符合Java语法规则的指令代码3.算数运算符 二元运算符：两个元素参与运算的运算符 1 + 2 算术表达式 &#x3D; 元素1 二元运算符 元素2 (表达式是有结果的，就需要有类型，这里的类型是元素种类类型最大的那一种，最小使用的类型为int类型) 123456System.out.println(1 + 2) //3System.out.println(2 - 2) //0System.out.println(1 * 2) //2System.out.println(4 / 2) //2 (int,int) ==&gt;int结果类型取决于类型大的那个System.out.println(1.0 / 2) //0.5 (double,int) ==&gt;double,结果类型取决于类型大的那个System.out.println(5 % 2) //1(取余数，模运算) 一元运算符：一个元素参与的运算符(++，--) ++:本质是加1操作的简化版本，也成为自增运算符,注意，++i，表示i先自加1随后在进入下面的运算，而i++表示i先参加运算后再加1 --:本质是减1操作的简化版本，也成为自减运算符,注意，–i，表示i先自减少1随后在进入下面的运算，而i–表示i先参加运算后再减1 4.赋值运算符123456789101112131415161718192021public class OperatorDemo3 &#123; public static void main(String[] args) &#123; // TODO 赋值运算符 //等号就是赋值运算符，将右边表达式的结果赋值给等号左边变量 //赋值运算符要考虑类型的关系 String name = &quot;zhangsan&quot;; //TODO 复合赋值运算符：+= // 如果元素进行运算后重新赋值给自己，那么可以将运算和赋值的符号进行简化 // 复合赋值运算符进行运算时，数据类型不会发生变化 int i =0; i+=1;//相当于i = i+1 System.out.println(i); byte num1 = 10; //下面这种写法由于二元运算符最小类型为int会导致报错 //num1 = num1 + 20; //使用复合运算符就不会报错了，因为复合赋值运算符进行运算时，数据类型不会发生变化 num1 +=20; System.out.println(num1); &#125;&#125; 5.逻辑运算符12345678910111213141516171819202122232425262728293031public class OperatorDemo1 &#123; public static void main(String[] args) &#123; //掌握逻辑运算符的使用 //需求:要求手机必须满足大于等于6.95英寸，切内存大于等于8 double size = 9.8; int storage = 16 boolean rs = size &gt;= 6.95 &amp; storage &gt;=8;//逻辑与:一假即假，两个都成立才为true System.out.println(rs); //需求:要求手机要么满足大于等于6.95英寸，要么内存大于等于8 boolean rs2 = size &gt;= 10 &amp; storage &gt;=8;//逻辑或:一真即真，两个都是假才为false System.out.println(rs2); System.out.println(&quot;---------------------&quot;); //逻辑非:取反的意思 System.out.println(2&gt;1); System.out.println(!(2&gt;1)); System.out.println(&quot;---------------------&quot;); //逻辑异或:前后结果条件相同返回false，不同返回true System.out.println(true ^ true); System.out.println(false ^ true); System.out.println(&quot;---------------------&quot;); //短路与: 写法:&amp;&amp;,规则:左边为false，右边不执行 //短路或: 写法:|| 规则:左边为true，右边不执行 int i = 10; int j =20; System.out.println(i&gt;100 &amp;&amp; ++j&gt;99); System.out.println(&quot;---------------------&quot;); int m =10; int n =30; System.out.println(m&gt;3 || ++n &gt;40); &#125;&#125; 6.三元运算符1234567891011public class OperatorDemo6 &#123; public static void main(String[] args) &#123; // TODO 运算符 - 三元运算符 // 指三个元素参与运算的运算符 //基本语法结构：变量 = （条件表达式）？（任意表达式1）：（任意表达式2） // 当条件表达式的结果为ture则执行表达式1，反之执行表达式2 int i = 10 ; int k =(i == 5)? (i+10):(i+1); System.out.println(k); &#125;&#125; 7、流程控制1.顺序执行 按照代码顺序从前往后执行 2.分支执行 if……else…… if……elif……….elif……..else…….. switch(变量){ case1: ……. ; case2: ……… ;default: ………..;},switch分支判断也叫等值分支判断。 其中在switch分支中如果想要跳出某个case并结束分支执行，就在那个case块的内容最后加上break用来跳出 3.重复执行（循环）在Java中用于循环的语法有3个： 1）while：有条件循环 while(条件表达式){需要循环的代码} 2）do….while(先执行一次，在进行条件判断) 3）for for(初始化表达式 ; 条件表达式 ; 更新表达式;){ 循环体内容 } ​ 初始化表达式实际上是对条件表达式中用到的变量进行初始化，循环体内容执行完毕后，会重新进行条件判断，如果判断为ture则会继续执行循环体内容。 小练习:九层妖塔 请在控制台输出打印如下 代码如下: 1234567891011for(int i = 0;i&lt;9;i++)&#123;//完成打印但是打印出来的是全部对齐的，并未达到要求 //下面打印空格因为最后一行不用输出空格所以我们只打印8层就可以，按照规律每层打印的空格数=8-层号for(int j=0;j&lt;8-i;j++)&#123;System.out.print(&quot; &quot;);&#125; for(int j=0;j&lt;i*2+1;j++)&#123; System.out.print(&quot;*&quot;); &#125; System.out.println(&quot; &quot;);&#125; 第三章 面向对象1）什么是面向对象？所谓面向对象，其实就是分析问题时，以问题所涉及的是或者物为中心的分析方式 2）类和对象1.类 and 对象(先有类，再有对象)类表示归纳和整理；对象表示具体的事务。 在Java中我们用class表示类，通常类名首写字母大写。 基本语法结构： 1234567class 类名&#123;特征(属性)功能(方法)&#125; 2.创建对象的语法结构对象：类的实例化(具象化) 12new 类名();//小括号不能丢//new是关键字，表示创建一个具体的对象，使用一次，创建一次，每次都是全新的对象。 对象是将内存地址赋值给了变量，所以变量其实引用了内存中的对象，所以称之为引用变量，而变量的类型称之为引用数据类型。 特殊的对象：空对象(null)，没有引用的对象，称之为空对象，关键字对象，所有引用对象的类型默认取值为null 3.属性所谓属性，就是类的对象的相同特征 声明：属性类型 属性名称 &#x3D; 属性值 如果在声明属性的同时进行了初始化赋值，那么所有对象的属性就完全相同。如果希望每个对象的属性不一致，那么我们可以只声明即可，那么属性会在构造对象的时候默认初始化，而默认初始化的值取决于属性的类型 byte，short，int，long &#x3D;&#x3D;&gt; 0 float,double &#x3D;&#x3D;&gt; 0.0 boolean flg &#x3D;&#x3D;&gt; false char &#x3D;&#x3D;&gt;空字符 引用数据类型 &#x3D;&#x3D;&gt; null 1234//初始化并赋值zhansanString name = &quot;zhansan&quot;;//只声明String name; 4.静态(static)针对于具体对象的属性称之为对象属性，成员属性，实例属性 针对于具体对象的方法称之为对象方法，成员方法，实例方法 把和对象无关，只和类相关的称之为静态， 和类相关的方法称为静态方法 和类相关的属性称为静态属性 静态语法：就是在属性和方法前面增加static关键字 在Java语法中： 成员方法可以访问静态属性和静态方法 静态方法不可以访问成员属性和静态方法 在访问静态类的属性时，可以用静态类名.属性名直接访问。 静态代码块当类的信息加载完成后，会自动调用静态代码块，可以完成静态属性的初始化功能 123static&#123; //代码块内容&#125; 在我们构建对象时，代码块会进行初始化，但不是静态的 1234&#123;//代码块内容&#125; 3）方法1.方法的声明：1【方法返回值类型】【void】 方法名(参数)&#123;功能代码&#125; 方法中void是空的意思，意味着没有结果。如果在方法中的结果需要返回，则确定返回值的类型利用return关键字来返回结果。没有返回值就用void 123456//返回的结果是布尔类型的所以用Booleanboolean register()&#123;System.out.println(&quot;注册成功&quot;) //返回结果return true;&#125; 2.方法传参(方法参数)1.语法:方法名(参数类型 参数名称) 方法名(参数类型1 参数名称1,参数类型2 参数名称2,参数类型3 参数名称3) { }进行多个参数的传递。 2.传参注意事项： 参数个数要匹配 参数类型要匹配 参数顺序要匹配 当参数个数不确定时，我们可以使用特殊语法来声明：可变参数 12参数类型... 参数名称方法名(String ... name)&#123; &#125; 当参数列表中还有别的参数时，我们需要将可变参数声明在参数列表最后。 基本数据类型:传数值 引用数据类型:传引用地址 1234567891011121314//main方法中User user = new User();String name =&quot;zhangsan&quot;； //传递参数user.sayHello(name);class User&#123;void sayHello(String name)&#123; //使用参数System.out.println(&quot;hello&quot;+ name); &#125;&#125; 小插曲Java中的三块内存区域 栈：存放的是(方法，变量) 堆：存放(对象) 元空间：存放类的信息，也称之为方法区 4）包-包中容纳类 语法：package 包完整路径; 包完整路径用·隔开 包名一般全是小写字母 包的导入:我们用import语法来导入包。 import使用在package后class前 12345package xxx.xxx.Xxxx;import xxxxxx;public class xxxx&#123;&#125; 5）面向对象——构建对象——构造方法12//创建了一个User类的对象userUser user = new User(); 上面这个过程实际上使用了构造方法来构建的对象下面来介绍一个构造方法 构造方法：专门用于构建对象 如果类中没有任何构造方法，那么**JVM(java虚拟机)**会自动添加一个公共的无参的构造方法。基本语法如下 123类名 ()&#123;&#125; 注意点: 构造方法也是方法，但是没有void关键字 方法名和类名完全相同 如果类中没有构造方法&#x3D;&#x3D;&#x3D;&gt;JVM会提供默认构造方法 如果类中有构造方法&#x3D;&#x3D;&#x3D;&gt;JVM不会提供默认构造方法 构造方法也是方法，可以传递参数，但是一般传递参数的目的是用于对象属性的赋值 6）面向对象——继承关键字：Extends 基本语法： 1class 子类 extends 父类 &#123; &#125; 类存在父子关系：子类可以直接获取到父类的成员属性和成员方法 类的继承只能是单继承，一个类只能有一个父类，不能存在多个父类 在继承中，如果父类和子类含有相同的属性，那么可以采用特殊的关键字进行区分:super &amp; this. super：表示上一级 this：表示当前 继承中的方法问题构造方法(完成内存控件属性的初始化操作): 父类对象是在子类对象前创建完成的，创建子类对象前，会先创建父类对象 如果父类提供了有参构造方法，那么JVM就不会提供默认的构造方法，那么子类应该调用super方法(带入参数)构建父类对象。 7）面向对象——多态所谓多态，其实就是一个对象在不同场景下表现出来的不同状态和形态。 多态语法其实就是对对象的使用场景进行了约束。 以父类声明的子类对象，只能使用父类中的方法，如果子类对象想使用子类方法，需要用子类来声明子类对象 8）面向对象——方法重载相同的方法：在一个类中，相同方法是指方法名，参数列表相同，和返回值类型无关的方法。 方法重载： 在Java中，如果方法名称相同，但是参数列表(个数，顺序，类型)不相同，会认为是不同的方法，只是名称一样，我们称之为方法的重载。 在构造方法中，想要调用其他构造方法，那么需要使用关键字:this 123456789101112131415161718192021222324package com.itheima.面相对象综合实例;public class ClassObject2 &#123; public static void main(String[] args) &#123; //我们只需要调用无参构造方法即可 //创建对象时会调用构造函数 User user = new User(); &#125;&#125;class User&#123; User()&#123; //使用this关键字传入参数调用下面构造方法 this(&quot;zhansan&quot;); &#125; User(String name)&#123; //接收name并用this关键字调用下面方法 this(&quot;zhangsan&quot;,&quot;男&quot;); &#125; User(String name, String sex)&#123; System.out.println(&quot;名字是:&quot;+name+&quot;,&quot;+sex); &#125;&#125; 打印如下: 1名字是:zhangsan,男 结论基本数据类型： 基本数据类型匹配方法时，可以在数值不变的情况下扩大数据的精度。 byte数据类型无法和char类型做转换，char没有负数，而byte存在着负数 引用数据类型： 引用数据类型无法扩大数据精度，但是引用数据类型匹配方法时，会往object类去找。 比如A类是B类的父类，那么当调用的方法在B类中不符合时，就去A类中寻找，如果A类中没有就去A类的父类object中寻找 9）面向对象——方法重写定义：在父类中的方法其实主要体现通用性(可以被多个子类继承，可以被多个子类使用自身方法)，无法在某一个特定情况去使用这个方法。如果子类对象需要再某个特定业务逻辑中使用该父类的方法，那么就需要对父类中的方法进行重写，这个操作成为重写。 请注意： 子类中的方法不会覆盖父类的方法，只是父类当前方法不适用这个场景 如果想在当前类调用父类方法可以使用super关键字进行调用 当子类的方法中的返回值类型，参数列表，方法名称都和父类相同时才可以进行重写 1234567891011121314151617181920212223package com.itheima.面相对象综合实例;public class RewriteMethods &#123; public static void main(String[] args) &#123; Child child = new Child(); Parent parent =new Parent(); System.out.println(child.sum());//40 System.out.println(parent.sum());//20 &#125;&#125; class Parent&#123; int i = 10; int sum()&#123; return i+10; &#125;&#125;class Child extends Parent&#123; int i =20; int sum()&#123; return i+20; &#125;&#125; 通过以上例子，总结四点： 一个对象能使用什么方法，取决于引用变量的类型 一个对象能使用什么属性，取决于引用变量的类型 一个对象的方法具体使用(这个方法怎么去执行，逻辑是什么，直接使用还是间接使用)，需要看具体对象 一个对象的属性具体的使用是不需要看具体的对象的，属性在哪里声明就在哪里使用 10）面向对象——递归定义：方法调用自身，成为递归方法 递归最经典的案例——求n以内的奇数和 123456789101112131415161718package com.itheima.面相对象综合实例;public class RewriteMethods &#123; public static void main(String[] args) &#123; int result = getSum(20); System.out.println(result); &#125; static int getSum(int n) &#123;//三元运算符，当n是偶数时会执行(n－1)，当n是奇数时直接用n n = n % 2 == 0 ? n - 1 : n; if (n == 1) &#123; return 1; &#125; else &#123; return n + getSum(n - 2); &#125; &#125;&#125; 递归——阶乘 一个大于1的数的阶乘就是这个数乘以这个数减一的阶乘 123456789101112131415package com.itheima.面相对象综合实例;public class RewriteMethods &#123; public static void main(String[] args) &#123; int result1 = jieCheng(5); System.out.println(result1); &#125; //求n以内的数的阶乘 public static int jieCheng(int n)&#123; if(n&lt;= 1)&#123; return 1; &#125;else &#123; return n * jieCheng(n-1); &#125; &#125;&#125; 注意： 递归应该有跳出的逻辑 调用自身时，传入的参数应该是有规律的 11）面向对象——访问权限 public：公共的，访问权限修饰符 ​ 在Java中，公共类只有一个，且名称和源码文件相同 ​ main方法：main方法是有JVM调用的，JVM可以任意调用，可以忽略权限问题 Java中的访问权限有四种： private：私有的，同一个类中可以使用，别的类，其他地方无法使用 (default)：默认权限，当不设定任何权限时，JVM会默认提供权限，包(路径)权限 protected：受保护的权限，子类可以访问 public：公共的，任意使用。 12）面向对象——内部类——外部类外部类：在源码中直接声明的类 内部类：类中声明的类 内部类在进行定义的时候，可以当成外部类的属性使用即可，但是在使用的时候，因为内部类被看做了外部类的属性，所以需要定义外部类对象进行使用。 1234//内部类定义class InnerClass&#123;&#125; 举个例子： 1234567891011121314151617181920212223242526package com.itheima.面相对象综合实例;public class InerClass &#123; public static void main(String[] args) &#123; //创建外部类对象 OuterClass outerClass = new OuterClass(); //通过外部类对象来创建内部类对象 OuterClass.InnerClass1 innerClass1 = outerClass.new InnerClass1(); //调用各自的方法 outerClass.printSome(); innerClass1.printSome(); &#125;&#125;class OuterClass&#123; public void printSome()&#123; System.out.println(&quot;我是外部类方法&quot;); &#125; class InnerClass1 &#123; public void printSome()&#123; System.out.println(&quot;我是内部类方法&quot;); &#125; &#125;&#125; 13）面向对象——final关键字 final可以修饰变量：变量的值一旦初始化不允许被修改 final可以修饰属性：但是JVM不会对自动对属性进行初始化，需要手动初始化，并且属性值不可以修改 final可以修饰方法：final修饰的方法不可以被子类重写 final可以修饰类：当final修饰一个类时，被修饰的类不可以有子类 final不可以修饰构造方法。 final可以修饰方法参数：一旦修饰，该参数无法修改。 一般将final修饰的变量称之为常量，或者叫不可变量。 14）面向对象——抽象—Abstract 抽象类：不完整的类就是抽象类，抽象类不能够构造对象 1234//语法abstract class 类名&#123;&#125; 抽象方法：只有声明方法，而不去写方法里面的逻辑。 12//语法abstract 返回值类型 方法名(参数); 在一个类中，有抽象方法就是抽象类，反之，如果有抽象类，他的方法不一定是抽象方法。 抽象类无法直接构造对象，但是可以通过子类间接构造对象。 如果抽象类中含有抽象方法，那么子类继承抽象类，需要重写抽象方法，将方法补充完整。 abstract关键字不能和final关键字一起使用 15）面向对象——接口(interface)接口：可以简单理解为规则。 基本语法： 12//接口语法interface 接口名称&#123; 接口属性，接口规则&#125; 接口其实是抽象的 规则的属性必须为固定值，而且不能修改。 属性和行为的访问权限是公共的。 属性是静态的。 行为是抽象的。 接口可以继承其他接口 类的对象需要遵循接口，在Java中其实就是实现(implements)接口。而且类可以实现多个接口 接口的一段演示代码 12345678910111213141516171819202122232425262728293031323334353637383940public class InterfaceTest &#123; public static void main(String[] args) &#123; Computer c = new Computer(); Light light = new Light(); //相当于把电灯插到usb1口上 c.usb1 = light; //把电灯插到usb2口上 c.usb2 = light; //电脑给上面两个供电(调用givePower方法) c.givePower(); &#125;&#125;interface rule &#123; &#125;interface PowerOut extends rule&#123; public void givePower();&#125;interface PowerIn extends rule&#123; public void receivePower();&#125;class Computer implements PowerOut&#123; public PowerIn usb1; public PowerIn usb2; public void givePower()&#123; System.out.println(&quot;电脑提供电源&quot;); usb1.receivePower(); usb2.receivePower(); &#125;&#125;class Light implements PowerIn&#123; public void receivePower()&#123; System.out.println(&quot;电灯接受电源&quot;); &#125;&#125; 16）面向对象——枚举(Enum)定义：枚举是一个特殊的类，其中包含了一组特定的对象，一般使用大写的的字母，这些对象不会发生改变。 123enum City&#123; BEIJING,SHANGHAI&#125; 枚举使用enum关键字使用。 枚举类的对象一般放在前面，如果还要写入别的语法那么应该用分号与后面的语法隔开。 枚举类不能创建对象，只能在内部使用 举个例子 1234567891011121314151617181920public class EnumTest &#123; public static void main(String[] args) &#123; System.out.print(City.SHANGHAI.name); System.out.println(City.SHANGHAI.code); System.out.print(City.BEIJING.name); System.out.println(City.BEIJING.code); &#125;&#125;enum City&#123; //相当于new一个对象,JVM完成 BEIJING(&quot;北京&quot;,1001),SHANGHAI(&quot;上海&quot;,1002); City(String name, int code)&#123; this.name = name; this.code = code; &#125; public String name; public int code;&#125; 17）面向对象——匿名类在某些场合下，类的名字不重要了，我们只是想使用类中的方法或功能，那么这个时候就需要用到特殊的语法：匿名类。 定义：没有名字的类，被称为匿名类 举个例子 1234567891011121314151617181920212223242526272829public class NoNameClass &#123; public static void main(String[] args) &#123; //创建了一个SayHello的对象me SayHello me = new SayHello(); //下面这种写法不需要再额外创建张三和李四的类，也就是我们创建了一个没有名字的类new person()&#123;&#125; me.sayHelloToPeople(new Person() &#123; //重写抽象方法具体化 public String name()&#123; return &quot;张三&quot;; &#125; &#125;); me.sayHelloToPeople(new Person() &#123; public String name()&#123; return &quot;李四&quot;; &#125; &#125;); &#125;&#125;abstract class Person&#123; //有抽象方法所以是抽象类 public abstract String name();&#125;class SayHello &#123; public void sayHelloToPeople(Person person) &#123; System.out.println(&quot;hello&quot; + person.name()); &#125;&#125; 接口也可以 12345678910111213//只关心你是怎么飞的，并没有考虑你是什么类，所以这里用匿名类。 new Fly() &#123; public void fly() &#123; System.out.println(&quot;使用飞行器飞行&quot;); &#125; &#125;.fly(); &#125;&#125;//接口是抽象的interface Fly&#123; public void fly();&#125; 18）面向对象——Bean规范 类要求必须含有无参的，公共的构造方法 属性必须私有化，然后提供公共的get，set方法 例子 1234567891011121314151617181920212223242526272829public class Movie &#123; private int id; private String name; private double price; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; &#125; 19）面向对象——作用域例子 12345678910111213141516171819202122package com.itheima.面相对象综合实例;public class ZuoYongYu &#123; public static void main(String[] args) &#123; User2 user2 = new User2(); user2.test(); &#125;&#125;class Person2&#123; &#125;class User2 extends Person2&#123; String name = &quot;lisi&quot;; public void test()&#123; //如果属性和(局部)变量名称相同，访问时不加修饰符，那么优先访问变量 String name = &quot;wangwu&quot;;//启动打印的是wangwu，如果注释掉这一行，那么打印的将会是lisi System.out.println(name); &#125;&#125; 第四章 常见类和对象1）常见类和对象——ObjectObject类的包路径：java.lang.Object Object对象的常用方法： 1234567891011121314151617181920212223242526272829303132333435package com.itheima.常见类和对象;public class ObjectClass &#123; public static void main(String[] args) &#123; Object obj = new Person(); //object对象的常用方法 // TODO toString()，将对象转换成字符串 String s = obj.toString(); System.out.println(s); // TODO 获取对象的内存地址 int i = obj.hashCode(); System.out.println(i); // TODO 判断两个对象是否相等，如果相等返回true，不相等返回flase // equals方法比较对象时，默认比较的是内存地址 Person person = new Person(); boolean equals1 = obj.equals(person); boolean equals2 = obj.equals(obj); System.out.println(equals1);//false System.out.println(equals2);//true //TODO getClass获取对象的类型信息 Class&lt;?&gt; currentClassName = obj.getClass(); System.out.println(currentClassName.getSimpleName()); &#125;&#125;class Person&#123;&#125;class user extends Person&#123;&#125; 2）常见类和对象——数组在Java中数组的声明方式：类型[] 变量名； 数组的创建：new 类型[容量]; 123456789101112131415//数组的声明String[] names;//数组的创建(创建了一个存储3个数据的names数组)String[] names = new String[3]//给数组赋值names[0] = &quot;lisi&quot;;names[1] = &quot;wangwu&quot;;//数组的访问System.out.println(names[0]);//打印lisiSystem.out.println(names[0]);//打印wangwu//也可以用循环访问数组for(int i;i&lt;names.length;i++)&#123; String j = names[i]; System.out.println(j);&#125;//循环执行完打印的是lisi，wangwu 如果需要一次创建多个对象可以用数组来完成 1234567//创建一个对象数组userUsers[] users = new Users[4];//利用for循环来生成该数组的对象for(int i ; i&lt;users.length;i++)&#123; //创建对象 users[i] = new Users();&#125; 3）常见类和对象——二维数组二维数组的定义 123456789//二维数组(可以简单理解为3X3的表格)String[][] names = new String[3][3];//二维数组的遍历for(int row= 0 ;row&lt;3;i++)&#123; for(int col =0; col &lt; 3; j++)&#123; System.out.print(names[row][col]); &#125; System.out.println(&quot; &quot;);&#125; 数组——应用冒泡排序*1234567891011121314151617181920212223package com.itheima.常见类和对象;public class MaoPaoPaiXu &#123; // TODO 将一个数组的最大的数放在数组最后面 public static void main(String[] args) &#123; int[] nums = &#123;1,4,3,5，2&#125;; //注意不能索引到最后一个数，因为最后一个数的下一位没有数据 //左边和右边比较，我们先找出最大的数，让他放在数组最后一个元素位置 for(int i = 0;i&lt; nums.length-1;i++)&#123; int num1 =nums[i]; int num2 =nums[i+1]; if(num1&gt;num2)&#123; nums[i] = num2; nums[i+1] = num1; &#125; &#125; for (int num : nums) &#123; //打印结果为1,3,2,4,5 System.out.println(num); &#125; &#125; &#125; 上面这个只是找出了我们的最大的数放到了数组最后面，那么我们的冒泡排序的结果应该1,2,3,4,5所以稍加改动如下: 解析：那么在上面的基础上，我们每次把最大数放在后面不就可以了吗？也就是说第一次比较5个数，那么5最大放在后面，第二次比较4个数一定是4最大，我们把四放在四个数的最后面。依次类推，不就完成了吗？ 123456789101112131415161718192021222324252627//代码逻辑(冒泡排序)package com.itheima.常见类和对象;public class ErWeiShuZu &#123; // TODO 将一个数组的最大的数放在数组最后面 public static void main(String[] args) &#123; int[] nums = &#123;1,4,3,5，2&#125;; //注意不能索引到最后一个数，因为最后一个数的下一位没有数据 //左边和右边比较，我们先找出最大的数，让他放在数组最后一个元素位置 for (int i = 0; i &lt; nums.length; i++) &#123; //当i=0时，我们下面的循环就找5个数的大小，等于1就找4个数的大小..... for (int j = 0; j &lt; nums.length - i - 1; j++) &#123; int num1 = nums[j]; int num2 = nums[j + 1]; if (num1 &gt; num2) &#123; nums[j] = num2; nums[j + 1] = num1; &#125; &#125; &#125; for (int num : nums) &#123; System.out.println(num); &#125; &#125;&#125; 选择排序*12345678910111213141516171819202122232425 //选择排序int[] nums = &#123;1,4,3,5，2&#125;;//第一步：找到最大值的索引 for (int j = 0; j &lt; nums.length; j++) &#123; //将最大值索引定为0，因为0已经被用了所以下面的循环从1开始 int maxIndex = 0; for (int i = 1; i &lt; nums.length-j; i++) &#123; int num1 = nums[i];//4 3 2 5 int num2 =nums[maxIndex];//1 4 4 4 if (num1&gt;num2)&#123; //循环完成后我们的最大值索引就被找到了 maxIndex = i; &#125; &#125; //把最后一个数和我们的最大值索引对应的数进行交换就完成了将最大的数放在数组最后面 int num3 = nums[nums.length-j-1]; int num4 = nums[maxIndex]; nums[nums.length-j-1] = num4; nums[maxIndex] = num3; &#125;for (int num : nums) &#123; //打印的结果为1，2，3，4，5 System.out.println(num); &#125; 二分查找法* 前提：数据有序。 解释：二分查找法，又称折半查找（Binary Search），是一种在有序数组中高效查找特定元素的算法。其核心思想是通过将待查找区间反复减半来逼近目标值，直至找到目标或者确定目标不存在于数组中。以下是二分查找的基本步骤： 初始化: 确定查找区间的初始边界，通常是整个数组的开始索引（设为left）和结束索引（设为right），或者说是数组的第一个元素和最后一个元素的索引。 计算中间索引: 在每一轮查找中，计算当前查找区间中间元素的索引 mid = (left + right) / 2（实际应用中为防止整数溢出，通常写作 mid = left + (right - left) / 2）。 比较与分支: 如果数组中间元素array[mid]正好等于目标值，查找成功，返回中间元素的索引mid。 如果array[mid]小于目标值，则说明目标值位于中间元素右侧的子区间，因此更新查找区间为left = mid + 1。 如果array[mid]大于目标值，则目标值位于中间元素左侧的子区间，更新查找区间为right = mid - 1。 重复步骤2和3，直到left &gt; right，此时说明目标值不在数组中，查找失败。 二分查找的时间复杂度为O(log n)，其中n是数组中的元素数量。这是因为每次操作都将查找范围减半，因此大大减少了需要检查的元素数量，尤其是在处理大数据集时，这种算法的效率优势更为明显。但需要注意的是，二分查找的前提是数组必须是有序的，且通常适用于静态数据结构，因为对数组的插入和删除操作可能会破坏其有序性，从而增加维护成本。 1234567891011121314151617181920212223242526272829package com.itheima.常见类和对象;//演示的是二分法查找，前提是必须数组有序public class SelectPaiXu &#123; public static void main(String[] args) &#123; int nums[]=&#123;1,2,3,4,5,6,7&#125;; //定义查找的目标数 int targetNumber = 5; //定义开始的索引 int startIndex = 0; //定义中间值索引 int middle = 0; //定义结束索引 int endIndex = nums.length - 1; //查找中间值索引 while (startIndex &lt;=endIndex )&#123; middle= (startIndex+endIndex) / 2; if(nums[middle] &gt; targetNumber)&#123; endIndex = middle -1; &#125;else if(nums[middle]&lt;targetNumber)&#123; startIndex= middle+1; &#125;else &#123; break; &#125; &#125; //打印中间值索引 System.out.println(&quot;数据的位置是：&quot;+middle); &#125;&#125; 4）常见类和对象——包装类12345678Byte b = null;Short s = null;Integer i = null;Long lon = null;Float f = null;Double d = null;Character c = null;Boolean bln = null; 将基本数据类型转换为包装类12345678910111213141516package com.itheima.常见类和对象;public class BaoZhuangLei &#123; public static void main(String[] args) &#123; int i =1; //将基本数据类型转换为包装类型 Integer i1 = Integer.valueOf(i); //也可以写成,这个过程称为自动装箱 Integer i2 =i; //自动拆箱 int j = i1.intValue(); //也可以写成 int j1 = i1; &#125;&#125; 5）常见类和对象——日期和日历日期类: 1234567891011121314151617181920212223242526272829package com.itheima.常见类和对象;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class DateTest &#123; public static void main(String[] args) throws ParseException &#123; //Date :日期类 //Calendar :日历类 Date d = new Date(); System.out.println(d);// Java格式化日期格式: //y(Y)-&gt;年-&gt; yyyy //m(M)-&gt;MM:月份，mm:分钟 //d(D)-&gt;dd :一个月中的日期，D:一年中的日期 //h(H)-&gt;h:12进制，HH:24进制 //s(S)-&gt;s :秒,S:亳秘 //Date -&gt;String SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); String dateFormatString =sdf.format(d); System.out.println(dateFormatString); //string -&gt;Date String dateString=&quot;2022-06-01&quot;; Date parseDate = sdf.parse(dateString); System.out.println(parseDate); &#125;&#125; 日历类： 123456789//拿到日历的对象Calendar instance =Calendar.getInstance();//打印日历中的各种属性System.out.println(instance.get(Calendar.YEAR)); System.out.println(instance.get(Calendar.MONTH));System.out.println(instance.get(Calendar.DATE));//在日历中找到当前时间instance.setTime(new Date());instance.add(Calendar.YEAR,1); 6）常见类和对象——工具类 工具类不应该创建对象才能使用，也就意味着，可以直接使用类中的属性和方法，一般都声明为静态的。 工具类对外提供的属性和方法都应该是公共的。 为了使开发者方便，应该尽量提供丰富的方法和属性。 第五章 异常Java中的异常分为两大类： 可以通过代码恢复正常逻辑执行的异常，称之为运行期异常：RuntimeException 不可以通过代码恢复正常执行逻辑的异常，称之为编译异常： Exception 异常处理的语法： try：尝试(放的是可能会出现问题的代码) catch：捕捉，捕捉多个异常时，优先选择小的异常，然后将其抛出 finally：最终 12345678910try&#123; //可能会出现异常的代码 //如果出现异常那么JVM会将异常进行封装，形成一个具体的异常类然后将这个异常抛出&#125;catch(抛出的异常对象 对象引用)&#123; //异常的解决方案&#125;catch()&#123;&#125;finally()&#123; //最 终要执行的逻辑(不论异常处没处理)&#125; 异常的常见类型： 1234567891011121314151617// TODO 异常//1.除数为0的算术异常:java.lang.ArithmeticException//运行期异常int i = 0;if(i!=0)&#123; int j= 10 /i;&#125;//2:空指针异常:java.lang.NullPointerException，调用了一个成员对象或成员方法为空(null)对象的属性或方法时，就会发生异常User3 user = null;System.out.println(user.tostring());//3:索引越界，针对数组，字符串索引越界，针对字符串class User3 &#123; &#125; 如果方法中可能会出现问题，那么需要提前声明，告诉其他人，我的方法可能会出现问题。这时，我们需要使用throws关键字 12345678910111213public static void main(String args[]) throws ArithmeticException&#123; User user = new User(); int i =10; int j =0; user.test(i,j);&#125;class User8public void test(int i,int j) throws ArithmeticException &#123;System.out.println(i/j); &#125; 那么在运行期的异常，他不会抱任何问题，因为只要你的逻辑对了，代码就能继续运行，那么我们该如何让他出现提示，需要解决异常呢？下面这种方法，我们手动抛出异常对象，但是使用的是throw关键字，然后new出异常对象 1234567891011121314151617public static void main(String args[]) throws Exception&#123; User user = new User(); int i =10; int j =0; user.test(i,j);&#125;class User8&#123; public void test(int i,int j) throws Exception &#123; try&#123; System.out.println(i/j); &#125;catch(ArithmeticException e) //这里演示手动抛出异常 throw new Exception(); &#125; &#125; （1）自定义异常看代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.itheima.Exception;public class ZiDingYiException &#123; public static void main(String[] args) throws Exception &#123; String username = &quot;admin&quot;; String password =&quot;admin&quot;; //对异常进行处理 try &#123; //可能出现异常的代码 loginSystem(username,password); &#125;catch (AccountException e)&#123; System.out.println(&quot;账号输入有误，请重新输入&quot;); &#125;catch (PasswordException e)&#123; System.out.println(&quot;密码输入有误，请重新输入&quot;); &#125; &#125; //如果下面是运行期异常(RuntimeException)这里可以不用抛出异常 //如果下面是编译期异常(Exception)，则需抛出异常 public static void loginSystem(String username,String password) throws AccountException,PasswordException&#123; if(!&quot;admin&quot;.equals(username))&#123; //创建异常对象 throw new AccountException(&quot;用户名不正确&quot;); &#125; if(!&quot;admin&quot;.equals(password))&#123; throw new PasswordException(&quot;密码不正确&quot;); &#125; System.out.println(&quot;登录成功&quot;); &#125;&#125;//账户异常class AccountException extends loginException&#123; public AccountException(String message) &#123; // 调用父类里面的方法，传入message参数，详细可以在代码中ctrl+左键点击查看 super(message); &#125;&#125;//密码异常class PasswordException extends loginException&#123; public PasswordException(String message)&#123; super(message); &#125;&#125;//自定义异常，如果这里继承运行期异常(RuntimeException)，那么上面就不需要抛出，如果是编译期异常(Exception),责需要抛出异常class loginException extends RuntimeException&#123; public loginException(String message)&#123; super(message); &#125;&#125; 第六章 Java中遇到的各种问题(1)Mybatis与java​ 在Mybatis和java联合编写xml文件时，有关Mapper.xml（编写SQL的）文件中，增删改查标签中，使用parameterType属性指定传递参数类，resultType属性指定返回结果类型，resultMap标签完成当数据库表字段和Java实体类属性名或类型不一致时的手动映射，另外，SQL文中，where条件中只有一个参数时，推荐使用基本类型（int，short，char，byte，float，double，long，boolean）+String，当有多个参数时，使用Java实体类，接下来，我们来讲讲具体的用法。来看示例： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--上面是文件头，下面是这个xml文件对应的mapper文件的路径--&gt;&lt;mapper namespace=&quot;com.ruoyi.publicController.mapper.proDetailMapper&quot;&gt; &lt;resultMap id=&quot;proDetailsResult&quot; type=&quot;proSelectDetails&quot;&gt; &lt;result property=&quot;proName&quot; column=&quot;pro_name&quot;/&gt; &lt;result property=&quot;profounder&quot; column=&quot;user_name&quot;/&gt; &lt;result property=&quot;proTrack&quot; column=&quot;pro_track&quot;/&gt; &lt;result property=&quot;proScore&quot; column=&quot;pro_score&quot;/&gt; &lt;/resultMap&gt; &lt;resultMap id=&quot;countResult&quot; type=&quot;proSelectDetails&quot;&gt; &lt;result property=&quot;countOne&quot; column=&quot;countOne&quot;/&gt; &lt;result property=&quot;countTwo&quot; column=&quot;countTwo&quot;/&gt; &lt;/resultMap&gt; &lt;!--查询总表所有项目信息--&gt; &lt;select id=&quot;selectAllInfo&quot; resultMap=&quot;proDetailsResult&quot; resultType=&quot;proSelectDetails&quot;&gt; &lt;include refid=&quot;selectProDetailsVo&quot;/&gt; &lt;/select&gt; &lt;sql id=&quot;selectProDetailsVo&quot;&gt; SELECT DISTINCT pro_details3.pro_id, pro_name, pro_details3.pro_score, user_name, pro_track FROM pro_details3 INNER JOIN judges_score ON judges_score.pro_id = pro_details3.pro_id INNER JOIN pro_coreteam ON pro_details3.pro_id = pro_coreteam.pro_id INNER JOIN sys_user ON sys_user.user_id = pro_coreteam.student_id &lt;/sql&gt; &lt;!--根据项目赛道查询项目信息--&gt; &lt;select id=&quot;selectProDetailsByProTrack&quot; resultMap=&quot;proDetailsResult&quot; resultType=&quot;proSelectDetails&quot;&gt; &lt;include refid=&quot;selectProDetailsVo&quot;/&gt; where pro_track = #&#123;proTrack&#125; &lt;/select&gt; 1.parameterType定义在增删改查标签中的属性，指定SQL文中where条件的参数类型，可以是基本数据类型（8个）或String或者对象类型例如，根据id查询name，如果数据库中定义的字段id是int类型，就可以指定parameterType的属性值是int，可以参看下边的代码。 1&lt; select id=&quot;queryPersonNameById&quot; parameterType=&quot;int&quot; resultType=&quot;String&quot;&gt;&lt;/select&gt; 2.resultType也是定义在增删改查标签中的属性，用于指定查询结果或增删改执行结果的类型，同样可以是基本数据类型+String+对象类型，这里需要注意的是，当查询结果是多条时，无需写List，MyBatis底层会自动为我们生成List&lt;数据类型&gt;，我们只需指定类型即可。同样是上边的例子，根据id查询name，name在数据库中是varchar类型，resultType就指定成String类型，类型不区分大小写，尽量保持和Java一致，使用大写。 1&lt; select id=&quot;queryPersonNameById&quot; parameterType=&quot;int&quot; resultType=&quot;String&quot;&gt;&lt;/select&gt; 3.resultMap当实体类的属性名和数据库表字段名或类型不一致时使用例如，Person表中，定义的字段是id和nameJava实体类中，定义的是pid和pname，这种情况下，使用resultMap手动完成数据库和Java实体类属性的映射。它是单独的&lt; resultMap&gt;标签，定义id(该属性是下面要用到的resultMap标签对应的值)，type（该属性指定了结果应该映射到的Java类的完全限定名或别名。）通常使用在查询标签中例如下边的代码id标签完成数据库主键的映射result标签完成数据库非主键字段的映射property属性指定java实体类中的属性名，column是数据库字段名 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;xxx.xxx.mapper.PersonMapper&quot;&gt; &lt;resultMap type=&quot;person&quot; id=&quot;personMapping&quot;&gt; &lt;id property=&quot;pid&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;pname&quot; column=&quot;name&quot;/&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;queryAllPersonUseResultMap&quot; resultMap=&quot;personMapping&quot;&gt; select * from person &lt;/select&gt;&lt;/mapper&gt;","categories":[],"tags":[{"name":"Java学习","slug":"Java学习","permalink":"http://example.com/tags/Java%E5%AD%A6%E4%B9%A0/"}]},{"title":"记录Hadoop中HDFS命令统计词频错误","slug":"记录Hadoop中HDFS命令统计词频错误","date":"2024-03-30T10:07:41.000Z","updated":"2024-03-30T10:14:54.518Z","comments":true,"path":"2024/03/30/记录Hadoop中HDFS命令统计词频错误/","permalink":"http://example.com/2024/03/30/%E8%AE%B0%E5%BD%95Hadoop%E4%B8%ADHDFS%E5%91%BD%E4%BB%A4%E7%BB%9F%E8%AE%A1%E8%AF%8D%E9%A2%91%E9%94%99%E8%AF%AF/","excerpt":"","text":"关于这次错误我个人搭建了Hadoop集群，当词频统计这个案例的时候，我上传没问题但就是查看有问题，我点击查看文件时，报出了个这么一个错误 Couldn&#39;t preview the file. NetworkError: Failed to execute &#39;send&#39; on &#39;XMLHttpRequest&#39;:xxx 大概翻译就是:无法预览文件。NetworkError：无法在“XMLHttpRequest”上执行“send”： 百度了很多，很多人都在说是配置文件hdfs-site.xml文件中有个叫做 1234&lt;property&gt; &lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt; &lt;value&gt;true&lt;/value&gt;&lt;/property&gt; 这个的value值是false或者根本没有设置这一条属性，当然了，我属于后者，我的配置文件中并没有这项配置，但是我也照做了，然而在次启动后，依旧报同样的错误。 实际上解决方法就是在windows上修改文件: C:\\Windows\\System32\\drivers\\etc\\hosts增加内容（Hadoop集群中各节点及主机名的映射 以我为例: 192.168.121.160 主机名1 192.168.121.161 主机名2 192.168.121.161 主机名3 重启，完美解决成功出现统计的词和文件内容。","categories":[],"tags":[{"name":"Linux Error","slug":"Linux-Error","permalink":"http://example.com/tags/Linux-Error/"}]},{"title":"开发(基于ruoyiui)笔记","slug":"开发-基于ruoyiui-笔记","date":"2024-03-21T07:30:34.000Z","updated":"2024-04-09T02:33:40.273Z","comments":true,"path":"2024/03/21/开发-基于ruoyiui-笔记/","permalink":"http://example.com/2024/03/21/%E5%BC%80%E5%8F%91-%E5%9F%BA%E4%BA%8Eruoyiui-%E7%AC%94%E8%AE%B0/","excerpt":"","text":"问题（一）在查询时参数没有带入1234567891011121314151617181920212223242526272829*&lt;el-form-item label=&quot;项目赛道&quot; prop=&quot;proTrack&quot;&gt;*​ *&lt;el-select*​ *v-model=&quot;queryParams.proTrack&quot;*​ *placeholder=&quot;请选择项目赛道&quot;*​ *clearable*​ *@keyup.enter.native=&quot;handleQuery&quot;*​ *\\&gt;*​ *&lt;el-option v-for=&quot;item in proTrackList&quot;*​ *:key=&quot;item.key&quot;*​ *:label=&quot;item.proTrack&quot;*​ *:value=&quot;item.proTrack&quot;*​ *\\&gt;*​ *&lt;/el-option&gt;*​ *&lt;/el-select&gt;* *&lt;/el-form-item&gt;* 这是一段vue代码,我出现的问题是再前端页面查询的时候无法带入proTrack这个参数。 解决方法:因为我们proTrackList中没有value这个字段，导致我再绑定的时候:value&#x3D;”item.value”绑定出错，将value更换为proTrack成功在查询时候带入了参数proTrack 还有一种没有带入参数的情况就是，有些需要参数的函数，你可能没有传入函数或者定义接受函数的变量。那这时候我们就需要去定义这个函数对于变量的传与接。下面来举一个我的错误例子 先来看我原本的写法 123456789101112131415161718192021222324252627 //查询小组列表 selectGroup()&#123; this.loading=true; selectGroupList(this.queryParams).then(response =&gt;&#123;​ this.tableList = response.rows;​ this.total = response.total;​ this.loading=false; &#125;) &#125;, //赛道改变清空组列表 selectOnChangeTrack()&#123; this.tableList = []; this.selectGroup(this.Track); &#125;, 可以看selectOnChangeTrack这个函数里，我在调用 this.selectGroup(this.Track);时，我传入了参数this.Track，this.Track是选择框的数据，proTrack是查询参数。而我在上面的函数时，却没有接收传过来的参数this.Track ,在vue中，通常定义一个形参，在作为传来参数的载体，然后再将这个形参的值赋值给查询变量，这样就能完成参数的传递，改动如下 12345678910111213141516171819//查询小组列表selectGroup(tempdata)&#123; //将形参tempdata赋值给查询参数proTrack，这样在查询时就会携带proTrack这个参数. this.queryParams.proTrack = tempdata this.loading=true; selectGroupList(this.queryParams).then(response =&gt;&#123; this.tableList = response.rows; this.total = response.total; this.loading=false; &#125;)&#125;, 以上即是改正后的。改正后可以带入要传的参数了。 问题（二）数据库字段名称与后端java应该对应这是一段ruoyi对应的后端代码 123456789101112&lt;select id=&quot;selectRecommendationList&quot; parameterType=&quot;Recommendation&quot; resultMap=&quot;RecommendationResult&quot;&gt; &lt;include refid=&quot;selectRecommendationVo&quot;/&gt; &lt;where&gt; &lt;if test=&quot;time != null &quot;&gt; and pro_details3.time = #&#123;time&#125;&lt;/if&gt; &lt;if test=&quot;proName != null and proName != &#x27;&#x27;&quot;&gt; and pro_name like concat(&#x27;%&#x27;, #&#123;proName&#125;, &#x27;%&#x27;)&lt;/if&gt; &lt;if test=&quot;proScore != null &quot;&gt; and pro_score = #&#123;proScore&#125;&lt;/if&gt; &lt;if test=&quot;proGroup != null and proGroup != &#x27;&#x27;&quot;&gt; and pro_group = #&#123;proGroup&#125;&lt;/if&gt; &lt;if test=&quot;userName != null and userName != &#x27;&#x27;&quot;&gt; and user_name = #&#123;userName&#125;&lt;/if&gt; &lt;if test=&quot;deptName != null and deptName != &#x27;&#x27;&quot;&gt; and dept_name = #&#123;deptName&#125;&lt;/if&gt; &lt;if test=&quot;proTrack !=null and proTrack != &#x27;&#x27;&quot;&gt; and pro_track=#&#123;proTrack&#125;&lt;/if&gt; &lt;/where&gt;&lt;/select&gt; mybaits中数据查询mapper文件中，值得注意的是在and后的字段名称**(比如uesr_name,dept_name,pro_track,pro_group等等)**要和数据库中的字段对应而前面的proGroup是实体类中我们自己定义的属性。 不对应，就会报错 以下这段代码是同样的道理，请注意数据字段是column后面的而实体类是property后面的，数据库字段要和自己的数据库中的字段一致(完全一致) 123456789101112&lt;resultMap type=&quot;Recommendation&quot; id=&quot;RecommendationResult&quot;&gt; &lt;result property=&quot;proId&quot; column=&quot;pro_id&quot; /&gt; &lt;result property=&quot;proName&quot; column=&quot;pro_name&quot; /&gt; &lt;result property=&quot;proScore&quot; column=&quot;pro_score&quot; /&gt; &lt;result property=&quot;proGroup&quot; column=&quot;pro_group&quot; /&gt; &lt;result property=&quot;userName&quot; column=&quot;user_name&quot; /&gt; &lt;result property=&quot;deptName&quot; column=&quot;dept_name&quot; /&gt; &lt;result property=&quot;proTrack&quot; column=&quot;pro_track&quot;/&gt; &lt;result property=&quot;proGroupId&quot; column=&quot;pro_group_Id&quot;/&gt; &lt;result property=&quot;proGroupName&quot; column=&quot;pro_group_name&quot;/&gt; &lt;result property=&quot;time&quot; column=&quot;time&quot;/&gt;&lt;/resultMap&gt; 问题(三)对vue中v-for的理解在Vue的v-for循环中，:key、:label和:value是用于绑定循环中每个元素的属性的特殊语法。 :key用于指定循环中每个元素的唯一标识符。它是必需的，用于帮助Vue跟踪每个元素的身份，以便在更新DOM时进行高效的重用和重新排序。通常，你可以使用一个唯一的属性或索引作为key，确保在循环中的元素之间具有唯一性。 :label用于指定循环中每个选项的显示文本。它绑定了每个选项的显示值，这将在选择框中显示给用户。 :value&#96;用于指定循环中每个选项的实际值。它绑定了每个选项的实际值，当用户选择某个选项时，该值将被传递给绑定的数据模型。 这些特殊语法（:key、:label和:value）是Vue中用于在循环中绑定属性的常见约定，但你也可以根据需要选择其他属性名称。重要的是确保在循环中的每个元素都有唯一的标识符作为key，以及适当的属性用于label和value。这样可以确保循环中的每个元素都能正确地显示和处理。 问题（四）理解一段代码的含义(以获取学院名称列表为例)12345678910111213141516171819/**获取学院名称函数 */ getDeptNameList()&#123; this.loading = true; listRecommendation(this.queryParams).then(response =&gt; &#123;​ this.deptNameList = response.rows;​ console.log(this.deptNameList)​ this.total = response.total;​ this.loading = false;​ &#125;) &#125;, 下面对这段代码剖析： 1234567891011121314getDeptNameList() &#123; this.loading = true; *// 设置 loading 状态为 true，表示正在加载数据* *// 调用 listRecommendation 函数，并传递 this.queryParams 参数* listRecommendation(this.queryParams).then(response =&gt; &#123; this.deptNameList = response.rows; *// 将返回的学院名称列表赋值给 this.deptNameList* console.log(this.deptNameList); *// 打印学院名称列表到控制台* this.total = response.total; *// 设置总数为返回结果的总数* this.loading = false; *// 设置 loading 状态为 false，表示加载数据完成* &#125;); &#125;, 帮助理解 思路（一）选择框一限定选择框二的内容如果想实现两个选择框第一个选择框里面的所选择的内容可以改变第二个选择框里面的数据（比如选择了第一个框里面的2021年，那第二个选择框就会显示在2021里面有什么内容) 可以考虑使用@change&#x3D;””来绑定一个变化，只要第一个选择框里面的内容变了，那么就会执行@change绑定的事件比如 12345678910111213141516171819202122232425262728 //选择框一&lt;el-form-item label=&quot;选择赛事:&quot; prop=&quot;time&quot;&gt;​ &lt;el-select​ v-model=&quot;queryParams.time&quot;​ placeholder=&quot;请选择参赛时间&quot;​ clearable //表示是否可以清除选择框内容​ @change=&quot;handleSelectionChange1&quot;​ \\&gt;​ &lt;el-option v-for=&quot;dict in dict.type.events_year&quot; ​ :key=&quot;dict.key&quot; ​ :label=&quot;dict.value&quot; ​ :value=&quot;dict.value&quot;&gt;​ &lt;/el-option&gt;​ &lt;/el-select&gt; &lt;/el-form-item&gt; 123456789101112131415161718192021222324252627282930//选择框二el-form-item label=&quot;&quot; prop=&quot;selectCompetition&quot;&gt;​ &lt;el-select​ class=&quot;custom-select&quot;​ v-model=&quot;queryParams.selectCompetition&quot;​ placeholder=&quot;请选择赛事&quot;​ clearable​ @keyup.enter.native=&quot;handleQuery&quot; //回车​ \\&gt;​ &lt;el-option v-for=&quot; item in competitionList&quot; ​ :key=&quot;item.key&quot;​ :label=&quot;item.eventName&quot;​ :value=&quot;item.value&quot;&gt;​ &lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; 123456789101112//@change的所绑定事件的功能 handleSelectionChange1() &#123; this.queryParams.startTime = this.queryParams.time; // Update the query parameter this.queryParams.selectCompetition = null; // Clear the competition dropdown this.competitionList = []; // Clear the competition list this.getEventsList(); // Call the function to fetch the updated competition list&#125;, 问题（五）:在今天编写代码时候遇到了这么一个问题，就是关于添加数据前端页面他不给我显示。 查看发现是getfilename函数作怪，因为我的这个函数是要获取路径去分割，然而我并没有在数据库给出路径，所以这两个数据显示不出来，更改函数后成功显示，函数更改如下 12345678910111213 getfileName(path)&#123; if(path)&#123;​ return path.split(&#x27;/&#x27;).pop(); &#125;else&#123;​ return &quot;暂无资料&quot;; &#125; &#125;, 方法1:在数据库中呢，我删除一个数据，由于这个数据关联很多表，那就需要一同删除，这可以利用触发器，以下是我在该项目中写道的触发器123BEGIN DELETE FROM pro_coreteam WHERE pro_id = OLD.pro_id;END 该触发器是当我们根据项目id（pro_id）删除数据时，他会带着通过项目id关联的id里面的内容一同删除,删除的表名称、是pro_coreteam 4.2新添加了一个触发器代码如下 1234567891011DELIMITER //CREATE TRIGGER update_group_idAFTER INSERT ON pro_mapping_groupFOR EACH ROWBEGIN UPDATE pro_details3 SET pro_group_id = NEW.group_id WHERE pro_id = NEW.pro_id;END;//DELIMITER ; 解释 在这个触发器中，当在 pro_mapping_group 表中插入新的记录时，将会更新 pro_details3 表中对应 pro_id 的 pro_group_id 字段。这里假设 pro_mapping_group 表和 pro_details3 表通过 pro_id 字段关联。如果你的实际情况不同，请根据实际情况修改 WHERE 子句。 请注意，这个触发器只在插入新的记录时触发，如果你更新 pro_mapping_group 表中的 group_id 字段，这个触发器不会触发。如果你希望在更新 group_id 时也触发，你需要创建一个额外的 AFTER UPDATE 触发器 方法2:如何写一个对话框即点击按钮弹出对话框？1234567891011121314151617181920212223242526&lt;template&gt; &lt;!-- ... --&gt; &lt;el-button type=&quot;success&quot; @click=&quot;showDialog&quot;&gt;导入互联网+大赛官网（大创网）项目资料&lt;/el-button&gt; &lt;el-dialog title=&quot;导入互联网+大赛官网（大创网）项目资料&quot; :visible.sync=&quot;dialogVisible&quot; width=&quot;800px&quot; top=&quot;5vh&quot; append-to-body&gt; &lt;!-- 对话框内容 --&gt; &lt;!-- ... --&gt; &lt;/el-dialog&gt;&lt;/template&gt;&lt;script&gt;export default &#123; // ... data() &#123; return &#123; dialogVisible: false, // 对话框可见性 &#125;; &#125;, methods: &#123; showDialog() &#123; this.dialogVisible = true; // 点击按钮时显示对话框 &#125;, // 其他方法 // ... &#125;,&#125;;&lt;/script&gt; 方法3:如何在插入数据时携带其他参数新建你要插入的属性比如我下面的 12345@Excel(name = &quot;学生账号&quot;)private Long StuNumber;/** 学生id*/private Long userId; 在服务层写好定义的方法 1public int insertCore(ProCoreteam proCoreteam); 实现类中实现方法 12345@Overridepublic int insertCore(ProCoreteam proCoreteam)&#123; return proManagerMapper.insertCore(proCoreteam);&#125; 在mapper中定义方法 1public int insertCore(ProCoreteam proCoreteam); 在xml文件中使用方法 1234&lt;insert id=&quot;insertCore&quot; parameterType=&quot;ProCoreteam&quot; &gt; insert into pro_coreteam (pro_id,student_id) value (#&#123;proId&#125;,#&#123;studentId&#125;)&lt;/insert&gt; 同理按照以上步骤创建stuNumber的方法 123&lt;select id=&quot;selectstuIdBystuNumber&quot; parameterType=&quot;long&quot; resultMap=&quot;ProManagerResult&quot;&gt; select user_id from sys_user where phonenumber = #&#123;stuNumber&#125;&lt;/select&gt; 关键点在下面，我们要先获取插入完成以后的proid 1234567-- &lt;insert&gt;//获取插入完以后的proid &lt;selectKey resultType=&quot;Long&quot; keyProperty=&quot;proId&quot; order=&quot;AFTER&quot;&gt; select LAST_INSERT_ID() &lt;/selectKey&gt; &lt;/insert&gt; 1.最外层的&lt;insert&gt;&lt;/insert&gt;没有返回属性（resultType），但是里面的&lt;selectKey&gt;&lt;/selectKey&gt;是有返回值类型的。 2.order=&quot;AFTER&quot;表示先执行插入，之后才执行selectkey语句的。 3.select @@identity和select LAST_INSERT_ID()都表示选出刚刚插入的最后一条数据的id。 4.实体类中id属性字段一定需要set以及get方法 5.此时，接口中仍不需要有返回值，框架会自动将值注入到我们insert的那个对象中，我们可以直接使用就可以了。 其实，我们的接口中可以有返回值，但是这个返回值不是id,而是表示插入后影响的行数，此时sql中仍和上面一样，不需要写返回值。 1234567&lt;insert id=&quot;insertStudentCacheId&quot; parameterType=&quot;Student&quot;&gt; insert into student(name,age,score) values(#&#123;name&#125;,#&#123;age&#125;,#&#123;score&#125;) &lt;!-- 指定结果类型resultType，keyProperty是属性，自动返回到属性id中，order是次序，after是指获取id是在于插入后 --&gt; &lt;selectKey resultType=&quot;int&quot; keyProperty=&quot;id&quot; order=&quot;AFTER&quot;&gt; select @@identity &lt;/selectKey&gt;&lt;/insert&gt; 最最最核心的一步 12345678//执行完以后主键自增，获取到自增的proId所以要先执行proManagerMapper.insertProManager(proManager);//创建实体类ProManager的对象S存储通过学生账号获得stuidProManager S = proManagerMapper.selectstuIdBystuNumber(proManager.getStuNumber());//带参数的构建对象方法,上面已经获取到了proId和studentId所以下面创建ProCoreteam的对象p_core存储这两个idProCoreteam p_core=new ProCoreteam(proManager.getProId(),S.getUserId());//调用插入方法插入id，由于是个导入过程所以会在导入过程中执行以上内容自动插入，这样就携带了其他参数proManagerMapper.insertCore(p_core); 问题（六）基于ruoyiUI新建对话框的一些属性问题我们首先新建一个对话框，代码如下(我这个时ruoyiUI的对话框建法) 1&lt;el-dialog :title=&quot;title&quot; :visible.sync=&quot;open&quot; width=&quot;1500px&quot; append-to-body&gt; &lt;/el-dialog&gt; :title=&quot;title&quot;：此属性设置对话框的标题。title 应该是你的 Vue 实例的 data 属性之一，用来存放对话框的标题。: 前缀表示这是一个动态属性，它的值会被解析为 JavaScript 表达式。 :visible.sync=&quot;open&quot;：此属性控制对话框的可见性。如果 open 是 true，对话框就会显示；如果 open 是 false，对话框就会隐藏。.sync 修饰符表示这个属性是双向绑定的：当对话框的可见性改变时，open 的值也会相应地改变（对话框自带的×）。 width=&quot;1500px&quot;：此属性设置对话框的宽度。在这个例子中，对话框的宽度被设置为 1500 像素。 append-to-body：此属性表示对话框将被附加到 body 元素。这可以防止对话框被其他 CSS 影响，确保它能正确地显示在其他元素之上。这是一个布尔属性，如果存在，其值就是 true。 方法4: 如何获取当前行id？面对这个问题我只想说，这可真是让我想的酣畅淋漓的一次啊，为什么这么说？先来看看我犯了什么错误把首先，我当时一心只想着获取当前行id，但是却忽视了原表格是一个静态表格这个前提。所以我花了快一个小时，唉还好脑子转得快(快什么，要是快的话早想到了)突然意识到了，这是一个静态表格，我去哪里动态获取当前行？ 其次，因为脑子当时很热，一点思路也没有，所以就乱撞，白白荒废了时间。 接下来，让我来整理获取当前行id的一个思路 首先想，你要在哪一行操作，好的定位到这一行，要用&lt;template&gt;&lt;/template&gt;标签，具体写法如下: 1234567891011121314151617&lt;el-table-column prop=&quot;selectPro&quot; label=&quot;查看项目&quot; width=&quot;208&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button class=&quot;ebtn1&quot; style=&quot;color: white;&quot; @click=&quot;getAllocationList(scope.row.groupId)&quot; \\&gt;查看&lt;/el-button&gt; &lt;/template&gt;&lt;/el-table-column&gt; 比如我就是这一行要注意了，绑定点击事件的时候，必须加scope.row.xxxx其中的xxxx是你要获取的什么什么id，那么这样你就可以获取到当前行的id了 12345678910111213141516getAllocationList(groupId)&#123; console.log(groupId) this.loading = true; alreadyAllocation(groupId).then(response =&gt;&#123; this.alAllocationList = response.rows; this.total = response.total; this.loading=false; &#125;) &#125; 可以在你所用的时间console.log(groupId)你获取的id然后查看控制台有没有对应的id输出，然后传递参数就可以了。 你甚至还可以这么写 1234567891011121314151617getAllocationList(groupId)&#123; // 输出传入的 groupId console.log(groupId) // 创建一个新对象，包含 groupId const params = &#123;groupId&#125; this.loading = true; //传递参数 alreadyAllocation(params).then(response =&gt;&#123; this.alAllocationList = response.rows; this.total = response.total; this.loading=false; &#125;) &#125; 也是可以的，ok今天就写这么多0.0 问题6:在传入参数时的错误报错是这样对的 Error: nested exception is org.apache.ibatis.binding.BindingException: Parameter &#39;groupId&#39; not found. Available parameters are [arg1, arg0, param1, param2] 翻译一下就是 错误：嵌套异常是 org.apache.ibatis.binding.BindingException：找不到参数“groupId”。可用参数为 [arg1， arg0， param1， param2] 这是我传入参数的函数 12345678910111213141516171819202122232425262728getAllocationList(row)&#123; const proTrack = this.Track; const groupId=row.groupId; const groupName=row.groupName; this.loading = true; alreadyAllocation(groupId,proTrack).then(response =&gt;&#123;​ this.alAllocationList = response.data;​ // console.log(this.alAllocationList)​ this.sendArrayToParent(this.alAllocationList);​ this.sendArrayToParent2(groupName);​ // console.log(tableList);​ this.total = response.total;​ this.loading=false; &#125;) &#125; 这是js里面对应的接口 1234567891011export function alreadyAllocation(groupId,proTrack)&#123; return request(&#123;​ url: &#x27;/project/csxmfp/group/&#x27; + groupId +&#x27;/&#x27;+ proTrack,​ method: &#x27;get&#x27; &#125;)&#125; 报错问题是gruopId找不到，可用参数给出了[arg1, arg0, param1, param2] 这四个参数，这时我就在想，那是不是传入的参数得用这四个中的几个呢？于是我检查了后端，在处理器(proAllocationController)中打印了我从前端带过来的两个参数 123456789101112 /** * 通过赛道名称和小组获取参赛项目分配详细信息 */ @PreAuthorize(&quot;@ss.hasPermi(&#x27;project:csxmfp:querybygroupId&#x27;)&quot;) @GetMapping(value = &quot;group/&#123;groupId&#125;/&#123;trackName&#125;&quot;) public AjaxResult getInfoByGroupId(@PathVariable(&quot;groupId&quot;) Long groupId,@PathVariable(&quot;trackName&quot;) String trackName) &#123; System.out.println(groupId); System.out.println(&quot;aaaa&quot;+trackName); return success(proAllocationService.selectGroupProjectByGroupId(groupId,trackName)); &#125;&#125; 控制台输出 可以看到控制台是有groupId的输出1这就是说拿到了前端数据那为什么后端确说我没有定义呢？检查xml文件 12345678910111213141516171819&lt;select id=&quot;selectGroupProjectByGroupId&quot; parameterType=&quot;GroupProject&quot; resultMap=&quot;GroupProjectresultMap&quot;&gt; SELECT pro_details3.pro_id, pro_details3.pro_name, pro_details3.pro_logo, pro_details3.pro_track, pro_details3.pro_group_id FROM pro_details3 INNER JOIN pro_mapping_group ON pro_details3.pro_id = pro_mapping_group.pro_id &lt;where&gt; pro_mapping_group.group_id = #&#123;group_id&#125; &lt;if test=&quot;proTrack != &#x27;null&#x27; and proTrack != &#x27;&#x27; and arg1!= null&quot;&gt; and pro_details3.pro_track = #&#123;proTrack&#125;&lt;/if&gt; &lt;/where&gt; ORDER BY pro_details3.pro_id;&lt;/select&gt; 于是就想到会不会是参数的传递问题呢？于是我就尝试用arg0代替groupId，用age1代替了proTrack,下面是更新完xml文件 12345678910111213141516171819&lt;select id=&quot;selectGroupProjectByGroupId&quot; parameterType=&quot;GroupProject&quot; resultMap=&quot;GroupProjectresultMap&quot;&gt; SELECT pro_details3.pro_id, pro_details3.pro_name, pro_details3.pro_logo, pro_details3.pro_track, pro_details3.pro_group_id FROM pro_details3 INNER JOIN pro_mapping_group ON pro_details3.pro_id = pro_mapping_group.pro_id &lt;where&gt; pro_mapping_group.group_id = #&#123;arg0&#125; &lt;if test=&quot;arg1 != &#x27;null&#x27; and arg1 != &#x27;&#x27; and arg1!= null&quot;&gt; and pro_details3.pro_track = #&#123;arg1&#125;&lt;/if&gt; &lt;/where&gt; ORDER BY pro_details3.pro_id;&lt;/select&gt; 运行代码，成功传递了数据，问题解决了。你要是问我为什么这样做，其实我也不清楚，但是通过报错信息给出了可用的四个参数，所以说有错误还是要从报错信息入手啊","categories":[],"tags":[{"name":"java和vue开发中遇到的错误以及如何改正和对他们的理解整理(参加的项目)","slug":"java和vue开发中遇到的错误以及如何改正和对他们的理解整理-参加的项目","permalink":"http://example.com/tags/java%E5%92%8Cvue%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E6%94%B9%E6%AD%A3%E5%92%8C%E5%AF%B9%E4%BB%96%E4%BB%AC%E7%9A%84%E7%90%86%E8%A7%A3%E6%95%B4%E7%90%86-%E5%8F%82%E5%8A%A0%E7%9A%84%E9%A1%B9%E7%9B%AE/"}]},{"title":"SpingCloud学习","slug":"SpingCloud学习","date":"2023-12-10T02:04:18.000Z","updated":"2024-03-06T12:42:59.377Z","comments":true,"path":"2023/12/10/SpingCloud学习/","permalink":"http://example.com/2023/12/10/SpingCloud%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"1. 系统架构演变概述目标：了解项目架构的演变历程 小结： 12345graph LR;1[集中式架构] --&gt; 2[垂直拆分]2 --&gt; 3[分布式服务]3 --&gt; 4[SOA面向服务架构]4 --&gt; 5[微服务架构] 2. 微服务架构说明目标：了解SOA与微服务架构的区别以及说出微服务架构的特点 分析： SOA使用了ESB组件的面向服务架构：ESB自身实现复杂；应用服务粒度较大，所有服务之间的通信都经过ESB会降低通信速度；部署、测试ESB比较麻烦。 小结： 微服务架构：是一套使用小服务或者单一业务来开发单个应用的方式或途径。 微服务架构特点： 单一职责 服务粒度小 面向服务（对外暴露REST api） 服务之间相互独立 与使用ESB的SOA架构的区别：微服务架构没有使用ESB，有服务治理注册中心；业务粒度小。 3. 服务调用方式说明目标：能够说出服务调用方式种类 小结： RPC：基于socket，速度快，效率高；webservice、dubbo HTTP：基于TCP，封装比较臃肿；对服务和调用方没有任何技术、语言的限定，自由灵活；RESTful，Spring Cloud 4. Spring RestTemplate示例工程导入目标：了解Spring RestTemplate的应用 分析： 一般情况下有如下三种http客户端工具类包都可以方便的进行http服务调用： httpClient okHttp JDK原生URLConnection spring 提供了RestTemplate的工具类对上述的3种http客户端工具类进行了封装，可在spring项目中使用RestTemplate进行服务调用。 小结： 12345678910111213141516@RunWith(SpringRunner.class)@SpringBootTestpublic class RestTemplateTest &#123; @Autowired private RestTemplate restTemplate; @Test public void test()&#123; String url = &quot;http://localhost/user/8&quot;; //restTemplate可以对json格式字符串进行反序列化 User user = restTemplate.getForObject(url, User.class); System.out.println(user); &#125;&#125; 5. Spring Cloud概述目标：Spring Cloud整合的组件和版本特征 小结： 整合的组件可以有很多组件；常见的组件有：eureka注册中心，Gateway网关，Ribbon负载均衡，Feign服务调用，Hystrix熔断器。在有需要的时候项目添加对于的启动器依赖即可。 版本特征：以英文单词命名（伦敦地铁站名） 6. 创建微服务工程目标：创建微服务父工程heima-springcloud、用户服务工程user-service、服务消费工程consumer-demo 分析： 需求：查询数据库中的用户数据并输出到浏览器 父工程heima-springcloud：添加spring boot父坐标和管理其它组件的依赖 用户服务工程user-service：整合mybatis查询数据库中用户数据；提供查询用户服务 服务消费工程consumer-demo：利用查询用户服务获取用户数据并输出到浏览器 小结： 123456789&lt;!-- springCloud --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt; 通过 scope 的import可以继承 spring-cloud-dependencies 工程中的依赖 7. 搭建配置user-service工程目标：配置user-service工程并能够根据用户id查询数据库中用户 分析： 需求：可以访问http://localhost:9091/user/8输出用户数据 实现步骤： 添加启动器依赖（web、通用Mapper）； 创建启动引导类和配置文件； 修改配置文件中的参数； 编写测试代码（UserMapper，UserService，UserController）； 测试 小结： 添加启动器依赖 123456789101112131415161718&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 通用Mapper启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写配置文件 123456789101112server: port: 9091spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/springcloud username: root password: rootmybatis: type-aliases-package: com.itheima.user.pojo 8. 搭建配置consumer-demo工程目标：编写测试类使用restTemplate访问user-service的路径根据id查询用户 分析： 需求：访问http://localhost:8080/consumer/8 使用RestTemplate获取http://localhost:9091/user/8的数据 实现步骤： 添加启动器依赖； 创建启动引导类（注册RestTemplate）和配置文件； 编写测试代码（ConsumerController中使用restTemplate访问服务获取数据） 测试 小结： 服务管理如何自动注册和发现如何实现状态监管如何实现动态路由 服务如何实现负载均衡 服务如何解决容灾问题 服务如何实现统一配置 上述的问题都可以通过Spring Cloud的各种组件解决。 9. Eureka注册中心说明目标：说出Eureka的主要功能 小结： Eureka的主要功能是进行服务管理，定期检查服务状态，返回服务地址列表。 10. 搭建eureka-server工程目标：添加eureka对应依赖和编写引导类搭建eureka服务并可访问eureka服务界面 分析： Eureka是服务注册中心，只做服务注册；自身并不提供服务也不消费服务。可以搭建web工程使用Eureka，可以使用Spring Boot方式搭建。 搭建步骤： 创建工程； 添加启动器依赖； 编写启动引导类（添加Eureka的服务注解）和配置文件； 修改配置文件（端口，应用名称…）； 启动测试 小结： 启动器依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件 1234567891011121314server: port: 10086spring: application: name: eureka-servereureka: client: service-url: # eureka 服务地址，如果是集群的话；需要指定其它集群eureka地址 defaultZone: http://127.0.0.1:10086/eureka # 不注册自己 register-with-eureka: false # 不拉取服务 fetch-registry: false 11. 服务注册与发现目标：将user-service的服务注册到eureka并在consumer-demo中可以根据服务名称调用 分析： 服务注册：在服务提供工程user-service上添加Eureka客户端依赖；自动将服务注册到EurekaServer服务地址列表。 添加依赖； 改造启动引导类；添加开启Eureka客户端发现的注解； 修改配置文件；设置Eureka 服务地址 服务发现：在服务消费工程consumer-demo上添加Eureka客户端依赖；可以使用工具类根据服务名称获取对应的服务地址列表。 添加依赖； 改造启动引导类；添加开启Eureka客户端发现的注解； 修改配置文件；设置Eureka 服务地址； 改造处理器类ConsumerController，可以使用工具类DiscoveryClient根据服务名称获取对应服务地址列表。 小结： 添加Eureka客户端依赖； 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 添加启动引导类注解； 修改配置 1234567spring: application: name: consumer-demoeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka 12. Eureka Server高可用配置目标：可以启动两台eureka-server实例；在eureka管理界面看到两个实例 分析： Eureka Server是一个web应用，可以启动多个实例（配置不同端口）保证Eureka Server的高可用。 小结： 高可用配置：将Eureka Server作为一个服务注册到其它Eureka Server，这样多个Eureka Server之间就能够互相发现对方，同步服务，实现Eureka Server集群。 13. Eureka客户端与服务端配置目标：配置eureka客户端user-service的注册、续约等配置项，配置eureka客户端consumer-demo的获取服务间隔时间；了解失效剔除和自我保护 分析： Eureka客户端工程 user-service 服务提供 服务地址使用ip方式 续约 consumer-demo 服务消费 获取服务地址的频率 Eureka服务端工程 eureka-server 失效剔除 自我保护 小结： user-service 12345678910111213eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: # 更倾向使用ip地址，而不是host名 prefer-ip-address: true # ip地址 ip-address: 127.0.0.1 # 续约间隔，默认30秒 lease-renewal-interval-in-seconds: 5 # 服务失效时间，默认90秒 lease-expiration-duration-in-seconds: 5 consumer-demo 123456eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka # 获取服务地址列表间隔时间，默认30秒 registry-fetch-interval-seconds: 10 eureka-server 123456eureka: server: # 服务失效剔除时间间隔，默认60秒 eviction-interval-timer-in-ms: 60000 # 关闭自我保护模式（默认是打开的） enable-self-preservation: false 14. 负载均衡Ribbon简介目标：描述负载均衡和ribbon的作用 分析： 负载均衡是一个算法，可以通过该算法实现从地址列表中获取一个地址进行服务调用。 在Spring Cloud中提供了负载均衡器：Ribbon 小结： Ribbon提供了轮询、随机两种负载均衡算法（默认是轮询）可以实现从地址列表中使用负载均衡算法获取地址进行服务调用。 15. Ribbon负载均衡应用目标：配置启动两个用户服务，在consumer-demo中使用服务名实现根据用户id获取用户 分析： 需求：可以使用RestTemplate访问http://user-service/user/8获取服务数据。 可以使用Ribbon负载均衡：在执行RestTemplate发送服务地址请求的时候，使用负载均衡拦截器拦截，根据服务名获取服务地址列表，使用Ribbon负载均衡算法从服务地址列表中选择一个服务地址，访问该地址获取服务数据。 实现步骤： 启动多个user-service实例（9091,9092）； 修改RestTemplate实例化方法，添加负载均衡注解； 修改ConsumerController； 测试 小结： 在实例化RestTemplate的时候使用@LoadBalanced，服务地址直接可以使用服务名。 16. 熔断器Hystrix简介目标：了解熔断器Hystrix的作用 小结： Hystrix是一个延迟和容错库，用于隔离访问远程服务，防止出现级联失败。 17. 线程隔离&amp;服务降级目标：了解什么是线程隔离和服务降级 分析： Hystrix解决雪崩效应： 线程隔离：用户请求不直接访问服务，而是使用线程池中空闲的线程访问服务，加速失败判断时间。 服务降级：及时返回服务调用失败的结果，让线程不因为等待服务而阻塞。 小结： 添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 开启熔断 降级逻辑 12345678910111213141516171819202122232425262728293031323334353637@RestController@RequestMapping(&quot;/consumer&quot;)@Slf4j@DefaultProperties(defaultFallback = &quot;defaultFallback&quot;)public class ConsumerController &#123; @Autowired private RestTemplate restTemplate; @Autowired private DiscoveryClient discoveryClient; @GetMapping(&quot;/&#123;id&#125;&quot;) //@HystrixCommand(fallbackMethod = &quot;queryByIdFallback&quot;) @HystrixCommand public String queryById(@PathVariable Long id)&#123; /*String url = &quot;http://localhost:9091/user/&quot;+id; //获取eureka中注册的user-service的实例 List&lt;ServiceInstance&gt; serviceInstances = discoveryClient.getInstances(&quot;user-service&quot;); ServiceInstance serviceInstance = serviceInstances.get(0); url = &quot;http://&quot; + serviceInstance.getHost() + &quot;:&quot; + serviceInstance.getPort() + &quot;/user/&quot; + id;*/ String url = &quot;http://user-service/user/&quot; + id; return restTemplate.getForObject(url, String.class); &#125; public String queryByIdFallback(Long id)&#123; log.error(&quot;查询用户信息失败。id：&#123;&#125;&quot;, id); return &quot;对不起，网络太拥挤了！&quot;; &#125; public String defaultFallback()&#123; return &quot;默认提示：对不起，网络太拥挤了！&quot;; &#125;&#125; 修改超时配置 1234567hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 2000 18. 服务熔断演示目标：了解熔断器工作原理 小结： 可以通过配置服务熔断参数修改默认： 1234567891011hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 2000 circuitBreaker: errorThresholdPercentage: 50 # 触发熔断错误比例阈值，默认值50% sleepWindowInMilliseconds: 10000 # 熔断后休眠时长，默认值5秒 requestVolumeThreshold: 10 # 熔断触发最小请求次数，默认值是20 SpringCloud第二天1. Feign应用目标：Feign的作用；使用Feign实现consumer-demo代码中调用服务 分析： 导入启动器依赖； 开启Feign功能； 编写Feign客户端； 编写一个处理器ConsumerFeignController，注入Feign客户端并使用； 测试 小结： Feign主要作用：自动根据参数拼接http请求地址。 启动器依赖； 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; Feign客户端： 123456789//声明当前类是一个Feign客户端，指定服务名为user-service@FeignClient(&quot;user-service&quot;)public interface UserClient &#123; //http://user-service/user/123 @GetMapping(&quot;/user/&#123;id&#125;&quot;) User queryById(@PathVariable Long id);&#125; 2. Feign负载均衡及熔断目标：可以配置Feign内置ribbon配置项和Hystrix熔断的Fallback配置 分析： 负载均衡 服务熔断 请求压缩 日志级别 都可以通过配置项在Feign中开启使用。 小结： 在服务消费工程consumer-demo中的配置文件： 12345678910111213141516171819ribbon: ConnectTimeout: 1000 # 连接超时时长 ReadTimeout: 2000 # 数据通信超时时长 MaxAutoRetries: 0 # 当前服务器的重试次数 MaxAutoRetriesNextServer: 0 # 重试多少次服务 OkToRetryOnAllOperations: false # 是否对所有的请求方式都重试feign: hystrix: enabled: true # 开启Feign的熔断功能 compression: request: enabled: true # 开启请求压缩 mime-types: text/html,application/xml,application/json # 设置压缩的数据类型 min-request-size: 2048 # 设置触发压缩的大小下限 response: enabled: truelogging: level: com.itheima: debug 3. Spring Cloud Gateway网关简介目标：Spring Cloud Gateway网关的作用 小结： Spring Cloud Gateway的核心就是一系列的过滤器，可以将客户端的请求转发到不同的微服务。主要作用：过滤和路由。 4. Spring Cloud Gateway入门目标：搭建网关服务工程测试网关服务作用 分析： 需求：通过网关系统heima-gateway将包含有 &#x2F;user 的请求 路由到 http://127.0.0.1:9091/user/用户id 实现步骤： 创建工程； 添加启动器依赖； 编写启动引导类和配置文件； 修改配置文件，设置路由信息； 启动测试 http://127.0.0.1:10010/user/8 –&gt; http://127.0.0.1:9091/user/8 小结： 启动器依赖 1234567891011&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置文件 12345678910111213141516171819202122server: port: 10010spring: application: name: api-gateway cloud: gateway: routes: # 路由id，可以任意 - id: user-service-route # 代理的服务地址 uri: http://127.0.0.1:9091 # 路由断言： 可以匹配映射路径 predicates: - Path=/user/**eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true 5. 面向服务的路由目标：使用在eureka注册的服务作为路由地址 分析： 如果将路由服务地址写死明显是不合理的；在Spring Cloud Gateway中可以通过配置动态路由解决。 小结： 面向服务的路由；只需要在配置文件中指定路由路径类似： lb://user-service lb 之后编写的服务名必须要在eureka中注册才能使用 6. 路由前缀处理目标：可以对请求到网关服务的地址添加或去除前缀 分析： 提供服务的地址：http://127.0.0.1:9091/user/8 添加前缀：对请求地址添加前缀路径之后再作为代理的服务地址； http://127.0.0.1:10010/8 –&gt; http://127.0.0.1:9091/user/8 添加前缀路径&#x2F;user 去除前缀：将请求地址中路径去除一些前缀路径之后再作为代理的服务地址； http://127.0.0.1:10010/api/user/8 –&gt; http://127.0.0.1:9091/user/8 去除前缀路径&#x2F;api 小结： 客户端的请求地址与微服务的服务地址如果不一致的时候，可以通过配置路径过滤器实现路径前缀的添加和去除。 7. 过滤器简介目标：Gateway默认过滤器的用法和过滤器类型 小结： 用法：在配置文件中指定要使用的过滤器名称； 类型：局部、全局； 使用场景：请求鉴权、异常处理、记录调用时长等。 8. 自定义局部过滤器目标：按照默认过滤器编写并配置一个自定义局部过滤器，该过滤器可以通过配置文件中的参数名称获取请求的参数值 分析： 需求：在过滤器（MyParamGatewayFilterFactory）中将http://localhost:10010/api/user/8?name=itcast中的参数name的值获取到并输出到控制台；并且参数名是可变的，也就是不一定每次都是name；需要可以通过配置过滤器的时候做到配置参数名。 实现步骤： 配置过滤器； 编写过滤器； 测试 小结： 配置；与其他过滤器的配置一致。 实现过滤器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.itheima.gateway.filter;import org.springframework.cloud.gateway.filter.GatewayFilter;import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;import org.springframework.http.server.reactive.ServerHttpRequest;import org.springframework.stereotype.Component;import java.util.Arrays;import java.util.List;@Componentpublic class MyParamGatewayFilterFactory extends AbstractGatewayFilterFactory&lt;MyParamGatewayFilterFactory.Config&gt; &#123; static final String PARAM_NAME = &quot;param&quot;; public MyParamGatewayFilterFactory() &#123; super(Config.class); &#125; public List&lt;String&gt; shortcutFieldOrder() &#123; return Arrays.asList(PARAM_NAME); &#125; @Override public GatewayFilter apply(Config config) &#123; return (exchange, chain) -&gt; &#123; // http://localhost:10010/api/user/8?name=itcast config.param ==&gt; name //获取请求参数中param对应的参数名 的参数值 ServerHttpRequest request = exchange.getRequest(); if(request.getQueryParams().containsKey(config.param))&#123; request.getQueryParams().get(config.param). forEach(value -&gt; System.out.printf(&quot;------------局部过滤器--------%s = %s------&quot;, config.param, value)); &#125; return chain.filter(exchange); &#125;; &#125; public static class Config&#123; //对应在配置过滤器的时候指定的参数名 private String param; public String getParam() &#123; return param; &#125; public void setParam(String param) &#123; this.param = param; &#125; &#125;&#125; 9. 自定义全局过滤器目标：定义一个全局过滤器检查请求中是否携带有token参数 分析： 需求：编写全局过滤器，在过滤器中检查请求地址是否携带token参数。如果token参数的值存在则放行；如果token的参数值为空或者不存在则设置返回的状态码为：未授权也不再执行下去。 实现步骤： 编写全局过滤器； 测试 小结： 123456789101112131415161718192021@Componentpublic class MyGlobalFilter implements GlobalFilter, Ordered &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; System.out.println(&quot;--------------全局过滤器MyGlobalFilter------------------&quot;); String token = exchange.getRequest().getQueryParams().getFirst(&quot;token&quot;); if(StringUtils.isBlank(token))&#123; //设置响应状态码为未授权 exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED); return exchange.getResponse().setComplete(); &#125; return chain.filter(exchange); &#125; @Override public int getOrder() &#123; //值越小越先执行 return 1; &#125;&#125; 10. Gateway其它配置说明目标：Gateway网关的负载均衡和熔断参数配置 小结： 网关服务配置文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455server: port: 10010spring: application: name: api-gateway cloud: gateway: routes: # 路由id，可以任意 - id: user-service-route # 代理的服务地址 #uri: http://127.0.0.1:9091 # lb表示从eureka中获取具体服务 uri: lb://user-service # 路由断言： 可以匹配映射路径 predicates: #- Path=/user/** #- Path=/** - Path=/api/user/** filters: # 添加请求路径的前缀 #- PrefixPath=/user #1表示过滤1个路径，2表示两个路径，以此类推 - StripPrefix=1 - MyParam=name # 默认过滤器，对所有路由都生效 default-filters: - AddResponseHeader=X-Response-Foo, Bar - AddResponseHeader=abc-myname,heima globalcors: corsConfigurations: &#x27;[/**]&#x27;: #allowedOrigins: * # 这种写法或者下面的都可以，*表示全部 allowedOrigins: - &quot;http://docs.spring.io&quot; allowedMethods: - GETeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: truehystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 6000ribbon: ConnectTimeout: 1000 ReadTimeout: 2000 MaxAutoRetries: 0 MaxAutoRetriesNextServer: 0 Gateway网关一般直接给终端请求使用；Feign一般用在微服务之间调用。 11. Spring Cloud Config分布式配置中心简介目标：分布式配置中心的作用 小结： spring cloud config作用：可以通过修改在git仓库中的配置文件实现其它所有微服务的配置文件的修改。 12. 搭建配置中心微服务目标：创建码云的远程公开git仓库，搭建配置中心微服务config-server 分析： 创建git仓库：在码云上创建仓库 搭建配置中心config-server：使用spring boot方式搭建和配置 小结： 配置中心依赖 1234567891011&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置中心的配置文件 1234567891011121314server: port: 12000spring: application: name: config-server cloud: config: server: git: uri: https://gitee.com/goheima/heima-config.giteureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka 在gitee中修改了配置文件会在配置中心服务及时更新。 13. 获取配置中心配置目标：改造用户微服务user-service，配置文件信息不再由微服务项目提供，而是从配置中心获取 分析： 需求：将服务提供工程user-service的application.yml配置文件删除，修改为从配置中心config-server中获取。 实现步骤： 添加启动器依赖； 修改配置文件； 启动测试 小结： 将原来的application.yml删除；然后添加bootstrap.yml配置文件，该文件也是spring boot的默认配置文件，其内容经常配置一些项目中固定的配置项。如果是项目经常变动的应该配置到application.yml中，现在使用了配置中心则应该配置到git仓库中对于的配置文件。 依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置文件bootstrap.yml 12345678910111213141516171819spring: cloud: config: # 要与仓库中的配置文件的application保持一致 name: user # 要与仓库中的配置文件的profile保持一致 profile: dev # 要与仓库中的配置文件所属的版本（分支）一样 label: master discovery: # 使用配置中心 enabled: true # 配置中心服务名 service-id: config-servereureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka 14. Spring Cloud Bus简介目标：了解Spring Cloud Bus作用 小结： Spring Cloud Bus作用：将git仓库的配置文件更新，在不重启系统的情况下实现及时同步到各个微服务。 15. Spring Cloud Bus应用目标：启动RabbitMQ通过修改码云中的配置文件后发送Post请求实现及时更新用户微服务中的配置项 分析： 需求：在码云的git仓库中修改user-dev.yml配置文件，实现不重启user-service的情况下可以及时更新配置文件。 实现步骤： 启动RabbitMQ； 修改配置中心config-server； 修改服务提供工程user-service； 测试 小结： config-server的依赖添加内容 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-bus&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;&lt;/dependency&gt; config-server的配置文件添加内容 1234567891011121314151617181920212223242526server: port: 12000spring: application: name: config-server cloud: config: server: git: uri: https://gitee.com/goheima/heima-config.git # 配置rabbitmq信息；如果是都与默认值一致则不需要配置 rabbitmq: host: localhost port: 5672 username: guest password: guesteureka: client: service-url: defaultZone: http://127.0.0.1:10086/eurekamanagement: endpoints: web: exposure: # 暴露触发消息总线的地址 include: bus-refresh user-service的依赖添加内容 12345678910111213&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-bus&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; user-service的配置文件添加内容 1234567# 配置rabbitmq信息；如果是都与默认值一致则不需要配置rabbitmq: host: localhost port: 5672 username: guest password: guest UserController的修改 16. Spring Cloud 体系技术综合应用说明目标：了解Spring Cloud中的Eureka、GateWay、Config、Bus、Feign等技术的综合应用 小结：","categories":[],"tags":[]},{"title":"后端获取图片数据的开发文档","slug":"基于ruoyi框架的开发笔记","date":"2023-12-06T13:42:11.048Z","updated":"2024-02-29T03:51:16.751Z","comments":true,"path":"2023/12/06/基于ruoyi框架的开发笔记/","permalink":"http://example.com/2023/12/06/%E5%9F%BA%E4%BA%8Eruoyi%E6%A1%86%E6%9E%B6%E7%9A%84%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/","excerpt":"","text":"后端获取图片数据的开发文档1.后端获取图片数据的基本需求（文件）在com&#x2F;ruoyi&#x2F;system&#x2F;domain&#x2F;目录下创建SysPicture.java 在该类中编写你在图片数据库中定义的属性:以下拿我的举例子 1234567891011121314151617181920212223242526272829/** * 图片表 data_entires * * */public class SysPicture extends BaseEntity&#123; private static final long serialVersionUID = 1L; /** 图片序号 */ @Excel(name = &quot;图片序号&quot;, cellType = Excel.ColumnType.NUMERIC) private Long pictureId; /** 图片编码 */ @Excel(name = &quot;图片编码&quot;) private String pictureCode; /** 图片名称 */ @Excel(name = &quot;图片名称&quot;) private String pictureName; /** 图片排序 */ @Excel(name = &quot;图片排序&quot;) private Integer pictureSort; /** 状态（0正常 1停用） */ @Excel(name = &quot;状态&quot;, readConverterExp = &quot;0=正常,1=停用&quot;) private String status; 添加Set,Get方法 123456789101112131415161718192021222324252627282930313233343536373839public Long getPictureId() &#123; return pictureId;&#125;public void setPictureId(Long pictureId) &#123; this.pictureId = pictureId;&#125;public String getPictureCode() &#123; return pictureCode;&#125;public void setPictureCode(String pictureCode) &#123; this.pictureCode = pictureCode;&#125;public String getPictureName() &#123; return pictureName;&#125;public void setPictureName(String pictureName) &#123; this.pictureName = pictureName;&#125;public Integer getPictureSort() &#123; return pictureSort;&#125;public void setPictureSort(Integer pictureSort) &#123; this.pictureSort = pictureSort;&#125;public String getStatus() &#123; return status;&#125;public void setStatus(String status) &#123; this.status = status;&#125; 添加toString()方法 1234567891011121314@Overridepublic String toString() &#123; return new ToStringBuilder(this, ToStringStyle.MULTI_LINE_STYLE) .append(&quot;pictureId&quot;, getPictureId()) .append(&quot;postCode&quot;, getPictureCode()) .append(&quot;postName&quot;, getPictureName()) .append(&quot;postSort&quot;, getPictureSort()) .append(&quot;status&quot;, getStatus()) .append(&quot;createBy&quot;, getCreateBy()) .append(&quot;createTime&quot;, getCreateTime()) .append(&quot;updateBy&quot;, getUpdateBy()) .append(&quot;updateTime&quot;, getUpdateTime()) .append(&quot;remark&quot;, getRemark()) .toString(); 可以参考其他的domian类文件。 在com&#x2F;ruoyi&#x2F;web&#x2F;controller&#x2F;system&#x2F;目录下创建SysPictureController.java 控制层中我们主要添加 1234567891011121314151617181920@RestController@RequestMapping(&quot;/system/picture&quot;)public class SysPictureController extends BaseController&#123; //创建并注入服务处的对象 @Autowired private ISysPictureService pictureService; /** * 获取图片 */ @PreAuthorize(&quot;@ss.hasPermi(&#x27;system:picture:list&#x27;)&quot;) @GetMapping(&quot;/list&quot;) public TableDataInfo list(SysPicture picture) &#123; startPage(); List&lt;SysPicture&gt; list = pictureService.selectPictureList(picture); return getDataTable(list); &#125;&#125; 在com&#x2F;ruoyi&#x2F;system&#x2F;service&#x2F;目录下创建服务层的类ISysPictureService.java 在该类中添加如下代码 123456789public interface ISysPictureService &#123; /** * 查询图片信息集合 * * @param picture 图片信息 * @return 图片列表 */ public List&lt;SysPicture&gt; selectPictureList(SysPicture picture);&#125; 在com&#x2F;ruoyi&#x2F;system&#x2F;service&#x2F;impl&#x2F;目录下编写SysPictureServiceImpl.java类并添加如下代码: 1234567891011@Servicepublic class SysPictureServiceImpl implements ISysPictureService &#123; @Autowired private SysPictureMapper pictureMapper; @Override public List&lt;SysPicture&gt; selectPictureList(SysPicture picture) &#123; return pictureMapper.selectPictureList(picture); &#125;&#125; 在com&#x2F;ruoyi&#x2F;system&#x2F;mapper&#x2F;目录下编写SysPictureMapper.java类 在该类中添加 123456789101112131415/** *图片信息 数据层 */@Repositorypublic interface SysPictureMapper &#123; /** * 查询图片数据集合 * * @param picture 图片信息 * @return 图片数据集合 */ public List&lt;SysPicture&gt; selectPictureList(SysPicture picture);&#125; 在mapper&#x2F;system&#x2F;目录下添加SysPictureMapper.xml文件 内容如下 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; 以上部分为文件头，可复制直接使用 &lt;mapper namespace=&quot;com.ruoyi.system.mapper.SysPictureMapper&quot;&gt;//该位置必须要找到Mapper文件所在位置 &lt;resultMap type=&quot;SysPicture&quot; id=&quot;SysPictureResult&quot;&gt; &lt;id property=&quot;pictureId&quot; column=&quot;picture_id&quot; /&gt; &lt;result property=&quot;pictureCode&quot; column=&quot;picture_code&quot; /&gt; &lt;result property=&quot;pictureName&quot; column=&quot;picture_name&quot; /&gt; &lt;result property=&quot;pictureSort&quot; column=&quot;picture_sort&quot; /&gt; &lt;result property=&quot;status&quot; column=&quot;status&quot; /&gt; &lt;result property=&quot;createBy&quot; column=&quot;create_By&quot; /&gt; &lt;result property=&quot;createTime&quot; column=&quot;create_time&quot; /&gt; &lt;result property=&quot;updateBy&quot; column=&quot;update_by&quot; /&gt; &lt;result property=&quot;updateTime&quot; column=&quot;update_time&quot; /&gt; &lt;result property=&quot;remark&quot; column=&quot;remark&quot; /&gt; &lt;/resultMap&gt; &lt;sql id=&quot;selectPictureVo&quot;&gt; select picture_id, picture_code, picture_name, picture_sort, status, create_by, create_time, remark from data_entires &lt;/sql&gt; &lt;select id=&quot;selectPictureList&quot; parameterType=&quot;SysPost&quot; resultMap=&quot;SysPictureResult&quot;&gt; &lt;include refid=&quot;selectPictureVo&quot;/&gt; &lt;where&gt; &lt;if test=&quot;pictureCode != null and pictureCode != &#x27;&#x27;&quot;&gt; AND picture_code like concat(&#x27;%&#x27;, #&#123;pictureCode&#125;, &#x27;%&#x27;) &lt;/if&gt; &lt;if test=&quot;status != null and status != &#x27;&#x27;&quot;&gt; AND status = #&#123;status&#125; &lt;/if&gt; &lt;if test=&quot;pictureName != null and pictureName != &#x27;&#x27;&quot;&gt; AND picture_name like concat(&#x27;%&#x27;, #&#123;pictureName&#125;, &#x27;%&#x27;) &lt;/if&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; 以上的大部分代码，均参考ruoyi官方编写的其他内容改编 由于ruoyi设置了查询权限，我们在运行项目进行数据查询时会提示权限不足,这时候我们需要带着两个请求头去查询 Cookie Authorization","categories":[],"tags":[]},{"title":"SpringBoot学习","slug":"SpringBoot学习","date":"2023-12-04T10:27:49.000Z","updated":"2023-12-04T12:46:37.149Z","comments":true,"path":"2023/12/04/SpringBoot学习/","permalink":"http://example.com/2023/12/04/SpringBoot%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Springboot模块学习笔记(一)1.SpringBoot的目标既是提供了一种快速使用Spring的方式，提高开发效率。那么Spring有什么缺点呢？ 1.配置繁琐 2.依赖繁琐 这样就引出了SpringBoot技术，下面介绍一下SpringBoot功能 （1）自动配置 （2）起步依赖 （3）辅助功能 SpringBoot并不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式 2.SpringBoot快速入门利用一个简单的小项目来入门一下 SpringBoot在创建项目时，使用jar的打包方式。 SpringBoot的引导类，是项目入口，运行main方法就可以启动项目。 使用SpringBoot和Spring构建的项目，业务代码编写方式完全一样。 同时利用idea工具可实现快速构建 在new–&gt;Module下的Spring Initializr选项卡中实现快速构建项目 3.Spring Boot 起步依赖原理（1）spring-boot-starter-parent （2）spring-boot-starter-web 4.Spring Boot配置原理配置文件分类: 在application.properties下编写如下代码: server.port &#x3D;8080 或者yml方式(在idea中的resources下创建application.yml或application.yaml文件里面编写如下配置): server: ​ port: 8080 以上三个配置文件的优先级(按照后缀来排序): .properties&gt;.yml&gt;.yaml yaml yaml:基本语法:joy: yaml:数据格式: 对象(map):键值对的集合。 数组:一组按次序排列的值。 纯量:单个的、不可再分的值。 以上注意 属性名称:(空格)+属性值 yaml:参数引用 YAML:小结 读取配置文件内容 (1)@Value @Value(“${name}”) ​ private String name ​ 采用这样的方式来获取application.yaml里对应的name的值 ​ 如果获取数组的值我们在@Value中取得是数组的下标 (2)Environment 使用Environment获取值时的步骤如下: 1)使用**@Autowired注解让Springboot启动时注入一个对象env** 2)直接在输出这一行利用env.getProperty(“”)输入你要获取的值的属性名字即可 (3)@ConfigurationProperties 创建一个你需要用到的对象类(如我图中的person类): 两个注解: ​ @Component:让Spring识别 ​ @ConfigurationProperties 注意了!!!! 如果此时你的@ConfigurationProperties并没有写前缀，那么它会读取配置文件中你所配置的属性名的属性值 如下 但是如果你加了前缀@ConfigurationProperties(prefix &#x3D; “person”)那么它读取的是你在.yaml文件里前缀为person：下的属性名的属性值 profile 1)profile配置方式 多profile文件方式 一般来讲结构是这样的 我们分别在dev、pro、test里面配置需要的属性 然后再主要文件application.properties里面加上 12spring.profiles.active=dev/pro/test这就是启动dev/pro/test配置文件 yml多文档方式 在yml中用—分割即可 2)profile激活方式 在运行位置编辑运行设置找到这两个; 虚拟机参数:-Dspring.profiles.active&#x3D;pro 命令行参数:–spring.profiles.active&#x3D;pro 内部配置加载顺序 外部配置加载顺序 3.SpringBoot整合其他框架(1)SpringBoot整合Junit。 1.在搭建的com&#x2F;itheima&#x2F;Springboottest&#x2F;下创建类UserService 并编写以下内容 这里我们编写了一个名为add()的方法，作用是打印add…… 在test包下的com&#x2F;itheima&#x2F;目录下创建test目录，在test下创建UserServiceTest类作为测试类 利用@Autowired注入一个类的对象userService @Test下创建一个test()函数，通过对象去访问UserService下的add方法即 userService.add() 以上注意点有: 当你的测试路径和的包名和上面主目录的包名一致时,@SpringBootTest(classes &#x3D; SpringbootTestApplication.class)中的classes &#x3D; SpringbootTestApplication.class可以省略不写 (2)SpringBoot整合Redis (3)SpringBoot整合mybaits 按步骤如下排列: 在主目录domain下创建类User 并且写好get，set方法最后写上toString() 在com&#x2F;itheima&#x2F;springbiittestmybaits&#x2F;下创建UserMapper文件 内容如下 注意写好@Mpper注解,@Repository注解，@Select(“”)里面写好查询语句(select * from t_user) 来到test目录下操作 在测试类中编写如下代码，其中@Autowired注解注入了UserMapper的对象userMapper @Test注解中编写了testFindAll()方法来调用对象userMapper中的findAll()方法并打印输出列表list 我们的application.yaml文件的内容如下 下面来看第二种方法在主目录下创建mapper目录，目录下创建UserXmlMapper接口并编写里面的内容 在resources目录下创建mapper文件，在里面创建UserMapper.xml文件并且编写如下 这一步注意:一定要指定namespace的路径(其实是UserMapper的路径) 在applications.yaml里面编写 在主要测试类中添加@Autowired注解注入UserXmlMapper的对象userXmlMapper，并且添加对象对应的findAll()方法 运行测试的结果 &#x3D;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-12-04T09:46:55.840Z","updated":"2023-12-04T09:46:55.840Z","comments":true,"path":"2023/12/04/hello-world/","permalink":"http://example.com/2023/12/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"","slug":"Springboot模块学习2","date":"2023-12-04T08:59:28.628Z","updated":"2023-12-09T11:06:31.174Z","comments":true,"path":"2023/12/04/Springboot模块学习2/","permalink":"http://example.com/2023/12/04/Springboot%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A02/","excerpt":"","text":"SpringBoot模块学习(二)—-SpringBoot高级1.SpringBoot自动配置1)Condition 以上是Condition的作用 2)切换内置web服务器SpringBoot的web环境中默认使用tomcat作为内置服务器，其实SpringBoot提供了4种内置服务器供我们选择，我们可以很方便进行切换 那么我们如何在这四种服务器之间切换呢？ 只需要在pom.xml文件中引入对应的服务器坐标就可以了 &lt;dependency&gt; &lt;artifactID&gt;spring-boot-starter-tomcat&lt;/artifactID&gt; &lt;groupID&gt;org.springframework.boot&lt;/groupID&gt; &lt;/dependency&gt; 以上是我们的tomcat的坐标 只需要将tomcat位置替换成jetty就可以了 3)@Enable注解 下面我们利用项目来加深一下理解 创建一个叫springboot-enable的模块和为名springboot-enable-other的模块，第二个模块的作用是提供一些Bean来查询。 以上是第一个项目需要的代码 第二个项目我们在包下创建 在UserConfig下编写如下代码即可 随后我们在springbootenable模块的pom文件中引入springbootenableother的依赖即可 运行第一个项目报错为正常情况，然后我们来说@Enable注解的作用。 我们自己写一个EnableUser注解 接下来我们在启动类里面运用上自己写的@EnableUser注解启动 成功访问到其他类的Bean！ 4)@Import注解Import注解有4种用法: 1234* 1.直接导入Bean:@Import(User.class)Bean名字* 2.导入配置类:@Import(UserConfig.class)配置类名字* 3.导入ImportSelector的实现类* 4.导入ImportBeanDefinitionRegistrar实现类 5)@EnableAutoConfiguration注解 6)自定义stater案例 7)SpringBoot监听器 这些监听器，是一些列的接口，我们要使用就要创建实现这些接口的类并实现里面的方法。 2.SpringBoot监控 上面的信息当中三个是health信息,一个是info 这里推荐使用json,cn网站来进行解析: 得到如下结果 我们访问info信息发现是空的，如果想要在info里面添加内容，需要在配置文件中写上以info.开头的属性名称和其对应的属性值,我下面只举一个例子: 在配置文件中添加如下内容后重新启动再次进入 关于health信息，初次访问只会显示一个内容 如果你想开启有关健康方面的所有内容，需要在配置文件中配置上如下内容 1management.endpoint.health.show-details=always 即可！ 如果你想开启所有监控信息全部暴露出来你需要在配置文件中添加: 2)SpringBoot 监控 Spring Boot Admin 使用步骤: 3.SpringBoot项目部署利用idea中的maven打包默认打jar包 可以在目录下用Powershell终端 java -jar+ jar包名 也可以打war包 在pom中将打包方式改为war 然后再启动类中继承一个名为SoringBootServletInitializer的类 随后在加一个@Override注解 将war包放在Tomcat的wabapp下启动Tomcat访问但注意: 1.目录发生了变化 2.端口号内置的不在起作用，需要从外置tomcat配置文件中更改","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"练习题，面试题","slug":"练习题，面试题","permalink":"http://example.com/tags/%E7%BB%83%E4%B9%A0%E9%A2%98%EF%BC%8C%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"Java学习","slug":"Java学习","permalink":"http://example.com/tags/Java%E5%AD%A6%E4%B9%A0/"},{"name":"Linux Error","slug":"Linux-Error","permalink":"http://example.com/tags/Linux-Error/"},{"name":"java和vue开发中遇到的错误以及如何改正和对他们的理解整理(参加的项目)","slug":"java和vue开发中遇到的错误以及如何改正和对他们的理解整理-参加的项目","permalink":"http://example.com/tags/java%E5%92%8Cvue%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E6%94%B9%E6%AD%A3%E5%92%8C%E5%AF%B9%E4%BB%96%E4%BB%AC%E7%9A%84%E7%90%86%E8%A7%A3%E6%95%B4%E7%90%86-%E5%8F%82%E5%8A%A0%E7%9A%84%E9%A1%B9%E7%9B%AE/"}]}